"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-chessboard";
exports.ids = ["vendor-chunks/react-chessboard"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-chessboard/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-chessboard/dist/index.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chessboard: () => (/* binding */ Chessboard),\n/* harmony export */   ChessboardDnDProvider: () => (/* binding */ ChessboardDnDProvider),\n/* harmony export */   SparePiece: () => (/* binding */ SparePiece)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nconst COLUMNS = \"abcdefgh\".split(\"\");\nconst START_POSITION_OBJECT = {\n    a8: \"bR\",\n    b8: \"bN\",\n    c8: \"bB\",\n    d8: \"bQ\",\n    e8: \"bK\",\n    f8: \"bB\",\n    g8: \"bN\",\n    h8: \"bR\",\n    a7: \"bP\",\n    b7: \"bP\",\n    c7: \"bP\",\n    d7: \"bP\",\n    e7: \"bP\",\n    f7: \"bP\",\n    g7: \"bP\",\n    h7: \"bP\",\n    a2: \"wP\",\n    b2: \"wP\",\n    c2: \"wP\",\n    d2: \"wP\",\n    e2: \"wP\",\n    f2: \"wP\",\n    g2: \"wP\",\n    h2: \"wP\",\n    a1: \"wR\",\n    b1: \"wN\",\n    c1: \"wB\",\n    d1: \"wQ\",\n    e1: \"wK\",\n    f1: \"wB\",\n    g1: \"wN\",\n    h1: \"wR\"\n};\nconst WHITE_COLUMN_VALUES = {\n    a: 0,\n    b: 1,\n    c: 2,\n    d: 3,\n    e: 4,\n    f: 5,\n    g: 6,\n    h: 7\n};\nconst BLACK_COLUMN_VALUES = {\n    a: 7,\n    b: 6,\n    c: 5,\n    d: 4,\n    e: 3,\n    f: 2,\n    g: 1,\n    h: 0\n};\nconst WHITE_ROWS = [\n    7,\n    6,\n    5,\n    4,\n    3,\n    2,\n    1,\n    0\n];\nconst BLACK_ROWS = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7\n];\n// https://commons.wikimedia.org/wiki/Category:SVG_chess_pieces\n// By en:User:Cburnett - Own work\n// This W3C - unspecified vector image was created with Inkscape., CC BY - SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1499810\nconst defaultPieces = {\n    wP: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\",\n            style: {\n                opacity: \"1\",\n                fill: \"#ffffff\",\n                fillOpacity: \"1\",\n                fillRule: \"nonzero\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"miter\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        })\n    })),\n    wR: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"#ffffff\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 34,14 L 31,17 L 14,17 L 11,14\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 31,17 L 31,29.5 L 14,29.5 L 14,17\",\n                    style: {\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 34,14\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    wN: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\",\n                    transform: \"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                })\n            ]\n        }))\n    })),\n    wB: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillRule: \"evenodd\",\n                fillOpacity: \"1\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\"\n                    }\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\"\n                        })\n                    ]\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    wQ: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"#ffffff\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinejoin: \"round\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11.5,30 C 15,29 30,29 33.5,30\",\n                    style: {\n                        fill: \"none\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,33.5 C 18,32.5 27,32.5 33,33.5\",\n                    style: {\n                        fill: \"none\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"6\",\n                    cy: \"12\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"14\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"22.5\",\n                    cy: \"8\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"31\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"39\",\n                    cy: \"12\",\n                    r: \"2\"\n                })\n            ]\n        }))\n    })),\n    wK: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,11.63 L 22.5,6\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 20,8 L 25,8\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,30 C 18,27 27,27 32.5,30\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,37 C 18,34 27,34 32.5,37\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bP: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\",\n            style: {\n                opacity: \"1\",\n                fill: \"#000000\",\n                fillOpacity: \"1\",\n                fillRule: \"nonzero\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"miter\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        })\n    })),\n    bR: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"#000000\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \",\n                    style: {\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,35.5 L 33,35.5 L 33,35.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 13,31.5 L 32,31.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,29.5 L 31,29.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,16.5 L 31,16.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 34,14\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bN: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#ffffff\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\",\n                    transform: \"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#ffffff\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"none\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bB: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillRule: \"evenodd\",\n                fillOpacity: \"1\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\"\n                    }\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\"\n                        })\n                    ]\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bQ: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"#000000\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\",\n                    style: {\n                        strokeLinecap: \"butt\",\n                        fill: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11.5,30 C 15,29 30,29 33.5,30\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"m 12,33.5 c 6,-1 15,-1 21,0\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"6\",\n                    cy: \"12\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"14\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"22.5\",\n                    cy: \"8\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"31\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"39\",\n                    cy: \"12\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,38.5 A 35,35 1 0 0 34,38.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\"\n                    }\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 11,29 A 35,35 1 0 1 34,29\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 12.5,31.5 L 32.5,31.5\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"\n                        })\n                    ]\n                }))\n            ]\n        }))\n    })),\n    bK: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,11.63 L 22.5,6\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    },\n                    id: \"path6570\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\",\n                    style: {\n                        fill: \"#000000\",\n                        fillOpacity: \"1\",\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 20,8 L 25,8\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\"\n                    }\n                })\n            ]\n        }))\n    }))\n};\n/**\r\n * Retrieves the coordinates at the centre of the requested square, relative to the top left of the board (0, 0).\r\n */ function getRelativeCoords(boardOrientation, boardWidth, square) {\n    const squareWidth = boardWidth / 8;\n    const columns = boardOrientation === \"white\" ? WHITE_COLUMN_VALUES : BLACK_COLUMN_VALUES;\n    const rows = boardOrientation === \"white\" ? WHITE_ROWS : BLACK_ROWS;\n    const x = columns[square[0]] * squareWidth + squareWidth / 2;\n    const y = rows[parseInt(square[1], 10) - 1] * squareWidth + squareWidth / 2;\n    return {\n        x,\n        y\n    };\n}\n/**\r\n * Returns whether the passed position is different from the start position.\r\n */ function isDifferentFromStart(newPosition) {\n    let isDifferent = false;\n    Object.keys(START_POSITION_OBJECT).forEach((square)=>{\n        if (newPosition[square] !== START_POSITION_OBJECT[square]) isDifferent = true;\n    });\n    Object.keys(newPosition).forEach((square)=>{\n        if (START_POSITION_OBJECT[square] !== newPosition[square]) isDifferent = true;\n    });\n    return isDifferent;\n}\n/**\r\n * Returns what pieces have been added and what pieces have been removed between board positions.\r\n */ function getPositionDifferences(currentPosition, newPosition) {\n    const difference = {\n        removed: {},\n        added: {}\n    };\n    // removed from current\n    Object.keys(currentPosition).forEach((square)=>{\n        if (newPosition[square] !== currentPosition[square]) difference.removed[square] = currentPosition[square];\n    });\n    // added from new\n    Object.keys(newPosition).forEach((square)=>{\n        if (currentPosition[square] !== newPosition[square]) difference.added[square] = newPosition[square];\n    });\n    return difference;\n}\n/**\r\n * Converts a fen string or existing position object to a position object.\r\n */ function convertPositionToObject(position) {\n    if (position === \"start\") {\n        return START_POSITION_OBJECT;\n    }\n    if (typeof position === \"string\") {\n        // attempt to convert fen to position object\n        return fenToObj(position);\n    }\n    return position;\n}\n/**\r\n * Converts a fen string to a position object.\r\n */ function fenToObj(fen) {\n    if (!isValidFen(fen)) return {};\n    // cut off any move, castling, etc info from the end. we're only interested in position information\n    fen = fen.replace(/ .+$/, \"\");\n    const rows = fen.split(\"/\");\n    const position = {};\n    let currentRow = 8;\n    for(let i = 0; i < 8; i++){\n        const row = rows[i].split(\"\");\n        let colIdx = 0;\n        // loop through each character in the FEN section\n        for(let j = 0; j < row.length; j++){\n            // number / empty squares\n            if (row[j].search(/[1-8]/) !== -1) {\n                const numEmptySquares = parseInt(row[j], 10);\n                colIdx = colIdx + numEmptySquares;\n            } else {\n                // piece\n                const square = COLUMNS[colIdx] + currentRow;\n                position[square] = fenToPieceCode(row[j]);\n                colIdx = colIdx + 1;\n            }\n        }\n        currentRow = currentRow - 1;\n    }\n    return position;\n}\n/**\r\n * Returns whether string is valid fen notation.\r\n */ function isValidFen(fen) {\n    // cut off any move, castling, etc info from the end. we're only interested in position information\n    fen = fen.replace(/ .+$/, \"\");\n    // expand the empty square numbers to just 1s\n    fen = expandFenEmptySquares(fen);\n    // fen should be 8 sections separated by slashes\n    const chunks = fen.split(\"/\");\n    if (chunks.length !== 8) return false;\n    // check each section\n    for(let i = 0; i < 8; i++){\n        if (chunks[i].length !== 8 || chunks[i].search(/[^kqrnbpKQRNBP1]/) !== -1) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * Expand out fen notation to countable characters for validation\r\n */ function expandFenEmptySquares(fen) {\n    return fen.replace(/8/g, \"11111111\").replace(/7/g, \"1111111\").replace(/6/g, \"111111\").replace(/5/g, \"11111\").replace(/4/g, \"1111\").replace(/3/g, \"111\").replace(/2/g, \"11\");\n}\n/**\r\n * Convert fen piece code to camel case notation. e.g. bP, wK.\r\n */ function fenToPieceCode(piece) {\n    // black piece\n    if (piece.toLowerCase() === piece) {\n        return \"b\" + piece.toUpperCase();\n    }\n    // white piece\n    return \"w\" + piece.toUpperCase();\n}\nconst useArrows = (customArrows, areArrowsAllowed = true, onArrowsChange, customArrowColor)=>{\n    // arrows passed programatically to `ChessBoard` as a react prop\n    const [customArrowsSet, setCustomArrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // arrows drawn with mouse by user on the board\n    const [arrows, setArrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // active arrow which user draws while dragging mouse\n    const [newArrow, setNewArrow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    // handle external `customArrows` props changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (Array.isArray(customArrows)) {\n            // so that custom arrows overwrite temporary arrows\n            clearArrows();\n            setCustomArrows(//filter out arrows which starts and ends in the same square\n            customArrows === null || customArrows === void 0 ? void 0 : customArrows.filter((arrow)=>arrow[0] !== arrow[1]));\n        }\n    }, [\n        customArrows\n    ]);\n    // callback when arrows changed after user interaction\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        onArrowsChange === null || onArrowsChange === void 0 ? void 0 : onArrowsChange(arrows);\n    }, [\n        arrows\n    ]);\n    // function clears all arrows drawed by user\n    function clearArrows() {\n        setArrows([]);\n        setNewArrow(undefined);\n    }\n    const drawNewArrow = (fromSquare, toSquare)=>{\n        if (!areArrowsAllowed) return;\n        setNewArrow([\n            fromSquare,\n            toSquare,\n            customArrowColor\n        ]);\n    };\n    const allBoardArrows = [\n        ...arrows,\n        ...customArrowsSet\n    ];\n    const onArrowDrawEnd = (fromSquare, toSquare)=>{\n        if (fromSquare === toSquare || !areArrowsAllowed) return;\n        let arrowsCopy;\n        const newArrow = [\n            fromSquare,\n            toSquare,\n            customArrowColor\n        ];\n        const isNewArrowUnique = allBoardArrows.every(([arrowFrom, arrowTo])=>{\n            return !(arrowFrom === fromSquare && arrowTo === toSquare);\n        });\n        // add the newArrow to arrows array if it is unique\n        if (isNewArrowUnique) {\n            arrowsCopy = [\n                ...arrows,\n                newArrow\n            ];\n        } else {\n            arrowsCopy = arrows.filter(([arrowFrom, arrowTo])=>{\n                return !(arrowFrom === fromSquare && arrowTo === toSquare);\n            });\n        }\n        setNewArrow(undefined);\n        setArrows(arrowsCopy);\n    };\n    return {\n        arrows: allBoardArrows,\n        newArrow,\n        clearArrows,\n        drawNewArrow,\n        setArrows,\n        onArrowDrawEnd\n    };\n};\nconst ChessboardContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nconst useChessboard = ()=>(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChessboardContext);\nconst ChessboardProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ allowDragOutsideBoard = true, animationDuration = 300, areArrowsAllowed = true, arePiecesDraggable = true, arePremovesAllowed = false, autoPromoteToQueen = false, boardOrientation = \"white\", boardWidth, children, clearPremovesOnRightClick = true, customArrows, customArrowColor = \"rgb(255,170,0)\", customBoardStyle, customNotationStyle, customDarkSquareStyle = {\n    backgroundColor: \"#B58863\"\n}, customDropSquareStyle = {\n    boxShadow: \"inset 0 0 1px 6px rgba(255,255,255,0.75)\"\n}, customLightSquareStyle = {\n    backgroundColor: \"#F0D9B5\"\n}, customPieces, customPremoveDarkSquareStyle = {\n    backgroundColor: \"#A42323\"\n}, customPremoveLightSquareStyle = {\n    backgroundColor: \"#BD2828\"\n}, customSquare = \"div\", customSquareStyles, dropOffBoardAction = \"snapback\", id = 0, isDraggablePiece = ()=>true, getPositionObject = ()=>{}, onArrowsChange = ()=>{}, onDragOverSquare = ()=>{}, onMouseOutSquare = ()=>{}, onMouseOverSquare = ()=>{}, onPieceClick = ()=>{}, onPieceDragBegin = ()=>{}, onPieceDragEnd = ()=>{}, onPieceDrop = ()=>true, onPieceDropOffBoard = ()=>{}, onPromotionCheck = (sourceSquare, targetSquare, piece)=>{\n    return (piece === \"wP\" && sourceSquare[1] === \"7\" && targetSquare[1] === \"8\" || piece === \"bP\" && sourceSquare[1] === \"2\" && targetSquare[1] === \"1\") && Math.abs(sourceSquare.charCodeAt(0) - targetSquare.charCodeAt(0)) <= 1;\n}, onPromotionPieceSelect = ()=>true, onSparePieceDrop = ()=>true, onSquareClick = ()=>{}, onSquareRightClick = ()=>{}, position = \"start\", promotionDialogVariant = \"default\", promotionToSquare = null, showBoardNotation = true, showPromotionDialog = false, snapToCursor = true }, ref)=>{\n    // position stored and displayed on board\n    const [currentPosition, setCurrentPosition] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(convertPositionToObject(position));\n    // calculated differences between current and incoming positions\n    const [positionDifferences, setPositionDifferences] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        removed: {},\n        added: {}\n    });\n    // colour of last piece moved to determine if premoving\n    const [lastPieceColour, setLastPieceColour] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined);\n    // show / hide promotion dialog\n    const [showPromoteDialog, setShowPromoteDialog] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(showPromotionDialog && !autoPromoteToQueen);\n    // which square a pawn is being promoted to\n    const [promoteFromSquare, setPromoteFromSquare] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [promoteToSquare, setPromoteToSquare] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(promotionToSquare);\n    // current premoves\n    const [premoves, setPremoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // ref used to access current value during timeouts (closures)\n    const premovesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(premoves);\n    // current right mouse down square\n    const [currentRightClickDown, setCurrentRightClickDown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    // chess pieces/styling\n    const [chessPieces, setChessPieces] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Object.assign(Object.assign({}, defaultPieces), customPieces));\n    // whether the last move was a manual drop or not\n    const [wasManualDrop, setWasManualDrop] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // the most recent timeout whilst waiting for animation to complete\n    const [previousTimeout, setPreviousTimeout] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    // if currently waiting for an animation to finish\n    const [isWaitingForAnimation, setIsWaitingForAnimation] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // last square dragged over for checking in touch events\n    const [lastSquareDraggedOver, setLastSquareDraggedOver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // open clearPremoves() to allow user to call on undo/reset/whenever\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, ()=>({\n            clearPremoves (clearLastPieceColour = true) {\n                clearPremoves(clearLastPieceColour);\n            }\n        }));\n    // handle custom pieces change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setChessPieces(Object.assign(Object.assign({}, defaultPieces), customPieces));\n    }, [\n        customPieces\n    ]);\n    // handle promote changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setShowPromoteDialog(showPromotionDialog);\n        setPromoteToSquare(promotionToSquare);\n    }, [\n        promotionToSquare,\n        showPromotionDialog\n    ]);\n    // handle external position change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _a, _b, _c;\n        // clear any open promotion dialogs\n        clearPromotion();\n        const newPosition = convertPositionToObject(position);\n        const differences = getPositionDifferences(currentPosition, newPosition);\n        const newPieceColour = ((_a = Object.keys(differences.added)) === null || _a === void 0 ? void 0 : _a.length) <= 2 ? (_c = (_b = Object.entries(differences.added)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c[1][0] : undefined;\n        // external move has come in before animation is over\n        // cancel animation and immediately update position\n        if (isWaitingForAnimation) {\n            setCurrentPosition(newPosition);\n            setIsWaitingForAnimation(false);\n            arePremovesAllowed && attemptPremove(newPieceColour);\n            if (previousTimeout) {\n                clearTimeout(previousTimeout);\n            }\n        } else {\n            // move was made using drag and drop\n            if (wasManualDrop) {\n                setCurrentPosition(newPosition);\n                setIsWaitingForAnimation(false);\n                arePremovesAllowed && attemptPremove(newPieceColour);\n            } else {\n                // move was made by external position change\n                // if position === start then don't override newPieceColour\n                // needs isDifferentFromStart in scenario where premoves have been cleared upon board reset but first move is made by computer, the last move colour would need to be updated\n                if (isDifferentFromStart(newPosition) && lastPieceColour !== undefined) {\n                    setLastPieceColour(newPieceColour);\n                } else if (!isDifferentFromStart(newPosition)) {\n                    // position === start, likely a board reset. set to black to allow black to make premoves on first move\n                    setLastPieceColour(\"b\");\n                } else {\n                    setLastPieceColour(undefined);\n                }\n                setPositionDifferences(differences);\n                // animate external move\n                setIsWaitingForAnimation(true);\n                const newTimeout = setTimeout(()=>{\n                    setCurrentPosition(newPosition);\n                    setIsWaitingForAnimation(false);\n                    arePremovesAllowed && attemptPremove(newPieceColour);\n                }, animationDuration);\n                setPreviousTimeout(newTimeout);\n            }\n        }\n        // reset manual drop, ready for next move to be made by user or external\n        setWasManualDrop(false);\n        // inform latest position information\n        getPositionObject(newPosition);\n        // clear arrows\n        clearArrows();\n        // clear timeout on unmount\n        return ()=>{\n            clearTimeout(previousTimeout);\n        };\n    }, [\n        position\n    ]);\n    const { arrows, newArrow, clearArrows, drawNewArrow, onArrowDrawEnd } = useArrows(customArrows, areArrowsAllowed, onArrowsChange, customArrowColor);\n    // handle drop position change\n    function handleSetPosition(sourceSq, targetSq, piece, wasManualDropOverride) {\n        // if dropped back down, don't do anything\n        if (sourceSq === targetSq) {\n            return;\n        }\n        clearArrows();\n        // if second move is made for same colour, or there are still premoves queued, then this move needs to be added to premove queue instead of played\n        // premoves length check for colour is added in because white could make 3 premoves, and then black responds to the first move (changing the last piece colour) and then white pre-moves again\n        if (arePremovesAllowed && isWaitingForAnimation || arePremovesAllowed && (lastPieceColour === piece[0] || premovesRef.current.filter((p)=>p.piece[0] === piece[0]).length > 0)) {\n            const oldPremoves = [\n                ...premovesRef.current\n            ];\n            oldPremoves.push({\n                sourceSq,\n                targetSq,\n                piece\n            });\n            premovesRef.current = oldPremoves;\n            setPremoves([\n                ...oldPremoves\n            ]);\n            clearPromotion();\n            return;\n        }\n        // if transitioning, don't allow new drop\n        if (!arePremovesAllowed && isWaitingForAnimation) return;\n        const newOnDropPosition = Object.assign({}, currentPosition);\n        setWasManualDrop(!!wasManualDropOverride);\n        setLastPieceColour(piece[0]);\n        // if onPieceDrop function provided, execute it, position must be updated externally and captured by useEffect above for this move to show on board\n        if (onPieceDrop.length) {\n            const isValidMove = onPieceDrop(sourceSq, targetSq, piece);\n            if (!isValidMove) {\n                clearPremoves();\n                setWasManualDrop(false);\n            }\n        } else {\n            // delete source piece\n            delete newOnDropPosition[sourceSq];\n            // add piece in new position\n            newOnDropPosition[targetSq] = piece;\n            setCurrentPosition(newOnDropPosition);\n        }\n        clearPromotion();\n        // inform latest position information\n        getPositionObject(newOnDropPosition);\n    }\n    function deletePieceFromSquare(square) {\n        const positionCopy = Object.assign({}, currentPosition);\n        delete positionCopy[square];\n        setCurrentPosition(positionCopy);\n        // inform latest position information\n        getPositionObject(positionCopy);\n    }\n    function attemptPremove(newPieceColour) {\n        if (premovesRef.current.length === 0) return;\n        // get current value of premove as this is called in a timeout so value may have changed since timeout was set\n        const premove = premovesRef.current[0];\n        // if premove is a differing colour to last move made, then this move can be made\n        if (premove.piece[0] !== undefined && premove.piece[0] !== newPieceColour && onPieceDrop.length) {\n            setLastPieceColour(premove.piece[0]);\n            setWasManualDrop(true); // pre-move doesn't need animation\n            const isValidMove = onPieceDrop(premove.sourceSq, premove.targetSq, premove.piece);\n            // premove was successful and can be removed from queue\n            if (isValidMove) {\n                const oldPremoves = [\n                    ...premovesRef.current\n                ];\n                oldPremoves.shift();\n                premovesRef.current = oldPremoves;\n                setPremoves([\n                    ...oldPremoves\n                ]);\n            } else {\n                // premove wasn't successful, clear premove queue\n                clearPremoves();\n            }\n        }\n    }\n    function handleSparePieceDrop(piece, targetSq) {\n        const isValidDrop = onSparePieceDrop(piece, targetSq);\n        if (!isValidDrop) return;\n        const newOnDropPosition = Object.assign({}, currentPosition);\n        // add piece in new position\n        newOnDropPosition[targetSq] = piece;\n        setCurrentPosition(newOnDropPosition);\n        // inform latest position information\n        getPositionObject(newOnDropPosition);\n    }\n    function clearPremoves(clearLastPieceColour = true) {\n        // don't clear when right clicking to clear, otherwise you won't be able to premove again before next go\n        if (clearLastPieceColour) setLastPieceColour(undefined);\n        premovesRef.current = [];\n        setPremoves([]);\n    }\n    function clearPromotion() {\n        setPromoteFromSquare(null);\n        setPromoteToSquare(null);\n        setShowPromoteDialog(false);\n    }\n    function onRightClickDown(square) {\n        setCurrentRightClickDown(square);\n    }\n    function onRightClickUp(square) {\n        if (currentRightClickDown) {\n            // same square, don't draw an arrow, but do clear premoves and run onSquareRightClick\n            if (currentRightClickDown === square) {\n                setCurrentRightClickDown(undefined);\n                clearPremovesOnRightClick && clearPremoves(false);\n                onSquareRightClick(square);\n                return;\n            }\n        } else setCurrentRightClickDown(undefined);\n    }\n    function clearCurrentRightClickDown() {\n        setCurrentRightClickDown(undefined);\n    }\n    const ChessboardProviderContextValue = {\n        allowDragOutsideBoard,\n        animationDuration,\n        arePiecesDraggable,\n        arePremovesAllowed,\n        arrows,\n        autoPromoteToQueen,\n        boardOrientation,\n        boardWidth,\n        chessPieces,\n        clearArrows,\n        clearCurrentRightClickDown,\n        currentPosition,\n        currentRightClickDown,\n        customArrowColor,\n        customBoardStyle,\n        customDarkSquareStyle,\n        customDropSquareStyle,\n        customLightSquareStyle,\n        customNotationStyle,\n        customPremoveDarkSquareStyle,\n        customPremoveLightSquareStyle,\n        customSquare,\n        customSquareStyles,\n        deletePieceFromSquare,\n        drawNewArrow,\n        dropOffBoardAction,\n        handleSetPosition,\n        handleSparePieceDrop,\n        id,\n        isDraggablePiece,\n        isWaitingForAnimation,\n        lastPieceColour,\n        lastSquareDraggedOver,\n        newArrow,\n        onArrowDrawEnd,\n        onDragOverSquare,\n        onMouseOutSquare,\n        onMouseOverSquare,\n        onPieceClick,\n        onPieceDragBegin,\n        onPieceDragEnd,\n        onPieceDrop,\n        onPieceDropOffBoard,\n        onPromotionCheck,\n        onPromotionPieceSelect,\n        onRightClickDown,\n        onRightClickUp,\n        onSparePieceDrop,\n        onSquareClick,\n        positionDifferences,\n        premoves,\n        promoteFromSquare,\n        promoteToSquare,\n        promotionDialogVariant,\n        setLastSquareDraggedOver,\n        setPromoteFromSquare,\n        setPromoteToSquare,\n        setShowPromoteDialog,\n        showBoardNotation,\n        showPromoteDialog,\n        snapToCursor\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardContext.Provider, Object.assign({\n        value: ChessboardProviderContextValue\n    }, {\n        children: children\n    }));\n});\nfunction Notation({ row, col }) {\n    const { boardOrientation, boardWidth, customDarkSquareStyle, customLightSquareStyle, customNotationStyle } = useChessboard();\n    const whiteColor = customLightSquareStyle.backgroundColor;\n    const blackColor = customDarkSquareStyle.backgroundColor;\n    const isRow = col === 0;\n    const isColumn = row === 7;\n    const isBottomLeftSquare = isRow && isColumn;\n    function getRow() {\n        return boardOrientation === \"white\" ? 8 - row : row + 1;\n    }\n    function getColumn() {\n        return boardOrientation === \"black\" ? COLUMNS[7 - col] : COLUMNS[col];\n    }\n    function renderBottomLeft() {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                    style: Object.assign(Object.assign({\n                        zIndex: 3,\n                        position: \"absolute\"\n                    }, {\n                        color: whiteColor\n                    }), numericStyle(boardWidth, customNotationStyle))\n                }, {\n                    children: getRow()\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                    style: Object.assign(Object.assign({\n                        zIndex: 3,\n                        position: \"absolute\"\n                    }, {\n                        color: whiteColor\n                    }), alphaStyle(boardWidth, customNotationStyle))\n                }, {\n                    children: getColumn()\n                }))\n            ]\n        });\n    }\n    function renderLetters() {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: Object.assign(Object.assign({\n                userSelect: \"none\",\n                zIndex: 3,\n                position: \"absolute\"\n            }, {\n                color: col % 2 !== 0 ? blackColor : whiteColor\n            }), alphaStyle(boardWidth, customNotationStyle))\n        }, {\n            children: getColumn()\n        }));\n    }\n    function renderNumbers() {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: Object.assign(Object.assign({\n                userSelect: \"none\",\n                zIndex: 3,\n                position: \"absolute\"\n            }, boardOrientation === \"black\" ? {\n                color: row % 2 === 0 ? blackColor : whiteColor\n            } : {\n                color: row % 2 === 0 ? blackColor : whiteColor\n            }), numericStyle(boardWidth, customNotationStyle))\n        }, {\n            children: getRow()\n        }));\n    }\n    if (isBottomLeftSquare) {\n        return renderBottomLeft();\n    }\n    if (isColumn) {\n        return renderLetters();\n    }\n    if (isRow) {\n        return renderNumbers();\n    }\n    return null;\n}\nconst alphaStyle = (width, customNotationStyle)=>Object.assign({\n        alignSelf: \"flex-end\",\n        paddingLeft: width / 8 - width / 48,\n        fontSize: width / 48\n    }, customNotationStyle);\nconst numericStyle = (width, customNotationStyle)=>Object.assign({\n        alignSelf: \"flex-start\",\n        paddingRight: width / 8 - width / 48,\n        fontSize: width / 48\n    }, customNotationStyle);\n/**\n * Create the React Context\n */ const DndContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    dragDropManager: undefined\n});\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */ function formatProdErrorMessage(code) {\n    return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + \"use the non-minified dev environment for full errors. \";\n}\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = function() {\n    return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n}();\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */ var randomString = function randomString() {\n    return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n};\nvar ActionTypes = {\n    INIT: \"@@redux/INIT\" + randomString(),\n    REPLACE: \"@@redux/REPLACE\" + randomString(),\n    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n    }\n};\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */ function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    var proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n}\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n    if (val === void 0) return \"undefined\";\n    if (val === null) return \"null\";\n    var type = typeof val;\n    switch(type){\n        case \"boolean\":\n        case \"string\":\n        case \"number\":\n        case \"symbol\":\n        case \"function\":\n            {\n                return type;\n            }\n    }\n    if (Array.isArray(val)) return \"array\";\n    if (isDate(val)) return \"date\";\n    if (isError(val)) return \"error\";\n    var constructorName = ctorName(val);\n    switch(constructorName){\n        case \"Symbol\":\n        case \"Promise\":\n        case \"WeakMap\":\n        case \"WeakSet\":\n        case \"Map\":\n        case \"Set\":\n            return constructorName;\n    } // other\n    return type.slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n    if (val instanceof Date) return true;\n    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n    var typeOfVal = typeof val;\n    if (true) {\n        typeOfVal = miniKindOf(val);\n    }\n    return typeOfVal;\n}\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */ function createStore(reducer, preloadedState, enhancer) {\n    var _ref2;\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n        throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to \" + \"createStore(). This is not supported. Instead, compose them \" + \"together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    if (typeof enhancer !== \"undefined\") {\n        if (typeof enhancer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n        }\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    if (typeof reducer !== \"function\") {\n        throw new Error( false ? 0 : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n    }\n    var currentReducer = reducer;\n    var currentState = preloadedState;\n    var currentListeners = [];\n    var nextListeners = currentListeners;\n    var isDispatching = false;\n    /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */ function ensureCanMutateNextListeners() {\n        if (nextListeners === currentListeners) {\n            nextListeners = currentListeners.slice();\n        }\n    }\n    /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */ function getState() {\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. \" + \"The reducer has already received the state as an argument. \" + \"Pass it down from the top reducer instead of reading it from the store.\");\n        }\n        return currentState;\n    }\n    /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */ function subscribe(listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. \" + \"If you would like to be notified after the store has been updated, subscribe from a \" + \"component and invoke store.getState() in the callback to access the latest state. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n        }\n        var isSubscribed = true;\n        ensureCanMutateNextListeners();\n        nextListeners.push(listener);\n        return function unsubscribe() {\n            if (!isSubscribed) {\n                return;\n            }\n            if (isDispatching) {\n                throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n            }\n            isSubscribed = false;\n            ensureCanMutateNextListeners();\n            var index = nextListeners.indexOf(listener);\n            nextListeners.splice(index, 1);\n            currentListeners = null;\n        };\n    }\n    /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */ function dispatch(action) {\n        if (!isPlainObject(action)) {\n            throw new Error( false ? 0 : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n        }\n        if (typeof action.type === \"undefined\") {\n            throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n        }\n        try {\n            isDispatching = true;\n            currentState = currentReducer(currentState, action);\n        } finally{\n            isDispatching = false;\n        }\n        var listeners = currentListeners = nextListeners;\n        for(var i = 0; i < listeners.length; i++){\n            var listener = listeners[i];\n            listener();\n        }\n        return action;\n    }\n    /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */ function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n        }\n        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n        // Any reducers that existed in both the new and old rootReducer\n        // will receive the previous state. This effectively populates\n        // the new state tree with any relevant data from the old one.\n        dispatch({\n            type: ActionTypes.REPLACE\n        });\n    }\n    /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */ function observable() {\n        var _ref;\n        var outerSubscribe = subscribe;\n        return _ref = {\n            /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe: function subscribe(observer) {\n                if (typeof observer !== \"object\" || observer === null) {\n                    throw new Error( false ? 0 : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n                }\n                function observeState() {\n                    if (observer.next) {\n                        observer.next(getState());\n                    }\n                }\n                observeState();\n                var unsubscribe = outerSubscribe(observeState);\n                return {\n                    unsubscribe: unsubscribe\n                };\n            }\n        }, _ref[$$observable] = function() {\n            return this;\n        }, _ref;\n    } // When a store is created, an \"INIT\" action is dispatched so that every\n    // reducer returns their initial state. This effectively populates\n    // the initial state tree.\n    dispatch({\n        type: ActionTypes.INIT\n    });\n    return _ref2 = {\n        dispatch: dispatch,\n        subscribe: subscribe,\n        getState: getState,\n        replaceReducer: replaceReducer\n    }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */ function warning(message) {\n    /* eslint-disable no-console */ if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    /* eslint-enable no-console */ try {\n        // This error was thrown as a convenience so that if you enable\n        // \"break on all exceptions\" in your console,\n        // it would pause the execution at this line.\n        throw new Error(message);\n    } catch (e) {} // eslint-disable-line no-empty\n}\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */ function isCrushed() {}\nif ( true && typeof isCrushed.name === \"string\" && isCrushed.name !== \"isCrushed\") {\n    warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + \"This means that you are running a slower development build of Redux. \" + \"You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify \" + \"or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) \" + \"to ensure you have the correct code for your production build.\");\n}\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ function invariant(condition, format, ...args) {\n    if (isProduction()) {\n        if (format === undefined) {\n            throw new Error(\"invariant requires an error message argument\");\n        }\n    }\n    if (!condition) {\n        let error;\n        if (format === undefined) {\n            error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n        } else {\n            let argIndex = 0;\n            error = new Error(format.replace(/%s/g, function() {\n                return args[argIndex++];\n            }));\n            error.name = \"Invariant Violation\";\n        }\n        error.framesToPop = 1 // we don't care about invariant's own frame\n        ;\n        throw error;\n    }\n}\nfunction isProduction() {\n    return typeof process !== \"undefined\" && \"development\" === \"production\";\n}\n// cheap lodash replacements\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */ function get(obj, path, defaultValue) {\n    return path.split(\".\").reduce((a, c)=>a && a[c] ? a[c] : defaultValue || null, obj);\n}\n/**\n * drop-in replacement for _.without\n */ function without$1(items, item) {\n    return items.filter((i)=>i !== item);\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */ function isObject(input) {\n    return typeof input === \"object\";\n}\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */ function xor(itemsA, itemsB) {\n    const map = new Map();\n    const insertItem = (item)=>{\n        map.set(item, map.has(item) ? map.get(item) + 1 : 1);\n    };\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    map.forEach((count, key)=>{\n        if (count === 1) {\n            result.push(key);\n        }\n    });\n    return result;\n}\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */ function intersection(itemsA, itemsB) {\n    return itemsA.filter((t)=>itemsB.indexOf(t) > -1);\n}\nconst INIT_COORDS = \"dnd-core/INIT_COORDS\";\nconst BEGIN_DRAG = \"dnd-core/BEGIN_DRAG\";\nconst PUBLISH_DRAG_SOURCE = \"dnd-core/PUBLISH_DRAG_SOURCE\";\nconst HOVER = \"dnd-core/HOVER\";\nconst DROP = \"dnd-core/DROP\";\nconst END_DRAG = \"dnd-core/END_DRAG\";\nfunction setClientOffset(clientOffset, sourceClientOffset) {\n    return {\n        type: INIT_COORDS,\n        payload: {\n            sourceClientOffset: sourceClientOffset || null,\n            clientOffset: clientOffset || null\n        }\n    };\n}\nconst ResetCoordinatesAction = {\n    type: INIT_COORDS,\n    payload: {\n        clientOffset: null,\n        sourceClientOffset: null\n    }\n};\nfunction createBeginDrag(manager) {\n    return function beginDrag(sourceIds = [], options = {\n        publishSource: true\n    }) {\n        const { publishSource = true, clientOffset, getSourceClientOffset } = options;\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        // Initialize the coordinates using the client offset\n        manager.dispatch(setClientOffset(clientOffset));\n        verifyInvariants$1(sourceIds, monitor, registry);\n        // Get the draggable source\n        const sourceId = getDraggableSource(sourceIds, monitor);\n        if (sourceId == null) {\n            manager.dispatch(ResetCoordinatesAction);\n            return;\n        }\n        // Get the source client offset\n        let sourceClientOffset = null;\n        if (clientOffset) {\n            if (!getSourceClientOffset) {\n                throw new Error(\"getSourceClientOffset must be defined\");\n            }\n            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);\n            sourceClientOffset = getSourceClientOffset(sourceId);\n        }\n        // Initialize the full coordinates\n        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));\n        const source = registry.getSource(sourceId);\n        const item = source.beginDrag(monitor, sourceId);\n        // If source.beginDrag returns null, this is an indicator to cancel the drag\n        if (item == null) {\n            return undefined;\n        }\n        verifyItemIsObject(item);\n        registry.pinSource(sourceId);\n        const itemType = registry.getSourceType(sourceId);\n        return {\n            type: BEGIN_DRAG,\n            payload: {\n                itemType,\n                item,\n                sourceId,\n                clientOffset: clientOffset || null,\n                sourceClientOffset: sourceClientOffset || null,\n                isSourcePublic: !!publishSource\n            }\n        };\n    };\n}\nfunction verifyInvariants$1(sourceIds, monitor, registry) {\n    invariant(!monitor.isDragging(), \"Cannot call beginDrag while dragging.\");\n    sourceIds.forEach(function(sourceId) {\n        invariant(registry.getSource(sourceId), \"Expected sourceIds to be registered.\");\n    });\n}\nfunction verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {\n    invariant(typeof getSourceClientOffset === \"function\", \"When clientOffset is provided, getSourceClientOffset must be a function.\");\n}\nfunction verifyItemIsObject(item) {\n    invariant(isObject(item), \"Item must be an object.\");\n}\nfunction getDraggableSource(sourceIds, monitor) {\n    let sourceId = null;\n    for(let i = sourceIds.length - 1; i >= 0; i--){\n        if (monitor.canDragSource(sourceIds[i])) {\n            sourceId = sourceIds[i];\n            break;\n        }\n    }\n    return sourceId;\n}\nfunction _defineProperty$4(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$4(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction createDrop(manager) {\n    return function drop(options = {}) {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyInvariants(monitor);\n        const targetIds = getDroppableTargets(monitor);\n        // Multiple actions are dispatched here, which is why this doesn't return an action\n        targetIds.forEach((targetId, index)=>{\n            const dropResult = determineDropResult(targetId, index, registry, monitor);\n            const action = {\n                type: DROP,\n                payload: {\n                    dropResult: _objectSpread$4({}, options, dropResult)\n                }\n            };\n            manager.dispatch(action);\n        });\n    };\n}\nfunction verifyInvariants(monitor) {\n    invariant(monitor.isDragging(), \"Cannot call drop while not dragging.\");\n    invariant(!monitor.didDrop(), \"Cannot call drop twice during one drag operation.\");\n}\nfunction determineDropResult(targetId, index, registry, monitor) {\n    const target = registry.getTarget(targetId);\n    let dropResult = target ? target.drop(monitor, targetId) : undefined;\n    verifyDropResultType(dropResult);\n    if (typeof dropResult === \"undefined\") {\n        dropResult = index === 0 ? {} : monitor.getDropResult();\n    }\n    return dropResult;\n}\nfunction verifyDropResultType(dropResult) {\n    invariant(typeof dropResult === \"undefined\" || isObject(dropResult), \"Drop result must either be an object or undefined.\");\n}\nfunction getDroppableTargets(monitor) {\n    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n    targetIds.reverse();\n    return targetIds;\n}\nfunction createEndDrag(manager) {\n    return function endDrag() {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyIsDragging(monitor);\n        const sourceId = monitor.getSourceId();\n        if (sourceId != null) {\n            const source = registry.getSource(sourceId, true);\n            source.endDrag(monitor, sourceId);\n            registry.unpinSource();\n        }\n        return {\n            type: END_DRAG\n        };\n    };\n}\nfunction verifyIsDragging(monitor) {\n    invariant(monitor.isDragging(), \"Cannot call endDrag while not dragging.\");\n}\nfunction matchesType(targetType, draggedItemType) {\n    if (draggedItemType === null) {\n        return targetType === null;\n    }\n    return Array.isArray(targetType) ? targetType.some((t)=>t === draggedItemType) : targetType === draggedItemType;\n}\nfunction createHover(manager) {\n    return function hover(targetIdsArg, { clientOffset } = {}) {\n        verifyTargetIdsIsArray(targetIdsArg);\n        const targetIds = targetIdsArg.slice(0);\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        const draggedItemType = monitor.getItemType();\n        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n        checkInvariants(targetIds, monitor, registry);\n        hoverAllTargets(targetIds, monitor, registry);\n        return {\n            type: HOVER,\n            payload: {\n                targetIds,\n                clientOffset: clientOffset || null\n            }\n        };\n    };\n}\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n    invariant(Array.isArray(targetIdsArg), \"Expected targetIds to be an array.\");\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n    invariant(monitor.isDragging(), \"Cannot call hover while not dragging.\");\n    invariant(!monitor.didDrop(), \"Cannot call hover after drop.\");\n    for(let i = 0; i < targetIds.length; i++){\n        const targetId = targetIds[i];\n        invariant(targetIds.lastIndexOf(targetId) === i, \"Expected targetIds to be unique in the passed array.\");\n        const target = registry.getTarget(targetId);\n        invariant(target, \"Expected targetIds to be registered.\");\n    }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n    // Remove those targetIds that don't match the targetType.  This\n    // fixes shallow isOver which would only be non-shallow because of\n    // non-matching targets.\n    for(let i = targetIds.length - 1; i >= 0; i--){\n        const targetId = targetIds[i];\n        const targetType = registry.getTargetType(targetId);\n        if (!matchesType(targetType, draggedItemType)) {\n            targetIds.splice(i, 1);\n        }\n    }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n    // Finally call hover on all matching targets.\n    targetIds.forEach(function(targetId) {\n        const target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n    });\n}\nfunction createPublishDragSource(manager) {\n    return function publishDragSource() {\n        const monitor = manager.getMonitor();\n        if (monitor.isDragging()) {\n            return {\n                type: PUBLISH_DRAG_SOURCE\n            };\n        }\n        return;\n    };\n}\nfunction createDragDropActions(manager) {\n    return {\n        beginDrag: createBeginDrag(manager),\n        publishDragSource: createPublishDragSource(manager),\n        hover: createHover(manager),\n        drop: createDrop(manager),\n        endDrag: createEndDrag(manager)\n    };\n}\nclass DragDropManagerImpl {\n    receiveBackend(backend) {\n        this.backend = backend;\n    }\n    getMonitor() {\n        return this.monitor;\n    }\n    getBackend() {\n        return this.backend;\n    }\n    getRegistry() {\n        return this.monitor.registry;\n    }\n    getActions() {\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */ const manager = this;\n        const { dispatch } = this.store;\n        function bindActionCreator(actionCreator) {\n            return (...args)=>{\n                const action = actionCreator.apply(manager, args);\n                if (typeof action !== \"undefined\") {\n                    dispatch(action);\n                }\n            };\n        }\n        const actions = createDragDropActions(this);\n        return Object.keys(actions).reduce((boundActions, key)=>{\n            const action = actions[key];\n            boundActions[key] = bindActionCreator(action);\n            return boundActions;\n        }, {});\n    }\n    dispatch(action) {\n        this.store.dispatch(action);\n    }\n    constructor(store, monitor){\n        this.isSetUp = false;\n        this.handleRefCountChange = ()=>{\n            const shouldSetUp = this.store.getState().refCount > 0;\n            if (this.backend) {\n                if (shouldSetUp && !this.isSetUp) {\n                    this.backend.setup();\n                    this.isSetUp = true;\n                } else if (!shouldSetUp && this.isSetUp) {\n                    this.backend.teardown();\n                    this.isSetUp = false;\n                }\n            }\n        };\n        this.store = store;\n        this.monitor = monitor;\n        store.subscribe(this.handleRefCountChange);\n    }\n}\n/**\n * Coordinate addition\n * @param a The first coordinate\n * @param b The second coordinate\n */ function add(a, b) {\n    return {\n        x: a.x + b.x,\n        y: a.y + b.y\n    };\n}\n/**\n * Coordinate subtraction\n * @param a The first coordinate\n * @param b The second coordinate\n */ function subtract(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\n/**\n * Returns the cartesian distance of the drag source component's position, based on its position\n * at the time when the current drag operation has started, and the movement difference.\n *\n * Returns null if no item is being dragged.\n *\n * @param state The offset state to compute from\n */ function getSourceClientOffset(state) {\n    const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;\n    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {\n        return null;\n    }\n    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);\n}\n/**\n * Determines the x,y offset between the client offset and the initial client offset\n *\n * @param state The offset state to compute from\n */ function getDifferenceFromInitialOffset(state) {\n    const { clientOffset, initialClientOffset } = state;\n    if (!clientOffset || !initialClientOffset) {\n        return null;\n    }\n    return subtract(clientOffset, initialClientOffset);\n}\nconst NONE = [];\nconst ALL = [];\nNONE.__IS_NONE__ = true;\nALL.__IS_ALL__ = true;\n/**\n * Determines if the given handler IDs are dirty or not.\n *\n * @param dirtyIds The set of dirty handler ids\n * @param handlerIds The set of handler ids to check\n */ function areDirty(dirtyIds, handlerIds) {\n    if (dirtyIds === NONE) {\n        return false;\n    }\n    if (dirtyIds === ALL || typeof handlerIds === \"undefined\") {\n        return true;\n    }\n    const commonIds = intersection(handlerIds, dirtyIds);\n    return commonIds.length > 0;\n}\nclass DragDropMonitorImpl {\n    subscribeToStateChange(listener, options = {}) {\n        const { handlerIds } = options;\n        invariant(typeof listener === \"function\", \"listener must be a function.\");\n        invariant(typeof handlerIds === \"undefined\" || Array.isArray(handlerIds), \"handlerIds, when specified, must be an array of strings.\");\n        let prevStateId = this.store.getState().stateId;\n        const handleChange = ()=>{\n            const state = this.store.getState();\n            const currentStateId = state.stateId;\n            try {\n                const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n                if (!canSkipListener) {\n                    listener();\n                }\n            } finally{\n                prevStateId = currentStateId;\n            }\n        };\n        return this.store.subscribe(handleChange);\n    }\n    subscribeToOffsetChange(listener) {\n        invariant(typeof listener === \"function\", \"listener must be a function.\");\n        let previousState = this.store.getState().dragOffset;\n        const handleChange = ()=>{\n            const nextState = this.store.getState().dragOffset;\n            if (nextState === previousState) {\n                return;\n            }\n            previousState = nextState;\n            listener();\n        };\n        return this.store.subscribe(handleChange);\n    }\n    canDragSource(sourceId) {\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (this.isDragging()) {\n            return false;\n        }\n        return source.canDrag(this, sourceId);\n    }\n    canDropOnTarget(targetId) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const target = this.registry.getTarget(targetId);\n        invariant(target, `Expected to find a valid target. targetId=${targetId}`);\n        if (!this.isDragging() || this.didDrop()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n    }\n    isDragging() {\n        return Boolean(this.getItemType());\n    }\n    isDraggingSource(sourceId) {\n        // undefined on initial render\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId, true);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (!this.isDragging() || !this.isSourcePublic()) {\n            return false;\n        }\n        const sourceType = this.registry.getSourceType(sourceId);\n        const draggedItemType = this.getItemType();\n        if (sourceType !== draggedItemType) {\n            return false;\n        }\n        return source.isDragging(this, sourceId);\n    }\n    isOverTarget(targetId, options = {\n        shallow: false\n    }) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const { shallow } = options;\n        if (!this.isDragging()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n            return false;\n        }\n        const targetIds = this.getTargetIds();\n        if (!targetIds.length) {\n            return false;\n        }\n        const index = targetIds.indexOf(targetId);\n        if (shallow) {\n            return index === targetIds.length - 1;\n        } else {\n            return index > -1;\n        }\n    }\n    getItemType() {\n        return this.store.getState().dragOperation.itemType;\n    }\n    getItem() {\n        return this.store.getState().dragOperation.item;\n    }\n    getSourceId() {\n        return this.store.getState().dragOperation.sourceId;\n    }\n    getTargetIds() {\n        return this.store.getState().dragOperation.targetIds;\n    }\n    getDropResult() {\n        return this.store.getState().dragOperation.dropResult;\n    }\n    didDrop() {\n        return this.store.getState().dragOperation.didDrop;\n    }\n    isSourcePublic() {\n        return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n    getInitialClientOffset() {\n        return this.store.getState().dragOffset.initialClientOffset;\n    }\n    getInitialSourceClientOffset() {\n        return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n    getClientOffset() {\n        return this.store.getState().dragOffset.clientOffset;\n    }\n    getSourceClientOffset() {\n        return getSourceClientOffset(this.store.getState().dragOffset);\n    }\n    getDifferenceFromInitialOffset() {\n        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n    constructor(store, registry){\n        this.store = store;\n        this.registry = registry;\n    }\n}\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n/* globals self */ const scope = typeof global !== \"undefined\" ? global : self;\nconst BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        const timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        const intervalHandle = setInterval(handleTimer, 50);\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    let toggle = 1;\n    const observer = new BrowserMutationObserver(callback);\n    const node = document.createTextNode(\"\");\n    observer.observe(node, {\n        characterData: true\n    });\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\nconst makeRequestCall = typeof BrowserMutationObserver === \"function\" ? // They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nmakeRequestCallFromMutationObserver : // 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\nmakeRequestCallFromTimer;\nclass AsapQueue {\n    // Use the fastest means possible to execute a task in its own turn, with\n    // priority over other events including IO, animation, reflow, and redraw\n    // events in browsers.\n    //\n    // An exception thrown by a task will permanently interrupt the processing of\n    // subsequent tasks. The higher level `asap` function ensures that if an\n    // exception is thrown by a task, that the task queue will continue flushing as\n    // soon as possible, but if you use `rawAsap` directly, you are responsible to\n    // either ensure that no exceptions are thrown from your task, or to manually\n    // call `rawAsap.requestFlush` if an exception is thrown.\n    enqueueTask(task) {\n        const { queue: q, requestFlush } = this;\n        if (!q.length) {\n            requestFlush();\n            this.flushing = true;\n        }\n        // Equivalent to push, but avoids a function call.\n        q[q.length] = task;\n    }\n    constructor(){\n        this.queue = [];\n        // We queue errors to ensure they are thrown in right order (FIFO).\n        // Array-as-queue is good enough here, since we are just dealing with exceptions.\n        this.pendingErrors = [];\n        // Once a flush has been requested, no further calls to `requestFlush` are\n        // necessary until the next `flush` completes.\n        // @ts-ignore\n        this.flushing = false;\n        // The position of the next task to execute in the task queue. This is\n        // preserved between calls to `flush` so that it can be resumed if\n        // a task throws an exception.\n        this.index = 0;\n        // If a task schedules additional tasks recursively, the task queue can grow\n        // unbounded. To prevent memory exhaustion, the task queue will periodically\n        // truncate already-completed tasks.\n        this.capacity = 1024;\n        // The flush function processes all tasks that have been scheduled with\n        // `rawAsap` unless and until one of those tasks throws an exception.\n        // If a task throws an exception, `flush` ensures that its state will remain\n        // consistent and will resume where it left off when called again.\n        // However, `flush` does not make any arrangements to be called again if an\n        // exception is thrown.\n        this.flush = ()=>{\n            const { queue: q } = this;\n            while(this.index < q.length){\n                const currentIndex = this.index;\n                // Advance the index before calling the task. This ensures that we will\n                // begin flushing on the next task the task throws an error.\n                this.index++;\n                q[currentIndex].call();\n                // Prevent leaking memory for long chains of recursive calls to `asap`.\n                // If we call `asap` within tasks scheduled by `asap`, the queue will\n                // grow, but to avoid an O(n) walk for every task we execute, we don't\n                // shift tasks off the queue after they have been executed.\n                // Instead, we periodically shift 1024 tasks off the queue.\n                if (this.index > this.capacity) {\n                    // Manually shift all values starting at the index back to the\n                    // beginning of the queue.\n                    for(let scan = 0, newLength = q.length - this.index; scan < newLength; scan++){\n                        q[scan] = q[scan + this.index];\n                    }\n                    q.length -= this.index;\n                    this.index = 0;\n                }\n            }\n            q.length = 0;\n            this.index = 0;\n            this.flushing = false;\n        };\n        // In a web browser, exceptions are not fatal. However, to avoid\n        // slowing down the queue of pending tasks, we rethrow the error in a\n        // lower priority turn.\n        this.registerPendingError = (err)=>{\n            this.pendingErrors.push(err);\n            this.requestErrorThrow();\n        };\n        // `requestFlush` requests that the high priority event queue be flushed as\n        // soon as possible.\n        // This is useful to prevent an error thrown in a task from stalling the event\n        // queue if the exception handled by Node.js’s\n        // `process.on(\"uncaughtException\")` or by a domain.\n        // `requestFlush` is implemented using a strategy based on data collected from\n        // every available SauceLabs Selenium web driver worker at time of writing.\n        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n        this.requestFlush = makeRequestCall(this.flush);\n        this.requestErrorThrow = makeRequestCallFromTimer(()=>{\n            // Throw first error\n            if (this.pendingErrors.length) {\n                throw this.pendingErrors.shift();\n            }\n        });\n    }\n} // The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// // its existence.\n// rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n// `call`, just like a function.\nclass RawTask {\n    call() {\n        try {\n            this.task && this.task();\n        } catch (error) {\n            this.onError(error);\n        } finally{\n            this.task = null;\n            this.release(this);\n        }\n    }\n    constructor(onError, release){\n        this.onError = onError;\n        this.release = release;\n        this.task = null;\n    }\n}\nclass TaskFactory {\n    create(task) {\n        const tasks = this.freeTasks;\n        const t1 = tasks.length ? tasks.pop() : new RawTask(this.onError, (t)=>tasks[tasks.length] = t);\n        t1.task = task;\n        return t1;\n    }\n    constructor(onError){\n        this.onError = onError;\n        this.freeTasks = [];\n    }\n}\nconst asapQueue = new AsapQueue();\nconst taskFactory = new TaskFactory(asapQueue.registerPendingError);\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */ function asap(task) {\n    asapQueue.enqueueTask(taskFactory.create(task));\n}\nconst ADD_SOURCE = \"dnd-core/ADD_SOURCE\";\nconst ADD_TARGET = \"dnd-core/ADD_TARGET\";\nconst REMOVE_SOURCE = \"dnd-core/REMOVE_SOURCE\";\nconst REMOVE_TARGET = \"dnd-core/REMOVE_TARGET\";\nfunction addSource(sourceId) {\n    return {\n        type: ADD_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nfunction addTarget(targetId) {\n    return {\n        type: ADD_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\nfunction removeSource(sourceId) {\n    return {\n        type: REMOVE_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nfunction removeTarget(targetId) {\n    return {\n        type: REMOVE_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\nfunction validateSourceContract(source) {\n    invariant(typeof source.canDrag === \"function\", \"Expected canDrag to be a function.\");\n    invariant(typeof source.beginDrag === \"function\", \"Expected beginDrag to be a function.\");\n    invariant(typeof source.endDrag === \"function\", \"Expected endDrag to be a function.\");\n}\nfunction validateTargetContract(target) {\n    invariant(typeof target.canDrop === \"function\", \"Expected canDrop to be a function.\");\n    invariant(typeof target.hover === \"function\", \"Expected hover to be a function.\");\n    invariant(typeof target.drop === \"function\", \"Expected beginDrag to be a function.\");\n}\nfunction validateType(type, allowArray) {\n    if (allowArray && Array.isArray(type)) {\n        type.forEach((t)=>validateType(t, false));\n        return;\n    }\n    invariant(typeof type === \"string\" || typeof type === \"symbol\", allowArray ? \"Type can only be a string, a symbol, or an array of either.\" : \"Type can only be a string or a symbol.\");\n}\nvar HandlerRole;\n(function(HandlerRole) {\n    HandlerRole[\"SOURCE\"] = \"SOURCE\";\n    HandlerRole[\"TARGET\"] = \"TARGET\";\n})(HandlerRole || (HandlerRole = {}));\nlet nextUniqueId = 0;\nfunction getNextUniqueId() {\n    return nextUniqueId++;\n}\nfunction getNextHandlerId(role) {\n    const id = getNextUniqueId().toString();\n    switch(role){\n        case HandlerRole.SOURCE:\n            return `S${id}`;\n        case HandlerRole.TARGET:\n            return `T${id}`;\n        default:\n            throw new Error(`Unknown Handler Role: ${role}`);\n    }\n}\nfunction parseRoleFromHandlerId(handlerId) {\n    switch(handlerId[0]){\n        case \"S\":\n            return HandlerRole.SOURCE;\n        case \"T\":\n            return HandlerRole.TARGET;\n        default:\n            throw new Error(`Cannot parse handler ID: ${handlerId}`);\n    }\n}\nfunction mapContainsValue(map, searchValue) {\n    const entries = map.entries();\n    let isDone = false;\n    do {\n        const { done, value: [, value] } = entries.next();\n        if (value === searchValue) {\n            return true;\n        }\n        isDone = !!done;\n    }while (!isDone);\n    return false;\n}\nclass HandlerRegistryImpl {\n    addSource(type, source) {\n        validateType(type);\n        validateSourceContract(source);\n        const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n        this.store.dispatch(addSource(sourceId));\n        return sourceId;\n    }\n    addTarget(type, target) {\n        validateType(type, true);\n        validateTargetContract(target);\n        const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n        this.store.dispatch(addTarget(targetId));\n        return targetId;\n    }\n    containsHandler(handler) {\n        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n    }\n    getSource(sourceId, includePinned = false) {\n        invariant(this.isSourceId(sourceId), \"Expected a valid source ID.\");\n        const isPinned = includePinned && sourceId === this.pinnedSourceId;\n        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n        return source;\n    }\n    getTarget(targetId) {\n        invariant(this.isTargetId(targetId), \"Expected a valid target ID.\");\n        return this.dropTargets.get(targetId);\n    }\n    getSourceType(sourceId) {\n        invariant(this.isSourceId(sourceId), \"Expected a valid source ID.\");\n        return this.types.get(sourceId);\n    }\n    getTargetType(targetId) {\n        invariant(this.isTargetId(targetId), \"Expected a valid target ID.\");\n        return this.types.get(targetId);\n    }\n    isSourceId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.SOURCE;\n    }\n    isTargetId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.TARGET;\n    }\n    removeSource(sourceId) {\n        invariant(this.getSource(sourceId), \"Expected an existing source.\");\n        this.store.dispatch(removeSource(sourceId));\n        asap(()=>{\n            this.dragSources.delete(sourceId);\n            this.types.delete(sourceId);\n        });\n    }\n    removeTarget(targetId) {\n        invariant(this.getTarget(targetId), \"Expected an existing target.\");\n        this.store.dispatch(removeTarget(targetId));\n        this.dropTargets.delete(targetId);\n        this.types.delete(targetId);\n    }\n    pinSource(sourceId) {\n        const source = this.getSource(sourceId);\n        invariant(source, \"Expected an existing source.\");\n        this.pinnedSourceId = sourceId;\n        this.pinnedSource = source;\n    }\n    unpinSource() {\n        invariant(this.pinnedSource, \"No source is pinned at the time.\");\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n    }\n    addHandler(role, type, handler) {\n        const id = getNextHandlerId(role);\n        this.types.set(id, type);\n        if (role === HandlerRole.SOURCE) {\n            this.dragSources.set(id, handler);\n        } else if (role === HandlerRole.TARGET) {\n            this.dropTargets.set(id, handler);\n        }\n        return id;\n    }\n    constructor(store){\n        this.types = new Map();\n        this.dragSources = new Map();\n        this.dropTargets = new Map();\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n        this.store = store;\n    }\n}\nconst strictEquality = (a, b)=>a === b;\n/**\n * Determine if two cartesian coordinate offsets are equal\n * @param offsetA\n * @param offsetB\n */ function areCoordsEqual(offsetA, offsetB) {\n    if (!offsetA && !offsetB) {\n        return true;\n    } else if (!offsetA || !offsetB) {\n        return false;\n    } else {\n        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;\n    }\n}\n/**\n * Determines if two arrays of items are equal\n * @param a The first array of items\n * @param b The second array of items\n */ function areArraysEqual(a, b, isEqual = strictEquality) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; ++i){\n        if (!isEqual(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction reduce$5(_state = NONE, action) {\n    switch(action.type){\n        case HOVER:\n            break;\n        case ADD_SOURCE:\n        case ADD_TARGET:\n        case REMOVE_TARGET:\n        case REMOVE_SOURCE:\n            return NONE;\n        case BEGIN_DRAG:\n        case PUBLISH_DRAG_SOURCE:\n        case END_DRAG:\n        case DROP:\n        default:\n            return ALL;\n    }\n    const { targetIds = [], prevTargetIds = [] } = action.payload;\n    const result = xor(targetIds, prevTargetIds);\n    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);\n    if (!didChange) {\n        return NONE;\n    }\n    // Check the target ids at the innermost position. If they are valid, add them\n    // to the result\n    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];\n    const innermostTargetId = targetIds[targetIds.length - 1];\n    if (prevInnermostTargetId !== innermostTargetId) {\n        if (prevInnermostTargetId) {\n            result.push(prevInnermostTargetId);\n        }\n        if (innermostTargetId) {\n            result.push(innermostTargetId);\n        }\n    }\n    return result;\n}\nfunction _defineProperty$3(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$3(target, key, source[key]);\n        });\n    }\n    return target;\n}\nconst initialState$1 = {\n    initialSourceClientOffset: null,\n    initialClientOffset: null,\n    clientOffset: null\n};\nfunction reduce$4(state = initialState$1, action) {\n    const { payload } = action;\n    switch(action.type){\n        case INIT_COORDS:\n        case BEGIN_DRAG:\n            return {\n                initialSourceClientOffset: payload.sourceClientOffset,\n                initialClientOffset: payload.clientOffset,\n                clientOffset: payload.clientOffset\n            };\n        case HOVER:\n            if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {\n                return state;\n            }\n            return _objectSpread$3({}, state, {\n                clientOffset: payload.clientOffset\n            });\n        case END_DRAG:\n        case DROP:\n            return initialState$1;\n        default:\n            return state;\n    }\n}\nfunction _defineProperty$2(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$2(target, key, source[key]);\n        });\n    }\n    return target;\n}\nconst initialState = {\n    itemType: null,\n    item: null,\n    sourceId: null,\n    targetIds: [],\n    dropResult: null,\n    didDrop: false,\n    isSourcePublic: null\n};\nfunction reduce$3(state = initialState, action) {\n    const { payload } = action;\n    switch(action.type){\n        case BEGIN_DRAG:\n            return _objectSpread$2({}, state, {\n                itemType: payload.itemType,\n                item: payload.item,\n                sourceId: payload.sourceId,\n                isSourcePublic: payload.isSourcePublic,\n                dropResult: null,\n                didDrop: false\n            });\n        case PUBLISH_DRAG_SOURCE:\n            return _objectSpread$2({}, state, {\n                isSourcePublic: true\n            });\n        case HOVER:\n            return _objectSpread$2({}, state, {\n                targetIds: payload.targetIds\n            });\n        case REMOVE_TARGET:\n            if (state.targetIds.indexOf(payload.targetId) === -1) {\n                return state;\n            }\n            return _objectSpread$2({}, state, {\n                targetIds: without$1(state.targetIds, payload.targetId)\n            });\n        case DROP:\n            return _objectSpread$2({}, state, {\n                dropResult: payload.dropResult,\n                didDrop: true,\n                targetIds: []\n            });\n        case END_DRAG:\n            return _objectSpread$2({}, state, {\n                itemType: null,\n                item: null,\n                sourceId: null,\n                dropResult: null,\n                didDrop: false,\n                isSourcePublic: null,\n                targetIds: []\n            });\n        default:\n            return state;\n    }\n}\nfunction reduce$2(state = 0, action) {\n    switch(action.type){\n        case ADD_SOURCE:\n        case ADD_TARGET:\n            return state + 1;\n        case REMOVE_SOURCE:\n        case REMOVE_TARGET:\n            return state - 1;\n        default:\n            return state;\n    }\n}\nfunction reduce$1(state = 0) {\n    return state + 1;\n}\nfunction _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$1(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction reduce(state = {}, action) {\n    return {\n        dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {\n            type: action.type,\n            payload: _objectSpread$1({}, action.payload, {\n                prevTargetIds: get(state, \"dragOperation.targetIds\", [])\n            })\n        }),\n        dragOffset: reduce$4(state.dragOffset, action),\n        refCount: reduce$2(state.refCount, action),\n        dragOperation: reduce$3(state.dragOperation, action),\n        stateId: reduce$1(state.stateId)\n    };\n}\nfunction createDragDropManager(backendFactory, globalContext = undefined, backendOptions = {}, debugMode = false) {\n    const store = makeStoreInstance(debugMode);\n    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));\n    const manager = new DragDropManagerImpl(store, monitor);\n    const backend = backendFactory(manager, globalContext, backendOptions);\n    manager.receiveBackend(backend);\n    return manager;\n}\nfunction makeStoreInstance(debugMode) {\n    // TODO: if we ever make a react-native version of this,\n    // we'll need to consider how to pull off dev-tooling\n    const reduxDevTools =  false && 0;\n    return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({\n        name: \"dnd-core\",\n        instanceId: \"dnd-core\"\n    }));\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nlet refCount = 0;\nconst INSTANCE_SYM = Symbol.for(\"__REACT_DND_CONTEXT_INSTANCE__\");\nvar DndProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(function DndProvider(_param) {\n    var { children } = _param, props = _objectWithoutProperties(_param, [\n        \"children\"\n    ]);\n    const [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props\n    ;\n    /**\n\t\t * If the global context was used to store the DND context\n\t\t * then where theres no more references to it we should\n\t\t * clean it up to avoid memory leaks\n\t\t */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isGlobalInstance) {\n            const context = getGlobalContext();\n            ++refCount;\n            return ()=>{\n                if (--refCount === 0) {\n                    context[INSTANCE_SYM] = null;\n                }\n            };\n        }\n        return;\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DndContext.Provider, {\n        value: manager,\n        children: children\n    });\n});\nfunction getDndContextValue(props) {\n    if (\"manager\" in props) {\n        const manager = {\n            dragDropManager: props.manager\n        };\n        return [\n            manager,\n            false\n        ];\n    }\n    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);\n    const isGlobalInstance = !props.context;\n    return [\n        manager,\n        isGlobalInstance\n    ];\n}\nfunction createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {\n    const ctx = context;\n    if (!ctx[INSTANCE_SYM]) {\n        ctx[INSTANCE_SYM] = {\n            dragDropManager: createDragDropManager(backend, context, options, debugMode)\n        };\n    }\n    return ctx[INSTANCE_SYM];\n}\nfunction getGlobalContext() {\n    return typeof global !== \"undefined\" ? global : window;\n}\n// do not edit .js files directly - edit src/index.jst\nvar fastDeepEqual = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\n// suppress the useLayoutEffect warning on server side.\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n *\n * @param monitor The monitor to collect state from\n * @param collect The collecting function\n * @param onUpdate A method to invoke when updates occur\n */ function useCollector(monitor, collect, onUpdate) {\n    const [collected, setCollected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>collect(monitor));\n    const updateCollected = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const nextValue = collect(monitor);\n        // This needs to be a deep-equality check because some monitor-collected values\n        // include XYCoord objects that may be equivalent, but do not have instance equality.\n        if (!fastDeepEqual(collected, nextValue)) {\n            setCollected(nextValue);\n            if (onUpdate) {\n                onUpdate();\n            }\n        }\n    }, [\n        collected,\n        monitor,\n        onUpdate\n    ]);\n    // update the collected properties after react renders.\n    // Note that the \"Dustbin Stress Test\" fails if this is not\n    // done when the component updates\n    useIsomorphicLayoutEffect(updateCollected);\n    return [\n        collected,\n        updateCollected\n    ];\n}\nfunction useMonitorOutput(monitor, collect, onCollect) {\n    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);\n    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {\n        const handlerId = monitor.getHandlerId();\n        if (handlerId == null) {\n            return;\n        }\n        return monitor.subscribeToStateChange(updateCollected, {\n            handlerIds: [\n                handlerId\n            ]\n        });\n    }, [\n        monitor,\n        updateCollected\n    ]);\n    return collected;\n}\nfunction useCollectedProps(collector, monitor, connector) {\n    return useMonitorOutput(monitor, collector || (()=>({})), ()=>connector.reconnect());\n}\nfunction useOptionalFactory(arg, deps) {\n    const memoDeps = [\n        ...deps || []\n    ];\n    if (deps == null && typeof arg !== \"function\") {\n        memoDeps.push(arg);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return typeof arg === \"function\" ? arg() : arg;\n    }, memoDeps);\n}\nfunction useConnectDragSource(connector) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dragSource(), [\n        connector\n    ]);\n}\nfunction useConnectDragPreview(connector) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dragPreview(), [\n        connector\n    ]);\n}\nlet isCallingCanDrag = false;\nlet isCallingIsDragging = false;\nclass DragSourceMonitorImpl {\n    receiveHandlerId(sourceId) {\n        this.sourceId = sourceId;\n    }\n    getHandlerId() {\n        return this.sourceId;\n    }\n    canDrag() {\n        invariant(!isCallingCanDrag, \"You may not call monitor.canDrag() inside your canDrag() implementation. \" + \"Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");\n        try {\n            isCallingCanDrag = true;\n            return this.internalMonitor.canDragSource(this.sourceId);\n        } finally{\n            isCallingCanDrag = false;\n        }\n    }\n    isDragging() {\n        if (!this.sourceId) {\n            return false;\n        }\n        invariant(!isCallingIsDragging, \"You may not call monitor.isDragging() inside your isDragging() implementation. \" + \"Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");\n        try {\n            isCallingIsDragging = true;\n            return this.internalMonitor.isDraggingSource(this.sourceId);\n        } finally{\n            isCallingIsDragging = false;\n        }\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    isDraggingSource(sourceId) {\n        return this.internalMonitor.isDraggingSource(sourceId);\n    }\n    isOverTarget(targetId, options) {\n        return this.internalMonitor.isOverTarget(targetId, options);\n    }\n    getTargetIds() {\n        return this.internalMonitor.getTargetIds();\n    }\n    isSourcePublic() {\n        return this.internalMonitor.isSourcePublic();\n    }\n    getSourceId() {\n        return this.internalMonitor.getSourceId();\n    }\n    subscribeToOffsetChange(listener) {\n        return this.internalMonitor.subscribeToOffsetChange(listener);\n    }\n    canDragSource(sourceId) {\n        return this.internalMonitor.canDragSource(sourceId);\n    }\n    canDropOnTarget(targetId) {\n        return this.internalMonitor.canDropOnTarget(targetId);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.sourceId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\nlet isCallingCanDrop = false;\nclass DropTargetMonitorImpl {\n    receiveHandlerId(targetId) {\n        this.targetId = targetId;\n    }\n    getHandlerId() {\n        return this.targetId;\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    canDrop() {\n        // Cut out early if the target id has not been set. This should prevent errors\n        // where the user has an older version of dnd-core like in\n        // https://github.com/react-dnd/react-dnd/issues/1310\n        if (!this.targetId) {\n            return false;\n        }\n        invariant(!isCallingCanDrop, \"You may not call monitor.canDrop() inside your canDrop() implementation. \" + \"Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor\");\n        try {\n            isCallingCanDrop = true;\n            return this.internalMonitor.canDropOnTarget(this.targetId);\n        } finally{\n            isCallingCanDrop = false;\n        }\n    }\n    isOver(options) {\n        if (!this.targetId) {\n            return false;\n        }\n        return this.internalMonitor.isOverTarget(this.targetId, options);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.targetId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\nfunction registerTarget(type, target, manager) {\n    const registry = manager.getRegistry();\n    const targetId = registry.addTarget(type, target);\n    return [\n        targetId,\n        ()=>registry.removeTarget(targetId)\n    ];\n}\nfunction registerSource(type, source, manager) {\n    const registry = manager.getRegistry();\n    const sourceId = registry.addSource(type, source);\n    return [\n        sourceId,\n        ()=>registry.removeSource(sourceId)\n    ];\n}\nfunction shallowEqual(objA, objB, compare, compareContext) {\n    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;\n    if (compareResult !== void 0) {\n        return !!compareResult;\n    }\n    if (objA === objB) {\n        return true;\n    }\n    if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n    // Test for A's keys different from B.\n    for(let idx = 0; idx < keysA.length; idx++){\n        const key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n            return false;\n        }\n        const valueA = objA[key];\n        const valueB = objB[key];\n        compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isRef(obj) {\n    return obj !== null && typeof obj === \"object\" && Object.prototype.hasOwnProperty.call(obj, \"current\");\n}\nfunction throwIfCompositeComponentElement(element) {\n    // Custom components can no longer be wrapped directly in React DnD 2.0\n    // so that we don't need to depend on findDOMNode() from react-dom.\n    if (typeof element.type === \"string\") {\n        return;\n    }\n    const displayName = element.type.displayName || element.type.name || \"the component\";\n    throw new Error(\"Only native element nodes can now be passed to React DnD connectors.\" + `You can either wrap ${displayName} into a <div>, or turn it into a ` + \"drag source or a drop target itself.\");\n}\nfunction wrapHookToRecognizeElement(hook) {\n    return (elementOrNode = null, options = null)=>{\n        // When passed a node, call the hook straight away.\n        if (!/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(elementOrNode)) {\n            const node = elementOrNode;\n            hook(node, options);\n            // return the node so it can be chained (e.g. when within callback refs\n            // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n            return node;\n        }\n        // If passed a ReactElement, clone it and attach this function as a ref.\n        // This helps us achieve a neat API where user doesn't even know that refs\n        // are being used under the hood.\n        const element = elementOrNode;\n        throwIfCompositeComponentElement(element);\n        // When no options are passed, use the hook directly\n        const ref = options ? (node)=>hook(node, options) : hook;\n        return cloneWithRef(element, ref);\n    };\n}\nfunction wrapConnectorHooks(hooks) {\n    const wrappedHooks = {};\n    Object.keys(hooks).forEach((key)=>{\n        const hook = hooks[key];\n        // ref objects should be passed straight through without wrapping\n        if (key.endsWith(\"Ref\")) {\n            wrappedHooks[key] = hooks[key];\n        } else {\n            const wrappedHook = wrapHookToRecognizeElement(hook);\n            wrappedHooks[key] = ()=>wrappedHook;\n        }\n    });\n    return wrappedHooks;\n}\nfunction setRef(ref, node) {\n    if (typeof ref === \"function\") {\n        ref(node);\n    } else {\n        ref.current = node;\n    }\n}\nfunction cloneWithRef(element, newRef) {\n    const previousRef = element.ref;\n    invariant(typeof previousRef !== \"string\", \"Cannot connect React DnD to an element with an existing string ref. \" + \"Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. \" + \"Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs\");\n    if (!previousRef) {\n        // When there is no ref on the element, use the new ref directly\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(element, {\n            ref: newRef\n        });\n    } else {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(element, {\n            ref: (node)=>{\n                setRef(previousRef, node);\n                setRef(newRef, node);\n            }\n        });\n    }\n}\nclass SourceConnector {\n    receiveHandlerId(newHandlerId) {\n        if (this.handlerId === newHandlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get connectTarget() {\n        return this.dragSource;\n    }\n    get dragSourceOptions() {\n        return this.dragSourceOptionsInternal;\n    }\n    set dragSourceOptions(options) {\n        this.dragSourceOptionsInternal = options;\n    }\n    get dragPreviewOptions() {\n        return this.dragPreviewOptionsInternal;\n    }\n    set dragPreviewOptions(options) {\n        this.dragPreviewOptionsInternal = options;\n    }\n    reconnect() {\n        const didChange = this.reconnectDragSource();\n        this.reconnectDragPreview(didChange);\n    }\n    reconnectDragSource() {\n        const dragSource = this.dragSource;\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();\n        if (didChange) {\n            this.disconnectDragSource();\n        }\n        if (!this.handlerId) {\n            return didChange;\n        }\n        if (!dragSource) {\n            this.lastConnectedDragSource = dragSource;\n            return didChange;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragSource = dragSource;\n            this.lastConnectedDragSourceOptions = this.dragSourceOptions;\n            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);\n        }\n        return didChange;\n    }\n    reconnectDragPreview(forceDidChange = false) {\n        const dragPreview = this.dragPreview;\n        // if nothing has changed then don't resubscribe\n        const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();\n        if (didChange) {\n            this.disconnectDragPreview();\n        }\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dragPreview) {\n            this.lastConnectedDragPreview = dragPreview;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragPreview = dragPreview;\n            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;\n            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);\n        }\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didConnectedDragSourceChange() {\n        return this.lastConnectedDragSource !== this.dragSource;\n    }\n    didConnectedDragPreviewChange() {\n        return this.lastConnectedDragPreview !== this.dragPreview;\n    }\n    didDragSourceOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);\n    }\n    didDragPreviewOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);\n    }\n    disconnectDragSource() {\n        if (this.dragSourceUnsubscribe) {\n            this.dragSourceUnsubscribe();\n            this.dragSourceUnsubscribe = undefined;\n        }\n    }\n    disconnectDragPreview() {\n        if (this.dragPreviewUnsubscribe) {\n            this.dragPreviewUnsubscribe();\n            this.dragPreviewUnsubscribe = undefined;\n            this.dragPreviewNode = null;\n            this.dragPreviewRef = null;\n        }\n    }\n    get dragSource() {\n        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;\n    }\n    get dragPreview() {\n        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;\n    }\n    clearDragSource() {\n        this.dragSourceNode = null;\n        this.dragSourceRef = null;\n    }\n    clearDragPreview() {\n        this.dragPreviewNode = null;\n        this.dragPreviewRef = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dragSource: (node, options)=>{\n                this.clearDragSource();\n                this.dragSourceOptions = options || null;\n                if (isRef(node)) {\n                    this.dragSourceRef = node;\n                } else {\n                    this.dragSourceNode = node;\n                }\n                this.reconnectDragSource();\n            },\n            dragPreview: (node, options)=>{\n                this.clearDragPreview();\n                this.dragPreviewOptions = options || null;\n                if (isRef(node)) {\n                    this.dragPreviewRef = node;\n                } else {\n                    this.dragPreviewNode = node;\n                }\n                this.reconnectDragPreview();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dragSourceRef = null;\n        this.dragSourceOptionsInternal = null;\n        // The drag preview may either be attached via ref or connect function\n        this.dragPreviewRef = null;\n        this.dragPreviewOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDragSource = null;\n        this.lastConnectedDragSourceOptions = null;\n        this.lastConnectedDragPreview = null;\n        this.lastConnectedDragPreviewOptions = null;\n        this.backend = backend;\n    }\n}\nclass TargetConnector {\n    get connectTarget() {\n        return this.dropTarget;\n    }\n    reconnect() {\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();\n        if (didChange) {\n            this.disconnectDropTarget();\n        }\n        const dropTarget = this.dropTarget;\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dropTarget) {\n            this.lastConnectedDropTarget = dropTarget;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDropTarget = dropTarget;\n            this.lastConnectedDropTargetOptions = this.dropTargetOptions;\n            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);\n        }\n    }\n    receiveHandlerId(newHandlerId) {\n        if (newHandlerId === this.handlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get dropTargetOptions() {\n        return this.dropTargetOptionsInternal;\n    }\n    set dropTargetOptions(options) {\n        this.dropTargetOptionsInternal = options;\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didDropTargetChange() {\n        return this.lastConnectedDropTarget !== this.dropTarget;\n    }\n    didOptionsChange() {\n        return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);\n    }\n    disconnectDropTarget() {\n        if (this.unsubscribeDropTarget) {\n            this.unsubscribeDropTarget();\n            this.unsubscribeDropTarget = undefined;\n        }\n    }\n    get dropTarget() {\n        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;\n    }\n    clearDropTarget() {\n        this.dropTargetRef = null;\n        this.dropTargetNode = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dropTarget: (node, options)=>{\n                this.clearDropTarget();\n                this.dropTargetOptions = options;\n                if (isRef(node)) {\n                    this.dropTargetRef = node;\n                } else {\n                    this.dropTargetNode = node;\n                }\n                this.reconnect();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dropTargetRef = null;\n        this.dropTargetOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDropTarget = null;\n        this.lastConnectedDropTargetOptions = null;\n        this.backend = backend;\n    }\n}\n/**\n * A hook to retrieve the DragDropManager from Context\n */ function useDragDropManager() {\n    const { dragDropManager } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DndContext);\n    invariant(dragDropManager != null, \"Expected drag drop context\");\n    return dragDropManager;\n}\nfunction useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {\n    const manager = useDragDropManager();\n    const connector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new SourceConnector(manager.getBackend()), [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragSourceOptions = dragSourceOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragSource();\n    }, [\n        connector,\n        dragSourceOptions\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragPreviewOptions = dragPreviewOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragPreview();\n    }, [\n        connector,\n        dragPreviewOptions\n    ]);\n    return connector;\n}\nfunction useDragSourceMonitor() {\n    const manager = useDragDropManager();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DragSourceMonitorImpl(manager), [\n        manager\n    ]);\n}\nclass DragSourceImpl {\n    beginDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        let result = null;\n        if (typeof spec.item === \"object\") {\n            result = spec.item;\n        } else if (typeof spec.item === \"function\") {\n            result = spec.item(monitor);\n        } else {\n            result = {};\n        }\n        return result !== null && result !== void 0 ? result : null;\n    }\n    canDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (typeof spec.canDrag === \"boolean\") {\n            return spec.canDrag;\n        } else if (typeof spec.canDrag === \"function\") {\n            return spec.canDrag(monitor);\n        } else {\n            return true;\n        }\n    }\n    isDragging(globalMonitor, target) {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const { isDragging } = spec;\n        return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();\n    }\n    endDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const connector = this.connector;\n        const { end } = spec;\n        if (end) {\n            end(monitor.getItem(), monitor);\n        }\n        connector.reconnect();\n    }\n    constructor(spec, monitor, connector){\n        this.spec = spec;\n        this.monitor = monitor;\n        this.connector = connector;\n    }\n}\nfunction useDragSource(spec, monitor, connector) {\n    const handler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DragSourceImpl(spec, monitor, connector), [\n        monitor,\n        connector\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        handler.spec = spec;\n    }, [\n        spec\n    ]);\n    return handler;\n}\nfunction useDragType(spec) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const result = spec.type;\n        invariant(result != null, \"spec.type must be defined\");\n        return result;\n    }, [\n        spec\n    ]);\n}\nfunction useRegisteredDragSource(spec, monitor, connector) {\n    const manager = useDragDropManager();\n    const handler = useDragSource(spec, monitor, connector);\n    const itemType = useDragType(spec);\n    useIsomorphicLayoutEffect(function registerDragSource() {\n        if (itemType != null) {\n            const [handlerId, unregister] = registerSource(itemType, handler, manager);\n            monitor.receiveHandlerId(handlerId);\n            connector.receiveHandlerId(handlerId);\n            return unregister;\n        }\n        return;\n    }, [\n        manager,\n        monitor,\n        connector,\n        handler,\n        itemType\n    ]);\n}\n/**\n * useDragSource hook\n * @param sourceSpec The drag source specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ function useDrag(specArg, deps) {\n    const spec = useOptionalFactory(specArg, deps);\n    invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);\n    const monitor = useDragSourceMonitor();\n    const connector = useDragSourceConnector(spec.options, spec.previewOptions);\n    useRegisteredDragSource(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDragSource(connector),\n        useConnectDragPreview(connector)\n    ];\n}\n/**\n * useDragLayer Hook\n * @param collector The property collector\n */ function useDragLayer(collect) {\n    const dragDropManager = useDragDropManager();\n    const monitor = dragDropManager.getMonitor();\n    const [collected, updateCollected] = useCollector(monitor, collect);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>monitor.subscribeToOffsetChange(updateCollected));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>monitor.subscribeToStateChange(updateCollected));\n    return collected;\n}\nfunction useConnectDropTarget(connector) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dropTarget(), [\n        connector\n    ]);\n}\nfunction useDropTargetConnector(options) {\n    const manager = useDragDropManager();\n    const connector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new TargetConnector(manager.getBackend()), [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dropTargetOptions = options || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDropTarget();\n    }, [\n        options\n    ]);\n    return connector;\n}\nfunction useDropTargetMonitor() {\n    const manager = useDragDropManager();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DropTargetMonitorImpl(manager), [\n        manager\n    ]);\n}\n/**\n * Internal utility hook to get an array-version of spec.accept.\n * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.\n * @param spec\n */ function useAccept(spec) {\n    const { accept } = spec;\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        invariant(spec.accept != null, \"accept must be defined\");\n        return Array.isArray(accept) ? accept : [\n            accept\n        ];\n    }, [\n        accept\n    ]);\n}\nclass DropTargetImpl {\n    canDrop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;\n    }\n    hover() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.hover) {\n            spec.hover(monitor.getItem(), monitor);\n        }\n    }\n    drop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.drop) {\n            return spec.drop(monitor.getItem(), monitor);\n        }\n        return;\n    }\n    constructor(spec, monitor){\n        this.spec = spec;\n        this.monitor = monitor;\n    }\n}\nfunction useDropTarget(spec, monitor) {\n    const dropTarget = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DropTargetImpl(spec, monitor), [\n        monitor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        dropTarget.spec = spec;\n    }, [\n        spec\n    ]);\n    return dropTarget;\n}\nfunction useRegisteredDropTarget(spec, monitor, connector) {\n    const manager = useDragDropManager();\n    const dropTarget = useDropTarget(spec, monitor);\n    const accept = useAccept(spec);\n    useIsomorphicLayoutEffect(function registerDropTarget() {\n        const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);\n        monitor.receiveHandlerId(handlerId);\n        connector.receiveHandlerId(handlerId);\n        return unregister;\n    }, [\n        manager,\n        monitor,\n        dropTarget,\n        connector,\n        accept.map((a)=>a.toString()).join(\"|\")\n    ]);\n}\n/**\n * useDropTarget Hook\n * @param spec The drop target specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ function useDrop(specArg, deps) {\n    const spec = useOptionalFactory(specArg, deps);\n    const monitor = useDropTargetMonitor();\n    const connector = useDropTargetConnector(spec.options);\n    useRegisteredDropTarget(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDropTarget(connector)\n    ];\n}\n// cheap lodash replacements\nfunction memoize(fn) {\n    let result = null;\n    const memoized = ()=>{\n        if (result == null) {\n            result = fn();\n        }\n        return result;\n    };\n    return memoized;\n}\n/**\n * drop-in replacement for _.without\n */ function without(items, item) {\n    return items.filter((i)=>i !== item);\n}\nfunction union(itemsA, itemsB) {\n    const set = new Set();\n    const insertItem = (item)=>set.add(item);\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    set.forEach((key)=>result.push(key));\n    return result;\n}\nclass EnterLeaveCounter {\n    enter(enteringNode) {\n        const previousLength = this.entered.length;\n        const isNodeEntered = (node)=>this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));\n        this.entered = union(this.entered.filter(isNodeEntered), [\n            enteringNode\n        ]);\n        return previousLength === 0 && this.entered.length > 0;\n    }\n    leave(leavingNode) {\n        const previousLength = this.entered.length;\n        this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);\n        return previousLength > 0 && this.entered.length === 0;\n    }\n    reset() {\n        this.entered = [];\n    }\n    constructor(isNodeInDocument){\n        this.entered = [];\n        this.isNodeInDocument = isNodeInDocument;\n    }\n}\nclass NativeDragSource {\n    initializeExposedProperties() {\n        Object.keys(this.config.exposeProperties).forEach((property)=>{\n            Object.defineProperty(this.item, property, {\n                configurable: true,\n                enumerable: true,\n                get () {\n                    // eslint-disable-next-line no-console\n                    console.warn(`Browser doesn't allow reading \"${property}\" until the drop event.`);\n                    return null;\n                }\n            });\n        });\n    }\n    loadDataTransfer(dataTransfer) {\n        if (dataTransfer) {\n            const newProperties = {};\n            Object.keys(this.config.exposeProperties).forEach((property)=>{\n                const propertyFn = this.config.exposeProperties[property];\n                if (propertyFn != null) {\n                    newProperties[property] = {\n                        value: propertyFn(dataTransfer, this.config.matchesTypes),\n                        configurable: true,\n                        enumerable: true\n                    };\n                }\n            });\n            Object.defineProperties(this.item, newProperties);\n        }\n    }\n    canDrag() {\n        return true;\n    }\n    beginDrag() {\n        return this.item;\n    }\n    isDragging(monitor, handle) {\n        return handle === monitor.getSourceId();\n    }\n    endDrag() {\n    // empty\n    }\n    constructor(config){\n        this.config = config;\n        this.item = {};\n        this.initializeExposedProperties();\n    }\n}\nconst FILE = \"__NATIVE_FILE__\";\nconst URL = \"__NATIVE_URL__\";\nconst TEXT = \"__NATIVE_TEXT__\";\nconst HTML = \"__NATIVE_HTML__\";\nvar NativeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    FILE: FILE,\n    HTML: HTML,\n    TEXT: TEXT,\n    URL: URL\n});\nfunction getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {\n    const result = typesToTry.reduce((resultSoFar, typeToTry)=>resultSoFar || dataTransfer.getData(typeToTry), \"\");\n    return result != null ? result : defaultValue;\n}\nconst nativeTypesConfig = {\n    [FILE]: {\n        exposeProperties: {\n            files: (dataTransfer)=>Array.prototype.slice.call(dataTransfer.files),\n            items: (dataTransfer)=>dataTransfer.items,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Files\"\n        ]\n    },\n    [HTML]: {\n        exposeProperties: {\n            html: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, \"\"),\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Html\",\n            \"text/html\"\n        ]\n    },\n    [URL]: {\n        exposeProperties: {\n            urls: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, \"\").split(\"\\n\"),\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Url\",\n            \"text/uri-list\"\n        ]\n    },\n    [TEXT]: {\n        exposeProperties: {\n            text: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, \"\"),\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Text\",\n            \"text/plain\"\n        ]\n    }\n};\nfunction createNativeDragSource(type, dataTransfer) {\n    const config = nativeTypesConfig[type];\n    if (!config) {\n        throw new Error(`native type ${type} has no configuration`);\n    }\n    const result = new NativeDragSource(config);\n    result.loadDataTransfer(dataTransfer);\n    return result;\n}\nfunction matchNativeItemType(dataTransfer) {\n    if (!dataTransfer) {\n        return null;\n    }\n    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);\n    return Object.keys(nativeTypesConfig).filter((nativeItemType)=>{\n        const typeConfig = nativeTypesConfig[nativeItemType];\n        if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {\n            return false;\n        }\n        return typeConfig.matchesTypes.some((t)=>dataTransferTypes.indexOf(t) > -1);\n    })[0] || null;\n}\nconst isFirefox = memoize(()=>/firefox/i.test(navigator.userAgent));\nconst isSafari = memoize(()=>Boolean(window.safari));\nclass MonotonicInterpolant {\n    interpolate(x) {\n        const { xs, ys, c1s, c2s, c3s } = this;\n        // The rightmost point in the dataset should give an exact result\n        let i = xs.length - 1;\n        if (x === xs[i]) {\n            return ys[i];\n        }\n        // Search for the interval x is in, returning the corresponding y if x is one of the original xs\n        let low = 0;\n        let high = c3s.length - 1;\n        let mid;\n        while(low <= high){\n            mid = Math.floor(0.5 * (low + high));\n            const xHere = xs[mid];\n            if (xHere < x) {\n                low = mid + 1;\n            } else if (xHere > x) {\n                high = mid - 1;\n            } else {\n                return ys[mid];\n            }\n        }\n        i = Math.max(0, high);\n        // Interpolate\n        const diff = x - xs[i];\n        const diffSq = diff * diff;\n        return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;\n    }\n    constructor(xs, ys){\n        const { length } = xs;\n        // Rearrange xs and ys so that xs is sorted\n        const indexes = [];\n        for(let i = 0; i < length; i++){\n            indexes.push(i);\n        }\n        indexes.sort((a, b)=>xs[a] < xs[b] ? -1 : 1);\n        const dxs = [];\n        const ms = [];\n        let dx;\n        let dy;\n        for(let i1 = 0; i1 < length - 1; i1++){\n            dx = xs[i1 + 1] - xs[i1];\n            dy = ys[i1 + 1] - ys[i1];\n            dxs.push(dx);\n            ms.push(dy / dx);\n        }\n        // Get degree-1 coefficients\n        const c1s = [\n            ms[0]\n        ];\n        for(let i2 = 0; i2 < dxs.length - 1; i2++){\n            const m2 = ms[i2];\n            const mNext = ms[i2 + 1];\n            if (m2 * mNext <= 0) {\n                c1s.push(0);\n            } else {\n                dx = dxs[i2];\n                const dxNext = dxs[i2 + 1];\n                const common = dx + dxNext;\n                c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));\n            }\n        }\n        c1s.push(ms[ms.length - 1]);\n        // Get degree-2 and degree-3 coefficients\n        const c2s = [];\n        const c3s = [];\n        let m;\n        for(let i3 = 0; i3 < c1s.length - 1; i3++){\n            m = ms[i3];\n            const c1 = c1s[i3];\n            const invDx = 1 / dxs[i3];\n            const common = c1 + c1s[i3 + 1] - m - m;\n            c2s.push((m - c1 - common) * invDx);\n            c3s.push(common * invDx * invDx);\n        }\n        this.xs = xs;\n        this.ys = ys;\n        this.c1s = c1s;\n        this.c2s = c2s;\n        this.c3s = c3s;\n    }\n}\nconst ELEMENT_NODE$1 = 1;\nfunction getNodeClientOffset$1(node) {\n    const el = node.nodeType === ELEMENT_NODE$1 ? node : node.parentElement;\n    if (!el) {\n        return null;\n    }\n    const { top, left } = el.getBoundingClientRect();\n    return {\n        x: left,\n        y: top\n    };\n}\nfunction getEventClientOffset$1(e) {\n    return {\n        x: e.clientX,\n        y: e.clientY\n    };\n}\nfunction isImageNode(node) {\n    var ref;\n    return node.nodeName === \"IMG\" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n    // Work around @2x coordinate discrepancies in browsers\n    if (isSafari() && isImage) {\n        dragPreviewHeight /= window.devicePixelRatio;\n        dragPreviewWidth /= window.devicePixelRatio;\n    }\n    return {\n        dragPreviewWidth,\n        dragPreviewHeight\n    };\n}\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n    // The browsers will use the image intrinsic size under different conditions.\n    // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n    const isImage = isImageNode(dragPreview);\n    const dragPreviewNode = isImage ? sourceNode : dragPreview;\n    const dragPreviewNodeOffsetFromClient = getNodeClientOffset$1(dragPreviewNode);\n    const offsetFromDragPreview = {\n        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n    };\n    const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;\n    const { anchorX, anchorY } = anchorPoint;\n    const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);\n    const calculateYOffset = ()=>{\n        const interpolantY = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the top\n            offsetFromDragPreview.y,\n            // Align at the center\n            offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,\n            // Dock to the bottom\n            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight\n        ]);\n        let y = interpolantY.interpolate(anchorY);\n        // Work around Safari 8 positioning bug\n        if (isSafari() && isImage) {\n            // We'll have to wait for @3x to see if this is entirely correct\n            y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n        }\n        return y;\n    };\n    const calculateXOffset = ()=>{\n        // Interpolate coordinates depending on anchor point\n        // If you know a simpler way to do this, let me know\n        const interpolantX = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the left\n            offsetFromDragPreview.x,\n            // Align at the center\n            offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,\n            // Dock to the right\n            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth\n        ]);\n        return interpolantX.interpolate(anchorX);\n    };\n    // Force offsets if specified in the options.\n    const { offsetX, offsetY } = offsetPoint;\n    const isManualOffsetX = offsetX === 0 || offsetX;\n    const isManualOffsetY = offsetY === 0 || offsetY;\n    return {\n        x: isManualOffsetX ? offsetX : calculateXOffset(),\n        y: isManualOffsetY ? offsetY : calculateYOffset()\n    };\n}\nlet OptionsReader$1 = class OptionsReader {\n    get window() {\n        if (this.globalContext) {\n            return this.globalContext;\n        } else if (false) {}\n        return undefined;\n    }\n    get document() {\n        var ref;\n        if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {\n            return this.globalContext.document;\n        } else if (this.window) {\n            return this.window.document;\n        } else {\n            return undefined;\n        }\n    }\n    get rootElement() {\n        var ref;\n        return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;\n    }\n    constructor(globalContext, options){\n        this.ownerDocument = null;\n        this.globalContext = globalContext;\n        this.optionsArgs = options;\n    }\n};\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nclass HTML5BackendImpl {\n    /**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */ profile() {\n        var ref, ref1;\n        return {\n            sourcePreviewNodes: this.sourcePreviewNodes.size,\n            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n            sourceNodeOptions: this.sourceNodeOptions.size,\n            sourceNodes: this.sourceNodes.size,\n            dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,\n            dropTargetIds: this.dropTargetIds.length,\n            dragEnterTargetIds: this.dragEnterTargetIds.length,\n            dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0\n        };\n    }\n    // public for test\n    get window() {\n        return this.options.window;\n    }\n    get document() {\n        return this.options.document;\n    }\n    /**\n\t * Get the root element to use for event subscriptions\n\t */ get rootElement() {\n        return this.options.rootElement;\n    }\n    setup() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        if (root.__isReactDndBackendSetUp) {\n            throw new Error(\"Cannot have two HTML5 backends at the same time.\");\n        }\n        root.__isReactDndBackendSetUp = true;\n        this.addEventListeners(root);\n    }\n    teardown() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        root.__isReactDndBackendSetUp = false;\n        this.removeEventListeners(this.rootElement);\n        this.clearCurrentDragSourceNode();\n        if (this.asyncEndDragFrameId) {\n            var ref;\n            (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);\n        }\n    }\n    connectDragPreview(sourceId, node, options) {\n        this.sourcePreviewNodeOptions.set(sourceId, options);\n        this.sourcePreviewNodes.set(sourceId, node);\n        return ()=>{\n            this.sourcePreviewNodes.delete(sourceId);\n            this.sourcePreviewNodeOptions.delete(sourceId);\n        };\n    }\n    connectDragSource(sourceId, node, options) {\n        this.sourceNodes.set(sourceId, node);\n        this.sourceNodeOptions.set(sourceId, options);\n        const handleDragStart = (e)=>this.handleDragStart(e, sourceId);\n        const handleSelectStart = (e)=>this.handleSelectStart(e);\n        node.setAttribute(\"draggable\", \"true\");\n        node.addEventListener(\"dragstart\", handleDragStart);\n        node.addEventListener(\"selectstart\", handleSelectStart);\n        return ()=>{\n            this.sourceNodes.delete(sourceId);\n            this.sourceNodeOptions.delete(sourceId);\n            node.removeEventListener(\"dragstart\", handleDragStart);\n            node.removeEventListener(\"selectstart\", handleSelectStart);\n            node.setAttribute(\"draggable\", \"false\");\n        };\n    }\n    connectDropTarget(targetId, node) {\n        const handleDragEnter = (e)=>this.handleDragEnter(e, targetId);\n        const handleDragOver = (e)=>this.handleDragOver(e, targetId);\n        const handleDrop = (e)=>this.handleDrop(e, targetId);\n        node.addEventListener(\"dragenter\", handleDragEnter);\n        node.addEventListener(\"dragover\", handleDragOver);\n        node.addEventListener(\"drop\", handleDrop);\n        return ()=>{\n            node.removeEventListener(\"dragenter\", handleDragEnter);\n            node.removeEventListener(\"dragover\", handleDragOver);\n            node.removeEventListener(\"drop\", handleDrop);\n        };\n    }\n    addEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.addEventListener) {\n            return;\n        }\n        target.addEventListener(\"dragstart\", this.handleTopDragStart);\n        target.addEventListener(\"dragstart\", this.handleTopDragStartCapture, true);\n        target.addEventListener(\"dragend\", this.handleTopDragEndCapture, true);\n        target.addEventListener(\"dragenter\", this.handleTopDragEnter);\n        target.addEventListener(\"dragenter\", this.handleTopDragEnterCapture, true);\n        target.addEventListener(\"dragleave\", this.handleTopDragLeaveCapture, true);\n        target.addEventListener(\"dragover\", this.handleTopDragOver);\n        target.addEventListener(\"dragover\", this.handleTopDragOverCapture, true);\n        target.addEventListener(\"drop\", this.handleTopDrop);\n        target.addEventListener(\"drop\", this.handleTopDropCapture, true);\n    }\n    removeEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.removeEventListener) {\n            return;\n        }\n        target.removeEventListener(\"dragstart\", this.handleTopDragStart);\n        target.removeEventListener(\"dragstart\", this.handleTopDragStartCapture, true);\n        target.removeEventListener(\"dragend\", this.handleTopDragEndCapture, true);\n        target.removeEventListener(\"dragenter\", this.handleTopDragEnter);\n        target.removeEventListener(\"dragenter\", this.handleTopDragEnterCapture, true);\n        target.removeEventListener(\"dragleave\", this.handleTopDragLeaveCapture, true);\n        target.removeEventListener(\"dragover\", this.handleTopDragOver);\n        target.removeEventListener(\"dragover\", this.handleTopDragOverCapture, true);\n        target.removeEventListener(\"drop\", this.handleTopDrop);\n        target.removeEventListener(\"drop\", this.handleTopDropCapture, true);\n    }\n    getCurrentSourceNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);\n        return _objectSpread({\n            dropEffect: this.altKeyPressed ? \"copy\" : \"move\"\n        }, sourceNodeOptions || {});\n    }\n    getCurrentDropEffect() {\n        if (this.isDraggingNativeItem()) {\n            // It makes more sense to default to 'copy' for native resources\n            return \"copy\";\n        }\n        return this.getCurrentSourceNodeOptions().dropEffect;\n    }\n    getCurrentSourcePreviewNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);\n        return _objectSpread({\n            anchorX: 0.5,\n            anchorY: 0.5,\n            captureDraggingState: false\n        }, sourcePreviewNodeOptions || {});\n    }\n    isDraggingNativeItem() {\n        const itemType = this.monitor.getItemType();\n        return Object.keys(NativeTypes).some((key)=>NativeTypes[key] === itemType);\n    }\n    beginDragNativeItem(type, dataTransfer) {\n        this.clearCurrentDragSourceNode();\n        this.currentNativeSource = createNativeDragSource(type, dataTransfer);\n        this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);\n        this.actions.beginDrag([\n            this.currentNativeHandle\n        ]);\n    }\n    setCurrentDragSourceNode(node) {\n        this.clearCurrentDragSourceNode();\n        this.currentDragSourceNode = node;\n        // A timeout of > 0 is necessary to resolve Firefox issue referenced\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        const MOUSE_MOVE_TIMEOUT = 1000;\n        // Receiving a mouse event in the middle of a dragging operation\n        // means it has ended and the drag source node disappeared from DOM,\n        // so the browser didn't dispatch the dragend event.\n        //\n        // We need to wait before we start listening for mousemove events.\n        // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event\n        // immediately in some browsers.\n        //\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        //\n        this.mouseMoveTimeoutTimer = setTimeout(()=>{\n            var ref;\n            return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener(\"mousemove\", this.endDragIfSourceWasRemovedFromDOM, true);\n        }, MOUSE_MOVE_TIMEOUT);\n    }\n    clearCurrentDragSourceNode() {\n        if (this.currentDragSourceNode) {\n            this.currentDragSourceNode = null;\n            if (this.rootElement) {\n                var ref;\n                (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);\n                this.rootElement.removeEventListener(\"mousemove\", this.endDragIfSourceWasRemovedFromDOM, true);\n            }\n            this.mouseMoveTimeoutTimer = null;\n            return true;\n        }\n        return false;\n    }\n    handleDragStart(e, sourceId) {\n        if (e.defaultPrevented) {\n            return;\n        }\n        if (!this.dragStartSourceIds) {\n            this.dragStartSourceIds = [];\n        }\n        this.dragStartSourceIds.unshift(sourceId);\n    }\n    handleDragEnter(_e, targetId) {\n        this.dragEnterTargetIds.unshift(targetId);\n    }\n    handleDragOver(_e, targetId) {\n        if (this.dragOverTargetIds === null) {\n            this.dragOverTargetIds = [];\n        }\n        this.dragOverTargetIds.unshift(targetId);\n    }\n    handleDrop(_e, targetId) {\n        this.dropTargetIds.unshift(targetId);\n    }\n    constructor(manager, globalContext, options){\n        this.sourcePreviewNodes = new Map();\n        this.sourcePreviewNodeOptions = new Map();\n        this.sourceNodes = new Map();\n        this.sourceNodeOptions = new Map();\n        this.dragStartSourceIds = null;\n        this.dropTargetIds = [];\n        this.dragEnterTargetIds = [];\n        this.currentNativeSource = null;\n        this.currentNativeHandle = null;\n        this.currentDragSourceNode = null;\n        this.altKeyPressed = false;\n        this.mouseMoveTimeoutTimer = null;\n        this.asyncEndDragFrameId = null;\n        this.dragOverTargetIds = null;\n        this.lastClientOffset = null;\n        this.hoverRafId = null;\n        this.getSourceClientOffset = (sourceId)=>{\n            const source = this.sourceNodes.get(sourceId);\n            return source && getNodeClientOffset$1(source) || null;\n        };\n        this.endDragNativeItem = ()=>{\n            if (!this.isDraggingNativeItem()) {\n                return;\n            }\n            this.actions.endDrag();\n            if (this.currentNativeHandle) {\n                this.registry.removeSource(this.currentNativeHandle);\n            }\n            this.currentNativeHandle = null;\n            this.currentNativeSource = null;\n        };\n        this.isNodeInDocument = (node)=>{\n            // Check the node either in the main document or in the current context\n            return Boolean(node && this.document && this.document.body && this.document.body.contains(node));\n        };\n        this.endDragIfSourceWasRemovedFromDOM = ()=>{\n            const node = this.currentDragSourceNode;\n            if (node == null || this.isNodeInDocument(node)) {\n                return;\n            }\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.scheduleHover = (dragOverTargetIds)=>{\n            if (this.hoverRafId === null && typeof requestAnimationFrame !== \"undefined\") {\n                this.hoverRafId = requestAnimationFrame(()=>{\n                    if (this.monitor.isDragging()) {\n                        this.actions.hover(dragOverTargetIds || [], {\n                            clientOffset: this.lastClientOffset\n                        });\n                    }\n                    this.hoverRafId = null;\n                });\n            }\n        };\n        this.cancelHover = ()=>{\n            if (this.hoverRafId !== null && typeof cancelAnimationFrame !== \"undefined\") {\n                cancelAnimationFrame(this.hoverRafId);\n                this.hoverRafId = null;\n            }\n        };\n        this.handleTopDragStartCapture = ()=>{\n            this.clearCurrentDragSourceNode();\n            this.dragStartSourceIds = [];\n        };\n        this.handleTopDragStart = (e)=>{\n            if (e.defaultPrevented) {\n                return;\n            }\n            const { dragStartSourceIds } = this;\n            this.dragStartSourceIds = null;\n            const clientOffset = getEventClientOffset$1(e);\n            // Avoid crashing if we missed a drop event or our previous drag died\n            if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n                this.cancelHover();\n            }\n            // Don't publish the source just yet (see why below)\n            this.actions.beginDrag(dragStartSourceIds || [], {\n                publishSource: false,\n                getSourceClientOffset: this.getSourceClientOffset,\n                clientOffset\n            });\n            const { dataTransfer } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (this.monitor.isDragging()) {\n                if (dataTransfer && typeof dataTransfer.setDragImage === \"function\") {\n                    // Use custom drag image if user specifies it.\n                    // If child drag source refuses drag but parent agrees,\n                    // use parent's node as drag image. Neither works in IE though.\n                    const sourceId = this.monitor.getSourceId();\n                    const sourceNode = this.sourceNodes.get(sourceId);\n                    const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;\n                    if (dragPreview) {\n                        const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();\n                        const anchorPoint = {\n                            anchorX,\n                            anchorY\n                        };\n                        const offsetPoint = {\n                            offsetX,\n                            offsetY\n                        };\n                        const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);\n                        dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);\n                    }\n                }\n                try {\n                    // Firefox won't drag without setting data\n                    dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData(\"application/json\", {});\n                } catch (err) {\n                // IE doesn't support MIME types in setData\n                }\n                // Store drag source node so we can check whether\n                // it is removed from DOM and trigger endDrag manually.\n                this.setCurrentDragSourceNode(e.target);\n                // Now we are ready to publish the drag source.. or are we not?\n                const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();\n                if (!captureDraggingState) {\n                    // Usually we want to publish it in the next tick so that browser\n                    // is able to screenshot the current (not yet dragging) state.\n                    //\n                    // It also neatly avoids a situation where render() returns null\n                    // in the same tick for the source element, and browser freaks out.\n                    setTimeout(()=>this.actions.publishDragSource(), 0);\n                } else {\n                    // In some cases the user may want to override this behavior, e.g.\n                    // to work around IE not supporting custom drag previews.\n                    //\n                    // When using a custom drag layer, the only way to prevent\n                    // the default drag preview from drawing in IE is to screenshot\n                    // the dragging state in which the node itself has zero opacity\n                    // and height. In this case, though, returning null from render()\n                    // will abruptly end the dragging, which is not obvious.\n                    //\n                    // This is the reason such behavior is strictly opt-in.\n                    this.actions.publishDragSource();\n                }\n            } else if (nativeType) {\n                // A native item (such as URL) dragged from inside the document\n                this.beginDragNativeItem(nativeType);\n            } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute(\"draggable\"))) {\n                // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.\n                // Just let it drag. It's a native type (URL or text) and will be picked up in\n                // dragenter handler.\n                return;\n            } else {\n                // If by this time no drag source reacted, tell browser not to drag.\n                e.preventDefault();\n            }\n        };\n        this.handleTopDragEndCapture = ()=>{\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                // Firefox can dispatch this event in an infinite loop\n                // if dragend handler does something like showing an alert.\n                // Only proceed if we have not handled it already.\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleTopDragEnterCapture = (e)=>{\n            this.dragEnterTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n            const isFirstEnter = this.enterLeaveCounter.enter(e.target);\n            if (!isFirstEnter || this.monitor.isDragging()) {\n                return;\n            }\n            const { dataTransfer } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (nativeType) {\n                // A native item (such as file or URL) dragged from outside the document\n                this.beginDragNativeItem(nativeType, dataTransfer);\n            }\n        };\n        this.handleTopDragEnter = (e)=>{\n            const { dragEnterTargetIds } = this;\n            this.dragEnterTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            // If the target changes position as the result of `dragenter`, `dragover` might still\n            // get dispatched despite target being no longer there. The easy solution is to check\n            // whether there actually is a target before firing `hover`.\n            if (dragEnterTargetIds.length > 0) {\n                this.actions.hover(dragEnterTargetIds, {\n                    clientOffset: getEventClientOffset$1(e)\n                });\n            }\n            const canDrop = dragEnterTargetIds.some((targetId)=>this.monitor.canDropOnTarget(targetId));\n            if (canDrop) {\n                // IE requires this to fire dragover events\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            }\n        };\n        this.handleTopDragOverCapture = (e)=>{\n            this.dragOverTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n        };\n        this.handleTopDragOver = (e)=>{\n            const { dragOverTargetIds } = this;\n            this.dragOverTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                // Prevent default \"drop and blow away the whole document\" action.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = \"none\";\n                }\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            this.lastClientOffset = getEventClientOffset$1(e);\n            this.scheduleHover(dragOverTargetIds);\n            const canDrop = (dragOverTargetIds || []).some((targetId)=>this.monitor.canDropOnTarget(targetId));\n            if (canDrop) {\n                // Show user-specified drop effect.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            } else if (this.isDraggingNativeItem()) {\n                // Don't show a nice cursor but still prevent default\n                // \"drop and blow away the whole document\" action.\n                e.preventDefault();\n            } else {\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = \"none\";\n                }\n            }\n        };\n        this.handleTopDragLeaveCapture = (e)=>{\n            if (this.isDraggingNativeItem()) {\n                e.preventDefault();\n            }\n            const isLastLeave = this.enterLeaveCounter.leave(e.target);\n            if (!isLastLeave) {\n                return;\n            }\n            if (this.isDraggingNativeItem()) {\n                setTimeout(()=>this.endDragNativeItem(), 0);\n            }\n            this.cancelHover();\n        };\n        this.handleTopDropCapture = (e)=>{\n            this.dropTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                e.preventDefault();\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            } else if (matchNativeItemType(e.dataTransfer)) {\n                // Dragging some elements, like <a> and <img> may still behave like a native drag event,\n                // even if the current drag event matches a user-defined type.\n                // Stop the default behavior when we're not expecting a native item to be dropped.\n                e.preventDefault();\n            }\n            this.enterLeaveCounter.reset();\n        };\n        this.handleTopDrop = (e)=>{\n            const { dropTargetIds } = this;\n            this.dropTargetIds = [];\n            this.actions.hover(dropTargetIds, {\n                clientOffset: getEventClientOffset$1(e)\n            });\n            this.actions.drop({\n                dropEffect: this.getCurrentDropEffect()\n            });\n            if (this.isDraggingNativeItem()) {\n                this.endDragNativeItem();\n            } else if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleSelectStart = (e)=>{\n            const target = e.target;\n            // Only IE requires us to explicitly say\n            // we want drag drop operation to start\n            if (typeof target.dragDrop !== \"function\") {\n                return;\n            }\n            // Inputs and textareas should be selectable\n            if (target.tagName === \"INPUT\" || target.tagName === \"SELECT\" || target.tagName === \"TEXTAREA\" || target.isContentEditable) {\n                return;\n            }\n            // For other targets, ask IE\n            // to enable drag and drop\n            e.preventDefault();\n            target.dragDrop();\n        };\n        this.options = new OptionsReader$1(globalContext, options);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.registry = manager.getRegistry();\n        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);\n    }\n}\nlet emptyImage;\nfunction getEmptyImage() {\n    if (!emptyImage) {\n        emptyImage = new Image();\n        emptyImage.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    }\n    return emptyImage;\n}\nconst HTML5Backend = function createBackend(manager, context, options) {\n    return new HTML5BackendImpl(manager, context, options);\n};\nfunction Piece({ isPremovedPiece = false, piece, square, squares }) {\n    const { animationDuration, arePiecesDraggable, boardWidth, boardOrientation, chessPieces, currentPosition, deletePieceFromSquare, dropOffBoardAction, id, isDraggablePiece, isWaitingForAnimation, onPieceClick, onPieceDragBegin, onPieceDragEnd, onPieceDropOffBoard, onPromotionCheck, positionDifferences } = useChessboard();\n    const [pieceStyle, setPieceStyle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        opacity: 1,\n        zIndex: 5,\n        touchAction: \"none\",\n        cursor: arePiecesDraggable && isDraggablePiece({\n            piece,\n            sourceSquare: square\n        }) ? \"-webkit-grab\" : \"default\"\n    });\n    const [{ canDrag, isDragging }, drag, dragPreview] = useDrag(()=>({\n            type: \"piece\",\n            item: ()=>{\n                onPieceDragBegin(piece, square);\n                return {\n                    piece,\n                    square,\n                    id\n                };\n            },\n            end: (item, monitor)=>{\n                onPieceDragEnd(piece, square);\n                const wasDropOutsideTheBoard = !monitor.didDrop();\n                if (wasDropOutsideTheBoard) {\n                    if (dropOffBoardAction === \"trash\") {\n                        deletePieceFromSquare(square);\n                    }\n                    onPieceDropOffBoard === null || onPieceDropOffBoard === void 0 ? void 0 : onPieceDropOffBoard(square, piece);\n                }\n            },\n            collect: (monitor)=>({\n                    canDrag: isDraggablePiece({\n                        piece,\n                        sourceSquare: square\n                    }),\n                    isDragging: !!monitor.isDragging()\n                })\n        }), [\n        piece,\n        square,\n        currentPosition,\n        id\n    ]);\n    // hide the default preview\n    dragPreview(getEmptyImage(), {\n        captureDraggingState: true\n    });\n    // hide piece on drag\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                opacity: isDragging ? 0 : 1\n            }));\n    }, [\n        isDragging\n    ]);\n    // new move has come in\n    // if waiting for animation, then animation has started and we can perform animation\n    // we need to head towards where we need to go, we are the source, we are heading towards the target\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _a;\n        const removedPiece = (_a = positionDifferences.removed) === null || _a === void 0 ? void 0 : _a[square];\n        // return as null and not loaded yet\n        if (!positionDifferences.added || !removedPiece) return;\n        // check if piece matches or if removed piece was a pawn and new square is on 1st or 8th rank (promotion)\n        const newSquare = Object.entries(positionDifferences.added).find(([s, p])=>p === removedPiece || onPromotionCheck(square, s, removedPiece));\n        // we can perform animation if our square was in removed, AND the matching piece is in added AND this isn't a premoved piece\n        if (isWaitingForAnimation && removedPiece && newSquare && !isPremovedPiece) {\n            const sourceSq = square;\n            const targetSq = newSquare[0];\n            if (sourceSq && targetSq) {\n                const squareWidth = boardWidth / 8;\n                setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                        transform: `translate(${(boardOrientation === \"black\" ? -1 : 1) * (targetSq.charCodeAt(0) - sourceSq.charCodeAt(0)) * squareWidth}px, ${(boardOrientation === \"black\" ? -1 : 1) * (Number(sourceSq[1]) - Number(targetSq[1])) * squareWidth}px)`,\n                        transition: `transform ${animationDuration}ms`,\n                        zIndex: 6\n                    }));\n            }\n        }\n    }, [\n        positionDifferences\n    ]);\n    // translate to their own positions (repaint on undo)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { sourceSq } = getSingleSquareCoordinates();\n        if (sourceSq) {\n            setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                    transform: `translate(${0}px, ${0}px)`,\n                    transition: `transform ${0}ms`\n                }));\n        }\n    }, [\n        currentPosition\n    ]);\n    // update is piece draggable\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                cursor: arePiecesDraggable && isDraggablePiece({\n                    piece,\n                    sourceSquare: square\n                }) ? \"-webkit-grab\" : \"default\"\n            }));\n    }, [\n        square,\n        currentPosition,\n        arePiecesDraggable\n    ]);\n    function getSingleSquareCoordinates() {\n        return {\n            sourceSq: squares[square]\n        };\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        ref: arePiecesDraggable && canDrag ? drag : null,\n        onClick: ()=>onPieceClick(piece, square),\n        \"data-piece\": piece,\n        style: pieceStyle\n    }, {\n        children: typeof chessPieces[piece] === \"function\" ? chessPieces[piece]({\n            squareWidth: boardWidth / 8,\n            isDragging,\n            square\n        }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n            viewBox: \"1 1 43 43\",\n            width: boardWidth / 8,\n            height: boardWidth / 8,\n            style: {\n                display: \"block\"\n            }\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                children: chessPieces[piece]\n            })\n        }))\n    }));\n}\nfunction Square({ square, squareColor, setSquares, squareHasPremove, children }) {\n    const squareRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { autoPromoteToQueen, boardWidth, boardOrientation, clearArrows, currentPosition, currentRightClickDown, customBoardStyle, customDarkSquareStyle, customDropSquareStyle, customLightSquareStyle, customPremoveDarkSquareStyle, customPremoveLightSquareStyle, customSquare: CustomSquare, customSquareStyles, drawNewArrow, handleSetPosition, handleSparePieceDrop, isWaitingForAnimation, lastPieceColour, lastSquareDraggedOver, onArrowDrawEnd, onDragOverSquare, onMouseOutSquare, onMouseOverSquare, onPieceDrop, onPromotionCheck, onRightClickDown, onRightClickUp, onSquareClick, setLastSquareDraggedOver, setPromoteFromSquare, setPromoteToSquare, setShowPromoteDialog } = useChessboard();\n    const [{ isOver }, drop] = useDrop(()=>({\n            accept: \"piece\",\n            drop: handleDrop,\n            collect: (monitor)=>({\n                    isOver: !!monitor.isOver()\n                })\n        }), [\n        square,\n        currentPosition,\n        onPieceDrop,\n        isWaitingForAnimation,\n        lastPieceColour\n    ]);\n    function handleDrop(item) {\n        if (item.isSpare) {\n            handleSparePieceDrop(item.piece, square);\n            return;\n        }\n        if (onPromotionCheck(item.square, square, item.piece)) {\n            if (autoPromoteToQueen) {\n                handleSetPosition(item.square, square, item.piece[0] === \"w\" ? \"wQ\" : \"bQ\");\n            } else {\n                setPromoteFromSquare(item.square);\n                setPromoteToSquare(square);\n                setShowPromoteDialog(true);\n            }\n        } else {\n            handleSetPosition(item.square, square, item.piece, true);\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (squareRef.current) {\n            const { x, y } = squareRef.current.getBoundingClientRect();\n            setSquares((oldSquares)=>Object.assign(Object.assign({}, oldSquares), {\n                    [square]: {\n                        x,\n                        y\n                    }\n                }));\n        }\n    }, [\n        boardWidth,\n        boardOrientation\n    ]);\n    const defaultSquareStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, borderRadius(square, boardOrientation, customBoardStyle)), squareColor === \"black\" ? customDarkSquareStyle : customLightSquareStyle), squareHasPremove && (squareColor === \"black\" ? customPremoveDarkSquareStyle : customPremoveLightSquareStyle)), isOver && customDropSquareStyle);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        ref: drop,\n        style: defaultSquareStyle,\n        \"data-square-color\": squareColor,\n        \"data-square\": square,\n        onTouchMove: (e)=>{\n            var _a;\n            // Handle touch events on tablet and mobile not covered by onMouseOver/onDragEnter\n            const touchLocation = e.touches[0];\n            const touchElement = document.elementsFromPoint(touchLocation.clientX, touchLocation.clientY);\n            const draggedOverSquare = (_a = touchElement === null || touchElement === void 0 ? void 0 : touchElement.find((el)=>el.getAttribute(\"data-square\"))) === null || _a === void 0 ? void 0 : _a.getAttribute(\"data-square\");\n            if (draggedOverSquare && draggedOverSquare !== lastSquareDraggedOver) {\n                setLastSquareDraggedOver(draggedOverSquare);\n                onDragOverSquare(draggedOverSquare);\n            }\n        },\n        onMouseOver: (e)=>{\n            // noop if moving from child of square into square.\n            if (e.buttons === 2 && currentRightClickDown) {\n                drawNewArrow(currentRightClickDown, square);\n            }\n            if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) {\n                return;\n            }\n            onMouseOverSquare(square);\n        },\n        onMouseOut: (e)=>{\n            // noop if moving from square into a child of square.\n            if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) return;\n            onMouseOutSquare(square);\n        },\n        onMouseDown: (e)=>{\n            if (e.button === 2) onRightClickDown(square);\n        },\n        onMouseUp: (e)=>{\n            if (e.button === 2) {\n                if (currentRightClickDown) onArrowDrawEnd(currentRightClickDown, square);\n                onRightClickUp(square);\n            }\n        },\n        onDragEnter: ()=>onDragOverSquare(square),\n        onClick: ()=>{\n            const piece = currentPosition[square];\n            onSquareClick(square, piece);\n            clearArrows();\n        },\n        onContextMenu: (e)=>{\n            e.preventDefault();\n        }\n    }, {\n        children: typeof CustomSquare === \"string\" ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomSquare, Object.assign({\n            // Type is too complex to properly evaluate, so ignore this line.\n            // @ts-ignore\n            ref: squareRef,\n            style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), !squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square]))\n        }, {\n            children: children\n        })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomSquare, Object.assign({\n            ref: squareRef,\n            square: square,\n            squareColor: squareColor,\n            style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), !squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square]))\n        }, {\n            children: children\n        }))\n    }));\n}\nconst center = {\n    display: \"flex\",\n    justifyContent: \"center\"\n};\nconst size = (width)=>({\n        width: width / 8,\n        height: width / 8\n    });\nconst borderRadius = (square, boardOrientation, customBoardStyle)=>{\n    if (!(customBoardStyle === null || customBoardStyle === void 0 ? void 0 : customBoardStyle.borderRadius)) return {};\n    if (square === \"a1\") {\n        return boardOrientation === \"white\" ? {\n            borderBottomLeftRadius: customBoardStyle.borderRadius\n        } : {\n            borderTopRightRadius: customBoardStyle.borderRadius\n        };\n    }\n    if (square === \"a8\") {\n        return boardOrientation === \"white\" ? {\n            borderTopLeftRadius: customBoardStyle.borderRadius\n        } : {\n            borderBottomRightRadius: customBoardStyle.borderRadius\n        };\n    }\n    if (square === \"h1\") {\n        return boardOrientation === \"white\" ? {\n            borderBottomRightRadius: customBoardStyle.borderRadius\n        } : {\n            borderTopLeftRadius: customBoardStyle.borderRadius\n        };\n    }\n    if (square === \"h8\") {\n        return boardOrientation === \"white\" ? {\n            borderTopRightRadius: customBoardStyle.borderRadius\n        } : {\n            borderBottomLeftRadius: customBoardStyle.borderRadius\n        };\n    }\n    return {};\n};\nfunction Squares() {\n    const [squares, setSquares] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const { arePremovesAllowed, boardOrientation, boardWidth, currentPosition, id, premoves, showBoardNotation } = useChessboard();\n    const premovesHistory = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const result = [];\n        // if premoves aren't allowed, don't waste time on calculations\n        if (!arePremovesAllowed) return [];\n        premoves.forEach((premove, index)=>{\n            const { sourceSq, targetSq, piece } = premove;\n            // determine if the premove is made by an already premoved piece\n            const relatedPremovedPiece = result.find((p)=>{\n                var _a;\n                return p.piece === piece && ((_a = p.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === sourceSq;\n            });\n            // if premove has been made by already premoved piece then write the move to its `premovesRoute` field to be able find its final destination later\n            if (relatedPremovedPiece) {\n                relatedPremovedPiece.premovesRoute.push({\n                    sourceSq,\n                    targetSq,\n                    index\n                });\n            } else {\n                result.push({\n                    piece,\n                    // index is useful for scenarios where two or more pieces are targeting the same square\n                    premovesRoute: [\n                        {\n                            sourceSq,\n                            targetSq,\n                            index\n                        }\n                    ]\n                });\n            }\n        });\n        return result;\n    }, [\n        premoves\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        \"data-boardid\": id\n    }, {\n        children: [\n            ...Array(8)\n        ].map((_, r)=>{\n            return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                style: {\n                    display: \"flex\",\n                    flexWrap: \"nowrap\",\n                    width: boardWidth\n                }\n            }, {\n                children: [\n                    ...Array(8)\n                ].map((_, c)=>{\n                    const square = boardOrientation === \"black\" ? COLUMNS[7 - c] + (r + 1) : COLUMNS[c] + (8 - r);\n                    const squareColor = c % 2 === r % 2 ? \"white\" : \"black\";\n                    const squareHasPremove = premoves.find((p)=>p.sourceSq === square || p.targetSq === square);\n                    const squareHasPremoveTarget = premovesHistory.filter(({ premovesRoute })=>{\n                        var _a;\n                        return ((_a = premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === square;\n                    })//the premoved piece with the higher index will be shown, as it is the latest one\n                    .sort((a, b)=>{\n                        var _a, _b;\n                        return ((_a = b.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.index) - ((_b = a.premovesRoute.at(-1)) === null || _b === void 0 ? void 0 : _b.index);\n                    }).at(0);\n                    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Square, Object.assign({\n                        square: square,\n                        squareColor: squareColor,\n                        setSquares: setSquares,\n                        squareHasPremove: !!squareHasPremove\n                    }, {\n                        children: [\n                            !squareHasPremove && currentPosition[square] && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Piece, {\n                                piece: currentPosition[square],\n                                square: square,\n                                squares: squares\n                            }),\n                            squareHasPremoveTarget && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Piece, {\n                                isPremovedPiece: true,\n                                piece: squareHasPremoveTarget.piece,\n                                square: square,\n                                squares: squares\n                            }),\n                            showBoardNotation && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Notation, {\n                                row: r,\n                                col: c\n                            })\n                        ]\n                    }), `${c}${r}`);\n                })\n            }), r.toString());\n        })\n    }));\n}\nconst Arrows = ()=>{\n    const { arrows, newArrow, boardOrientation, boardWidth, customArrowColor: primaryArrowCollor } = useChessboard();\n    const arrowsList = [\n        ...arrows,\n        newArrow\n    ].filter(Boolean);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        width: boardWidth,\n        height: boardWidth,\n        style: {\n            position: \"absolute\",\n            top: \"0\",\n            left: \"0\",\n            pointerEvents: \"none\",\n            zIndex: \"10\"\n        }\n    }, {\n        children: arrowsList.map((arrow, i)=>{\n            const [arrowStartField, arrowEndField, arrowColor] = arrow;\n            if (arrowStartField === arrowEndField) return null;\n            const from = getRelativeCoords(boardOrientation, boardWidth, arrowStartField);\n            const to = getRelativeCoords(boardOrientation, boardWidth, arrowEndField);\n            let ARROW_LENGTH_REDUCER = boardWidth / 32;\n            const isArrowActive = i === arrows.length;\n            // if there are different arrows targeting the same square make their length a bit shorter\n            if (arrows.some((restArrow)=>restArrow[0] !== arrowStartField && restArrow[1] === arrowEndField) && !isArrowActive) {\n                ARROW_LENGTH_REDUCER = boardWidth / 16;\n            }\n            const dx = to.x - from.x;\n            const dy = to.y - from.y;\n            const r = Math.hypot(dy, dx);\n            const end = {\n                x: from.x + dx * (r - ARROW_LENGTH_REDUCER) / r,\n                y: from.y + dy * (r - ARROW_LENGTH_REDUCER) / r\n            };\n            return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", Object.assign({\n                        id: `arrowhead-${i}`,\n                        markerWidth: \"2\",\n                        markerHeight: \"2.5\",\n                        refX: \"1.25\",\n                        refY: \"1.25\",\n                        orient: \"auto\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polygon\", {\n                            points: \"0.3 0, 2 1.25, 0.3 2.5\",\n                            fill: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor\n                        })\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"line\", {\n                        x1: from.x,\n                        y1: from.y,\n                        x2: end.x,\n                        y2: end.y,\n                        opacity: isArrowActive ? \"0.5\" : \"0.65\",\n                        stroke: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor,\n                        strokeWidth: isArrowActive ? 0.9 * boardWidth / 40 : boardWidth / 40,\n                        markerEnd: `url(#arrowhead-${i})`\n                    })\n                ]\n            }, `${arrowStartField}-${arrowEndField}${isArrowActive ? \"-active\" : \"\"}`);\n        })\n    }));\n};\nfunction PromotionOption({ option }) {\n    const [isHover, setIsHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { boardWidth, chessPieces, customDarkSquareStyle, customLightSquareStyle, handleSetPosition, onPromotionPieceSelect, promoteFromSquare, promoteToSquare, promotionDialogVariant } = useChessboard();\n    const backgroundColor = ()=>{\n        switch(option[1]){\n            case \"Q\":\n                return customDarkSquareStyle.backgroundColor;\n            case \"R\":\n                return customLightSquareStyle.backgroundColor;\n            case \"N\":\n                return promotionDialogVariant === \"default\" ? customLightSquareStyle.backgroundColor : customDarkSquareStyle.backgroundColor;\n            case \"B\":\n                return promotionDialogVariant === \"default\" ? customDarkSquareStyle.backgroundColor : customLightSquareStyle.backgroundColor;\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        onClick: ()=>{\n            if (onPromotionPieceSelect(option, promoteFromSquare !== null && promoteFromSquare !== void 0 ? promoteFromSquare : undefined, promoteToSquare !== null && promoteToSquare !== void 0 ? promoteToSquare : undefined)) handleSetPosition(promoteFromSquare, promoteToSquare, option, true);\n        },\n        onMouseOver: ()=>setIsHover(true),\n        onMouseOut: ()=>setIsHover(false),\n        \"data-piece\": option,\n        style: {\n            cursor: \"pointer\",\n            backgroundColor: isHover ? backgroundColor() : `${backgroundColor()}aa`,\n            borderRadius: \"4px\",\n            transition: \"all 0.1s ease-out\"\n        }\n    }, {\n        children: typeof chessPieces[option] === \"function\" ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: {\n                transition: \"all 0.1s ease-out\",\n                transform: isHover ? \"scale(1)\" : \"scale(0.85)\"\n            }\n        }, {\n            children: chessPieces[option]({\n                squareWidth: boardWidth / 8,\n                isDragging: false\n            })\n        })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n            viewBox: \"1 1 43 43\",\n            width: boardWidth / 8,\n            height: boardWidth / 8,\n            style: {\n                transition: \"all 0.1s ease-out\",\n                transform: isHover ? \"scale(1)\" : \"scale(0.85)\"\n            }\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                children: chessPieces[option]\n            })\n        }))\n    }));\n}\nfunction PromotionDialog() {\n    const { boardOrientation, boardWidth, promotionDialogVariant, promoteToSquare } = useChessboard();\n    const promotePieceColor = (promoteToSquare === null || promoteToSquare === void 0 ? void 0 : promoteToSquare[1]) === \"1\" ? \"b\" : \"w\";\n    const promotionOptions = [\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}Q`,\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}R`,\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}N`,\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}B`\n    ];\n    const dialogStyles = {\n        default: {\n            display: \"grid\",\n            gridTemplateColumns: \"1fr 1fr\",\n            transform: `translate(${-boardWidth / 8}px, ${-boardWidth / 8}px)`\n        },\n        vertical: {\n            transform: `translate(${-boardWidth / 16}px, ${-boardWidth / 16}px)`\n        },\n        modal: {\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            transform: `translate(0px, ${3 * boardWidth / 8}px)`,\n            width: \"100%\",\n            height: `${boardWidth / 4}px`,\n            top: 0,\n            backgroundColor: \"white\",\n            left: 0\n        }\n    };\n    const dialogCoords = getRelativeCoords(boardOrientation, boardWidth, promoteToSquare || \"a8\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        style: Object.assign({\n            position: \"absolute\",\n            top: `${dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.y}px`,\n            left: `${dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.x}px`,\n            zIndex: 1000\n        }, dialogStyles[promotionDialogVariant]),\n        title: \"Choose promotion piece\"\n    }, {\n        children: promotionOptions.map((option)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromotionOption, {\n                option: option\n            }, option))\n    }));\n}\nconst errorImage = {\n    whiteKing: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        style: {\n            shapeRendering: \"geometricPrecision\",\n            textRendering: \"geometricPrecision\",\n            imageRendering: \"crisp-edges\"\n        },\n        viewBox: \"0 0 4210 12970\",\n        x: \"0px\",\n        y: \"0px\",\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        width: \"250\",\n        height: \"250\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                style: {\n                    fill: \"black\",\n                    fillRule: \"nonzero\"\n                },\n                d: \"M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z\"\n            })\n        })\n    }))\n};\nfunction ErrorBoundary({ children }) {\n    try {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    } catch (error) {\n        console.log(error);\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WhiteKing, {\n            showError: true\n        });\n    }\n}\nfunction WhiteKing({ showError = false }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        style: {\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            flexDirection: \"column\"\n        }\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                style: {\n                    width: 250,\n                    height: 250,\n                    transform: \"rotate(90deg)\"\n                }\n            }, {\n                children: errorImage.whiteKing\n            })),\n            showError && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n                children: \"Something went wrong\"\n            })\n        ]\n    }));\n}\nfunction Board() {\n    const boardRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boardWidth, clearCurrentRightClickDown, onPromotionPieceSelect, setShowPromoteDialog, showPromoteDialog, customBoardStyle } = useChessboard();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        function handleClickOutside(event) {\n            if (boardRef.current && !boardRef.current.contains(event.target)) {\n                clearCurrentRightClickDown();\n            }\n        }\n        document.addEventListener(\"mouseup\", handleClickOutside);\n        return ()=>{\n            document.removeEventListener(\"mouseup\", handleClickOutside);\n        };\n    }, []);\n    return boardWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        style: {\n            perspective: \"1000px\"\n        }\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            ref: boardRef,\n            style: Object.assign(Object.assign({\n                position: \"relative\"\n            }, boardStyles(boardWidth)), customBoardStyle)\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Squares, {}),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Arrows, {}),\n                showPromoteDialog && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                            onClick: ()=>{\n                                setShowPromoteDialog(false);\n                                onPromotionPieceSelect === null || onPromotionPieceSelect === void 0 ? void 0 : onPromotionPieceSelect();\n                            },\n                            style: {\n                                position: \"absolute\",\n                                top: \"0\",\n                                left: \"0\",\n                                zIndex: \"100\",\n                                backgroundColor: \"rgba(22,21,18,.7)\",\n                                width: boardWidth,\n                                height: boardWidth\n                            }\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromotionDialog, {})\n                    ]\n                })\n            ]\n        }))\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WhiteKing, {});\n}\nconst boardStyles = (width)=>({\n        cursor: \"default\",\n        height: width,\n        width\n    });\nvar ListenerType;\n(function(ListenerType) {\n    ListenerType[\"mouse\"] = \"mouse\";\n    ListenerType[\"touch\"] = \"touch\";\n    ListenerType[\"keyboard\"] = \"keyboard\";\n})(ListenerType || (ListenerType = {}));\nclass OptionsReader {\n    get delay() {\n        var _delay;\n        return (_delay = this.args.delay) !== null && _delay !== void 0 ? _delay : 0;\n    }\n    get scrollAngleRanges() {\n        return this.args.scrollAngleRanges;\n    }\n    get getDropTargetElementsAtPoint() {\n        return this.args.getDropTargetElementsAtPoint;\n    }\n    get ignoreContextMenu() {\n        var _ignoreContextMenu;\n        return (_ignoreContextMenu = this.args.ignoreContextMenu) !== null && _ignoreContextMenu !== void 0 ? _ignoreContextMenu : false;\n    }\n    get enableHoverOutsideTarget() {\n        var _enableHoverOutsideTarget;\n        return (_enableHoverOutsideTarget = this.args.enableHoverOutsideTarget) !== null && _enableHoverOutsideTarget !== void 0 ? _enableHoverOutsideTarget : false;\n    }\n    get enableKeyboardEvents() {\n        var _enableKeyboardEvents;\n        return (_enableKeyboardEvents = this.args.enableKeyboardEvents) !== null && _enableKeyboardEvents !== void 0 ? _enableKeyboardEvents : false;\n    }\n    get enableMouseEvents() {\n        var _enableMouseEvents;\n        return (_enableMouseEvents = this.args.enableMouseEvents) !== null && _enableMouseEvents !== void 0 ? _enableMouseEvents : false;\n    }\n    get enableTouchEvents() {\n        var _enableTouchEvents;\n        return (_enableTouchEvents = this.args.enableTouchEvents) !== null && _enableTouchEvents !== void 0 ? _enableTouchEvents : true;\n    }\n    get touchSlop() {\n        return this.args.touchSlop || 0;\n    }\n    get delayTouchStart() {\n        var ref, ref1;\n        var ref2, ref3;\n        return (ref3 = (ref2 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayTouchStart) !== null && ref2 !== void 0 ? ref2 : (ref1 = this.args) === null || ref1 === void 0 ? void 0 : ref1.delay) !== null && ref3 !== void 0 ? ref3 : 0;\n    }\n    get delayMouseStart() {\n        var ref, ref4;\n        var ref5, ref6;\n        return (ref6 = (ref5 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayMouseStart) !== null && ref5 !== void 0 ? ref5 : (ref4 = this.args) === null || ref4 === void 0 ? void 0 : ref4.delay) !== null && ref6 !== void 0 ? ref6 : 0;\n    }\n    get window() {\n        if (this.context && this.context.window) {\n            return this.context.window;\n        } else if (false) {}\n        return undefined;\n    }\n    get document() {\n        var ref;\n        if ((ref = this.context) === null || ref === void 0 ? void 0 : ref.document) {\n            return this.context.document;\n        }\n        if (this.window) {\n            return this.window.document;\n        }\n        return undefined;\n    }\n    get rootElement() {\n        var ref;\n        return ((ref = this.args) === null || ref === void 0 ? void 0 : ref.rootElement) || this.document;\n    }\n    constructor(args, context){\n        this.args = args;\n        this.context = context;\n    }\n}\nfunction distance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(Math.abs(x2 - x1), 2) + Math.pow(Math.abs(y2 - y1), 2));\n}\nfunction inAngleRanges(x1, y1, x2, y2, angleRanges) {\n    if (!angleRanges) {\n        return false;\n    }\n    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI + 180;\n    for(let i = 0; i < angleRanges.length; ++i){\n        const ar = angleRanges[i];\n        if (ar && (ar.start == null || angle >= ar.start) && (ar.end == null || angle <= ar.end)) {\n            return true;\n        }\n    }\n    return false;\n}\n// Used for MouseEvent.buttons (note the s on the end).\nconst MouseButtons = {\n    Left: 1,\n    Right: 2,\n    Center: 4\n};\n// Used for e.button (note the lack of an s on the end).\nconst MouseButton = {\n    Left: 0,\n    Center: 1,\n    Right: 2\n};\n/**\n * Only touch events and mouse events where the left button is pressed should initiate a drag.\n * @param {MouseEvent | TouchEvent} e The event\n */ function eventShouldStartDrag(e) {\n    // For touch events, button will be undefined. If e.button is defined,\n    // then it should be MouseButton.Left.\n    return e.button === undefined || e.button === MouseButton.Left;\n}\n/**\n * Only touch events and mouse events where the left mouse button is no longer held should end a drag.\n * It's possible the user mouse downs with the left mouse button, then mouse down and ups with the right mouse button.\n * We don't want releasing the right mouse button to end the drag.\n * @param {MouseEvent | TouchEvent} e The event\n */ function eventShouldEndDrag(e) {\n    // Touch events will have buttons be undefined, while mouse events will have e.buttons's left button\n    // bit field unset if the left mouse button has been released\n    return e.buttons === undefined || (e.buttons & MouseButtons.Left) === 0;\n}\nfunction isTouchEvent(e) {\n    return !!e.targetTouches;\n}\nconst ELEMENT_NODE = 1;\nfunction getNodeClientOffset(node) {\n    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n    if (!el) {\n        return undefined;\n    }\n    const { top, left } = el.getBoundingClientRect();\n    return {\n        x: left,\n        y: top\n    };\n}\nfunction getEventClientTouchOffset(e, lastTargetTouchFallback) {\n    if (e.targetTouches.length === 1) {\n        return getEventClientOffset(e.targetTouches[0]);\n    } else if (lastTargetTouchFallback && e.touches.length === 1) {\n        if (e.touches[0].target === lastTargetTouchFallback.target) {\n            return getEventClientOffset(e.touches[0]);\n        }\n    }\n    return;\n}\nfunction getEventClientOffset(e, lastTargetTouchFallback) {\n    if (isTouchEvent(e)) {\n        return getEventClientTouchOffset(e, lastTargetTouchFallback);\n    } else {\n        return {\n            x: e.clientX,\n            y: e.clientY\n        };\n    }\n}\nconst supportsPassive = (()=>{\n    // simular to jQuery's test\n    let supported = false;\n    try {\n        addEventListener(\"test\", ()=>{\n        // do nothing\n        }, Object.defineProperty({}, \"passive\", {\n            get () {\n                supported = true;\n                return true;\n            }\n        }));\n    } catch (e) {\n    // do nothing\n    }\n    return supported;\n})();\nconst eventNames = {\n    [ListenerType.mouse]: {\n        start: \"mousedown\",\n        move: \"mousemove\",\n        end: \"mouseup\",\n        contextmenu: \"contextmenu\"\n    },\n    [ListenerType.touch]: {\n        start: \"touchstart\",\n        move: \"touchmove\",\n        end: \"touchend\"\n    },\n    [ListenerType.keyboard]: {\n        keydown: \"keydown\"\n    }\n};\nclass TouchBackendImpl {\n    /**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */ profile() {\n        var ref;\n        return {\n            sourceNodes: this.sourceNodes.size,\n            sourcePreviewNodes: this.sourcePreviewNodes.size,\n            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n            targetNodes: this.targetNodes.size,\n            dragOverTargetIds: ((ref = this.dragOverTargetIds) === null || ref === void 0 ? void 0 : ref.length) || 0\n        };\n    }\n    // public for test\n    get document() {\n        return this.options.document;\n    }\n    setup() {\n        const root = this.options.rootElement;\n        if (!root) {\n            return;\n        }\n        invariant(!TouchBackendImpl.isSetUp, \"Cannot have two Touch backends at the same time.\");\n        TouchBackendImpl.isSetUp = true;\n        this.addEventListener(root, \"start\", this.getTopMoveStartHandler());\n        this.addEventListener(root, \"start\", this.handleTopMoveStartCapture, true);\n        this.addEventListener(root, \"move\", this.handleTopMove);\n        this.addEventListener(root, \"move\", this.handleTopMoveCapture, true);\n        this.addEventListener(root, \"end\", this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.addEventListener(root, \"contextmenu\", this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.addEventListener(root, \"keydown\", this.handleCancelOnEscape, true);\n        }\n    }\n    teardown() {\n        const root = this.options.rootElement;\n        if (!root) {\n            return;\n        }\n        TouchBackendImpl.isSetUp = false;\n        this._mouseClientOffset = {};\n        this.removeEventListener(root, \"start\", this.handleTopMoveStartCapture, true);\n        this.removeEventListener(root, \"start\", this.handleTopMoveStart);\n        this.removeEventListener(root, \"move\", this.handleTopMoveCapture, true);\n        this.removeEventListener(root, \"move\", this.handleTopMove);\n        this.removeEventListener(root, \"end\", this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.removeEventListener(root, \"contextmenu\", this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.removeEventListener(root, \"keydown\", this.handleCancelOnEscape, true);\n        }\n        this.uninstallSourceNodeRemovalObserver();\n    }\n    addEventListener(subject, event, handler, capture = false) {\n        const options = supportsPassive ? {\n            capture,\n            passive: false\n        } : capture;\n        this.listenerTypes.forEach(function(listenerType) {\n            const evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.addEventListener(evt, handler, options);\n            }\n        });\n    }\n    removeEventListener(subject, event, handler, capture = false) {\n        const options = supportsPassive ? {\n            capture,\n            passive: false\n        } : capture;\n        this.listenerTypes.forEach(function(listenerType) {\n            const evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.removeEventListener(evt, handler, options);\n            }\n        });\n    }\n    connectDragSource(sourceId, node) {\n        const handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n        this.sourceNodes.set(sourceId, node);\n        this.addEventListener(node, \"start\", handleMoveStart);\n        return ()=>{\n            this.sourceNodes.delete(sourceId);\n            this.removeEventListener(node, \"start\", handleMoveStart);\n        };\n    }\n    connectDragPreview(sourceId, node, options) {\n        this.sourcePreviewNodeOptions.set(sourceId, options);\n        this.sourcePreviewNodes.set(sourceId, node);\n        return ()=>{\n            this.sourcePreviewNodes.delete(sourceId);\n            this.sourcePreviewNodeOptions.delete(sourceId);\n        };\n    }\n    connectDropTarget(targetId, node) {\n        const root = this.options.rootElement;\n        if (!this.document || !root) {\n            return ()=>{\n            /* noop */ };\n        }\n        const handleMove = (e)=>{\n            if (!this.document || !root || !this.monitor.isDragging()) {\n                return;\n            }\n            let coords;\n            /**\n\t\t\t * Grab the coordinates for the current mouse/touch position\n\t\t\t */ switch(e.type){\n                case eventNames.mouse.move:\n                    coords = {\n                        x: e.clientX,\n                        y: e.clientY\n                    };\n                    break;\n                case eventNames.touch.move:\n                    var ref, ref1;\n                    coords = {\n                        x: ((ref = e.touches[0]) === null || ref === void 0 ? void 0 : ref.clientX) || 0,\n                        y: ((ref1 = e.touches[0]) === null || ref1 === void 0 ? void 0 : ref1.clientY) || 0\n                    };\n                    break;\n            }\n            /**\n\t\t\t * Use the coordinates to grab the element the drag ended on.\n\t\t\t * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n\t\t\t */ const droppedOn = coords != null ? this.document.elementFromPoint(coords.x, coords.y) : undefined;\n            const childMatch = droppedOn && node.contains(droppedOn);\n            if (droppedOn === node || childMatch) {\n                return this.handleMove(e, targetId);\n            }\n        };\n        /**\n\t\t * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n\t\t */ this.addEventListener(this.document.body, \"move\", handleMove);\n        this.targetNodes.set(targetId, node);\n        return ()=>{\n            if (this.document) {\n                this.targetNodes.delete(targetId);\n                this.removeEventListener(this.document.body, \"move\", handleMove);\n            }\n        };\n    }\n    getTopMoveStartHandler() {\n        if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n            return this.handleTopMoveStart;\n        }\n        return this.handleTopMoveStartDelay;\n    }\n    installSourceNodeRemovalObserver(node) {\n        this.uninstallSourceNodeRemovalObserver();\n        this.draggedSourceNode = node;\n        this.draggedSourceNodeRemovalObserver = new MutationObserver(()=>{\n            if (node && !node.parentElement) {\n                this.resurrectSourceNode();\n                this.uninstallSourceNodeRemovalObserver();\n            }\n        });\n        if (!node || !node.parentElement) {\n            return;\n        }\n        this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n            childList: true\n        });\n    }\n    resurrectSourceNode() {\n        if (this.document && this.draggedSourceNode) {\n            this.draggedSourceNode.style.display = \"none\";\n            this.draggedSourceNode.removeAttribute(\"data-reactid\");\n            this.document.body.appendChild(this.draggedSourceNode);\n        }\n    }\n    uninstallSourceNodeRemovalObserver() {\n        if (this.draggedSourceNodeRemovalObserver) {\n            this.draggedSourceNodeRemovalObserver.disconnect();\n        }\n        this.draggedSourceNodeRemovalObserver = undefined;\n        this.draggedSourceNode = undefined;\n    }\n    constructor(manager, context, options){\n        this.getSourceClientOffset = (sourceId)=>{\n            const element = this.sourceNodes.get(sourceId);\n            return element && getNodeClientOffset(element);\n        };\n        this.handleTopMoveStartCapture = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            this.moveStartSourceIds = [];\n        };\n        this.handleMoveStart = (sourceId)=>{\n            // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n            // We only collect start collecting drag sources on touch and left mouse events.\n            if (Array.isArray(this.moveStartSourceIds)) {\n                this.moveStartSourceIds.unshift(sourceId);\n            }\n        };\n        this.handleTopMoveStart = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            // Don't prematurely preventDefault() here since it might:\n            // 1. Mess up scrolling\n            // 2. Mess up long tap (which brings up context menu)\n            // 3. If there's an anchor link as a child, tap won't be triggered on link\n            const clientOffset = getEventClientOffset(e);\n            if (clientOffset) {\n                if (isTouchEvent(e)) {\n                    this.lastTargetTouchFallback = e.targetTouches[0];\n                }\n                this._mouseClientOffset = clientOffset;\n            }\n            this.waitingForDelay = false;\n        };\n        this.handleTopMoveStartDelay = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            const delay = e.type === eventNames.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;\n            this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e), delay);\n            this.waitingForDelay = true;\n        };\n        this.handleTopMoveCapture = ()=>{\n            this.dragOverTargetIds = [];\n        };\n        this.handleMove = (_evt, targetId)=>{\n            if (this.dragOverTargetIds) {\n                this.dragOverTargetIds.unshift(targetId);\n            }\n        };\n        this.handleTopMove = (e1)=>{\n            if (this.timeout) {\n                clearTimeout(this.timeout);\n            }\n            if (!this.document || this.waitingForDelay) {\n                return;\n            }\n            const { moveStartSourceIds, dragOverTargetIds } = this;\n            const enableHoverOutsideTarget = this.options.enableHoverOutsideTarget;\n            const clientOffset = getEventClientOffset(e1, this.lastTargetTouchFallback);\n            if (!clientOffset) {\n                return;\n            }\n            // If the touch move started as a scroll, or is is between the scroll angles\n            if (this._isScrolling || !this.monitor.isDragging() && inAngleRanges(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, this.options.scrollAngleRanges)) {\n                this._isScrolling = true;\n                return;\n            }\n            // If we're not dragging and we've moved a little, that counts as a drag start\n            if (!this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n            this._mouseClientOffset.hasOwnProperty(\"x\") && moveStartSourceIds && distance(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (this.options.touchSlop ? this.options.touchSlop : 0)) {\n                this.moveStartSourceIds = undefined;\n                this.actions.beginDrag(moveStartSourceIds, {\n                    clientOffset: this._mouseClientOffset,\n                    getSourceClientOffset: this.getSourceClientOffset,\n                    publishSource: false\n                });\n            }\n            if (!this.monitor.isDragging()) {\n                return;\n            }\n            const sourceNode = this.sourceNodes.get(this.monitor.getSourceId());\n            this.installSourceNodeRemovalObserver(sourceNode);\n            this.actions.publishDragSource();\n            if (e1.cancelable) e1.preventDefault();\n            // Get the node elements of the hovered DropTargets\n            const dragOverTargetNodes = (dragOverTargetIds || []).map((key)=>this.targetNodes.get(key)).filter((e)=>!!e);\n            // Get the a ordered list of nodes that are touched by\n            const elementsAtPoint = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : this.document.elementsFromPoint(clientOffset.x, clientOffset.y);\n            // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n            const elementsAtPointExtended = [];\n            for(const nodeId in elementsAtPoint){\n                // eslint-disable-next-line no-prototype-builtins\n                if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n                    continue;\n                }\n                let currentNode = elementsAtPoint[nodeId];\n                if (currentNode != null) {\n                    elementsAtPointExtended.push(currentNode);\n                }\n                while(currentNode){\n                    currentNode = currentNode.parentElement;\n                    if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n                        elementsAtPointExtended.push(currentNode);\n                    }\n                }\n            }\n            const orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n            .filter((node)=>dragOverTargetNodes.indexOf(node) > -1) // Map back the nodes elements to targetIds\n            .map((node)=>this._getDropTargetId(node)) // Filter off possible null rows\n            .filter((node)=>!!node).filter((id, index, ids)=>ids.indexOf(id) === index);\n            // Invoke hover for drop targets when source node is still over and pointer is outside\n            if (enableHoverOutsideTarget) {\n                for(const targetId in this.targetNodes){\n                    const targetNode = this.targetNodes.get(targetId);\n                    if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n                        orderedDragOverTargetIds.unshift(targetId);\n                        break;\n                    }\n                }\n            }\n            // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n            orderedDragOverTargetIds.reverse();\n            this.actions.hover(orderedDragOverTargetIds, {\n                clientOffset: clientOffset\n            });\n        };\n        /**\n\t *\n\t * visible for testing\n\t */ this._getDropTargetId = (node)=>{\n            const keys = this.targetNodes.keys();\n            let next = keys.next();\n            while(next.done === false){\n                const targetId = next.value;\n                if (node === this.targetNodes.get(targetId)) {\n                    return targetId;\n                } else {\n                    next = keys.next();\n                }\n            }\n            return undefined;\n        };\n        this.handleTopMoveEndCapture = (e)=>{\n            this._isScrolling = false;\n            this.lastTargetTouchFallback = undefined;\n            if (!eventShouldEndDrag(e)) {\n                return;\n            }\n            if (!this.monitor.isDragging() || this.monitor.didDrop()) {\n                this.moveStartSourceIds = undefined;\n                return;\n            }\n            if (e.cancelable) e.preventDefault();\n            this._mouseClientOffset = {};\n            this.uninstallSourceNodeRemovalObserver();\n            this.actions.drop();\n            this.actions.endDrag();\n        };\n        this.handleCancelOnEscape = (e)=>{\n            if (e.key === \"Escape\" && this.monitor.isDragging()) {\n                this._mouseClientOffset = {};\n                this.uninstallSourceNodeRemovalObserver();\n                this.actions.endDrag();\n            }\n        };\n        this.options = new OptionsReader(options, context);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.sourceNodes = new Map();\n        this.sourcePreviewNodes = new Map();\n        this.sourcePreviewNodeOptions = new Map();\n        this.targetNodes = new Map();\n        this.listenerTypes = [];\n        this._mouseClientOffset = {};\n        this._isScrolling = false;\n        if (this.options.enableMouseEvents) {\n            this.listenerTypes.push(ListenerType.mouse);\n        }\n        if (this.options.enableTouchEvents) {\n            this.listenerTypes.push(ListenerType.touch);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.listenerTypes.push(ListenerType.keyboard);\n        }\n    }\n}\nconst TouchBackend = function createBackend(manager, context = {}, options = {}) {\n    return new TouchBackendImpl(manager, context, options);\n};\nconst ChessboardDnDContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    isCustomDndProviderSet: false\n});\nconst EmptyProvider = ({ children })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    });\n};\nconst ChessboardDnDProvider = ({ children, backend, context, options, debugMode })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardDnDContext.Provider, Object.assign({\n        value: {\n            isCustomDndProviderSet: true\n        }\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DndProvider, Object.assign({\n            backend: backend || (\"ontouchstart\" in window ? TouchBackend : HTML5Backend),\n            context: context,\n            options: options,\n            debugMode: debugMode !== null && debugMode !== void 0 ? debugMode : false\n        }, {\n            children: children\n        }))\n    }));\n};\nconst ChessboardDnDRoot = ({ customDndBackend, customDndBackendOptions, children })=>{\n    const [clientWindow, setClientWindow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [backendSet, setBackendSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isMobile, setIsMobile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { isCustomDndProviderSet } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChessboardDnDContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setIsMobile(\"ontouchstart\" in window);\n        setBackendSet(true);\n        setClientWindow(window);\n    }, []);\n    // in case we already wrapped `<Chessboard/>`  with `<DnDProvider/>` we don't need to create a new one\n    const DnDWrapper = isCustomDndProviderSet ? EmptyProvider : DndProvider;\n    if (!backendSet) {\n        return null;\n    }\n    return clientWindow ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DnDWrapper, Object.assign({\n        backend: customDndBackend || (isMobile ? TouchBackend : HTML5Backend),\n        context: clientWindow,\n        options: customDndBackend ? customDndBackendOptions : undefined\n    }, {\n        children: children\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    });\n};\nfunction CustomDragLayer({ boardContainer }) {\n    const { boardWidth, chessPieces, id, snapToCursor, allowDragOutsideBoard } = useChessboard();\n    const collectedProps = useDragLayer((monitor)=>({\n            item: monitor.getItem(),\n            clientOffset: monitor.getClientOffset(),\n            sourceClientOffset: monitor.getSourceClientOffset(),\n            isDragging: monitor.isDragging()\n        }));\n    const { isDragging, item, clientOffset, sourceClientOffset } = collectedProps;\n    const getItemStyle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((clientOffset, sourceClientOffset)=>{\n        if (!clientOffset || !sourceClientOffset) return {\n            display: \"none\"\n        };\n        let { x, y } = snapToCursor ? clientOffset : sourceClientOffset;\n        const halfSquareWidth = boardWidth / 8 / 2;\n        if (snapToCursor) {\n            x -= halfSquareWidth;\n            y -= halfSquareWidth;\n        }\n        if (!allowDragOutsideBoard) {\n            const { left, top } = boardContainer;\n            // half square so the piece reaches the board\n            const maxLeft = left - halfSquareWidth;\n            const maxTop = top - halfSquareWidth;\n            const maxRight = left + boardWidth - halfSquareWidth;\n            const maxBottom = top + boardWidth - halfSquareWidth;\n            x = Math.max(maxLeft, Math.min(x, maxRight));\n            y = Math.max(maxTop, Math.min(y, maxBottom));\n        }\n        const transform = `translate(${x}px, ${y}px)`;\n        return {\n            transform,\n            WebkitTransform: transform,\n            touchAction: \"none\"\n        };\n    }, [\n        boardWidth,\n        allowDragOutsideBoard,\n        snapToCursor,\n        boardContainer\n    ]);\n    return isDragging && item.id === id ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        style: {\n            position: \"fixed\",\n            pointerEvents: \"none\",\n            zIndex: 10,\n            left: 0,\n            top: 0\n        }\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: getItemStyle(clientOffset, sourceClientOffset)\n        }, {\n            children: typeof chessPieces[item.piece] === \"function\" ? chessPieces[item.piece]({\n                squareWidth: boardWidth / 8,\n                isDragging: true\n            }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n                viewBox: \"1 1 43 43\",\n                width: boardWidth / 8,\n                height: boardWidth / 8\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                    children: chessPieces[item.piece]\n                })\n            }))\n        }))\n    })) : null;\n}\nconst SparePiece = ({ piece, width, customPieceJSX, dndId })=>{\n    const renderPiece = customPieceJSX !== null && customPieceJSX !== void 0 ? customPieceJSX : defaultPieces[piece];\n    const [{ canDrag, isDragging }, drag, dragPreview] = useDrag(()=>({\n            type: \"piece\",\n            item: ()=>{\n                return {\n                    piece,\n                    isSpare: true,\n                    id: dndId\n                };\n            },\n            collect: (monitor)=>({\n                    canDrag: true,\n                    isDragging: !!monitor.isDragging()\n                })\n        }), [\n        piece,\n        dndId\n    ]);\n    // hide the default preview\n    dragPreview(getEmptyImage(), {\n        captureDraggingState: true\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        ref: canDrag ? drag : null,\n        \"data-piece\": piece,\n        style: {\n            cursor: \"move\"\n        }\n    }, {\n        children: typeof renderPiece === \"function\" ? renderPiece({\n            squareWidth: width,\n            isDragging\n        }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n            viewBox: \"1 1 43 43\",\n            width: width,\n            height: width\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                children: renderPiece\n            })\n        }))\n    }));\n};\nconst Chessboard = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>{\n    const { customDndBackend, customDndBackendOptions, onBoardWidthChange } = props, otherProps = __rest(props, [\n        \"customDndBackend\",\n        \"customDndBackendOptions\",\n        \"onBoardWidthChange\"\n    ]);\n    const [boardWidth, setBoardWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(props.boardWidth);\n    const boardRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const boardContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [boardContainerPos, setBoardContainerPos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        left: 0,\n        top: 0\n    });\n    const metrics = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        var _a;\n        return (_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n    }, [\n        boardRef.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        boardWidth && (onBoardWidthChange === null || onBoardWidthChange === void 0 ? void 0 : onBoardWidthChange(boardWidth));\n    }, [\n        boardWidth\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setBoardContainerPos({\n            left: (metrics === null || metrics === void 0 ? void 0 : metrics.left) ? metrics === null || metrics === void 0 ? void 0 : metrics.left : 0,\n            top: (metrics === null || metrics === void 0 ? void 0 : metrics.top) ? metrics === null || metrics === void 0 ? void 0 : metrics.top : 0\n        });\n    }, [\n        metrics\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _a;\n        if (props.boardWidth === undefined && ((_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth)) {\n            const resizeObserver = new ResizeObserver(()=>{\n                var _a;\n                setBoardWidth((_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth);\n            });\n            resizeObserver.observe(boardRef.current);\n            return ()=>{\n                resizeObserver.disconnect();\n            };\n        }\n    }, [\n        boardRef.current\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorBoundary, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            ref: boardContainerRef,\n            style: {\n                display: \"flex\",\n                flexDirection: \"column\",\n                width: \"100%\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    ref: boardRef,\n                    style: {\n                        width: \"100%\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardDnDRoot, Object.assign({\n                    customDndBackend: customDndBackend,\n                    customDndBackendOptions: customDndBackendOptions\n                }, {\n                    children: boardWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ChessboardProvider, Object.assign({\n                        boardWidth: boardWidth\n                    }, otherProps, {\n                        ref: ref\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomDragLayer, {\n                                boardContainer: boardContainerPos\n                            }),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Board, {})\n                        ]\n                    }))\n                }))\n            ]\n        }))\n    });\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2hlc3Nib2FyZC9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdEO0FBQzJKO0FBRW5OOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTaUIsT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUVBLE1BQU1XLFVBQVUsV0FBV0MsS0FBSyxDQUFDO0FBQ2pDLE1BQU1DLHdCQUF3QjtJQUMxQkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0FBQ1I7QUFDQSxNQUFNQyxzQkFBc0I7SUFDeEJDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSG5ELEdBQUc7SUFDSG9ELEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0FBQ1A7QUFDQSxNQUFNQyxzQkFBc0I7SUFDeEJQLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSG5ELEdBQUc7SUFDSG9ELEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0FBQ1A7QUFDQSxNQUFNRSxhQUFhO0lBQUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFFO0FBQzNDLE1BQU1DLGFBQWE7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0NBQUU7QUFFM0MsK0RBQStEO0FBQy9ELGlDQUFpQztBQUNqQywwSUFBMEk7QUFDMUksTUFBTUMsZ0JBQWdCO0lBQ2xCQyxJQUFLOUUsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRUMsT0FBTztRQUE4QkMsU0FBUztRQUFPQyxPQUFPO1FBQU1DLFFBQVE7SUFBSyxHQUFHO1FBQUVDLFVBQVVwRixzREFBR0EsQ0FBQyxRQUFRO1lBQUVzRSxHQUFHO1lBQW1UZSxPQUFPO2dCQUM3YkMsU0FBUztnQkFDVEMsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkMsa0JBQWtCO2dCQUNsQkMsaUJBQWlCO2dCQUNqQkMsZUFBZTtZQUNuQjtRQUFFO0lBQUc7SUFDYkMsSUFBS2pHLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1FBQUVDLE9BQU87UUFBOEJDLFNBQVM7UUFBT0MsT0FBTztRQUFNQyxRQUFRO0lBQUssR0FBRztRQUFFQyxVQUFVbkYsdURBQUlBLENBQUMsS0FBS3FCLE9BQU95RCxNQUFNLENBQUM7WUFBRU0sT0FBTztnQkFDbkpDLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLGVBQWU7Z0JBQ2ZDLGdCQUFnQjtnQkFDaEJDLGtCQUFrQjtnQkFDbEJDLGlCQUFpQjtnQkFDakJDLGVBQWU7WUFDbkI7UUFBRSxHQUFHO1lBQUVaLFVBQVU7Z0JBQUNwRixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBMkNlLE9BQU87d0JBQUVPLGVBQWU7b0JBQU87Z0JBQUU7Z0JBQUk1RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBOENlLE9BQU87d0JBQUVPLGVBQWU7b0JBQU87Z0JBQUU7Z0JBQUk1RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBNkZlLE9BQU87d0JBQUVPLGVBQWU7b0JBQU87Z0JBQUU7Z0JBQUk1RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztnQkFBa0M7Z0JBQUl0RSxzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBdUNlLE9BQU87d0JBQUVPLGVBQWU7d0JBQVFDLGdCQUFnQjtvQkFBUTtnQkFBRTtnQkFBSTdGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO2dCQUEwQztnQkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUFtQmUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBUUcsUUFBUTt3QkFBV0csZ0JBQWdCO29CQUFRO2dCQUFFO2FBQUc7UUFBQztJQUFJO0lBQzlzQkssSUFBS2xHLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1FBQUVDLE9BQU87UUFBOEJDLFNBQVM7UUFBT0MsT0FBTztRQUFNQyxRQUFRO0lBQUssR0FBRztRQUFFQyxVQUFVbkYsdURBQUlBLENBQUMsS0FBS3FCLE9BQU95RCxNQUFNLENBQUM7WUFBRU0sT0FBTztnQkFDbkpDLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLGFBQWE7Z0JBQ2JDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLGVBQWU7Z0JBQ2ZDLGdCQUFnQjtnQkFDaEJDLGtCQUFrQjtnQkFDbEJDLGlCQUFpQjtnQkFDakJDLGVBQWU7WUFDbkI7UUFBRSxHQUFHO1lBQUVaLFVBQVU7Z0JBQUNwRixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBaUVlLE9BQU87d0JBQUVFLE1BQU07d0JBQVdHLFFBQVE7b0JBQVU7Z0JBQUU7Z0JBQUkxRixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBcVRlLE9BQU87d0JBQUVFLE1BQU07d0JBQVdHLFFBQVE7b0JBQVU7Z0JBQUU7Z0JBQUkxRixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBa0VlLE9BQU87d0JBQUVFLE1BQU07d0JBQVdHLFFBQVE7b0JBQVU7Z0JBQUU7Z0JBQUkxRixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBaUU2QixXQUFXO29CQUE2Q2QsT0FBTzt3QkFBRUUsTUFBTTt3QkFBV0csUUFBUTtvQkFBVTtnQkFBRTthQUFHO1FBQUM7SUFBSTtJQUMzMUJVLElBQUtwRyxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFQyxPQUFPO1FBQThCQyxTQUFTO1FBQU9DLE9BQU87UUFBTUMsUUFBUTtJQUFLLEdBQUc7UUFBRUMsVUFBVW5GLHVEQUFJQSxDQUFDLEtBQUtxQixPQUFPeUQsTUFBTSxDQUFDO1lBQUVNLE9BQU87Z0JBQ25KQyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNORSxVQUFVO2dCQUNWRCxhQUFhO2dCQUNiRSxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxlQUFlO2dCQUNmQyxnQkFBZ0I7Z0JBQ2hCQyxrQkFBa0I7Z0JBQ2xCQyxpQkFBaUI7Z0JBQ2pCQyxlQUFlO1lBQ25CO1FBQUUsR0FBRztZQUFFWixVQUFVO2dCQUFDbkYsdURBQUlBLENBQUMsS0FBS3FCLE9BQU95RCxNQUFNLENBQUM7b0JBQUVNLE9BQU87d0JBQUVFLE1BQU07d0JBQVdHLFFBQVE7d0JBQVdFLGVBQWU7b0JBQU87Z0JBQUUsR0FBRztvQkFBRVIsVUFBVTt3QkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUFrUTt3QkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUFvTTt3QkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUF1RDtxQkFBRztnQkFBQztnQkFBS3RFLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUErRWUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBUUcsUUFBUTt3QkFBV0csZ0JBQWdCO29CQUFRO2dCQUFFO2FBQUc7UUFBQztJQUFJO0lBQ3QzQlEsSUFBS3JHLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1FBQUVDLE9BQU87UUFBOEJDLFNBQVM7UUFBT0MsT0FBTztRQUFNQyxRQUFRO0lBQUssR0FBRztRQUFFQyxVQUFVbkYsdURBQUlBLENBQUMsS0FBS3FCLE9BQU95RCxNQUFNLENBQUM7WUFBRU0sT0FBTztnQkFDbkpFLE1BQU07Z0JBQ05HLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JFLGdCQUFnQjtZQUNwQjtRQUFFLEdBQUc7WUFBRVQsVUFBVTtnQkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO2dCQUE2STtnQkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO2dCQUFnUjtnQkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUFtQ2UsT0FBTzt3QkFBRUUsTUFBTTtvQkFBTztnQkFBRTtnQkFBSXZGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUF1Q2UsT0FBTzt3QkFBRUUsTUFBTTtvQkFBTztnQkFBRTtnQkFBSXZGLHNEQUFHQSxDQUFDLFVBQVU7b0JBQUVzRyxJQUFJO29CQUFLQyxJQUFJO29CQUFNQyxHQUFHO2dCQUFJO2dCQUFJeEcsc0RBQUdBLENBQUMsVUFBVTtvQkFBRXNHLElBQUk7b0JBQU1DLElBQUk7b0JBQUtDLEdBQUc7Z0JBQUk7Z0JBQUl4RyxzREFBR0EsQ0FBQyxVQUFVO29CQUFFc0csSUFBSTtvQkFBUUMsSUFBSTtvQkFBS0MsR0FBRztnQkFBSTtnQkFBSXhHLHNEQUFHQSxDQUFDLFVBQVU7b0JBQUVzRyxJQUFJO29CQUFNQyxJQUFJO29CQUFLQyxHQUFHO2dCQUFJO2dCQUFJeEcsc0RBQUdBLENBQUMsVUFBVTtvQkFBRXNHLElBQUk7b0JBQU1DLElBQUk7b0JBQU1DLEdBQUc7Z0JBQUk7YUFBRztRQUFDO0lBQUk7SUFDbDNCQyxJQUFLekcsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRUMsT0FBTztRQUE4QkMsU0FBUztRQUFPQyxPQUFPO1FBQU1DLFFBQVE7SUFBSyxHQUFHO1FBQUVDLFVBQVVuRix1REFBSUEsQ0FBQyxLQUFLcUIsT0FBT3lELE1BQU0sQ0FBQztZQUFFTSxPQUFPO2dCQUNuSkUsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkMsa0JBQWtCO2dCQUNsQkMsaUJBQWlCO2dCQUNqQkMsZUFBZTtZQUNuQjtRQUFFLEdBQUc7WUFBRVosVUFBVTtnQkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUF5QmUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBUUcsUUFBUTt3QkFBV0csZ0JBQWdCO29CQUFRO2dCQUFFO2dCQUFJN0Ysc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQWlCZSxPQUFPO3dCQUFFRSxNQUFNO3dCQUFRRyxRQUFRO3dCQUFXRyxnQkFBZ0I7b0JBQVE7Z0JBQUU7Z0JBQUk3RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBNkhlLE9BQU87d0JBQ3ZYRSxNQUFNO3dCQUNORyxRQUFRO3dCQUNSRSxlQUFlO3dCQUNmQyxnQkFBZ0I7b0JBQ3BCO2dCQUFFO2dCQUFJN0Ysc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQTZMZSxPQUFPO3dCQUFFRSxNQUFNO3dCQUFXRyxRQUFRO29CQUFVO2dCQUFFO2dCQUFJMUYsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQW1DZSxPQUFPO3dCQUFFRSxNQUFNO3dCQUFRRyxRQUFRO29CQUFVO2dCQUFFO2dCQUFJMUYsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQTJDZSxPQUFPO3dCQUFFRSxNQUFNO3dCQUFRRyxRQUFRO29CQUFVO2dCQUFFO2dCQUFJMUYsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQW1DZSxPQUFPO3dCQUFFRSxNQUFNO3dCQUFRRyxRQUFRO29CQUFVO2dCQUFFO2FBQUc7UUFBQztJQUFJO0lBQzNrQmdCLElBQUsxRyxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFQyxPQUFPO1FBQThCQyxTQUFTO1FBQU9DLE9BQU87UUFBTUMsUUFBUTtJQUFLLEdBQUc7UUFBRUMsVUFBVXBGLHNEQUFHQSxDQUFDLFFBQVE7WUFBRXNFLEdBQUc7WUFBbVRlLE9BQU87Z0JBQzdiQyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNOQyxhQUFhO2dCQUNiQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxlQUFlO2dCQUNmQyxnQkFBZ0I7Z0JBQ2hCQyxrQkFBa0I7Z0JBQ2xCQyxpQkFBaUI7Z0JBQ2pCQyxlQUFlO1lBQ25CO1FBQUU7SUFBRztJQUNiVyxJQUFLM0csc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRUMsT0FBTztRQUE4QkMsU0FBUztRQUFPQyxPQUFPO1FBQU1DLFFBQVE7SUFBSyxHQUFHO1FBQUVDLFVBQVVuRix1REFBSUEsQ0FBQyxLQUFLcUIsT0FBT3lELE1BQU0sQ0FBQztZQUFFTSxPQUFPO2dCQUNuSkMsU0FBUztnQkFDVEMsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkMsa0JBQWtCO2dCQUNsQkMsaUJBQWlCO2dCQUNqQkMsZUFBZTtZQUNuQjtRQUFFLEdBQUc7WUFBRVosVUFBVTtnQkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUEyQ2UsT0FBTzt3QkFBRU8sZUFBZTtvQkFBTztnQkFBRTtnQkFBSTVGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUF3RGUsT0FBTzt3QkFBRU8sZUFBZTtvQkFBTztnQkFBRTtnQkFBSTVGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUE4Q2UsT0FBTzt3QkFBRU8sZUFBZTtvQkFBTztnQkFBRTtnQkFBSTVGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUF3RGUsT0FBTzt3QkFBRU8sZUFBZTt3QkFBUUMsZ0JBQWdCO29CQUFRO2dCQUFFO2dCQUFJN0Ysc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQW9EZSxPQUFPO3dCQUFFTyxlQUFlO29CQUFPO2dCQUFFO2dCQUFJNUYsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQXdHZSxPQUFPO3dCQUFFTyxlQUFlO29CQUFPO2dCQUFFO2dCQUFJNUYsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQWlDZSxPQUFPO3dCQUNqd0JFLE1BQU07d0JBQ05HLFFBQVE7d0JBQ1JDLGFBQWE7d0JBQ2JFLGdCQUFnQjtvQkFDcEI7Z0JBQUU7Z0JBQUk3RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBdUJlLE9BQU87d0JBQ2pERSxNQUFNO3dCQUNORyxRQUFRO3dCQUNSQyxhQUFhO3dCQUNiRSxnQkFBZ0I7b0JBQ3BCO2dCQUFFO2dCQUFJN0Ysc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQXVCZSxPQUFPO3dCQUNqREUsTUFBTTt3QkFDTkcsUUFBUTt3QkFDUkMsYUFBYTt3QkFDYkUsZ0JBQWdCO29CQUNwQjtnQkFBRTtnQkFBSTdGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUF1QmUsT0FBTzt3QkFDakRFLE1BQU07d0JBQ05HLFFBQVE7d0JBQ1JDLGFBQWE7d0JBQ2JFLGdCQUFnQjtvQkFDcEI7Z0JBQUU7Z0JBQUk3RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBbUJlLE9BQU87d0JBQzdDRSxNQUFNO3dCQUNORyxRQUFRO3dCQUNSQyxhQUFhO3dCQUNiRSxnQkFBZ0I7b0JBQ3BCO2dCQUFFO2FBQUc7UUFBQztJQUFJO0lBQzFCZSxJQUFLNUcsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRUMsT0FBTztRQUE4QkMsU0FBUztRQUFPQyxPQUFPO1FBQU1DLFFBQVE7SUFBSyxHQUFHO1FBQUVDLFVBQVVuRix1REFBSUEsQ0FBQyxLQUFLcUIsT0FBT3lELE1BQU0sQ0FBQztZQUFFTSxPQUFPO2dCQUNuSkMsU0FBUztnQkFDVEMsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkMsa0JBQWtCO2dCQUNsQkMsaUJBQWlCO2dCQUNqQkMsZUFBZTtZQUNuQjtRQUFFLEdBQUc7WUFBRVosVUFBVTtnQkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUFpRWUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBV0csUUFBUTtvQkFBVTtnQkFBRTtnQkFBSTFGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUFxVGUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBV0csUUFBUTtvQkFBVTtnQkFBRTtnQkFBSTFGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUFrRWUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBV0csUUFBUTtvQkFBVTtnQkFBRTtnQkFBSTFGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUFpRTZCLFdBQVc7b0JBQTZDZCxPQUFPO3dCQUFFRSxNQUFNO3dCQUFXRyxRQUFRO29CQUFVO2dCQUFFO2dCQUFJMUYsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQXVPZSxPQUFPO3dCQUFFRSxNQUFNO3dCQUFXRyxRQUFRO29CQUFPO2dCQUFFO2FBQUc7UUFBQztJQUFJO0lBQ2xvQ21CLElBQUs3RyxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFQyxPQUFPO1FBQThCQyxTQUFTO1FBQU9DLE9BQU87UUFBTUMsUUFBUTtJQUFLLEdBQUc7UUFBRUMsVUFBVW5GLHVEQUFJQSxDQUFDLEtBQUtxQixPQUFPeUQsTUFBTSxDQUFDO1lBQUVNLE9BQU87Z0JBQ25KQyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNORSxVQUFVO2dCQUNWRCxhQUFhO2dCQUNiRSxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxlQUFlO2dCQUNmQyxnQkFBZ0I7Z0JBQ2hCQyxrQkFBa0I7Z0JBQ2xCQyxpQkFBaUI7Z0JBQ2pCQyxlQUFlO1lBQ25CO1FBQUUsR0FBRztZQUFFWixVQUFVO2dCQUFDbkYsdURBQUlBLENBQUMsS0FBS3FCLE9BQU95RCxNQUFNLENBQUM7b0JBQUVNLE9BQU87d0JBQUVFLE1BQU07d0JBQVdHLFFBQVE7d0JBQVdFLGVBQWU7b0JBQU87Z0JBQUUsR0FBRztvQkFBRVIsVUFBVTt3QkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUFrUTt3QkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUFvTTt3QkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUF1RDtxQkFBRztnQkFBQztnQkFBS3RFLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUErRWUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBUUcsUUFBUTt3QkFBV0csZ0JBQWdCO29CQUFRO2dCQUFFO2FBQUc7UUFBQztJQUFJO0lBQ3QzQmlCLElBQUs5RyxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFQyxPQUFPO1FBQThCQyxTQUFTO1FBQU9DLE9BQU87UUFBTUMsUUFBUTtJQUFLLEdBQUc7UUFBRUMsVUFBVW5GLHVEQUFJQSxDQUFDLEtBQUtxQixPQUFPeUQsTUFBTSxDQUFDO1lBQUVNLE9BQU87Z0JBQ25KRSxNQUFNO2dCQUNORyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiQyxlQUFlO2dCQUNmQyxnQkFBZ0I7WUFDcEI7UUFBRSxHQUFHO1lBQUVULFVBQVU7Z0JBQUNwRixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBOEllLE9BQU87d0JBQUVPLGVBQWU7d0JBQVFMLE1BQU07b0JBQVU7Z0JBQUU7Z0JBQUl2RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztnQkFBMk47Z0JBQUl0RSxzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztnQkFBa0M7Z0JBQUl0RSxzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztnQkFBOEI7Z0JBQUl0RSxzREFBR0EsQ0FBQyxVQUFVO29CQUFFc0csSUFBSTtvQkFBS0MsSUFBSTtvQkFBTUMsR0FBRztnQkFBSTtnQkFBSXhHLHNEQUFHQSxDQUFDLFVBQVU7b0JBQUVzRyxJQUFJO29CQUFNQyxJQUFJO29CQUFLQyxHQUFHO2dCQUFJO2dCQUFJeEcsc0RBQUdBLENBQUMsVUFBVTtvQkFBRXNHLElBQUk7b0JBQVFDLElBQUk7b0JBQUtDLEdBQUc7Z0JBQUk7Z0JBQUl4RyxzREFBR0EsQ0FBQyxVQUFVO29CQUFFc0csSUFBSTtvQkFBTUMsSUFBSTtvQkFBS0MsR0FBRztnQkFBSTtnQkFBSXhHLHNEQUFHQSxDQUFDLFVBQVU7b0JBQUVzRyxJQUFJO29CQUFNQyxJQUFJO29CQUFNQyxHQUFHO2dCQUFJO2dCQUFJeEcsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXNFLEdBQUc7b0JBQW1DZSxPQUFPO3dCQUFFRSxNQUFNO3dCQUFRRyxRQUFRO3dCQUFXRSxlQUFlO29CQUFPO2dCQUFFO2dCQUFJM0YsdURBQUlBLENBQUMsS0FBS3FCLE9BQU95RCxNQUFNLENBQUM7b0JBQUVNLE9BQU87d0JBQUVFLE1BQU07d0JBQVFHLFFBQVE7b0JBQVU7Z0JBQUUsR0FBRztvQkFBRU4sVUFBVTt3QkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUE4Qjt3QkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUEwQjt3QkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUFzQzt3QkFBSXRFLHNEQUFHQSxDQUFDLFFBQVE7NEJBQUVzRSxHQUFHO3dCQUFzQztxQkFBRztnQkFBQzthQUFJO1FBQUM7SUFBSTtJQUNsdUN5QyxJQUFLL0csc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRUMsT0FBTztRQUE4QkMsU0FBUztRQUFPQyxPQUFPO1FBQU1DLFFBQVE7SUFBSyxHQUFHO1FBQUVDLFVBQVVuRix1REFBSUEsQ0FBQyxLQUFLcUIsT0FBT3lELE1BQU0sQ0FBQztZQUFFTSxPQUFPO2dCQUNuSkUsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkMsa0JBQWtCO2dCQUNsQkMsaUJBQWlCO2dCQUNqQkMsZUFBZTtZQUNuQjtRQUFFLEdBQUc7WUFBRVosVUFBVTtnQkFBQ3BGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUF5QmUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBUUcsUUFBUTt3QkFBV0csZ0JBQWdCO29CQUFRO29CQUFHbUIsSUFBSTtnQkFBVztnQkFBSWhILHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUE2SGUsT0FBTzt3QkFDN1JFLE1BQU07d0JBQ05DLGFBQWE7d0JBQ2JJLGVBQWU7d0JBQ2ZDLGdCQUFnQjtvQkFDcEI7Z0JBQUU7Z0JBQUk3RixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBNkxlLE9BQU87d0JBQUVFLE1BQU07d0JBQVdHLFFBQVE7b0JBQVU7Z0JBQUU7Z0JBQUkxRixzREFBR0EsQ0FBQyxRQUFRO29CQUFFc0UsR0FBRztvQkFBaUJlLE9BQU87d0JBQUVFLE1BQU07d0JBQVFHLFFBQVE7d0JBQVdHLGdCQUFnQjtvQkFBUTtnQkFBRTtnQkFBSTdGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUF1SmUsT0FBTzt3QkFBRUUsTUFBTTt3QkFBUUcsUUFBUTtvQkFBVTtnQkFBRTtnQkFBSTFGLHNEQUFHQSxDQUFDLFFBQVE7b0JBQUVzRSxHQUFHO29CQUEyR2UsT0FBTzt3QkFBRUUsTUFBTTt3QkFBUUcsUUFBUTtvQkFBVTtnQkFBRTthQUFHO1FBQUM7SUFBSTtBQUMxd0I7QUFFQTs7Q0FFQyxHQUNELFNBQVN1QixrQkFBa0JDLGdCQUFnQixFQUFFQyxVQUFVLEVBQUVDLE1BQU07SUFDM0QsTUFBTUMsY0FBY0YsYUFBYTtJQUNqQyxNQUFNRyxVQUFVSixxQkFBcUIsVUFBVWhELHNCQUFzQlE7SUFDckUsTUFBTTZDLE9BQU9MLHFCQUFxQixVQUFVdkMsYUFBYUM7SUFDekQsTUFBTTRDLElBQUlGLE9BQU8sQ0FBQ0YsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHQyxjQUFjQSxjQUFjO0lBQzNELE1BQU1JLElBQUlGLElBQUksQ0FBQ0csU0FBU04sTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBR0MsY0FBY0EsY0FBYztJQUMxRSxPQUFPO1FBQUVHO1FBQUdDO0lBQUU7QUFDbEI7QUFDQTs7Q0FFQyxHQUNELFNBQVNFLHFCQUFxQkMsV0FBVztJQUNyQyxJQUFJQyxjQUFjO0lBQ2xCdkcsT0FBT3dHLElBQUksQ0FBQzdGLHVCQUF1QjhGLE9BQU8sQ0FBQyxDQUFDWDtRQUN4QyxJQUFJUSxXQUFXLENBQUNSLE9BQU8sS0FBS25GLHFCQUFxQixDQUFDbUYsT0FBTyxFQUNyRFMsY0FBYztJQUN0QjtJQUNBdkcsT0FBT3dHLElBQUksQ0FBQ0YsYUFBYUcsT0FBTyxDQUFDLENBQUNYO1FBQzlCLElBQUluRixxQkFBcUIsQ0FBQ21GLE9BQU8sS0FBS1EsV0FBVyxDQUFDUixPQUFPLEVBQ3JEUyxjQUFjO0lBQ3RCO0lBQ0EsT0FBT0E7QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU0csdUJBQXVCQyxlQUFlLEVBQUVMLFdBQVc7SUFDeEQsTUFBTU0sYUFBYTtRQUNmQyxTQUFTLENBQUM7UUFDVkMsT0FBTyxDQUFDO0lBQ1o7SUFDQSx1QkFBdUI7SUFDdkI5RyxPQUFPd0csSUFBSSxDQUFDRyxpQkFBaUJGLE9BQU8sQ0FBQyxDQUFDWDtRQUNsQyxJQUFJUSxXQUFXLENBQUNSLE9BQU8sS0FBS2EsZUFBZSxDQUFDYixPQUFPLEVBQy9DYyxXQUFXQyxPQUFPLENBQUNmLE9BQU8sR0FBR2EsZUFBZSxDQUFDYixPQUFPO0lBQzVEO0lBQ0EsaUJBQWlCO0lBQ2pCOUYsT0FBT3dHLElBQUksQ0FBQ0YsYUFBYUcsT0FBTyxDQUFDLENBQUNYO1FBQzlCLElBQUlhLGVBQWUsQ0FBQ2IsT0FBTyxLQUFLUSxXQUFXLENBQUNSLE9BQU8sRUFDL0NjLFdBQVdFLEtBQUssQ0FBQ2hCLE9BQU8sR0FBR1EsV0FBVyxDQUFDUixPQUFPO0lBQ3REO0lBQ0EsT0FBT2M7QUFDWDtBQUNBOztDQUVDLEdBQ0QsU0FBU0csd0JBQXdCQyxRQUFRO0lBQ3JDLElBQUlBLGFBQWEsU0FBUztRQUN0QixPQUFPckc7SUFDWDtJQUNBLElBQUksT0FBT3FHLGFBQWEsVUFBVTtRQUM5Qiw0Q0FBNEM7UUFDNUMsT0FBT0MsU0FBU0Q7SUFDcEI7SUFDQSxPQUFPQTtBQUNYO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQyxTQUFTQyxHQUFHO0lBQ2pCLElBQUksQ0FBQ0MsV0FBV0QsTUFDWixPQUFPLENBQUM7SUFDWixtR0FBbUc7SUFDbkdBLE1BQU1BLElBQUlFLE9BQU8sQ0FBQyxRQUFRO0lBQzFCLE1BQU1uQixPQUFPaUIsSUFBSXhHLEtBQUssQ0FBQztJQUN2QixNQUFNc0csV0FBVyxDQUFDO0lBQ2xCLElBQUlLLGFBQWE7SUFDakIsSUFBSyxJQUFJL0csSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEIsTUFBTWdILE1BQU1yQixJQUFJLENBQUMzRixFQUFFLENBQUNJLEtBQUssQ0FBQztRQUMxQixJQUFJNkcsU0FBUztRQUNiLGlEQUFpRDtRQUNqRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsSUFBSS9HLE1BQU0sRUFBRWlILElBQUs7WUFDakMseUJBQXlCO1lBQ3pCLElBQUlGLEdBQUcsQ0FBQ0UsRUFBRSxDQUFDQyxNQUFNLENBQUMsYUFBYSxDQUFDLEdBQUc7Z0JBQy9CLE1BQU1DLGtCQUFrQnRCLFNBQVNrQixHQUFHLENBQUNFLEVBQUUsRUFBRTtnQkFDekNELFNBQVNBLFNBQVNHO1lBQ3RCLE9BQ0s7Z0JBQ0QsUUFBUTtnQkFDUixNQUFNNUIsU0FBU3JGLE9BQU8sQ0FBQzhHLE9BQU8sR0FBR0Y7Z0JBQ2pDTCxRQUFRLENBQUNsQixPQUFPLEdBQUc2QixlQUFlTCxHQUFHLENBQUNFLEVBQUU7Z0JBQ3hDRCxTQUFTQSxTQUFTO1lBQ3RCO1FBQ0o7UUFDQUYsYUFBYUEsYUFBYTtJQUM5QjtJQUNBLE9BQU9MO0FBQ1g7QUFDQTs7Q0FFQyxHQUNELFNBQVNHLFdBQVdELEdBQUc7SUFDbkIsbUdBQW1HO0lBQ25HQSxNQUFNQSxJQUFJRSxPQUFPLENBQUMsUUFBUTtJQUMxQiw2Q0FBNkM7SUFDN0NGLE1BQU1VLHNCQUFzQlY7SUFDNUIsZ0RBQWdEO0lBQ2hELE1BQU1XLFNBQVNYLElBQUl4RyxLQUFLLENBQUM7SUFDekIsSUFBSW1ILE9BQU90SCxNQUFNLEtBQUssR0FDbEIsT0FBTztJQUNYLHFCQUFxQjtJQUNyQixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQ3hCLElBQUl1SCxNQUFNLENBQUN2SCxFQUFFLENBQUNDLE1BQU0sS0FBSyxLQUFLc0gsTUFBTSxDQUFDdkgsRUFBRSxDQUFDbUgsTUFBTSxDQUFDLHdCQUF3QixDQUFDLEdBQUc7WUFDdkUsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Q0FFQyxHQUNELFNBQVNHLHNCQUFzQlYsR0FBRztJQUM5QixPQUFPQSxJQUNGRSxPQUFPLENBQUMsTUFBTSxZQUNkQSxPQUFPLENBQUMsTUFBTSxXQUNkQSxPQUFPLENBQUMsTUFBTSxVQUNkQSxPQUFPLENBQUMsTUFBTSxTQUNkQSxPQUFPLENBQUMsTUFBTSxRQUNkQSxPQUFPLENBQUMsTUFBTSxPQUNkQSxPQUFPLENBQUMsTUFBTTtBQUN2QjtBQUNBOztDQUVDLEdBQ0QsU0FBU08sZUFBZUcsS0FBSztJQUN6QixjQUFjO0lBQ2QsSUFBSUEsTUFBTUMsV0FBVyxPQUFPRCxPQUFPO1FBQy9CLE9BQVEsTUFBTUEsTUFBTUUsV0FBVztJQUNuQztJQUNBLGNBQWM7SUFDZCxPQUFRLE1BQU1GLE1BQU1FLFdBQVc7QUFDbkM7QUFFQSxNQUFNQyxZQUFZLENBQUNDLGNBQWNDLG1CQUFtQixJQUFJLEVBQUVDLGdCQUFnQkM7SUFDdEUsZ0VBQWdFO0lBQ2hFLE1BQU0sQ0FBQ0MsaUJBQWlCQyxnQkFBZ0IsR0FBRzFKLCtDQUFRQSxDQUFDLEVBQUU7SUFDdEQsK0NBQStDO0lBQy9DLE1BQU0sQ0FBQzJKLFFBQVFDLFVBQVUsR0FBRzVKLCtDQUFRQSxDQUFDLEVBQUU7SUFDdkMscURBQXFEO0lBQ3JELE1BQU0sQ0FBQzZKLFVBQVVDLFlBQVksR0FBRzlKLCtDQUFRQTtJQUN4QywrQ0FBK0M7SUFDL0NDLGdEQUFTQSxDQUFDO1FBQ04sSUFBSThKLE1BQU1DLE9BQU8sQ0FBQ1gsZUFBZTtZQUM3QixtREFBbUQ7WUFDbkRZO1lBQ0FQLGdCQUNBLDREQUE0RDtZQUM1REwsaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhYSxNQUFNLENBQUMsQ0FBQ0MsUUFBVUEsS0FBSyxDQUFDLEVBQUUsS0FBS0EsS0FBSyxDQUFDLEVBQUU7UUFDcEg7SUFDSixHQUFHO1FBQUNkO0tBQWE7SUFDakIsc0RBQXNEO0lBQ3REcEosZ0RBQVNBLENBQUM7UUFDTnNKLG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZUk7SUFDbkYsR0FBRztRQUFDQTtLQUFPO0lBQ1gsNENBQTRDO0lBQzVDLFNBQVNNO1FBQ0xMLFVBQVUsRUFBRTtRQUNaRSxZQUFZTTtJQUNoQjtJQUNBLE1BQU1DLGVBQWUsQ0FBQ0MsWUFBWUM7UUFDOUIsSUFBSSxDQUFDakIsa0JBQ0Q7UUFDSlEsWUFBWTtZQUFDUTtZQUFZQztZQUFVZjtTQUFpQjtJQUN4RDtJQUNBLE1BQU1nQixpQkFBaUI7V0FBSWI7V0FBV0Y7S0FBZ0I7SUFDdEQsTUFBTWdCLGlCQUFpQixDQUFDSCxZQUFZQztRQUNoQyxJQUFJRCxlQUFlQyxZQUFZLENBQUNqQixrQkFDNUI7UUFDSixJQUFJb0I7UUFDSixNQUFNYixXQUFXO1lBQUNTO1lBQVlDO1lBQVVmO1NBQWlCO1FBQ3pELE1BQU1tQixtQkFBbUJILGVBQWVJLEtBQUssQ0FBQyxDQUFDLENBQUNDLFdBQVdDLFFBQVE7WUFDL0QsT0FBTyxDQUFFRCxDQUFBQSxjQUFjUCxjQUFjUSxZQUFZUCxRQUFPO1FBQzVEO1FBQ0EsbURBQW1EO1FBQ25ELElBQUlJLGtCQUFrQjtZQUNsQkQsYUFBYTttQkFBSWY7Z0JBQVFFO2FBQVM7UUFDdEMsT0FFSztZQUNEYSxhQUFhZixPQUFPTyxNQUFNLENBQUMsQ0FBQyxDQUFDVyxXQUFXQyxRQUFRO2dCQUM1QyxPQUFPLENBQUVELENBQUFBLGNBQWNQLGNBQWNRLFlBQVlQLFFBQU87WUFDNUQ7UUFDSjtRQUNBVCxZQUFZTTtRQUNaUixVQUFVYztJQUNkO0lBQ0EsT0FBTztRQUNIZixRQUFRYTtRQUNSWDtRQUNBSTtRQUNBSTtRQUNBVDtRQUNBYTtJQUNKO0FBQ0o7QUFFQSxNQUFNTSxrQ0FBb0I3SyxvREFBYUEsQ0FBQyxDQUFDO0FBQ3pDLE1BQU04SyxnQkFBZ0IsSUFBTTFLLGlEQUFVQSxDQUFDeUs7QUFDdkMsTUFBTUUsbUNBQXFCOUssaURBQVVBLENBQUMsQ0FBQyxFQUFFK0ssd0JBQXdCLElBQUksRUFBRUMsb0JBQW9CLEdBQUcsRUFBRTdCLG1CQUFtQixJQUFJLEVBQUU4QixxQkFBcUIsSUFBSSxFQUFFQyxxQkFBcUIsS0FBSyxFQUFFQyxxQkFBcUIsS0FBSyxFQUFFdkUsbUJBQW1CLE9BQU8sRUFBRUMsVUFBVSxFQUFFL0IsUUFBUSxFQUFFc0csNEJBQTRCLElBQUksRUFBRWxDLFlBQVksRUFBRUcsbUJBQW1CLGdCQUFnQixFQUFFZ0MsZ0JBQWdCLEVBQUVDLG1CQUFtQixFQUFFQyx3QkFBd0I7SUFBRUMsaUJBQWlCO0FBQVUsQ0FBQyxFQUFFQyx3QkFBd0I7SUFDdGNDLFdBQVc7QUFDZixDQUFDLEVBQUVDLHlCQUF5QjtJQUFFSCxpQkFBaUI7QUFBVSxDQUFDLEVBQUVJLFlBQVksRUFBRUMsK0JBQStCO0lBQUVMLGlCQUFpQjtBQUFVLENBQUMsRUFBRU0sZ0NBQWdDO0lBQUVOLGlCQUFpQjtBQUFVLENBQUMsRUFBRU8sZUFBZSxLQUFLLEVBQUVDLGtCQUFrQixFQUFFQyxxQkFBcUIsVUFBVSxFQUFFdkYsS0FBSyxDQUFDLEVBQUV3RixtQkFBbUIsSUFBTSxJQUFJLEVBQUVDLG9CQUFvQixLQUFRLENBQUMsRUFBRS9DLGlCQUFpQixLQUFRLENBQUMsRUFBRWdELG1CQUFtQixLQUFRLENBQUMsRUFBRUMsbUJBQW1CLEtBQVEsQ0FBQyxFQUFFQyxvQkFBb0IsS0FBUSxDQUFDLEVBQUVDLGVBQWUsS0FBUSxDQUFDLEVBQUVDLG1CQUFtQixLQUFRLENBQUMsRUFBRUMsaUJBQWlCLEtBQVEsQ0FBQyxFQUFFQyxjQUFjLElBQU0sSUFBSSxFQUFFQyxzQkFBc0IsS0FBUSxDQUFDLEVBQUVDLG1CQUFtQixDQUFDQyxjQUFjQyxjQUFjaEU7SUFDNW9CLE9BQVEsQ0FBQyxVQUFXLFFBQ2hCK0QsWUFBWSxDQUFDLEVBQUUsS0FBSyxPQUNwQkMsWUFBWSxDQUFDLEVBQUUsS0FBSyxPQUNuQmhFLFVBQVUsUUFDUCtELFlBQVksQ0FBQyxFQUFFLEtBQUssT0FDcEJDLFlBQVksQ0FBQyxFQUFFLEtBQUssR0FBRyxLQUMzQkMsS0FBS0MsR0FBRyxDQUFDSCxhQUFhSSxVQUFVLENBQUMsS0FBS0gsYUFBYUcsVUFBVSxDQUFDLE9BQU87QUFDN0UsQ0FBQyxFQUFFQyx5QkFBeUIsSUFBTSxJQUFJLEVBQUVDLG1CQUFtQixJQUFNLElBQUksRUFBRUMsZ0JBQWdCLEtBQVEsQ0FBQyxFQUFFQyxxQkFBcUIsS0FBUSxDQUFDLEVBQUVyRixXQUFXLE9BQU8sRUFBRXNGLHlCQUF5QixTQUFTLEVBQUVDLG9CQUFvQixJQUFJLEVBQUVDLG9CQUFvQixJQUFJLEVBQUVDLHNCQUFzQixLQUFLLEVBQUVDLGVBQWUsSUFBSSxFQUFHLEVBQUVDO0lBQy9SLHlDQUF5QztJQUN6QyxNQUFNLENBQUNoRyxpQkFBaUJpRyxtQkFBbUIsR0FBRy9OLCtDQUFRQSxDQUFDa0ksd0JBQXdCQztJQUMvRSxnRUFBZ0U7SUFDaEUsTUFBTSxDQUFDNkYscUJBQXFCQyx1QkFBdUIsR0FBR2pPLCtDQUFRQSxDQUFDO1FBQUVnSSxTQUFTLENBQUM7UUFBR0MsT0FBTyxDQUFDO0lBQUU7SUFDeEYsdURBQXVEO0lBQ3ZELE1BQU0sQ0FBQ2lHLGlCQUFpQkMsbUJBQW1CLEdBQUduTywrQ0FBUUEsQ0FBQ29LO0lBQ3ZELCtCQUErQjtJQUMvQixNQUFNLENBQUNnRSxtQkFBbUJDLHFCQUFxQixHQUFHck8sK0NBQVFBLENBQUM0Tix1QkFBdUIsQ0FBQ3RDO0lBQ25GLDJDQUEyQztJQUMzQyxNQUFNLENBQUNnRCxtQkFBbUJDLHFCQUFxQixHQUFHdk8sK0NBQVFBLENBQUM7SUFDM0QsTUFBTSxDQUFDd08saUJBQWlCQyxtQkFBbUIsR0FBR3pPLCtDQUFRQSxDQUFDME47SUFDdkQsbUJBQW1CO0lBQ25CLE1BQU0sQ0FBQ2dCLFVBQVVDLFlBQVksR0FBRzNPLCtDQUFRQSxDQUFDLEVBQUU7SUFDM0MsOERBQThEO0lBQzlELE1BQU00TyxjQUFjeE8sNkNBQU1BLENBQUNzTztJQUMzQixrQ0FBa0M7SUFDbEMsTUFBTSxDQUFDRyx1QkFBdUJDLHlCQUF5QixHQUFHOU8sK0NBQVFBO0lBQ2xFLHVCQUF1QjtJQUN2QixNQUFNLENBQUMrTyxhQUFhQyxlQUFlLEdBQUdoUCwrQ0FBUUEsQ0FBQ21CLE9BQU95RCxNQUFNLENBQUN6RCxPQUFPeUQsTUFBTSxDQUFDLENBQUMsR0FBR0YsZ0JBQWdCcUg7SUFDL0YsaURBQWlEO0lBQ2pELE1BQU0sQ0FBQ2tELGVBQWVDLGlCQUFpQixHQUFHbFAsK0NBQVFBLENBQUM7SUFDbkQsbUVBQW1FO0lBQ25FLE1BQU0sQ0FBQ21QLGlCQUFpQkMsbUJBQW1CLEdBQUdwUCwrQ0FBUUE7SUFDdEQsa0RBQWtEO0lBQ2xELE1BQU0sQ0FBQ3FQLHVCQUF1QkMseUJBQXlCLEdBQUd0UCwrQ0FBUUEsQ0FBQztJQUNuRSx3REFBd0Q7SUFDeEQsTUFBTSxDQUFDdVAsdUJBQXVCQyx5QkFBeUIsR0FBR3hQLCtDQUFRQSxDQUFDO0lBQ25FLG9FQUFvRTtJQUNwRUssMERBQW1CQSxDQUFDeU4sS0FBSyxJQUFPO1lBQzVCMkIsZUFBY0MsdUJBQXVCLElBQUk7Z0JBQ3JDRCxjQUFjQztZQUNsQjtRQUNKO0lBQ0EsOEJBQThCO0lBQzlCelAsZ0RBQVNBLENBQUM7UUFDTitPLGVBQWU3TixPQUFPeUQsTUFBTSxDQUFDekQsT0FBT3lELE1BQU0sQ0FBQyxDQUFDLEdBQUdGLGdCQUFnQnFIO0lBQ25FLEdBQUc7UUFBQ0E7S0FBYTtJQUNqQix5QkFBeUI7SUFDekI5TCxnREFBU0EsQ0FBQztRQUNOb08scUJBQXFCVDtRQUNyQmEsbUJBQW1CZjtJQUN2QixHQUFHO1FBQUNBO1FBQW1CRTtLQUFvQjtJQUMzQyxrQ0FBa0M7SUFDbEMzTixnREFBU0EsQ0FBQztRQUNOLElBQUkwUCxJQUFJQyxJQUFJQztRQUNaLG1DQUFtQztRQUNuQ0M7UUFDQSxNQUFNckksY0FBY1Msd0JBQXdCQztRQUM1QyxNQUFNNEgsY0FBY2xJLHVCQUF1QkMsaUJBQWlCTDtRQUM1RCxNQUFNdUksaUJBQWlCLENBQUMsQ0FBQ0wsS0FBS3hPLE9BQU93RyxJQUFJLENBQUNvSSxZQUFZOUgsS0FBSyxPQUFPLFFBQVEwSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqTyxNQUFNLEtBQUssSUFDM0csQ0FBQ21PLEtBQUssQ0FBQ0QsS0FBS3pPLE9BQU84TyxPQUFPLENBQUNGLFlBQVk5SCxLQUFLLE9BQU8sUUFBUTJILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUN4SXpGO1FBQ04scURBQXFEO1FBQ3JELG1EQUFtRDtRQUNuRCxJQUFJaUYsdUJBQXVCO1lBQ3ZCdEIsbUJBQW1CdEc7WUFDbkI2SCx5QkFBeUI7WUFDekJqRSxzQkFBc0I2RSxlQUFlRjtZQUNyQyxJQUFJYixpQkFBaUI7Z0JBQ2pCZ0IsYUFBYWhCO1lBQ2pCO1FBQ0osT0FDSztZQUNELG9DQUFvQztZQUNwQyxJQUFJRixlQUFlO2dCQUNmbEIsbUJBQW1CdEc7Z0JBQ25CNkgseUJBQXlCO2dCQUN6QmpFLHNCQUFzQjZFLGVBQWVGO1lBQ3pDLE9BQ0s7Z0JBQ0QsNENBQTRDO2dCQUM1QywyREFBMkQ7Z0JBQzNELDZLQUE2SztnQkFDN0ssSUFBSXhJLHFCQUFxQkMsZ0JBQ3JCeUcsb0JBQW9COUQsV0FBVztvQkFDL0IrRCxtQkFBbUI2QjtnQkFDdkIsT0FDSyxJQUFJLENBQUN4SSxxQkFBcUJDLGNBQWM7b0JBQ3pDLHVHQUF1RztvQkFDdkcwRyxtQkFBbUI7Z0JBQ3ZCLE9BQ0s7b0JBQ0RBLG1CQUFtQi9EO2dCQUN2QjtnQkFDQTZELHVCQUF1QjhCO2dCQUN2Qix3QkFBd0I7Z0JBQ3hCVCx5QkFBeUI7Z0JBQ3pCLE1BQU1jLGFBQWFDLFdBQVc7b0JBQzFCdEMsbUJBQW1CdEc7b0JBQ25CNkgseUJBQXlCO29CQUN6QmpFLHNCQUFzQjZFLGVBQWVGO2dCQUN6QyxHQUFHN0U7Z0JBQ0hpRSxtQkFBbUJnQjtZQUN2QjtRQUNKO1FBQ0Esd0VBQXdFO1FBQ3hFbEIsaUJBQWlCO1FBQ2pCLHFDQUFxQztRQUNyQzVDLGtCQUFrQjdFO1FBQ2xCLGVBQWU7UUFDZndDO1FBQ0EsMkJBQTJCO1FBQzNCLE9BQU87WUFDSGtHLGFBQWFoQjtRQUNqQjtJQUNKLEdBQUc7UUFBQ2hIO0tBQVM7SUFDYixNQUFNLEVBQUV3QixNQUFNLEVBQUVFLFFBQVEsRUFBRUksV0FBVyxFQUFFSSxZQUFZLEVBQUVJLGNBQWMsRUFBRSxHQUFHckIsVUFBVUMsY0FBY0Msa0JBQWtCQyxnQkFBZ0JDO0lBQ2xJLDhCQUE4QjtJQUM5QixTQUFTOEcsa0JBQWtCQyxRQUFRLEVBQUVDLFFBQVEsRUFBRXZILEtBQUssRUFBRXdILHFCQUFxQjtRQUN2RSwwQ0FBMEM7UUFDMUMsSUFBSUYsYUFBYUMsVUFBVTtZQUN2QjtRQUNKO1FBQ0F2RztRQUNBLGtKQUFrSjtRQUNsSiw4TEFBOEw7UUFDOUwsSUFBSSxzQkFBdUJvRix5QkFDdEJoRSxzQkFDSTZDLENBQUFBLG9CQUFvQmpGLEtBQUssQ0FBQyxFQUFFLElBQ3pCMkYsWUFBWThCLE9BQU8sQ0FBQ3hHLE1BQU0sQ0FBQyxDQUFDaEosSUFBTUEsRUFBRStILEtBQUssQ0FBQyxFQUFFLEtBQUtBLEtBQUssQ0FBQyxFQUFFLEVBQ3BEdkgsTUFBTSxHQUFHLElBQUs7WUFDM0IsTUFBTWlQLGNBQWM7bUJBQUkvQixZQUFZOEIsT0FBTzthQUFDO1lBQzVDQyxZQUFZQyxJQUFJLENBQUM7Z0JBQUVMO2dCQUFVQztnQkFBVXZIO1lBQU07WUFDN0MyRixZQUFZOEIsT0FBTyxHQUFHQztZQUN0QmhDLFlBQVk7bUJBQUlnQzthQUFZO1lBQzVCYjtZQUNBO1FBQ0o7UUFDQSx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDekUsc0JBQXNCZ0UsdUJBQ3ZCO1FBQ0osTUFBTXdCLG9CQUFvQjFQLE9BQU95RCxNQUFNLENBQUMsQ0FBQyxHQUFHa0Q7UUFDNUNvSCxpQkFBaUIsQ0FBQyxDQUFDdUI7UUFDbkJ0QyxtQkFBbUJsRixLQUFLLENBQUMsRUFBRTtRQUMzQixtSkFBbUo7UUFDbkosSUFBSTRELFlBQVluTCxNQUFNLEVBQUU7WUFDcEIsTUFBTW9QLGNBQWNqRSxZQUFZMEQsVUFBVUMsVUFBVXZIO1lBQ3BELElBQUksQ0FBQzZILGFBQWE7Z0JBQ2RyQjtnQkFDQVAsaUJBQWlCO1lBQ3JCO1FBQ0osT0FDSztZQUNELHNCQUFzQjtZQUN0QixPQUFPMkIsaUJBQWlCLENBQUNOLFNBQVM7WUFDbEMsNEJBQTRCO1lBQzVCTSxpQkFBaUIsQ0FBQ0wsU0FBUyxHQUFHdkg7WUFDOUI4RSxtQkFBbUI4QztRQUN2QjtRQUNBZjtRQUNBLHFDQUFxQztRQUNyQ3hELGtCQUFrQnVFO0lBQ3RCO0lBQ0EsU0FBU0Usc0JBQXNCOUosTUFBTTtRQUNqQyxNQUFNK0osZUFBZTdQLE9BQU95RCxNQUFNLENBQUMsQ0FBQyxHQUFHa0Q7UUFDdkMsT0FBT2tKLFlBQVksQ0FBQy9KLE9BQU87UUFDM0I4RyxtQkFBbUJpRDtRQUNuQixxQ0FBcUM7UUFDckMxRSxrQkFBa0IwRTtJQUN0QjtJQUNBLFNBQVNkLGVBQWVGLGNBQWM7UUFDbEMsSUFBSXBCLFlBQVk4QixPQUFPLENBQUNoUCxNQUFNLEtBQUssR0FDL0I7UUFDSiw4R0FBOEc7UUFDOUcsTUFBTXVQLFVBQVVyQyxZQUFZOEIsT0FBTyxDQUFDLEVBQUU7UUFDdEMsaUZBQWlGO1FBQ2pGLElBQUlPLFFBQVFoSSxLQUFLLENBQUMsRUFBRSxLQUFLbUIsYUFDckI2RyxRQUFRaEksS0FBSyxDQUFDLEVBQUUsS0FBSytHLGtCQUNyQm5ELFlBQVluTCxNQUFNLEVBQUU7WUFDcEJ5TSxtQkFBbUI4QyxRQUFRaEksS0FBSyxDQUFDLEVBQUU7WUFDbkNpRyxpQkFBaUIsT0FBTyxrQ0FBa0M7WUFDMUQsTUFBTTRCLGNBQWNqRSxZQUFZb0UsUUFBUVYsUUFBUSxFQUFFVSxRQUFRVCxRQUFRLEVBQUVTLFFBQVFoSSxLQUFLO1lBQ2pGLHVEQUF1RDtZQUN2RCxJQUFJNkgsYUFBYTtnQkFDYixNQUFNSCxjQUFjO3VCQUFJL0IsWUFBWThCLE9BQU87aUJBQUM7Z0JBQzVDQyxZQUFZTyxLQUFLO2dCQUNqQnRDLFlBQVk4QixPQUFPLEdBQUdDO2dCQUN0QmhDLFlBQVk7dUJBQUlnQztpQkFBWTtZQUNoQyxPQUNLO2dCQUNELGlEQUFpRDtnQkFDakRsQjtZQUNKO1FBQ0o7SUFDSjtJQUNBLFNBQVMwQixxQkFBcUJsSSxLQUFLLEVBQUV1SCxRQUFRO1FBQ3pDLE1BQU1ZLGNBQWM5RCxpQkFBaUJyRSxPQUFPdUg7UUFDNUMsSUFBSSxDQUFDWSxhQUNEO1FBQ0osTUFBTVAsb0JBQW9CMVAsT0FBT3lELE1BQU0sQ0FBQyxDQUFDLEdBQUdrRDtRQUM1Qyw0QkFBNEI7UUFDNUIrSSxpQkFBaUIsQ0FBQ0wsU0FBUyxHQUFHdkg7UUFDOUI4RSxtQkFBbUI4QztRQUNuQixxQ0FBcUM7UUFDckN2RSxrQkFBa0J1RTtJQUN0QjtJQUNBLFNBQVNwQixjQUFjQyx1QkFBdUIsSUFBSTtRQUM5Qyx3R0FBd0c7UUFDeEcsSUFBSUEsc0JBQ0F2QixtQkFBbUIvRDtRQUN2QndFLFlBQVk4QixPQUFPLEdBQUcsRUFBRTtRQUN4Qi9CLFlBQVksRUFBRTtJQUNsQjtJQUNBLFNBQVNtQjtRQUNMdkIscUJBQXFCO1FBQ3JCRSxtQkFBbUI7UUFDbkJKLHFCQUFxQjtJQUN6QjtJQUNBLFNBQVNnRCxpQkFBaUJwSyxNQUFNO1FBQzVCNkgseUJBQXlCN0g7SUFDN0I7SUFDQSxTQUFTcUssZUFBZXJLLE1BQU07UUFDMUIsSUFBSTRILHVCQUF1QjtZQUN2QixxRkFBcUY7WUFDckYsSUFBSUEsMEJBQTBCNUgsUUFBUTtnQkFDbEM2SCx5QkFBeUIxRTtnQkFDekJtQiw2QkFBNkJrRSxjQUFjO2dCQUMzQ2pDLG1CQUFtQnZHO2dCQUNuQjtZQUNKO1FBQ0osT0FFSTZILHlCQUF5QjFFO0lBQ2pDO0lBQ0EsU0FBU21IO1FBQ0x6Qyx5QkFBeUIxRTtJQUM3QjtJQUNBLE1BQU1vSCxpQ0FBaUM7UUFDbkN0RztRQUNBQztRQUNBQztRQUNBQztRQUNBMUI7UUFDQTJCO1FBQ0F2RTtRQUNBQztRQUNBK0g7UUFDQTlFO1FBQ0FzSDtRQUNBeko7UUFDQStHO1FBQ0FyRjtRQUNBZ0M7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUw7UUFDQU87UUFDQUM7UUFDQUM7UUFDQUM7UUFDQTRFO1FBQ0ExRztRQUNBK0I7UUFDQWtFO1FBQ0FhO1FBQ0F0SztRQUNBd0Y7UUFDQWdEO1FBQ0FuQjtRQUNBcUI7UUFDQTFGO1FBQ0FZO1FBQ0E4QjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBTTtRQUNBZ0U7UUFDQUM7UUFDQWhFO1FBQ0FDO1FBQ0FTO1FBQ0FVO1FBQ0FKO1FBQ0FFO1FBQ0FmO1FBQ0ErQjtRQUNBakI7UUFDQUU7UUFDQUo7UUFDQVY7UUFDQVM7UUFDQVA7SUFDSjtJQUNBLE9BQVFoTyxzREFBR0EsQ0FBQ2tMLGtCQUFrQjBHLFFBQVEsRUFBRXRRLE9BQU95RCxNQUFNLENBQUM7UUFBRThNLE9BQU9GO0lBQStCLEdBQUc7UUFBRXZNLFVBQVVBO0lBQVM7QUFDMUg7QUFFQSxTQUFTME0sU0FBUyxFQUFFbEosR0FBRyxFQUFFbUosR0FBRyxFQUFFO0lBQzFCLE1BQU0sRUFBRTdLLGdCQUFnQixFQUFFQyxVQUFVLEVBQUUwRSxxQkFBcUIsRUFBRUksc0JBQXNCLEVBQUVMLG1CQUFtQixFQUFHLEdBQUdUO0lBQzlHLE1BQU02RyxhQUFhL0YsdUJBQXVCSCxlQUFlO0lBQ3pELE1BQU1tRyxhQUFhcEcsc0JBQXNCQyxlQUFlO0lBQ3hELE1BQU1vRyxRQUFRSCxRQUFRO0lBQ3RCLE1BQU1JLFdBQVd2SixRQUFRO0lBQ3pCLE1BQU13SixxQkFBcUJGLFNBQVNDO0lBQ3BDLFNBQVNFO1FBQ0wsT0FBT25MLHFCQUFxQixVQUFVLElBQUkwQixNQUFNQSxNQUFNO0lBQzFEO0lBQ0EsU0FBUzBKO1FBQ0wsT0FBT3BMLHFCQUFxQixVQUFVbkYsT0FBTyxDQUFDLElBQUlnUSxJQUFJLEdBQUdoUSxPQUFPLENBQUNnUSxJQUFJO0lBQ3pFO0lBQ0EsU0FBU1E7UUFDTCxPQUFRdFMsdURBQUlBLENBQUNDLHVEQUFRQSxFQUFFO1lBQUVrRixVQUFVO2dCQUFDcEYsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7b0JBQUVNLE9BQU8vRCxPQUFPeUQsTUFBTSxDQUFDekQsT0FBT3lELE1BQU0sQ0FBQzt3QkFBRXlOLFFBQVE7d0JBQUdsSyxVQUFVO29CQUFXLEdBQUc7d0JBQUVtSyxPQUFPVDtvQkFBVyxJQUFJVSxhQUFhdkwsWUFBWXlFO2dCQUFzQixHQUFHO29CQUFFeEcsVUFBVWlOO2dCQUFTO2dCQUFLclMsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7b0JBQUVNLE9BQU8vRCxPQUFPeUQsTUFBTSxDQUFDekQsT0FBT3lELE1BQU0sQ0FBQzt3QkFBRXlOLFFBQVE7d0JBQUdsSyxVQUFVO29CQUFXLEdBQUc7d0JBQUVtSyxPQUFPVDtvQkFBVyxJQUFJVyxXQUFXeEwsWUFBWXlFO2dCQUFzQixHQUFHO29CQUFFeEcsVUFBVWtOO2dCQUFZO2FBQUk7UUFBQztJQUN2YjtJQUNBLFNBQVNNO1FBQ0wsT0FBUTVTLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1lBQUVNLE9BQU8vRCxPQUFPeUQsTUFBTSxDQUFDekQsT0FBT3lELE1BQU0sQ0FBQztnQkFBRThOLFlBQVk7Z0JBQVFMLFFBQVE7Z0JBQUdsSyxVQUFVO1lBQVcsR0FBRztnQkFBRW1LLE9BQU9WLE1BQU0sTUFBTSxJQUFJRSxhQUFhRDtZQUFXLElBQUlXLFdBQVd4TCxZQUFZeUU7UUFBc0IsR0FBRztZQUFFeEcsVUFBVWtOO1FBQVk7SUFDaFE7SUFDQSxTQUFTUTtRQUNMLE9BQVE5UyxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztZQUFFTSxPQUFPL0QsT0FBT3lELE1BQU0sQ0FBQ3pELE9BQU95RCxNQUFNLENBQUM7Z0JBQUU4TixZQUFZO2dCQUFRTCxRQUFRO2dCQUFHbEssVUFBVTtZQUFXLEdBQUlwQixxQkFBcUIsVUFDM0k7Z0JBQUV1TCxPQUFPN0osTUFBTSxNQUFNLElBQUlxSixhQUFhRDtZQUFXLElBQ2pEO2dCQUFFUyxPQUFPN0osTUFBTSxNQUFNLElBQUlxSixhQUFhRDtZQUFXLElBQUtVLGFBQWF2TCxZQUFZeUU7UUFBc0IsR0FBRztZQUFFeEcsVUFBVWlOO1FBQVM7SUFDM0k7SUFDQSxJQUFJRCxvQkFBb0I7UUFDcEIsT0FBT0c7SUFDWDtJQUNBLElBQUlKLFVBQVU7UUFDVixPQUFPUztJQUNYO0lBQ0EsSUFBSVYsT0FBTztRQUNQLE9BQU9ZO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxNQUFNSCxhQUFhLENBQUN6TixPQUFPMEcsc0JBQXlCdEssT0FBT3lELE1BQU0sQ0FBQztRQUFFZ08sV0FBVztRQUFZQyxhQUFhOU4sUUFBUSxJQUFJQSxRQUFRO1FBQUkrTixVQUFVL04sUUFBUTtJQUFHLEdBQUcwRztBQUN4SixNQUFNOEcsZUFBZSxDQUFDeE4sT0FBTzBHLHNCQUF5QnRLLE9BQU95RCxNQUFNLENBQUM7UUFBRWdPLFdBQVc7UUFBY0csY0FBY2hPLFFBQVEsSUFBSUEsUUFBUTtRQUFJK04sVUFBVS9OLFFBQVE7SUFBRyxHQUFHMEc7QUFFN0o7O0NBRUMsR0FBRyxNQUFNdUgsMkJBQWE5UyxvREFBYUEsQ0FBQztJQUNqQytTLGlCQUFpQjdJO0FBQ3JCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBUzhJLHVCQUF1QkMsSUFBSTtJQUNsQyxPQUFPLDJCQUEyQkEsT0FBTyw4Q0FBOENBLE9BQU8sOEJBQThCO0FBQzlIO0FBRUEsc0RBQXNEO0FBQ3RELElBQUlDLGVBQWU7SUFDakIsT0FBTyxPQUFPQyxXQUFXLGNBQWNBLE9BQU9DLFVBQVUsSUFBSTtBQUM5RDtBQUVBOzs7OztDQUtDLEdBQ0QsSUFBSUMsZUFBZSxTQUFTQTtJQUMxQixPQUFPckcsS0FBS3NHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHN1IsS0FBSyxDQUFDLElBQUk4UixJQUFJLENBQUM7QUFDaEU7QUFFQSxJQUFJQyxjQUFjO0lBQ2hCQyxNQUFNLGlCQUFpQk47SUFDdkJPLFNBQVMsb0JBQW9CUDtJQUM3QlEsc0JBQXNCLFNBQVNBO1FBQzdCLE9BQU8saUNBQWlDUjtJQUMxQztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU1MsY0FBY0MsR0FBRztJQUN4QixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxNQUFNLE9BQU87SUFDcEQsSUFBSUMsUUFBUUQ7SUFFWixNQUFPOVMsT0FBT2dULGNBQWMsQ0FBQ0QsV0FBVyxLQUFNO1FBQzVDQSxRQUFRL1MsT0FBT2dULGNBQWMsQ0FBQ0Q7SUFDaEM7SUFFQSxPQUFPL1MsT0FBT2dULGNBQWMsQ0FBQ0YsU0FBU0M7QUFDeEM7QUFFQSx3RkFBd0Y7QUFDeEYsU0FBU0UsV0FBV0MsR0FBRztJQUNyQixJQUFJQSxRQUFRLEtBQUssR0FBRyxPQUFPO0lBQzNCLElBQUlBLFFBQVEsTUFBTSxPQUFPO0lBQ3pCLElBQUlDLE9BQU8sT0FBT0Q7SUFFbEIsT0FBUUM7UUFDTixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNIO2dCQUNFLE9BQU9BO1lBQ1Q7SUFDSjtJQUVBLElBQUl2SyxNQUFNQyxPQUFPLENBQUNxSyxNQUFNLE9BQU87SUFDL0IsSUFBSUUsT0FBT0YsTUFBTSxPQUFPO0lBQ3hCLElBQUlHLFFBQVFILE1BQU0sT0FBTztJQUN6QixJQUFJSSxrQkFBa0JDLFNBQVNMO0lBRS9CLE9BQVFJO1FBQ04sS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT0E7SUFDWCxFQUFFLFFBQVE7SUFHVixPQUFPSCxLQUFLSyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUd6TCxXQUFXLEdBQUdYLE9BQU8sQ0FBQyxPQUFPO0FBQ3hEO0FBRUEsU0FBU21NLFNBQVNMLEdBQUc7SUFDbkIsT0FBTyxPQUFPQSxJQUFJTyxXQUFXLEtBQUssYUFBYVAsSUFBSU8sV0FBVyxDQUFDQyxJQUFJLEdBQUc7QUFDeEU7QUFFQSxTQUFTTCxRQUFRSCxHQUFHO0lBQ2xCLE9BQU9BLGVBQWVTLFNBQVMsT0FBT1QsSUFBSVUsT0FBTyxLQUFLLFlBQVlWLElBQUlPLFdBQVcsSUFBSSxPQUFPUCxJQUFJTyxXQUFXLENBQUNJLGVBQWUsS0FBSztBQUNsSTtBQUVBLFNBQVNULE9BQU9GLEdBQUc7SUFDakIsSUFBSUEsZUFBZVksTUFBTSxPQUFPO0lBQ2hDLE9BQU8sT0FBT1osSUFBSWEsWUFBWSxLQUFLLGNBQWMsT0FBT2IsSUFBSWMsT0FBTyxLQUFLLGNBQWMsT0FBT2QsSUFBSWUsT0FBTyxLQUFLO0FBQy9HO0FBRUEsU0FBU0MsT0FBT2hCLEdBQUc7SUFDakIsSUFBSWlCLFlBQVksT0FBT2pCO0lBRXZCLElBQUlrQixJQUF5QixFQUFjO1FBQ3pDRCxZQUFZbEIsV0FBV0M7SUFDekI7SUFFQSxPQUFPaUI7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FFRCxTQUFTRSxZQUFZQyxPQUFPLEVBQUVDLGNBQWMsRUFBRUMsUUFBUTtJQUNwRCxJQUFJQztJQUVKLElBQUksT0FBT0YsbUJBQW1CLGNBQWMsT0FBT0MsYUFBYSxjQUFjLE9BQU9BLGFBQWEsY0FBYyxPQUFPRSxTQUFTLENBQUMsRUFBRSxLQUFLLFlBQVk7UUFDbEosTUFBTSxJQUFJZixNQUFNUyxNQUFxQyxHQUFHckMsQ0FBeUIsR0FBRyw4REFBOEQsaUVBQWlFO0lBQ3JOO0lBRUEsSUFBSSxPQUFPd0MsbUJBQW1CLGNBQWMsT0FBT0MsYUFBYSxhQUFhO1FBQzNFQSxXQUFXRDtRQUNYQSxpQkFBaUJ0TDtJQUNuQjtJQUVBLElBQUksT0FBT3VMLGFBQWEsYUFBYTtRQUNuQyxJQUFJLE9BQU9BLGFBQWEsWUFBWTtZQUNsQyxNQUFNLElBQUliLE1BQU1TLE1BQXFDLEdBQUdyQyxDQUF5QixHQUFHLGlFQUFpRW1DLE9BQU9NLFlBQVk7UUFDMUs7UUFFQSxPQUFPQSxTQUFTSCxhQUFhQyxTQUFTQztJQUN4QztJQUVBLElBQUksT0FBT0QsWUFBWSxZQUFZO1FBQ2pDLE1BQU0sSUFBSVgsTUFBTVMsTUFBcUMsR0FBR3JDLENBQXlCLEdBQUcscUVBQXFFbUMsT0FBT0ksV0FBVztJQUM3SztJQUVBLElBQUlLLGlCQUFpQkw7SUFDckIsSUFBSU0sZUFBZUw7SUFDbkIsSUFBSU0sbUJBQW1CLEVBQUU7SUFDekIsSUFBSUMsZ0JBQWdCRDtJQUNwQixJQUFJRSxnQkFBZ0I7SUFDcEI7Ozs7OztHQU1DLEdBRUQsU0FBU0M7UUFDUCxJQUFJRixrQkFBa0JELGtCQUFrQjtZQUN0Q0MsZ0JBQWdCRCxpQkFBaUJyQixLQUFLO1FBQ3hDO0lBQ0Y7SUFDQTs7OztHQUlDLEdBR0QsU0FBU3lCO1FBQ1AsSUFBSUYsZUFBZTtZQUNqQixNQUFNLElBQUlwQixNQUFNUyxNQUFxQyxHQUFHckMsQ0FBeUIsR0FBRyx1RUFBdUUsZ0VBQWdFO1FBQzdOO1FBRUEsT0FBTzZDO0lBQ1Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCQyxHQUdELFNBQVNNLFVBQVVDLFFBQVE7UUFDekIsSUFBSSxPQUFPQSxhQUFhLFlBQVk7WUFDbEMsTUFBTSxJQUFJeEIsTUFBTVMsTUFBcUMsR0FBR3JDLENBQXlCLEdBQUcsaUVBQWlFbUMsT0FBT2lCLFlBQVk7UUFDMUs7UUFFQSxJQUFJSixlQUFlO1lBQ2pCLE1BQU0sSUFBSXBCLE1BQU1TLE1BQXFDLEdBQUdyQyxDQUF5QixHQUFHLHdFQUF3RSx5RkFBeUYsdUZBQXVGO1FBQzlVO1FBRUEsSUFBSXFELGVBQWU7UUFDbkJKO1FBQ0FGLGNBQWNyRixJQUFJLENBQUMwRjtRQUNuQixPQUFPLFNBQVNFO1lBQ2QsSUFBSSxDQUFDRCxjQUFjO2dCQUNqQjtZQUNGO1lBRUEsSUFBSUwsZUFBZTtnQkFDakIsTUFBTSxJQUFJcEIsTUFBTVMsTUFBcUMsR0FBR3JDLENBQXlCLEdBQUcsbUZBQW1GO1lBQ3pLO1lBRUFxRCxlQUFlO1lBQ2ZKO1lBQ0EsSUFBSU0sUUFBUVIsY0FBYzFVLE9BQU8sQ0FBQytVO1lBQ2xDTCxjQUFjUyxNQUFNLENBQUNELE9BQU87WUFDNUJULG1CQUFtQjtRQUNyQjtJQUNGO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdCQyxHQUdELFNBQVNXLFNBQVNDLE1BQU07UUFDdEIsSUFBSSxDQUFDNUMsY0FBYzRDLFNBQVM7WUFDMUIsTUFBTSxJQUFJOUIsTUFBTVMsTUFBcUMsR0FBR3JDLENBQXlCLEdBQUcsbUVBQW1FbUMsT0FBT3VCLFVBQVU7UUFDMUs7UUFFQSxJQUFJLE9BQU9BLE9BQU90QyxJQUFJLEtBQUssYUFBYTtZQUN0QyxNQUFNLElBQUlRLE1BQU1TLE1BQXFDLEdBQUdyQyxDQUF5QixHQUFHO1FBQ3RGO1FBRUEsSUFBSWdELGVBQWU7WUFDakIsTUFBTSxJQUFJcEIsTUFBTVMsTUFBcUMsR0FBR3JDLENBQXlCLEdBQUc7UUFDdEY7UUFFQSxJQUFJO1lBQ0ZnRCxnQkFBZ0I7WUFDaEJILGVBQWVELGVBQWVDLGNBQWNhO1FBQzlDLFNBQVU7WUFDUlYsZ0JBQWdCO1FBQ2xCO1FBRUEsSUFBSVcsWUFBWWIsbUJBQW1CQztRQUVuQyxJQUFLLElBQUl4VSxJQUFJLEdBQUdBLElBQUlvVixVQUFVblYsTUFBTSxFQUFFRCxJQUFLO1lBQ3pDLElBQUk2VSxXQUFXTyxTQUFTLENBQUNwVixFQUFFO1lBQzNCNlU7UUFDRjtRQUVBLE9BQU9NO0lBQ1Q7SUFDQTs7Ozs7Ozs7O0dBU0MsR0FHRCxTQUFTRSxlQUFlQyxXQUFXO1FBQ2pDLElBQUksT0FBT0EsZ0JBQWdCLFlBQVk7WUFDckMsTUFBTSxJQUFJakMsTUFBTVMsTUFBcUMsR0FBR3JDLENBQTBCLEdBQUcsb0VBQW9FbUMsT0FBTzBCO1FBQ2xLO1FBRUFqQixpQkFBaUJpQixhQUFhLHlEQUF5RDtRQUN2RixnRUFBZ0U7UUFDaEUsOERBQThEO1FBQzlELDhEQUE4RDtRQUU5REosU0FBUztZQUNQckMsTUFBTVYsWUFBWUUsT0FBTztRQUMzQjtJQUNGO0lBQ0E7Ozs7O0dBS0MsR0FHRCxTQUFTUjtRQUNQLElBQUkwRDtRQUVKLElBQUlDLGlCQUFpQlo7UUFDckIsT0FBT1csT0FBTztZQUNaOzs7Ozs7O09BT0MsR0FDRFgsV0FBVyxTQUFTQSxVQUFVYSxRQUFRO2dCQUNwQyxJQUFJLE9BQU9BLGFBQWEsWUFBWUEsYUFBYSxNQUFNO29CQUNyRCxNQUFNLElBQUlwQyxNQUFNUyxNQUFxQyxHQUFHckMsQ0FBMEIsR0FBRyxnRUFBZ0VtQyxPQUFPNkIsWUFBWTtnQkFDMUs7Z0JBRUEsU0FBU0M7b0JBQ1AsSUFBSUQsU0FBU0UsSUFBSSxFQUFFO3dCQUNqQkYsU0FBU0UsSUFBSSxDQUFDaEI7b0JBQ2hCO2dCQUNGO2dCQUVBZTtnQkFDQSxJQUFJWCxjQUFjUyxlQUFlRTtnQkFDakMsT0FBTztvQkFDTFgsYUFBYUE7Z0JBQ2Y7WUFDRjtRQUNGLEdBQUdRLElBQUksQ0FBQzVELGFBQWEsR0FBRztZQUN0QixPQUFPLElBQUk7UUFDYixHQUFHNEQ7SUFDTCxFQUFFLHdFQUF3RTtJQUMxRSxrRUFBa0U7SUFDbEUsMEJBQTBCO0lBRzFCTCxTQUFTO1FBQ1ByQyxNQUFNVixZQUFZQyxJQUFJO0lBQ3hCO0lBQ0EsT0FBTytCLFFBQVE7UUFDYmUsVUFBVUE7UUFDVk4sV0FBV0E7UUFDWEQsVUFBVUE7UUFDVlUsZ0JBQWdCQTtJQUNsQixHQUFHbEIsS0FBSyxDQUFDeEMsYUFBYSxHQUFHRSxZQUFZc0M7QUFDdkM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVN5QixRQUFRdEMsT0FBTztJQUN0Qiw2QkFBNkIsR0FDN0IsSUFBSSxPQUFPdUMsWUFBWSxlQUFlLE9BQU9BLFFBQVFDLEtBQUssS0FBSyxZQUFZO1FBQ3pFRCxRQUFRQyxLQUFLLENBQUN4QztJQUNoQjtJQUNBLDRCQUE0QixHQUc1QixJQUFJO1FBQ0YsK0RBQStEO1FBQy9ELDZDQUE2QztRQUM3Qyw2Q0FBNkM7UUFDN0MsTUFBTSxJQUFJRCxNQUFNQztJQUNsQixFQUFFLE9BQU8vVCxHQUFHLENBQUMsRUFBRSwrQkFBK0I7QUFFaEQ7QUFFQTs7O0NBR0MsR0FFRCxTQUFTd1csYUFBYTtBQUV0QixJQUFJakMsS0FBeUIsSUFBZ0IsT0FBT2lDLFVBQVUzQyxJQUFJLEtBQUssWUFBWTJDLFVBQVUzQyxJQUFJLEtBQUssYUFBYTtJQUNqSHdDLFFBQVEsaUZBQWlGLDBFQUEwRSx1RkFBdUYsc0ZBQXNGO0FBQ2xWO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQUcsU0FBU0ksVUFBVUMsU0FBUyxFQUFFQyxNQUFNLEVBQUUsR0FBR0MsSUFBSTtJQUM3QyxJQUFJQyxnQkFBZ0I7UUFDaEIsSUFBSUYsV0FBV3ZOLFdBQVc7WUFDdEIsTUFBTSxJQUFJMEssTUFBTTtRQUNwQjtJQUNKO0lBQ0EsSUFBSSxDQUFDNEMsV0FBVztRQUNaLElBQUlIO1FBQ0osSUFBSUksV0FBV3ZOLFdBQVc7WUFDdEJtTixRQUFRLElBQUl6QyxNQUFNLHVFQUF1RTtRQUM3RixPQUFPO1lBQ0gsSUFBSWdELFdBQVc7WUFDZlAsUUFBUSxJQUFJekMsTUFBTTZDLE9BQU9wUCxPQUFPLENBQUMsT0FBTztnQkFDcEMsT0FBT3FQLElBQUksQ0FBQ0UsV0FBVztZQUMzQjtZQUNBUCxNQUFNMUMsSUFBSSxHQUFHO1FBQ2pCO1FBQ0EwQyxNQUFNUSxXQUFXLEdBQUcsRUFBRSw0Q0FBNEM7O1FBRWxFLE1BQU1SO0lBQ1Y7QUFDSjtBQUNBLFNBQVNNO0lBQ0wsT0FBTyxPQUFPdEMsWUFBWSxlQUFlQSxrQkFBNEI7QUFDekU7QUFFQSw0QkFBNEI7QUFDNUI7Ozs7O0NBS0MsR0FBRyxTQUFTeUMsSUFBSS9ELEdBQUcsRUFBRWdFLElBQUksRUFBRUMsWUFBWTtJQUNwQyxPQUFPRCxLQUFLcFcsS0FBSyxDQUFDLEtBQUtzVyxNQUFNLENBQUMsQ0FBQ25VLEdBQUdFLElBQUlGLEtBQUtBLENBQUMsQ0FBQ0UsRUFBRSxHQUFHRixDQUFDLENBQUNFLEVBQUUsR0FBR2dVLGdCQUFnQixNQUN2RWpFO0FBQ047QUFDQTs7Q0FFQyxHQUFHLFNBQVNtRSxVQUFVQyxLQUFLLEVBQUVDLElBQUk7SUFDOUIsT0FBT0QsTUFBTW5PLE1BQU0sQ0FBQyxDQUFDekksSUFBSUEsTUFBTTZXO0FBRW5DO0FBQ0E7OztDQUdDLEdBQUcsU0FBU0MsU0FBU0MsS0FBSztJQUN2QixPQUFPLE9BQU9BLFVBQVU7QUFDNUI7QUFDQTs7OztDQUlDLEdBQUcsU0FBU0MsSUFBSUMsTUFBTSxFQUFFQyxNQUFNO0lBQzNCLE1BQU1DLE1BQU0sSUFBSUM7SUFDaEIsTUFBTUMsYUFBYSxDQUFDUjtRQUNoQk0sSUFBSUcsR0FBRyxDQUFDVCxNQUFNTSxJQUFJSSxHQUFHLENBQUNWLFFBQVFNLElBQUlaLEdBQUcsQ0FBQ00sUUFBUSxJQUFJO0lBQ3REO0lBQ0FJLE9BQU85USxPQUFPLENBQUNrUjtJQUNmSCxPQUFPL1EsT0FBTyxDQUFDa1I7SUFDZixNQUFNRyxTQUFTLEVBQUU7SUFDakJMLElBQUloUixPQUFPLENBQUMsQ0FBQ3NSLE9BQU9DO1FBQ2hCLElBQUlELFVBQVUsR0FBRztZQUNiRCxPQUFPckksSUFBSSxDQUFDdUk7UUFDaEI7SUFDSjtJQUNBLE9BQU9GO0FBQ1g7QUFDQTs7OztDQUlDLEdBQUcsU0FBU0csYUFBYVYsTUFBTSxFQUFFQyxNQUFNO0lBQ3BDLE9BQU9ELE9BQU94TyxNQUFNLENBQUMsQ0FBQ2pKLElBQUkwWCxPQUFPcFgsT0FBTyxDQUFDTixLQUFLLENBQUM7QUFFbkQ7QUFFQSxNQUFNb1ksY0FBYztBQUNwQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsT0FBTztBQUNiLE1BQU1DLFdBQVc7QUFFakIsU0FBU0MsZ0JBQWdCQyxZQUFZLEVBQUVDLGtCQUFrQjtJQUNyRCxPQUFPO1FBQ0h2RixNQUFNK0U7UUFDTlMsU0FBUztZQUNMRCxvQkFBb0JBLHNCQUFzQjtZQUMxQ0QsY0FBY0EsZ0JBQWdCO1FBQ2xDO0lBQ0o7QUFDSjtBQUVBLE1BQU1HLHlCQUF5QjtJQUMzQnpGLE1BQU0rRTtJQUNOUyxTQUFTO1FBQ0xGLGNBQWM7UUFDZEMsb0JBQW9CO0lBQ3hCO0FBQ0o7QUFDQSxTQUFTRyxnQkFBZ0JDLE9BQU87SUFDNUIsT0FBTyxTQUFTQyxVQUFVQyxZQUFZLEVBQUUsRUFBRUMsVUFBVTtRQUNoREMsZUFBZTtJQUNuQixDQUFDO1FBQ0csTUFBTSxFQUFFQSxnQkFBZSxJQUFJLEVBQUdULFlBQVksRUFBR1UscUJBQXFCLEVBQUssR0FBR0Y7UUFDMUUsTUFBTUcsVUFBVU4sUUFBUU8sVUFBVTtRQUNsQyxNQUFNQyxXQUFXUixRQUFRUyxXQUFXO1FBQ3BDLHFEQUFxRDtRQUNyRFQsUUFBUXRELFFBQVEsQ0FBQ2dELGdCQUFnQkM7UUFDakNlLG1CQUFtQlIsV0FBV0ksU0FBU0U7UUFDdkMsMkJBQTJCO1FBQzNCLE1BQU1HLFdBQVdDLG1CQUFtQlYsV0FBV0k7UUFDL0MsSUFBSUssWUFBWSxNQUFNO1lBQ2xCWCxRQUFRdEQsUUFBUSxDQUFDb0Q7WUFDakI7UUFDSjtRQUNBLCtCQUErQjtRQUMvQixJQUFJRixxQkFBcUI7UUFDekIsSUFBSUQsY0FBYztZQUNkLElBQUksQ0FBQ1UsdUJBQXVCO2dCQUN4QixNQUFNLElBQUl4RixNQUFNO1lBQ3BCO1lBQ0FnRyxzQ0FBc0NSO1lBQ3RDVCxxQkFBcUJTLHNCQUFzQk07UUFDL0M7UUFDQSxrQ0FBa0M7UUFDbENYLFFBQVF0RCxRQUFRLENBQUNnRCxnQkFBZ0JDLGNBQWNDO1FBQy9DLE1BQU1rQixTQUFTTixTQUFTTyxTQUFTLENBQUNKO1FBQ2xDLE1BQU10QyxPQUFPeUMsT0FBT2IsU0FBUyxDQUFDSyxTQUFTSztRQUN2Qyw0RUFBNEU7UUFDNUUsSUFBSXRDLFFBQVEsTUFBTTtZQUNkLE9BQU9sTztRQUNYO1FBQ0E2USxtQkFBbUIzQztRQUNuQm1DLFNBQVNTLFNBQVMsQ0FBQ047UUFDbkIsTUFBTU8sV0FBV1YsU0FBU1csYUFBYSxDQUFDUjtRQUN4QyxPQUFPO1lBQ0h0RyxNQUFNZ0Y7WUFDTlEsU0FBUztnQkFDTHFCO2dCQUNBN0M7Z0JBQ0FzQztnQkFDQWhCLGNBQWNBLGdCQUFnQjtnQkFDOUJDLG9CQUFvQkEsc0JBQXNCO2dCQUMxQ3dCLGdCQUFnQixDQUFDLENBQUNoQjtZQUN0QjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNNLG1CQUFtQlIsU0FBUyxFQUFFSSxPQUFPLEVBQUVFLFFBQVE7SUFDcERoRCxVQUFVLENBQUM4QyxRQUFRZSxVQUFVLElBQUk7SUFDakNuQixVQUFVdlMsT0FBTyxDQUFDLFNBQVNnVCxRQUFRO1FBQy9CbkQsVUFBVWdELFNBQVNPLFNBQVMsQ0FBQ0osV0FBVztJQUM1QztBQUNKO0FBQ0EsU0FBU0Usc0NBQXNDUixxQkFBcUI7SUFDaEU3QyxVQUFVLE9BQU82QywwQkFBMEIsWUFBWTtBQUMzRDtBQUNBLFNBQVNXLG1CQUFtQjNDLElBQUk7SUFDNUJiLFVBQVVjLFNBQVNELE9BQU87QUFDOUI7QUFDQSxTQUFTdUMsbUJBQW1CVixTQUFTLEVBQUVJLE9BQU87SUFDMUMsSUFBSUssV0FBVztJQUNmLElBQUksSUFBSW5aLElBQUkwWSxVQUFVelksTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSTtRQUMxQyxJQUFJOFksUUFBUWdCLGFBQWEsQ0FBQ3BCLFNBQVMsQ0FBQzFZLEVBQUUsR0FBRztZQUNyQ21aLFdBQVdULFNBQVMsQ0FBQzFZLEVBQUU7WUFDdkI7UUFDSjtJQUNKO0lBQ0EsT0FBT21aO0FBQ1g7QUFFQSxTQUFTWSxrQkFBa0J2SCxHQUFHLEVBQUVrRixHQUFHLEVBQUV6SCxLQUFLO0lBQ3RDLElBQUl5SCxPQUFPbEYsS0FBSztRQUNaOVMsT0FBT3NhLGNBQWMsQ0FBQ3hILEtBQUtrRixLQUFLO1lBQzVCekgsT0FBT0E7WUFDUGdLLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ2Q7SUFDSixPQUFPO1FBQ0gzSCxHQUFHLENBQUNrRixJQUFJLEdBQUd6SDtJQUNmO0lBQ0EsT0FBT3VDO0FBQ1g7QUFDQSxTQUFTNEgsZ0JBQWdCQyxNQUFNO0lBQzNCLElBQUksSUFBSXJhLElBQUksR0FBR0EsSUFBSW9VLFVBQVVuVSxNQUFNLEVBQUVELElBQUk7UUFDckMsSUFBSXNaLFNBQVNsRixTQUFTLENBQUNwVSxFQUFFLElBQUksT0FBT29VLFNBQVMsQ0FBQ3BVLEVBQUUsR0FBRyxDQUFDO1FBQ3BELElBQUlzYSxVQUFVNWEsT0FBT3dHLElBQUksQ0FBQ29UO1FBQzFCLElBQUksT0FBTzVaLE9BQU9LLHFCQUFxQixLQUFLLFlBQVk7WUFDcER1YSxVQUFVQSxRQUFRQyxNQUFNLENBQUM3YSxPQUFPSyxxQkFBcUIsQ0FBQ3VaLFFBQVE3USxNQUFNLENBQUMsU0FBUytSLEdBQUc7Z0JBQzdFLE9BQU85YSxPQUFPK2Esd0JBQXdCLENBQUNuQixRQUFRa0IsS0FBS1AsVUFBVTtZQUNsRTtRQUNKO1FBQ0FLLFFBQVFuVSxPQUFPLENBQUMsU0FBU3VSLEdBQUc7WUFDeEJxQyxrQkFBa0JNLFFBQVEzQyxLQUFLNEIsTUFBTSxDQUFDNUIsSUFBSTtRQUM5QztJQUNKO0lBQ0EsT0FBTzJDO0FBQ1g7QUFDQSxTQUFTSyxXQUFXbEMsT0FBTztJQUN2QixPQUFPLFNBQVNtQyxLQUFLaEMsVUFBVSxDQUFDLENBQUM7UUFDN0IsTUFBTUcsVUFBVU4sUUFBUU8sVUFBVTtRQUNsQyxNQUFNQyxXQUFXUixRQUFRUyxXQUFXO1FBQ3BDMkIsaUJBQWlCOUI7UUFDakIsTUFBTStCLFlBQVlDLG9CQUFvQmhDO1FBQ3RDLG1GQUFtRjtRQUNuRitCLFVBQVUxVSxPQUFPLENBQUMsQ0FBQzRVLFVBQVUvRjtZQUN6QixNQUFNZ0csYUFBYUMsb0JBQW9CRixVQUFVL0YsT0FBT2dFLFVBQVVGO1lBQ2xFLE1BQU0zRCxTQUFTO2dCQUNYdEMsTUFBTW1GO2dCQUNOSyxTQUFTO29CQUNMMkMsWUFBWVosZ0JBQWdCLENBQUMsR0FBR3pCLFNBQVNxQztnQkFDN0M7WUFDSjtZQUNBeEMsUUFBUXRELFFBQVEsQ0FBQ0M7UUFDckI7SUFDSjtBQUNKO0FBQ0EsU0FBU3lGLGlCQUFpQjlCLE9BQU87SUFDN0I5QyxVQUFVOEMsUUFBUWUsVUFBVSxJQUFJO0lBQ2hDN0QsVUFBVSxDQUFDOEMsUUFBUW9DLE9BQU8sSUFBSTtBQUNsQztBQUNBLFNBQVNELG9CQUFvQkYsUUFBUSxFQUFFL0YsS0FBSyxFQUFFZ0UsUUFBUSxFQUFFRixPQUFPO0lBQzNELE1BQU11QixTQUFTckIsU0FBU21DLFNBQVMsQ0FBQ0o7SUFDbEMsSUFBSUMsYUFBYVgsU0FBU0EsT0FBT00sSUFBSSxDQUFDN0IsU0FBU2lDLFlBQVlwUztJQUMzRHlTLHFCQUFxQko7SUFDckIsSUFBSSxPQUFPQSxlQUFlLGFBQWE7UUFDbkNBLGFBQWFoRyxVQUFVLElBQUksQ0FBQyxJQUFJOEQsUUFBUXVDLGFBQWE7SUFDekQ7SUFDQSxPQUFPTDtBQUNYO0FBQ0EsU0FBU0kscUJBQXFCSixVQUFVO0lBQ3BDaEYsVUFBVSxPQUFPZ0YsZUFBZSxlQUFlbEUsU0FBU2tFLGFBQWE7QUFDekU7QUFDQSxTQUFTRixvQkFBb0JoQyxPQUFPO0lBQ2hDLE1BQU0rQixZQUFZL0IsUUFBUXdDLFlBQVksR0FBRzdTLE1BQU0sQ0FBQ3FRLFFBQVF5QyxlQUFlLEVBQUV6QztJQUN6RStCLFVBQVVXLE9BQU87SUFDakIsT0FBT1g7QUFDWDtBQUVBLFNBQVNZLGNBQWNqRCxPQUFPO0lBQzFCLE9BQU8sU0FBU2tEO1FBQ1osTUFBTTVDLFVBQVVOLFFBQVFPLFVBQVU7UUFDbEMsTUFBTUMsV0FBV1IsUUFBUVMsV0FBVztRQUNwQzBDLGlCQUFpQjdDO1FBQ2pCLE1BQU1LLFdBQVdMLFFBQVE4QyxXQUFXO1FBQ3BDLElBQUl6QyxZQUFZLE1BQU07WUFDbEIsTUFBTUcsU0FBU04sU0FBU08sU0FBUyxDQUFDSixVQUFVO1lBQzVDRyxPQUFPb0MsT0FBTyxDQUFDNUMsU0FBU0s7WUFDeEJILFNBQVM2QyxXQUFXO1FBQ3hCO1FBQ0EsT0FBTztZQUNIaEosTUFBTW9GO1FBQ1Y7SUFDSjtBQUNKO0FBQ0EsU0FBUzBELGlCQUFpQjdDLE9BQU87SUFDN0I5QyxVQUFVOEMsUUFBUWUsVUFBVSxJQUFJO0FBQ3BDO0FBRUEsU0FBU2lDLFlBQVlDLFVBQVUsRUFBRUMsZUFBZTtJQUM1QyxJQUFJQSxvQkFBb0IsTUFBTTtRQUMxQixPQUFPRCxlQUFlO0lBQzFCO0lBQ0EsT0FBT3pULE1BQU1DLE9BQU8sQ0FBQ3dULGNBQWNBLFdBQVdFLElBQUksQ0FBQyxDQUFDemMsSUFBSUEsTUFBTXdjLG1CQUMxREQsZUFBZUM7QUFDdkI7QUFFQSxTQUFTRSxZQUFZMUQsT0FBTztJQUN4QixPQUFPLFNBQVMyRCxNQUFNQyxZQUFZLEVBQUUsRUFBRWpFLFlBQVksRUFBRyxHQUFHLENBQUMsQ0FBQztRQUN0RGtFLHVCQUF1QkQ7UUFDdkIsTUFBTXZCLFlBQVl1QixhQUFhbEosS0FBSyxDQUFDO1FBQ3JDLE1BQU00RixVQUFVTixRQUFRTyxVQUFVO1FBQ2xDLE1BQU1DLFdBQVdSLFFBQVFTLFdBQVc7UUFDcEMsTUFBTStDLGtCQUFrQmxELFFBQVF3RCxXQUFXO1FBQzNDQywyQkFBMkIxQixXQUFXN0IsVUFBVWdEO1FBQ2hEUSxnQkFBZ0IzQixXQUFXL0IsU0FBU0U7UUFDcEN5RCxnQkFBZ0I1QixXQUFXL0IsU0FBU0U7UUFDcEMsT0FBTztZQUNIbkcsTUFBTWtGO1lBQ05NLFNBQVM7Z0JBQ0x3QztnQkFDQTFDLGNBQWNBLGdCQUFnQjtZQUNsQztRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNrRSx1QkFBdUJELFlBQVk7SUFDeENwRyxVQUFVMU4sTUFBTUMsT0FBTyxDQUFDNlQsZUFBZTtBQUMzQztBQUNBLFNBQVNJLGdCQUFnQjNCLFNBQVMsRUFBRS9CLE9BQU8sRUFBRUUsUUFBUTtJQUNqRGhELFVBQVU4QyxRQUFRZSxVQUFVLElBQUk7SUFDaEM3RCxVQUFVLENBQUM4QyxRQUFRb0MsT0FBTyxJQUFJO0lBQzlCLElBQUksSUFBSWxiLElBQUksR0FBR0EsSUFBSTZhLFVBQVU1YSxNQUFNLEVBQUVELElBQUk7UUFDckMsTUFBTSthLFdBQVdGLFNBQVMsQ0FBQzdhLEVBQUU7UUFDN0JnVyxVQUFVNkUsVUFBVTZCLFdBQVcsQ0FBQzNCLGNBQWMvYSxHQUFHO1FBQ2pELE1BQU1xYSxTQUFTckIsU0FBU21DLFNBQVMsQ0FBQ0o7UUFDbEMvRSxVQUFVcUUsUUFBUTtJQUN0QjtBQUNKO0FBQ0EsU0FBU2tDLDJCQUEyQjFCLFNBQVMsRUFBRTdCLFFBQVEsRUFBRWdELGVBQWU7SUFDcEUsZ0VBQWdFO0lBQ2hFLGtFQUFrRTtJQUNsRSx3QkFBd0I7SUFDeEIsSUFBSSxJQUFJaGMsSUFBSTZhLFVBQVU1YSxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxJQUFJO1FBQzFDLE1BQU0rYSxXQUFXRixTQUFTLENBQUM3YSxFQUFFO1FBQzdCLE1BQU0rYixhQUFhL0MsU0FBUzJELGFBQWEsQ0FBQzVCO1FBQzFDLElBQUksQ0FBQ2UsWUFBWUMsWUFBWUMsa0JBQWtCO1lBQzNDbkIsVUFBVTVGLE1BQU0sQ0FBQ2pWLEdBQUc7UUFDeEI7SUFDSjtBQUNKO0FBQ0EsU0FBU3ljLGdCQUFnQjVCLFNBQVMsRUFBRS9CLE9BQU8sRUFBRUUsUUFBUTtJQUNqRCw4Q0FBOEM7SUFDOUM2QixVQUFVMVUsT0FBTyxDQUFDLFNBQVM0VSxRQUFRO1FBQy9CLE1BQU1WLFNBQVNyQixTQUFTbUMsU0FBUyxDQUFDSjtRQUNsQ1YsT0FBTzhCLEtBQUssQ0FBQ3JELFNBQVNpQztJQUMxQjtBQUNKO0FBRUEsU0FBUzZCLHdCQUF3QnBFLE9BQU87SUFDcEMsT0FBTyxTQUFTcUU7UUFDWixNQUFNL0QsVUFBVU4sUUFBUU8sVUFBVTtRQUNsQyxJQUFJRCxRQUFRZSxVQUFVLElBQUk7WUFDdEIsT0FBTztnQkFDSGhILE1BQU1pRjtZQUNWO1FBQ0o7UUFDQTtJQUNKO0FBQ0o7QUFFQSxTQUFTZ0Ysc0JBQXNCdEUsT0FBTztJQUNsQyxPQUFPO1FBQ0hDLFdBQVdGLGdCQUFnQkM7UUFDM0JxRSxtQkFBbUJELHdCQUF3QnBFO1FBQzNDMkQsT0FBT0QsWUFBWTFEO1FBQ25CbUMsTUFBTUQsV0FBV2xDO1FBQ2pCa0QsU0FBU0QsY0FBY2pEO0lBQzNCO0FBQ0o7QUFFQSxNQUFNdUU7SUFDRkMsZUFBZUMsT0FBTyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBbEUsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDRCxPQUFPO0lBQ3ZCO0lBQ0FvRSxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNELE9BQU87SUFDdkI7SUFDQWhFLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ0gsT0FBTyxDQUFDRSxRQUFRO0lBQ2hDO0lBQ0FtRSxhQUFhO1FBQ1QsNkRBQTZELEdBQUcsTUFBTTNFLFVBQVUsSUFBSTtRQUNwRixNQUFNLEVBQUV0RCxRQUFRLEVBQUcsR0FBRyxJQUFJLENBQUNrSSxLQUFLO1FBQ2hDLFNBQVNDLGtCQUFrQkMsYUFBYTtZQUNwQyxPQUFPLENBQUMsR0FBR25IO2dCQUNQLE1BQU1oQixTQUFTbUksY0FBY0MsS0FBSyxDQUFDL0UsU0FBU3JDO2dCQUM1QyxJQUFJLE9BQU9oQixXQUFXLGFBQWE7b0JBQy9CRCxTQUFTQztnQkFDYjtZQUNKO1FBQ0o7UUFDQSxNQUFNcUksVUFBVVYsc0JBQXNCLElBQUk7UUFDMUMsT0FBT3BkLE9BQU93RyxJQUFJLENBQUNzWCxTQUFTOUcsTUFBTSxDQUFDLENBQUMrRyxjQUFjL0Y7WUFDOUMsTUFBTXZDLFNBQVNxSSxPQUFPLENBQUM5RixJQUFJO1lBQzNCK0YsWUFBWSxDQUFDL0YsSUFBSSxHQUFHMkYsa0JBQWtCbEk7WUFDdEMsT0FBT3NJO1FBQ1gsR0FBRyxDQUFDO0lBQ1I7SUFDQXZJLFNBQVNDLE1BQU0sRUFBRTtRQUNiLElBQUksQ0FBQ2lJLEtBQUssQ0FBQ2xJLFFBQVEsQ0FBQ0M7SUFDeEI7SUFDQWhDLFlBQVlpSyxLQUFLLEVBQUV0RSxPQUFPLENBQUM7UUFDdkIsSUFBSSxDQUFDNEUsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztZQUN4QixNQUFNQyxjQUFjLElBQUksQ0FBQ1IsS0FBSyxDQUFDekksUUFBUSxHQUFHa0osUUFBUSxHQUFHO1lBQ3JELElBQUksSUFBSSxDQUFDWixPQUFPLEVBQUU7Z0JBQ2QsSUFBSVcsZUFBZSxDQUFDLElBQUksQ0FBQ0YsT0FBTyxFQUFFO29CQUM5QixJQUFJLENBQUNULE9BQU8sQ0FBQ2EsS0FBSztvQkFDbEIsSUFBSSxDQUFDSixPQUFPLEdBQUc7Z0JBQ25CLE9BQU8sSUFBSSxDQUFDRSxlQUFlLElBQUksQ0FBQ0YsT0FBTyxFQUFFO29CQUNyQyxJQUFJLENBQUNULE9BQU8sQ0FBQ2MsUUFBUTtvQkFDckIsSUFBSSxDQUFDTCxPQUFPLEdBQUc7Z0JBQ25CO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ04sS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3RFLE9BQU8sR0FBR0E7UUFDZnNFLE1BQU14SSxTQUFTLENBQUMsSUFBSSxDQUFDK0ksb0JBQW9CO0lBQzdDO0FBQ0o7QUFFQTs7OztDQUlDLEdBQUcsU0FBU0ssSUFBSXpiLENBQUMsRUFBRUMsQ0FBQztJQUNqQixPQUFPO1FBQ0hvRCxHQUFHckQsRUFBRXFELENBQUMsR0FBR3BELEVBQUVvRCxDQUFDO1FBQ1pDLEdBQUd0RCxFQUFFc0QsQ0FBQyxHQUFHckQsRUFBRXFELENBQUM7SUFDaEI7QUFDSjtBQUNBOzs7O0NBSUMsR0FBRyxTQUFTb1ksU0FBUzFiLENBQUMsRUFBRUMsQ0FBQztJQUN0QixPQUFPO1FBQ0hvRCxHQUFHckQsRUFBRXFELENBQUMsR0FBR3BELEVBQUVvRCxDQUFDO1FBQ1pDLEdBQUd0RCxFQUFFc0QsQ0FBQyxHQUFHckQsRUFBRXFELENBQUM7SUFDaEI7QUFDSjtBQUNBOzs7Ozs7O0NBT0MsR0FBRyxTQUFTZ1Qsc0JBQXNCcUYsS0FBSztJQUNwQyxNQUFNLEVBQUUvRixZQUFZLEVBQUdnRyxtQkFBbUIsRUFBR0MseUJBQXlCLEVBQUcsR0FBR0Y7SUFDNUUsSUFBSSxDQUFDL0YsZ0JBQWdCLENBQUNnRyx1QkFBdUIsQ0FBQ0MsMkJBQTJCO1FBQ3JFLE9BQU87SUFDWDtJQUNBLE9BQU9ILFNBQVNELElBQUk3RixjQUFjaUcsNEJBQTRCRDtBQUNsRTtBQUNBOzs7O0NBSUMsR0FBRyxTQUFTRSwrQkFBK0JILEtBQUs7SUFDN0MsTUFBTSxFQUFFL0YsWUFBWSxFQUFHZ0csbUJBQW1CLEVBQUcsR0FBR0Q7SUFDaEQsSUFBSSxDQUFDL0YsZ0JBQWdCLENBQUNnRyxxQkFBcUI7UUFDdkMsT0FBTztJQUNYO0lBQ0EsT0FBT0YsU0FBUzlGLGNBQWNnRztBQUNsQztBQUVBLE1BQU1HLE9BQU8sRUFBRTtBQUNmLE1BQU1DLE1BQU0sRUFBRTtBQUNkRCxLQUFLRSxXQUFXLEdBQUc7QUFDbkJELElBQUlFLFVBQVUsR0FBRztBQUNqQjs7Ozs7Q0FLQyxHQUFHLFNBQVNDLFNBQVNDLFFBQVEsRUFBRUMsVUFBVTtJQUN0QyxJQUFJRCxhQUFhTCxNQUFNO1FBQ25CLE9BQU87SUFDWDtJQUNBLElBQUlLLGFBQWFKLE9BQU8sT0FBT0ssZUFBZSxhQUFhO1FBQ3ZELE9BQU87SUFDWDtJQUNBLE1BQU1DLFlBQVlsSCxhQUFhaUgsWUFBWUQ7SUFDM0MsT0FBT0UsVUFBVTVlLE1BQU0sR0FBRztBQUM5QjtBQUVBLE1BQU02ZTtJQUNGQyx1QkFBdUJsSyxRQUFRLEVBQUU4RCxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQzNDLE1BQU0sRUFBRWlHLFVBQVUsRUFBRyxHQUFHakc7UUFDeEIzQyxVQUFVLE9BQU9uQixhQUFhLFlBQVk7UUFDMUNtQixVQUFVLE9BQU80SSxlQUFlLGVBQWV0VyxNQUFNQyxPQUFPLENBQUNxVyxhQUFhO1FBQzFFLElBQUlJLGNBQWMsSUFBSSxDQUFDNUIsS0FBSyxDQUFDekksUUFBUSxHQUFHc0ssT0FBTztRQUMvQyxNQUFNQyxlQUFlO1lBQ2pCLE1BQU1oQixRQUFRLElBQUksQ0FBQ2QsS0FBSyxDQUFDekksUUFBUTtZQUNqQyxNQUFNd0ssaUJBQWlCakIsTUFBTWUsT0FBTztZQUNwQyxJQUFJO2dCQUNBLE1BQU1HLGtCQUFrQkQsbUJBQW1CSCxlQUFlRyxtQkFBbUJILGNBQWMsS0FBSyxDQUFDTixTQUFTUixNQUFNbUIsZUFBZSxFQUFFVDtnQkFDakksSUFBSSxDQUFDUSxpQkFBaUI7b0JBQ2xCdks7Z0JBQ0o7WUFDSixTQUFTO2dCQUNMbUssY0FBY0c7WUFDbEI7UUFDSjtRQUNBLE9BQU8sSUFBSSxDQUFDL0IsS0FBSyxDQUFDeEksU0FBUyxDQUFDc0s7SUFDaEM7SUFDQUksd0JBQXdCekssUUFBUSxFQUFFO1FBQzlCbUIsVUFBVSxPQUFPbkIsYUFBYSxZQUFZO1FBQzFDLElBQUkwSyxnQkFBZ0IsSUFBSSxDQUFDbkMsS0FBSyxDQUFDekksUUFBUSxHQUFHNkssVUFBVTtRQUNwRCxNQUFNTixlQUFlO1lBQ2pCLE1BQU1PLFlBQVksSUFBSSxDQUFDckMsS0FBSyxDQUFDekksUUFBUSxHQUFHNkssVUFBVTtZQUNsRCxJQUFJQyxjQUFjRixlQUFlO2dCQUM3QjtZQUNKO1lBQ0FBLGdCQUFnQkU7WUFDaEI1SztRQUNKO1FBQ0EsT0FBTyxJQUFJLENBQUN1SSxLQUFLLENBQUN4SSxTQUFTLENBQUNzSztJQUNoQztJQUNBcEYsY0FBY1gsUUFBUSxFQUFFO1FBQ3BCLElBQUksQ0FBQ0EsVUFBVTtZQUNYLE9BQU87UUFDWDtRQUNBLE1BQU1HLFNBQVMsSUFBSSxDQUFDTixRQUFRLENBQUNPLFNBQVMsQ0FBQ0o7UUFDdkNuRCxVQUFVc0QsUUFBUSxDQUFDLDBDQUEwQyxFQUFFSCxTQUFTLENBQUM7UUFDekUsSUFBSSxJQUFJLENBQUNVLFVBQVUsSUFBSTtZQUNuQixPQUFPO1FBQ1g7UUFDQSxPQUFPUCxPQUFPb0csT0FBTyxDQUFDLElBQUksRUFBRXZHO0lBQ2hDO0lBQ0FvQyxnQkFBZ0JSLFFBQVEsRUFBRTtRQUN0Qiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDQSxVQUFVO1lBQ1gsT0FBTztRQUNYO1FBQ0EsTUFBTVYsU0FBUyxJQUFJLENBQUNyQixRQUFRLENBQUNtQyxTQUFTLENBQUNKO1FBQ3ZDL0UsVUFBVXFFLFFBQVEsQ0FBQywwQ0FBMEMsRUFBRVUsU0FBUyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxJQUFJLENBQUNsQixVQUFVLE1BQU0sSUFBSSxDQUFDcUIsT0FBTyxJQUFJO1lBQ3RDLE9BQU87UUFDWDtRQUNBLE1BQU1hLGFBQWEsSUFBSSxDQUFDL0MsUUFBUSxDQUFDMkQsYUFBYSxDQUFDNUI7UUFDL0MsTUFBTWlCLGtCQUFrQixJQUFJLENBQUNNLFdBQVc7UUFDeEMsT0FBT1IsWUFBWUMsWUFBWUMsb0JBQW9CM0IsT0FBT3NGLE9BQU8sQ0FBQyxJQUFJLEVBQUU1RTtJQUM1RTtJQUNBbEIsYUFBYTtRQUNULE9BQU8rRixRQUFRLElBQUksQ0FBQ3RELFdBQVc7SUFDbkM7SUFDQXVELGlCQUFpQjFHLFFBQVEsRUFBRTtRQUN2Qiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDQSxVQUFVO1lBQ1gsT0FBTztRQUNYO1FBQ0EsTUFBTUcsU0FBUyxJQUFJLENBQUNOLFFBQVEsQ0FBQ08sU0FBUyxDQUFDSixVQUFVO1FBQ2pEbkQsVUFBVXNELFFBQVEsQ0FBQywwQ0FBMEMsRUFBRUgsU0FBUyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxJQUFJLENBQUNVLFVBQVUsTUFBTSxDQUFDLElBQUksQ0FBQ0QsY0FBYyxJQUFJO1lBQzlDLE9BQU87UUFDWDtRQUNBLE1BQU1rRyxhQUFhLElBQUksQ0FBQzlHLFFBQVEsQ0FBQ1csYUFBYSxDQUFDUjtRQUMvQyxNQUFNNkMsa0JBQWtCLElBQUksQ0FBQ00sV0FBVztRQUN4QyxJQUFJd0QsZUFBZTlELGlCQUFpQjtZQUNoQyxPQUFPO1FBQ1g7UUFDQSxPQUFPMUMsT0FBT08sVUFBVSxDQUFDLElBQUksRUFBRVY7SUFDbkM7SUFDQTRHLGFBQWFoRixRQUFRLEVBQUVwQyxVQUFVO1FBQzdCcUgsU0FBUztJQUNiLENBQUMsRUFBRTtRQUNDLDhCQUE4QjtRQUM5QixJQUFJLENBQUNqRixVQUFVO1lBQ1gsT0FBTztRQUNYO1FBQ0EsTUFBTSxFQUFFaUYsT0FBTyxFQUFHLEdBQUdySDtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDa0IsVUFBVSxJQUFJO1lBQ3BCLE9BQU87UUFDWDtRQUNBLE1BQU1rQyxhQUFhLElBQUksQ0FBQy9DLFFBQVEsQ0FBQzJELGFBQWEsQ0FBQzVCO1FBQy9DLE1BQU1pQixrQkFBa0IsSUFBSSxDQUFDTSxXQUFXO1FBQ3hDLElBQUlOLG1CQUFtQixDQUFDRixZQUFZQyxZQUFZQyxrQkFBa0I7WUFDOUQsT0FBTztRQUNYO1FBQ0EsTUFBTW5CLFlBQVksSUFBSSxDQUFDUyxZQUFZO1FBQ25DLElBQUksQ0FBQ1QsVUFBVTVhLE1BQU0sRUFBRTtZQUNuQixPQUFPO1FBQ1g7UUFDQSxNQUFNK1UsUUFBUTZGLFVBQVUvYSxPQUFPLENBQUNpYjtRQUNoQyxJQUFJaUYsU0FBUztZQUNULE9BQU9oTCxVQUFVNkYsVUFBVTVhLE1BQU0sR0FBRztRQUN4QyxPQUFPO1lBQ0gsT0FBTytVLFFBQVEsQ0FBQztRQUNwQjtJQUNKO0lBQ0FzSCxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUNjLEtBQUssQ0FBQ3pJLFFBQVEsR0FBR3NMLGFBQWEsQ0FBQ3ZHLFFBQVE7SUFDdkQ7SUFDQXdHLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQzlDLEtBQUssQ0FBQ3pJLFFBQVEsR0FBR3NMLGFBQWEsQ0FBQ3BKLElBQUk7SUFDbkQ7SUFDQStFLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ3dCLEtBQUssQ0FBQ3pJLFFBQVEsR0FBR3NMLGFBQWEsQ0FBQzlHLFFBQVE7SUFDdkQ7SUFDQW1DLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQzhCLEtBQUssQ0FBQ3pJLFFBQVEsR0FBR3NMLGFBQWEsQ0FBQ3BGLFNBQVM7SUFDeEQ7SUFDQVEsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJLENBQUMrQixLQUFLLENBQUN6SSxRQUFRLEdBQUdzTCxhQUFhLENBQUNqRixVQUFVO0lBQ3pEO0lBQ0FFLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ2tDLEtBQUssQ0FBQ3pJLFFBQVEsR0FBR3NMLGFBQWEsQ0FBQy9FLE9BQU87SUFDdEQ7SUFDQXRCLGlCQUFpQjtRQUNiLE9BQU9nRyxRQUFRLElBQUksQ0FBQ3hDLEtBQUssQ0FBQ3pJLFFBQVEsR0FBR3NMLGFBQWEsQ0FBQ3JHLGNBQWM7SUFDckU7SUFDQXVHLHlCQUF5QjtRQUNyQixPQUFPLElBQUksQ0FBQy9DLEtBQUssQ0FBQ3pJLFFBQVEsR0FBRzZLLFVBQVUsQ0FBQ3JCLG1CQUFtQjtJQUMvRDtJQUNBaUMsK0JBQStCO1FBQzNCLE9BQU8sSUFBSSxDQUFDaEQsS0FBSyxDQUFDekksUUFBUSxHQUFHNkssVUFBVSxDQUFDcEIseUJBQXlCO0lBQ3JFO0lBQ0FpQyxrQkFBa0I7UUFDZCxPQUFPLElBQUksQ0FBQ2pELEtBQUssQ0FBQ3pJLFFBQVEsR0FBRzZLLFVBQVUsQ0FBQ3JILFlBQVk7SUFDeEQ7SUFDQVUsd0JBQXdCO1FBQ3BCLE9BQU9BLHNCQUFzQixJQUFJLENBQUN1RSxLQUFLLENBQUN6SSxRQUFRLEdBQUc2SyxVQUFVO0lBQ2pFO0lBQ0FuQixpQ0FBaUM7UUFDN0IsT0FBT0EsK0JBQStCLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ3pJLFFBQVEsR0FBRzZLLFVBQVU7SUFDMUU7SUFDQXJNLFlBQVlpSyxLQUFLLEVBQUVwRSxRQUFRLENBQUM7UUFDeEIsSUFBSSxDQUFDb0UsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3BFLFFBQVEsR0FBR0E7SUFDcEI7QUFDSjtBQUVBLDRFQUE0RTtBQUM1RSxvRUFBb0U7QUFDcEUsaUZBQWlGO0FBQ2pGLG1FQUFtRTtBQUNuRSxnQkFBZ0IsR0FBRyxNQUFNc0gsUUFBUSxPQUFPQyxXQUFXLGNBQWNBLFNBQVNDO0FBQzFFLE1BQU1DLDBCQUEwQkgsTUFBTUksZ0JBQWdCLElBQUlKLE1BQU1LLHNCQUFzQjtBQUN0RixTQUFTQyx5QkFBeUJDLFFBQVE7SUFDdEMsT0FBTyxTQUFTQztRQUNaLHFFQUFxRTtRQUNyRSxzRUFBc0U7UUFDdEUscUVBQXFFO1FBQ3JFLGtCQUFrQjtRQUNsQixNQUFNQyxnQkFBZ0JuUyxXQUFXb1MsYUFBYTtRQUM5QywrREFBK0Q7UUFDL0QsOERBQThEO1FBQzlELGtEQUFrRDtRQUNsRCxNQUFNQyxpQkFBaUJDLFlBQVlGLGFBQWE7UUFDaEQsU0FBU0E7WUFDTCx1REFBdUQ7WUFDdkQsd0JBQXdCO1lBQ3hCdFMsYUFBYXFTO1lBQ2JJLGNBQWNGO1lBQ2RKO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsOEVBQThFO0FBQzlFLGdEQUFnRDtBQUNoRCxTQUFTTyxvQ0FBb0NQLFFBQVE7SUFDakQsSUFBSVEsU0FBUztJQUNiLE1BQU01TCxXQUFXLElBQUlnTCx3QkFBd0JJO0lBQzdDLE1BQU1TLE9BQU9DLFNBQVNDLGNBQWMsQ0FBQztJQUNyQy9MLFNBQVNnTSxPQUFPLENBQUNILE1BQU07UUFDbkJJLGVBQWU7SUFDbkI7SUFDQSxPQUFPLFNBQVNaO1FBQ1pPLFNBQVMsQ0FBQ0E7UUFDVkMsS0FBS0ssSUFBSSxHQUFHTjtJQUNoQjtBQUNKO0FBQ0EsTUFBTU8sa0JBQWtCLE9BQU9uQiw0QkFBNEIsYUFDM0QsK0NBQStDO0FBQy9DLEVBQUU7QUFDRixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixlQUFlO0FBQ2ZXLHNDQUNBLDZDQUE2QztBQUM3Qyw2RUFBNkU7QUFDN0UseURBQXlEO0FBQ3pELHFFQUFxRTtBQUNyRSwwRUFBMEU7QUFDMUUsOEJBQThCO0FBQzlCLHNFQUFzRTtBQUN0RSxtRUFBbUU7QUFDbkUsMkJBQTJCO0FBQzNCLDhFQUE4RTtBQUM5RSxpRUFBaUU7QUFDakUsbURBQW1EO0FBQ25ELDRDQUE0QztBQUM1QyxzQ0FBc0M7QUFDdEMsdUVBQXVFO0FBQ3ZFLHNDQUFzQztBQUN0Qyw0RUFBNEU7QUFDNUUsOEJBQThCO0FBQzlCLEVBQUU7QUFDRixpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQixlQUFlO0FBQ2ZSO0FBRUEsTUFBTWlCO0lBQ0YseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxzQkFBc0I7SUFDdEIsRUFBRTtJQUNGLDZFQUE2RTtJQUM3RSx3RUFBd0U7SUFDeEUsK0VBQStFO0lBQy9FLDhFQUE4RTtJQUM5RSw2RUFBNkU7SUFDN0UseURBQXlEO0lBQ3pEQyxZQUFZQyxJQUFJLEVBQUU7UUFDZCxNQUFNLEVBQUVDLE9BQU9DLENBQUMsRUFBR0MsWUFBWSxFQUFHLEdBQUcsSUFBSTtRQUN6QyxJQUFJLENBQUNELEVBQUVoaUIsTUFBTSxFQUFFO1lBQ1hpaUI7WUFDQSxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNwQjtRQUNBLGtEQUFrRDtRQUNsREYsQ0FBQyxDQUFDQSxFQUFFaGlCLE1BQU0sQ0FBQyxHQUFHOGhCO0lBQ2xCO0lBQ0E1TyxhQUFhO1FBQ1QsSUFBSSxDQUFDNk8sS0FBSyxHQUFHLEVBQUU7UUFDZixtRUFBbUU7UUFDbkUsaUZBQWlGO1FBQ2pGLElBQUksQ0FBQ0ksYUFBYSxHQUFHLEVBQUU7UUFDdkIsMEVBQTBFO1FBQzFFLDhDQUE4QztRQUM5QyxhQUFhO1FBQ2IsSUFBSSxDQUFDRCxRQUFRLEdBQUc7UUFDaEIsc0VBQXNFO1FBQ3RFLGtFQUFrRTtRQUNsRSw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDbk4sS0FBSyxHQUFHO1FBQ2IsNEVBQTRFO1FBQzVFLDRFQUE0RTtRQUM1RSxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDcU4sUUFBUSxHQUFHO1FBQ2hCLHVFQUF1RTtRQUN2RSxxRUFBcUU7UUFDckUsNEVBQTRFO1FBQzVFLGtFQUFrRTtRQUNsRSwyRUFBMkU7UUFDM0UsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1lBQ1QsTUFBTSxFQUFFTixPQUFPQyxDQUFDLEVBQUcsR0FBRyxJQUFJO1lBQzFCLE1BQU0sSUFBSSxDQUFDak4sS0FBSyxHQUFHaU4sRUFBRWhpQixNQUFNLENBQUM7Z0JBQ3hCLE1BQU1zaUIsZUFBZSxJQUFJLENBQUN2TixLQUFLO2dCQUMvQix1RUFBdUU7Z0JBQ3ZFLDREQUE0RDtnQkFDNUQsSUFBSSxDQUFDQSxLQUFLO2dCQUNWaU4sQ0FBQyxDQUFDTSxhQUFhLENBQUMxaUIsSUFBSTtnQkFDcEIsdUVBQXVFO2dCQUN2RSxxRUFBcUU7Z0JBQ3JFLHNFQUFzRTtnQkFDdEUsMkRBQTJEO2dCQUMzRCwyREFBMkQ7Z0JBQzNELElBQUksSUFBSSxDQUFDbVYsS0FBSyxHQUFHLElBQUksQ0FBQ3FOLFFBQVEsRUFBRTtvQkFDNUIsOERBQThEO29CQUM5RCwwQkFBMEI7b0JBQzFCLElBQUksSUFBSUcsT0FBTyxHQUFHQyxZQUFZUixFQUFFaGlCLE1BQU0sR0FBRyxJQUFJLENBQUMrVSxLQUFLLEVBQUV3TixPQUFPQyxXQUFXRCxPQUFPO3dCQUMxRVAsQ0FBQyxDQUFDTyxLQUFLLEdBQUdQLENBQUMsQ0FBQ08sT0FBTyxJQUFJLENBQUN4TixLQUFLLENBQUM7b0JBQ2xDO29CQUNBaU4sRUFBRWhpQixNQUFNLElBQUksSUFBSSxDQUFDK1UsS0FBSztvQkFDdEIsSUFBSSxDQUFDQSxLQUFLLEdBQUc7Z0JBQ2pCO1lBQ0o7WUFDQWlOLEVBQUVoaUIsTUFBTSxHQUFHO1lBQ1gsSUFBSSxDQUFDK1UsS0FBSyxHQUFHO1lBQ2IsSUFBSSxDQUFDbU4sUUFBUSxHQUFHO1FBQ3BCO1FBQ0EsZ0VBQWdFO1FBQ2hFLHFFQUFxRTtRQUNyRSx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDTyxvQkFBb0IsR0FBRyxDQUFDQztZQUN6QixJQUFJLENBQUNQLGFBQWEsQ0FBQ2pULElBQUksQ0FBQ3dUO1lBQ3hCLElBQUksQ0FBQ0MsaUJBQWlCO1FBQzFCO1FBQ0EsMkVBQTJFO1FBQzNFLG9CQUFvQjtRQUNwQiw4RUFBOEU7UUFDOUUsOENBQThDO1FBQzlDLG9EQUFvRDtRQUNwRCw4RUFBOEU7UUFDOUUsMkVBQTJFO1FBQzNFLHlHQUF5RztRQUN6RyxJQUFJLENBQUNWLFlBQVksR0FBR04sZ0JBQWdCLElBQUksQ0FBQ1UsS0FBSztRQUM5QyxJQUFJLENBQUNNLGlCQUFpQixHQUFHaEMseUJBQXlCO1lBQzlDLG9CQUFvQjtZQUNwQixJQUFJLElBQUksQ0FBQ3dCLGFBQWEsQ0FBQ25pQixNQUFNLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSSxDQUFDbWlCLGFBQWEsQ0FBQzNTLEtBQUs7WUFDbEM7UUFDSjtJQUNKO0FBQ0osRUFBRSx3RUFBd0U7QUFDekUsd0NBQXdDO0FBQ3hDLHdEQUF3RDtBQUN4RCw0RUFBNEU7QUFDNUUsaUVBQWlFO0FBQ2pFLGlFQUFpRTtBQUNqRSx5REFBeUQ7QUFDekQsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQyxzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLFNBQVM7QUFDVCxJQUFJO0FBQ0osd0VBQXdFO0FBQ3hFLDJCQUEyQjtBQUMzQixpRUFBaUU7QUFDakUsMEVBQTBFO0FBQzFFLDZFQUE2RTtBQUM3RSxXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLHVEQUF1RDtBQUN2RCxzQ0FBc0M7QUFDdEMsa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVCxJQUFJO0FBQ0osd0VBQXdFO0FBQ3hFLDJFQUEyRTtBQUMzRSw4REFBOEQ7QUFDOUQsK0VBQStFO0FBQy9FLDREQUE0RDtBQUM1RCwyRUFBMkU7QUFDM0UsNEVBQTRFO0FBQzVFLGFBQWE7QUFDYiw4QkFBOEI7QUFDOUIsNkVBQTZFO0FBQzdFLG9CQUFvQjtBQUNwQiw4REFBOEQ7QUFDOUQsMkVBQTJFO0FBQzNFLDBFQUEwRTtBQUMxRSw4RUFBOEU7QUFDOUUsK0VBQStFO0FBQy9FLHlCQUF5QjtBQUN6QixvR0FBb0c7QUFFckcsZ0NBQWdDO0FBQ2hDLE1BQU1vVDtJQUNGaGpCLE9BQU87UUFDSCxJQUFJO1lBQ0EsSUFBSSxDQUFDa2lCLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUk7UUFDMUIsRUFBRSxPQUFPak0sT0FBTztZQUNaLElBQUksQ0FBQ2dOLE9BQU8sQ0FBQ2hOO1FBQ2pCLFNBQVM7WUFDTCxJQUFJLENBQUNpTSxJQUFJLEdBQUc7WUFDWixJQUFJLENBQUNnQixPQUFPLENBQUMsSUFBSTtRQUNyQjtJQUNKO0lBQ0E1UCxZQUFZMlAsT0FBTyxFQUFFQyxPQUFPLENBQUM7UUFDekIsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDaEIsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFFQSxNQUFNaUI7SUFDRkMsT0FBT2xCLElBQUksRUFBRTtRQUNULE1BQU1tQixRQUFRLElBQUksQ0FBQ0MsU0FBUztRQUM1QixNQUFNQyxLQUFLRixNQUFNampCLE1BQU0sR0FBR2lqQixNQUFNRyxHQUFHLEtBQUssSUFBSVIsUUFBUSxJQUFJLENBQUNDLE9BQU8sRUFBRSxDQUFDdGpCLElBQUkwakIsS0FBSyxDQUFDQSxNQUFNampCLE1BQU0sQ0FBQyxHQUFHVDtRQUU3RjRqQixHQUFHckIsSUFBSSxHQUFHQTtRQUNWLE9BQU9xQjtJQUNYO0lBQ0FqUSxZQUFZMlAsT0FBTyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0ssU0FBUyxHQUFHLEVBQUU7SUFDdkI7QUFDSjtBQUVBLE1BQU1HLFlBQVksSUFBSXpCO0FBQ3RCLE1BQU0wQixjQUFjLElBQUlQLFlBQVlNLFVBQVVaLG9CQUFvQjtBQUNsRTs7Ozs7OztDQU9DLEdBQUcsU0FBU2MsS0FBS3pCLElBQUk7SUFDbEJ1QixVQUFVeEIsV0FBVyxDQUFDeUIsWUFBWU4sTUFBTSxDQUFDbEI7QUFDN0M7QUFFQSxNQUFNMEIsYUFBYTtBQUNuQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGdCQUFnQjtBQUN0QixNQUFNQyxnQkFBZ0I7QUFDdEIsU0FBU0MsVUFBVTFLLFFBQVE7SUFDdkIsT0FBTztRQUNIdEcsTUFBTTRRO1FBQ05wTCxTQUFTO1lBQ0xjO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBUzJLLFVBQVUvSSxRQUFRO0lBQ3ZCLE9BQU87UUFDSGxJLE1BQU02UTtRQUNOckwsU0FBUztZQUNMMEM7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTZ0osYUFBYTVLLFFBQVE7SUFDMUIsT0FBTztRQUNIdEcsTUFBTThRO1FBQ050TCxTQUFTO1lBQ0xjO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBUzZLLGFBQWFqSixRQUFRO0lBQzFCLE9BQU87UUFDSGxJLE1BQU0rUTtRQUNOdkwsU0FBUztZQUNMMEM7UUFDSjtJQUNKO0FBQ0o7QUFFQSxTQUFTa0osdUJBQXVCM0ssTUFBTTtJQUNsQ3RELFVBQVUsT0FBT3NELE9BQU9vRyxPQUFPLEtBQUssWUFBWTtJQUNoRDFKLFVBQVUsT0FBT3NELE9BQU9iLFNBQVMsS0FBSyxZQUFZO0lBQ2xEekMsVUFBVSxPQUFPc0QsT0FBT29DLE9BQU8sS0FBSyxZQUFZO0FBQ3BEO0FBQ0EsU0FBU3dJLHVCQUF1QjdKLE1BQU07SUFDbENyRSxVQUFVLE9BQU9xRSxPQUFPc0YsT0FBTyxLQUFLLFlBQVk7SUFDaEQzSixVQUFVLE9BQU9xRSxPQUFPOEIsS0FBSyxLQUFLLFlBQVk7SUFDOUNuRyxVQUFVLE9BQU9xRSxPQUFPTSxJQUFJLEtBQUssWUFBWTtBQUNqRDtBQUNBLFNBQVN3SixhQUFhdFIsSUFBSSxFQUFFdVIsVUFBVTtJQUNsQyxJQUFJQSxjQUFjOWIsTUFBTUMsT0FBTyxDQUFDc0ssT0FBTztRQUNuQ0EsS0FBSzFNLE9BQU8sQ0FBQyxDQUFDM0csSUFBSTJrQixhQUFhM2tCLEdBQUc7UUFFbEM7SUFDSjtJQUNBd1csVUFBVSxPQUFPbkQsU0FBUyxZQUFZLE9BQU9BLFNBQVMsVUFBVXVSLGFBQWEsZ0VBQWdFO0FBQ2pKO0FBRUEsSUFBSUM7QUFDSCxVQUFTQSxXQUFXO0lBQ2pCQSxXQUFXLENBQUMsU0FBUyxHQUFHO0lBQ3hCQSxXQUFXLENBQUMsU0FBUyxHQUFHO0FBQzVCLEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFFbEMsSUFBSUMsZUFBZTtBQUNuQixTQUFTQztJQUNMLE9BQU9EO0FBQ1g7QUFFQSxTQUFTRSxpQkFBaUJDLElBQUk7SUFDMUIsTUFBTXJmLEtBQUttZixrQkFBa0J2UyxRQUFRO0lBQ3JDLE9BQU95UztRQUNILEtBQUtKLFlBQVlLLE1BQU07WUFDbkIsT0FBTyxDQUFDLENBQUMsRUFBRXRmLEdBQUcsQ0FBQztRQUNuQixLQUFLaWYsWUFBWU0sTUFBTTtZQUNuQixPQUFPLENBQUMsQ0FBQyxFQUFFdmYsR0FBRyxDQUFDO1FBQ25CO1lBQ0ksTUFBTSxJQUFJaU8sTUFBTSxDQUFDLHNCQUFzQixFQUFFb1IsS0FBSyxDQUFDO0lBQ3ZEO0FBQ0o7QUFDQSxTQUFTRyx1QkFBdUJDLFNBQVM7SUFDckMsT0FBT0EsU0FBUyxDQUFDLEVBQUU7UUFDZixLQUFLO1lBQ0QsT0FBT1IsWUFBWUssTUFBTTtRQUM3QixLQUFLO1lBQ0QsT0FBT0wsWUFBWU0sTUFBTTtRQUM3QjtZQUNJLE1BQU0sSUFBSXRSLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRXdSLFVBQVUsQ0FBQztJQUMvRDtBQUNKO0FBQ0EsU0FBU0MsaUJBQWlCM04sR0FBRyxFQUFFNE4sV0FBVztJQUN0QyxNQUFNdlcsVUFBVTJJLElBQUkzSSxPQUFPO0lBQzNCLElBQUl3VyxTQUFTO0lBQ2IsR0FBRztRQUNDLE1BQU0sRUFBRUMsSUFBSSxFQUFHaFYsT0FBTyxHQUFHQSxNQUFNLEVBQUssR0FBR3pCLFFBQVFtSCxJQUFJO1FBQ25ELElBQUkxRixVQUFVOFUsYUFBYTtZQUN2QixPQUFPO1FBQ1g7UUFDQUMsU0FBUyxDQUFDLENBQUNDO0lBQ2YsUUFBUSxDQUFDRCxRQUFPO0lBQ2hCLE9BQU87QUFDWDtBQUNBLE1BQU1FO0lBQ0ZyQixVQUFVaFIsSUFBSSxFQUFFeUcsTUFBTSxFQUFFO1FBQ3BCNkssYUFBYXRSO1FBQ2JvUix1QkFBdUIzSztRQUN2QixNQUFNSCxXQUFXLElBQUksQ0FBQ2dNLFVBQVUsQ0FBQ2QsWUFBWUssTUFBTSxFQUFFN1IsTUFBTXlHO1FBQzNELElBQUksQ0FBQzhELEtBQUssQ0FBQ2xJLFFBQVEsQ0FBQzJPLFVBQVUxSztRQUM5QixPQUFPQTtJQUNYO0lBQ0EySyxVQUFValIsSUFBSSxFQUFFd0gsTUFBTSxFQUFFO1FBQ3BCOEosYUFBYXRSLE1BQU07UUFDbkJxUix1QkFBdUI3SjtRQUN2QixNQUFNVSxXQUFXLElBQUksQ0FBQ29LLFVBQVUsQ0FBQ2QsWUFBWU0sTUFBTSxFQUFFOVIsTUFBTXdIO1FBQzNELElBQUksQ0FBQytDLEtBQUssQ0FBQ2xJLFFBQVEsQ0FBQzRPLFVBQVUvSTtRQUM5QixPQUFPQTtJQUNYO0lBQ0FxSyxnQkFBZ0JDLE9BQU8sRUFBRTtRQUNyQixPQUFPUCxpQkFBaUIsSUFBSSxDQUFDUSxXQUFXLEVBQUVELFlBQVlQLGlCQUFpQixJQUFJLENBQUNTLFdBQVcsRUFBRUY7SUFDN0Y7SUFDQTlMLFVBQVVKLFFBQVEsRUFBRXFNLGdCQUFnQixLQUFLLEVBQUU7UUFDdkN4UCxVQUFVLElBQUksQ0FBQ3lQLFVBQVUsQ0FBQ3RNLFdBQVc7UUFDckMsTUFBTXVNLFdBQVdGLGlCQUFpQnJNLGFBQWEsSUFBSSxDQUFDd00sY0FBYztRQUNsRSxNQUFNck0sU0FBU29NLFdBQVcsSUFBSSxDQUFDRSxZQUFZLEdBQUcsSUFBSSxDQUFDTixXQUFXLENBQUMvTyxHQUFHLENBQUM0QztRQUNuRSxPQUFPRztJQUNYO0lBQ0E2QixVQUFVSixRQUFRLEVBQUU7UUFDaEIvRSxVQUFVLElBQUksQ0FBQzZQLFVBQVUsQ0FBQzlLLFdBQVc7UUFDckMsT0FBTyxJQUFJLENBQUN3SyxXQUFXLENBQUNoUCxHQUFHLENBQUN3RTtJQUNoQztJQUNBcEIsY0FBY1IsUUFBUSxFQUFFO1FBQ3BCbkQsVUFBVSxJQUFJLENBQUN5UCxVQUFVLENBQUN0TSxXQUFXO1FBQ3JDLE9BQU8sSUFBSSxDQUFDMk0sS0FBSyxDQUFDdlAsR0FBRyxDQUFDNEM7SUFDMUI7SUFDQXdELGNBQWM1QixRQUFRLEVBQUU7UUFDcEIvRSxVQUFVLElBQUksQ0FBQzZQLFVBQVUsQ0FBQzlLLFdBQVc7UUFDckMsT0FBTyxJQUFJLENBQUMrSyxLQUFLLENBQUN2UCxHQUFHLENBQUN3RTtJQUMxQjtJQUNBMEssV0FBV1osU0FBUyxFQUFFO1FBQ2xCLE1BQU1KLE9BQU9HLHVCQUF1QkM7UUFDcEMsT0FBT0osU0FBU0osWUFBWUssTUFBTTtJQUN0QztJQUNBbUIsV0FBV2hCLFNBQVMsRUFBRTtRQUNsQixNQUFNSixPQUFPRyx1QkFBdUJDO1FBQ3BDLE9BQU9KLFNBQVNKLFlBQVlNLE1BQU07SUFDdEM7SUFDQVosYUFBYTVLLFFBQVEsRUFBRTtRQUNuQm5ELFVBQVUsSUFBSSxDQUFDdUQsU0FBUyxDQUFDSixXQUFXO1FBQ3BDLElBQUksQ0FBQ2lFLEtBQUssQ0FBQ2xJLFFBQVEsQ0FBQzZPLGFBQWE1SztRQUNqQ3FLLEtBQUs7WUFDRCxJQUFJLENBQUM4QixXQUFXLENBQUNTLE1BQU0sQ0FBQzVNO1lBQ3hCLElBQUksQ0FBQzJNLEtBQUssQ0FBQ0MsTUFBTSxDQUFDNU07UUFDdEI7SUFDSjtJQUNBNkssYUFBYWpKLFFBQVEsRUFBRTtRQUNuQi9FLFVBQVUsSUFBSSxDQUFDbUYsU0FBUyxDQUFDSixXQUFXO1FBQ3BDLElBQUksQ0FBQ3FDLEtBQUssQ0FBQ2xJLFFBQVEsQ0FBQzhPLGFBQWFqSjtRQUNqQyxJQUFJLENBQUN3SyxXQUFXLENBQUNRLE1BQU0sQ0FBQ2hMO1FBQ3hCLElBQUksQ0FBQytLLEtBQUssQ0FBQ0MsTUFBTSxDQUFDaEw7SUFDdEI7SUFDQXRCLFVBQVVOLFFBQVEsRUFBRTtRQUNoQixNQUFNRyxTQUFTLElBQUksQ0FBQ0MsU0FBUyxDQUFDSjtRQUM5Qm5ELFVBQVVzRCxRQUFRO1FBQ2xCLElBQUksQ0FBQ3FNLGNBQWMsR0FBR3hNO1FBQ3RCLElBQUksQ0FBQ3lNLFlBQVksR0FBR3RNO0lBQ3hCO0lBQ0F1QyxjQUFjO1FBQ1Y3RixVQUFVLElBQUksQ0FBQzRQLFlBQVksRUFBRTtRQUM3QixJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFlBQVksR0FBRztJQUN4QjtJQUNBVCxXQUFXVixJQUFJLEVBQUU1UixJQUFJLEVBQUV3UyxPQUFPLEVBQUU7UUFDNUIsTUFBTWpnQixLQUFLb2YsaUJBQWlCQztRQUM1QixJQUFJLENBQUNxQixLQUFLLENBQUN4TyxHQUFHLENBQUNsUyxJQUFJeU47UUFDbkIsSUFBSTRSLFNBQVNKLFlBQVlLLE1BQU0sRUFBRTtZQUM3QixJQUFJLENBQUNZLFdBQVcsQ0FBQ2hPLEdBQUcsQ0FBQ2xTLElBQUlpZ0I7UUFDN0IsT0FBTyxJQUFJWixTQUFTSixZQUFZTSxNQUFNLEVBQUU7WUFDcEMsSUFBSSxDQUFDWSxXQUFXLENBQUNqTyxHQUFHLENBQUNsUyxJQUFJaWdCO1FBQzdCO1FBQ0EsT0FBT2pnQjtJQUNYO0lBQ0ErTixZQUFZaUssS0FBSyxDQUFDO1FBQ2QsSUFBSSxDQUFDMEksS0FBSyxHQUFHLElBQUkxTztRQUNqQixJQUFJLENBQUNrTyxXQUFXLEdBQUcsSUFBSWxPO1FBQ3ZCLElBQUksQ0FBQ21PLFdBQVcsR0FBRyxJQUFJbk87UUFDdkIsSUFBSSxDQUFDdU8sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ3hJLEtBQUssR0FBR0E7SUFDakI7QUFDSjtBQUVBLE1BQU00SSxpQkFBaUIsQ0FBQ3pqQixHQUFHQyxJQUFJRCxNQUFNQztBQUVyQzs7OztDQUlDLEdBQUcsU0FBU3lqQixlQUFlQyxPQUFPLEVBQUVDLE9BQU87SUFDeEMsSUFBSSxDQUFDRCxXQUFXLENBQUNDLFNBQVM7UUFDdEIsT0FBTztJQUNYLE9BQU8sSUFBSSxDQUFDRCxXQUFXLENBQUNDLFNBQVM7UUFDN0IsT0FBTztJQUNYLE9BQU87UUFDSCxPQUFPRCxRQUFRdGdCLENBQUMsS0FBS3VnQixRQUFRdmdCLENBQUMsSUFBSXNnQixRQUFRcmdCLENBQUMsS0FBS3NnQixRQUFRdGdCLENBQUM7SUFDN0Q7QUFDSjtBQUNBOzs7O0NBSUMsR0FBRyxTQUFTdWdCLGVBQWU3akIsQ0FBQyxFQUFFQyxDQUFDLEVBQUU2akIsVUFBVUwsY0FBYztJQUN0RCxJQUFJempCLEVBQUV0QyxNQUFNLEtBQUt1QyxFQUFFdkMsTUFBTSxFQUFFO1FBQ3ZCLE9BQU87SUFDWDtJQUNBLElBQUksSUFBSUQsSUFBSSxHQUFHQSxJQUFJdUMsRUFBRXRDLE1BQU0sRUFBRSxFQUFFRCxFQUFFO1FBQzdCLElBQUksQ0FBQ3FtQixRQUFROWpCLENBQUMsQ0FBQ3ZDLEVBQUUsRUFBRXdDLENBQUMsQ0FBQ3hDLEVBQUUsR0FBRztZQUN0QixPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUVBLFNBQVNzbUIsU0FDVEMsU0FBU2pJLElBQUksRUFBRW5KLE1BQU07SUFDakIsT0FBT0EsT0FBT3RDLElBQUk7UUFDZCxLQUFLa0Y7WUFDRDtRQUNKLEtBQUswTDtRQUNMLEtBQUtDO1FBQ0wsS0FBS0U7UUFDTCxLQUFLRDtZQUNELE9BQU9yRjtRQUNYLEtBQUt6RztRQUNMLEtBQUtDO1FBQ0wsS0FBS0c7UUFDTCxLQUFLRDtRQUNMO1lBQ0ksT0FBT3VHO0lBQ2Y7SUFDQSxNQUFNLEVBQUUxRCxZQUFXLEVBQUUsRUFBRzJMLGdCQUFlLEVBQUUsRUFBRyxHQUFHclIsT0FBT2tELE9BQU87SUFDN0QsTUFBTWIsU0FBU1IsSUFBSTZELFdBQVcyTDtJQUM5QixNQUFNQyxZQUFZalAsT0FBT3ZYLE1BQU0sR0FBRyxLQUFLLENBQUNtbUIsZUFBZXZMLFdBQVcyTDtJQUNsRSxJQUFJLENBQUNDLFdBQVc7UUFDWixPQUFPbkk7SUFDWDtJQUNBLDhFQUE4RTtJQUM5RSxnQkFBZ0I7SUFDaEIsTUFBTW9JLHdCQUF3QkYsYUFBYSxDQUFDQSxjQUFjdm1CLE1BQU0sR0FBRyxFQUFFO0lBQ3JFLE1BQU0wbUIsb0JBQW9COUwsU0FBUyxDQUFDQSxVQUFVNWEsTUFBTSxHQUFHLEVBQUU7SUFDekQsSUFBSXltQiwwQkFBMEJDLG1CQUFtQjtRQUM3QyxJQUFJRCx1QkFBdUI7WUFDdkJsUCxPQUFPckksSUFBSSxDQUFDdVg7UUFDaEI7UUFDQSxJQUFJQyxtQkFBbUI7WUFDbkJuUCxPQUFPckksSUFBSSxDQUFDd1g7UUFDaEI7SUFDSjtJQUNBLE9BQU9uUDtBQUNYO0FBRUEsU0FBU29QLGtCQUFrQnBVLEdBQUcsRUFBRWtGLEdBQUcsRUFBRXpILEtBQUs7SUFDdEMsSUFBSXlILE9BQU9sRixLQUFLO1FBQ1o5UyxPQUFPc2EsY0FBYyxDQUFDeEgsS0FBS2tGLEtBQUs7WUFDNUJ6SCxPQUFPQTtZQUNQZ0ssWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7UUFDZDtJQUNKLE9BQU87UUFDSDNILEdBQUcsQ0FBQ2tGLElBQUksR0FBR3pIO0lBQ2Y7SUFDQSxPQUFPdUM7QUFDWDtBQUNBLFNBQVNxVSxnQkFBZ0J4TSxNQUFNO0lBQzNCLElBQUksSUFBSXJhLElBQUksR0FBR0EsSUFBSW9VLFVBQVVuVSxNQUFNLEVBQUVELElBQUk7UUFDckMsSUFBSXNaLFNBQVNsRixTQUFTLENBQUNwVSxFQUFFLElBQUksT0FBT29VLFNBQVMsQ0FBQ3BVLEVBQUUsR0FBRyxDQUFDO1FBQ3BELElBQUlzYSxVQUFVNWEsT0FBT3dHLElBQUksQ0FBQ29UO1FBQzFCLElBQUksT0FBTzVaLE9BQU9LLHFCQUFxQixLQUFLLFlBQVk7WUFDcER1YSxVQUFVQSxRQUFRQyxNQUFNLENBQUM3YSxPQUFPSyxxQkFBcUIsQ0FBQ3VaLFFBQVE3USxNQUFNLENBQUMsU0FBUytSLEdBQUc7Z0JBQzdFLE9BQU85YSxPQUFPK2Esd0JBQXdCLENBQUNuQixRQUFRa0IsS0FBS1AsVUFBVTtZQUNsRTtRQUNKO1FBQ0FLLFFBQVFuVSxPQUFPLENBQUMsU0FBU3VSLEdBQUc7WUFDeEJrUCxrQkFBa0J2TSxRQUFRM0MsS0FBSzRCLE1BQU0sQ0FBQzVCLElBQUk7UUFDOUM7SUFDSjtJQUNBLE9BQU8yQztBQUNYO0FBQ0EsTUFBTXlNLGlCQUFpQjtJQUNuQjFJLDJCQUEyQjtJQUMzQkQscUJBQXFCO0lBQ3JCaEcsY0FBYztBQUNsQjtBQUNBLFNBQVM0TyxTQUFTN0ksUUFBUTRJLGNBQWMsRUFBRTNSLE1BQU07SUFDNUMsTUFBTSxFQUFFa0QsT0FBTyxFQUFHLEdBQUdsRDtJQUNyQixPQUFPQSxPQUFPdEMsSUFBSTtRQUNkLEtBQUsrRTtRQUNMLEtBQUtDO1lBQ0QsT0FBTztnQkFDSHVHLDJCQUEyQi9GLFFBQVFELGtCQUFrQjtnQkFDckQrRixxQkFBcUI5RixRQUFRRixZQUFZO2dCQUN6Q0EsY0FBY0UsUUFBUUYsWUFBWTtZQUN0QztRQUNKLEtBQUtKO1lBQ0QsSUFBSWtPLGVBQWUvSCxNQUFNL0YsWUFBWSxFQUFFRSxRQUFRRixZQUFZLEdBQUc7Z0JBQzFELE9BQU8rRjtZQUNYO1lBQ0EsT0FBTzJJLGdCQUFnQixDQUFDLEdBQUczSSxPQUFPO2dCQUM5Qi9GLGNBQWNFLFFBQVFGLFlBQVk7WUFDdEM7UUFDSixLQUFLRjtRQUNMLEtBQUtEO1lBQ0QsT0FBTzhPO1FBQ1g7WUFDSSxPQUFPNUk7SUFDZjtBQUNKO0FBRUEsU0FBUzhJLGtCQUFrQnhVLEdBQUcsRUFBRWtGLEdBQUcsRUFBRXpILEtBQUs7SUFDdEMsSUFBSXlILE9BQU9sRixLQUFLO1FBQ1o5UyxPQUFPc2EsY0FBYyxDQUFDeEgsS0FBS2tGLEtBQUs7WUFDNUJ6SCxPQUFPQTtZQUNQZ0ssWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7UUFDZDtJQUNKLE9BQU87UUFDSDNILEdBQUcsQ0FBQ2tGLElBQUksR0FBR3pIO0lBQ2Y7SUFDQSxPQUFPdUM7QUFDWDtBQUNBLFNBQVN5VSxnQkFBZ0I1TSxNQUFNO0lBQzNCLElBQUksSUFBSXJhLElBQUksR0FBR0EsSUFBSW9VLFVBQVVuVSxNQUFNLEVBQUVELElBQUk7UUFDckMsSUFBSXNaLFNBQVNsRixTQUFTLENBQUNwVSxFQUFFLElBQUksT0FBT29VLFNBQVMsQ0FBQ3BVLEVBQUUsR0FBRyxDQUFDO1FBQ3BELElBQUlzYSxVQUFVNWEsT0FBT3dHLElBQUksQ0FBQ29UO1FBQzFCLElBQUksT0FBTzVaLE9BQU9LLHFCQUFxQixLQUFLLFlBQVk7WUFDcER1YSxVQUFVQSxRQUFRQyxNQUFNLENBQUM3YSxPQUFPSyxxQkFBcUIsQ0FBQ3VaLFFBQVE3USxNQUFNLENBQUMsU0FBUytSLEdBQUc7Z0JBQzdFLE9BQU85YSxPQUFPK2Esd0JBQXdCLENBQUNuQixRQUFRa0IsS0FBS1AsVUFBVTtZQUNsRTtRQUNKO1FBQ0FLLFFBQVFuVSxPQUFPLENBQUMsU0FBU3VSLEdBQUc7WUFDeEJzUCxrQkFBa0IzTSxRQUFRM0MsS0FBSzRCLE1BQU0sQ0FBQzVCLElBQUk7UUFDOUM7SUFDSjtJQUNBLE9BQU8yQztBQUNYO0FBQ0EsTUFBTTZNLGVBQWU7SUFDakJ4TixVQUFVO0lBQ1Y3QyxNQUFNO0lBQ05zQyxVQUFVO0lBQ1YwQixXQUFXLEVBQUU7SUFDYkcsWUFBWTtJQUNaRSxTQUFTO0lBQ1R0QixnQkFBZ0I7QUFDcEI7QUFDQSxTQUFTdU4sU0FBU2pKLFFBQVFnSixZQUFZLEVBQUUvUixNQUFNO0lBQzFDLE1BQU0sRUFBRWtELE9BQU8sRUFBRyxHQUFHbEQ7SUFDckIsT0FBT0EsT0FBT3RDLElBQUk7UUFDZCxLQUFLZ0Y7WUFDRCxPQUFPb1AsZ0JBQWdCLENBQUMsR0FBRy9JLE9BQU87Z0JBQzlCeEUsVUFBVXJCLFFBQVFxQixRQUFRO2dCQUMxQjdDLE1BQU13QixRQUFReEIsSUFBSTtnQkFDbEJzQyxVQUFVZCxRQUFRYyxRQUFRO2dCQUMxQlMsZ0JBQWdCdkIsUUFBUXVCLGNBQWM7Z0JBQ3RDb0IsWUFBWTtnQkFDWkUsU0FBUztZQUNiO1FBQ0osS0FBS3BEO1lBQ0QsT0FBT21QLGdCQUFnQixDQUFDLEdBQUcvSSxPQUFPO2dCQUM5QnRFLGdCQUFnQjtZQUNwQjtRQUNKLEtBQUs3QjtZQUNELE9BQU9rUCxnQkFBZ0IsQ0FBQyxHQUFHL0ksT0FBTztnQkFDOUJyRCxXQUFXeEMsUUFBUXdDLFNBQVM7WUFDaEM7UUFDSixLQUFLK0k7WUFDRCxJQUFJMUYsTUFBTXJELFNBQVMsQ0FBQy9hLE9BQU8sQ0FBQ3VZLFFBQVEwQyxRQUFRLE1BQU0sQ0FBQyxHQUFHO2dCQUNsRCxPQUFPbUQ7WUFDWDtZQUNBLE9BQU8rSSxnQkFBZ0IsQ0FBQyxHQUFHL0ksT0FBTztnQkFDOUJyRCxXQUFXbEUsVUFBVXVILE1BQU1yRCxTQUFTLEVBQUV4QyxRQUFRMEMsUUFBUTtZQUMxRDtRQUNKLEtBQUsvQztZQUNELE9BQU9pUCxnQkFBZ0IsQ0FBQyxHQUFHL0ksT0FBTztnQkFDOUJsRCxZQUFZM0MsUUFBUTJDLFVBQVU7Z0JBQzlCRSxTQUFTO2dCQUNUTCxXQUFXLEVBQUU7WUFDakI7UUFDSixLQUFLNUM7WUFDRCxPQUFPZ1AsZ0JBQWdCLENBQUMsR0FBRy9JLE9BQU87Z0JBQzlCeEUsVUFBVTtnQkFDVjdDLE1BQU07Z0JBQ05zQyxVQUFVO2dCQUNWNkIsWUFBWTtnQkFDWkUsU0FBUztnQkFDVHRCLGdCQUFnQjtnQkFDaEJpQixXQUFXLEVBQUU7WUFDakI7UUFDSjtZQUNJLE9BQU9xRDtJQUNmO0FBQ0o7QUFFQSxTQUFTa0osU0FBU2xKLFFBQVEsQ0FBQyxFQUFFL0ksTUFBTTtJQUMvQixPQUFPQSxPQUFPdEMsSUFBSTtRQUNkLEtBQUs0UTtRQUNMLEtBQUtDO1lBQ0QsT0FBT3hGLFFBQVE7UUFDbkIsS0FBS3lGO1FBQ0wsS0FBS0M7WUFDRCxPQUFPMUYsUUFBUTtRQUNuQjtZQUNJLE9BQU9BO0lBQ2Y7QUFDSjtBQUVBLFNBQVNtSixTQUFTbkosUUFBUSxDQUFDO0lBQ3ZCLE9BQU9BLFFBQVE7QUFDbkI7QUFFQSxTQUFTb0osa0JBQWtCOVUsR0FBRyxFQUFFa0YsR0FBRyxFQUFFekgsS0FBSztJQUN0QyxJQUFJeUgsT0FBT2xGLEtBQUs7UUFDWjlTLE9BQU9zYSxjQUFjLENBQUN4SCxLQUFLa0YsS0FBSztZQUM1QnpILE9BQU9BO1lBQ1BnSyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtRQUNkO0lBQ0osT0FBTztRQUNIM0gsR0FBRyxDQUFDa0YsSUFBSSxHQUFHekg7SUFDZjtJQUNBLE9BQU91QztBQUNYO0FBQ0EsU0FBUytVLGdCQUFnQmxOLE1BQU07SUFDM0IsSUFBSSxJQUFJcmEsSUFBSSxHQUFHQSxJQUFJb1UsVUFBVW5VLE1BQU0sRUFBRUQsSUFBSTtRQUNyQyxJQUFJc1osU0FBU2xGLFNBQVMsQ0FBQ3BVLEVBQUUsSUFBSSxPQUFPb1UsU0FBUyxDQUFDcFUsRUFBRSxHQUFHLENBQUM7UUFDcEQsSUFBSXNhLFVBQVU1YSxPQUFPd0csSUFBSSxDQUFDb1Q7UUFDMUIsSUFBSSxPQUFPNVosT0FBT0sscUJBQXFCLEtBQUssWUFBWTtZQUNwRHVhLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQzdhLE9BQU9LLHFCQUFxQixDQUFDdVosUUFBUTdRLE1BQU0sQ0FBQyxTQUFTK1IsR0FBRztnQkFDN0UsT0FBTzlhLE9BQU8rYSx3QkFBd0IsQ0FBQ25CLFFBQVFrQixLQUFLUCxVQUFVO1lBQ2xFO1FBQ0o7UUFDQUssUUFBUW5VLE9BQU8sQ0FBQyxTQUFTdVIsR0FBRztZQUN4QjRQLGtCQUFrQmpOLFFBQVEzQyxLQUFLNEIsTUFBTSxDQUFDNUIsSUFBSTtRQUM5QztJQUNKO0lBQ0EsT0FBTzJDO0FBQ1g7QUFDQSxTQUFTM0QsT0FBT3dILFFBQVEsQ0FBQyxDQUFDLEVBQUUvSSxNQUFNO0lBQzlCLE9BQU87UUFDSGtLLGlCQUFpQmlILFNBQVNwSSxNQUFNbUIsZUFBZSxFQUFFO1lBQzdDeE0sTUFBTXNDLE9BQU90QyxJQUFJO1lBQ2pCd0YsU0FBU2tQLGdCQUFnQixDQUFDLEdBQUdwUyxPQUFPa0QsT0FBTyxFQUFFO2dCQUN6Q21PLGVBQWVqUSxJQUFJMkgsT0FBTywyQkFBMkIsRUFBRTtZQUMzRDtRQUNKO1FBQ0FzQixZQUFZdUgsU0FBUzdJLE1BQU1zQixVQUFVLEVBQUVySztRQUN2QzBJLFVBQVV1SixTQUFTbEosTUFBTUwsUUFBUSxFQUFFMUk7UUFDbkM4SyxlQUFla0gsU0FBU2pKLE1BQU0rQixhQUFhLEVBQUU5SztRQUM3QzhKLFNBQVNvSSxTQUFTbkosTUFBTWUsT0FBTztJQUNuQztBQUNKO0FBRUEsU0FBU3VJLHNCQUFzQkMsY0FBYyxFQUFFQyxnQkFBZ0IvZSxTQUFTLEVBQUVnZixpQkFBaUIsQ0FBQyxDQUFDLEVBQUVDLFlBQVksS0FBSztJQUM1RyxNQUFNeEssUUFBUXlLLGtCQUFrQkQ7SUFDaEMsTUFBTTlPLFVBQVUsSUFBSWdHLG9CQUFvQjFCLE9BQU8sSUFBSThILG9CQUFvQjlIO0lBQ3ZFLE1BQU01RSxVQUFVLElBQUl1RSxvQkFBb0JLLE9BQU90RTtJQUMvQyxNQUFNbUUsVUFBVXdLLGVBQWVqUCxTQUFTa1AsZUFBZUM7SUFDdkRuUCxRQUFRd0UsY0FBYyxDQUFDQztJQUN2QixPQUFPekU7QUFDWDtBQUNBLFNBQVNxUCxrQkFBa0JELFNBQVM7SUFDaEMsd0RBQXdEO0lBQ3hELHFEQUFxRDtJQUNyRCxNQUFNRSxnQkFBZ0IsTUFBa0IsSUFBZUMsQ0FBbUM7SUFDMUYsT0FBT2hVLFlBQVkyQyxRQUFRa1IsYUFBYUUsaUJBQWlCQSxjQUFjO1FBQ25FMVUsTUFBTTtRQUNONlUsWUFBWTtJQUNoQjtBQUNKO0FBRUEsU0FBU0MseUJBQXlCNU8sTUFBTSxFQUFFNk8sUUFBUTtJQUM5QyxJQUFJN08sVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJZSxTQUFTK04sOEJBQThCOU8sUUFBUTZPO0lBQ25ELElBQUl6USxLQUFLMVg7SUFDVCxJQUFJTixPQUFPSyxxQkFBcUIsRUFBRTtRQUM5QixJQUFJc29CLG1CQUFtQjNvQixPQUFPSyxxQkFBcUIsQ0FBQ3VaO1FBQ3BELElBQUl0WixJQUFJLEdBQUdBLElBQUlxb0IsaUJBQWlCcG9CLE1BQU0sRUFBRUQsSUFBSTtZQUN4QzBYLE1BQU0yUSxnQkFBZ0IsQ0FBQ3JvQixFQUFFO1lBQ3pCLElBQUltb0IsU0FBU3JvQixPQUFPLENBQUM0WCxRQUFRLEdBQUc7WUFDaEMsSUFBSSxDQUFDaFksT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDeVosUUFBUTVCLE1BQU07WUFDOUQyQyxNQUFNLENBQUMzQyxJQUFJLEdBQUc0QixNQUFNLENBQUM1QixJQUFJO1FBQzdCO0lBQ0o7SUFDQSxPQUFPMkM7QUFDWDtBQUNBLFNBQVMrTiw4QkFBOEI5TyxNQUFNLEVBQUU2TyxRQUFRO0lBQ25ELElBQUk3TyxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQzVCLElBQUllLFNBQVMsQ0FBQztJQUNkLElBQUlpTyxhQUFhNW9CLE9BQU93RyxJQUFJLENBQUNvVDtJQUM3QixJQUFJNUIsS0FBSzFYO0lBQ1QsSUFBSUEsSUFBSSxHQUFHQSxJQUFJc29CLFdBQVdyb0IsTUFBTSxFQUFFRCxJQUFJO1FBQ2xDMFgsTUFBTTRRLFVBQVUsQ0FBQ3RvQixFQUFFO1FBQ25CLElBQUltb0IsU0FBU3JvQixPQUFPLENBQUM0WCxRQUFRLEdBQUc7UUFDaEMyQyxNQUFNLENBQUMzQyxJQUFJLEdBQUc0QixNQUFNLENBQUM1QixJQUFJO0lBQzdCO0lBQ0EsT0FBTzJDO0FBQ1g7QUFDQSxJQUFJd0QsV0FBVztBQUNmLE1BQU0wSyxlQUFlM1csT0FBTzRXLEdBQUcsQ0FBQztBQUNoQyxJQUFJQyxjQUFjLFdBQVcsR0FBRzNwQiwyQ0FBSUEsQ0FBQyxTQUFTMnBCLFlBQVlDLE1BQU07SUFDNUQsSUFBSSxFQUFFbGxCLFFBQVEsRUFBRyxHQUFHa2xCLFFBQVFDLFFBQVFULHlCQUF5QlEsUUFBUTtRQUNqRTtLQUNIO0lBQ0QsTUFBTSxDQUFDbFEsU0FBU29RLGlCQUFpQixHQUFHQyxtQkFBbUJGLE9BQU8sc0JBQXNCOztJQUVwRjs7OztHQUlELEdBQUducUIsZ0RBQVNBLENBQUM7UUFDUixJQUFJb3FCLGtCQUFrQjtZQUNsQixNQUFNRSxVQUFVQztZQUNoQixFQUFFbEw7WUFDRixPQUFPO2dCQUNILElBQUksRUFBRUEsYUFBYSxHQUFHO29CQUNsQmlMLE9BQU8sQ0FBQ1AsYUFBYSxHQUFHO2dCQUM1QjtZQUNKO1FBQ0o7UUFDQTtJQUNKLEdBQUcsRUFBRTtJQUNMLE9BQU8sV0FBVyxHQUFHbnFCLHNEQUFHQSxDQUFDbVQsV0FBV3ZCLFFBQVEsRUFBRTtRQUMxQ0MsT0FBT3VJO1FBQ1BoVixVQUFVQTtJQUNkO0FBQ0o7QUFDQSxTQUFTcWxCLG1CQUFtQkYsS0FBSztJQUM3QixJQUFJLGFBQWFBLE9BQU87UUFDcEIsTUFBTW5RLFVBQVU7WUFDWmhILGlCQUFpQm1YLE1BQU1uUSxPQUFPO1FBQ2xDO1FBQ0EsT0FBTztZQUNIQTtZQUNBO1NBQ0g7SUFDTDtJQUNBLE1BQU1BLFVBQVV3USwwQkFBMEJMLE1BQU0xTCxPQUFPLEVBQUUwTCxNQUFNRyxPQUFPLEVBQUVILE1BQU1oUSxPQUFPLEVBQUVnUSxNQUFNZixTQUFTO0lBQ3RHLE1BQU1nQixtQkFBbUIsQ0FBQ0QsTUFBTUcsT0FBTztJQUN2QyxPQUFPO1FBQ0h0UTtRQUNBb1E7S0FDSDtBQUNMO0FBQ0EsU0FBU0ksMEJBQTBCL0wsT0FBTyxFQUFFNkwsVUFBVUMsa0JBQWtCLEVBQUVwUSxPQUFPLEVBQUVpUCxTQUFTO0lBQ3hGLE1BQU1xQixNQUFNSDtJQUNaLElBQUksQ0FBQ0csR0FBRyxDQUFDVixhQUFhLEVBQUU7UUFDcEJVLEdBQUcsQ0FBQ1YsYUFBYSxHQUFHO1lBQ2hCL1csaUJBQWlCZ1csc0JBQXNCdkssU0FBUzZMLFNBQVNuUSxTQUFTaVA7UUFDdEU7SUFDSjtJQUNBLE9BQU9xQixHQUFHLENBQUNWLGFBQWE7QUFDNUI7QUFDQSxTQUFTUTtJQUNMLE9BQU8sT0FBT3hJLFdBQVcsY0FBY0EsU0FBU3dIO0FBQ3BEO0FBRUEsc0RBQXNEO0FBSXRELElBQUltQixnQkFBZ0IsU0FBU0MsTUFBTTVtQixDQUFDLEVBQUVDLENBQUM7SUFDckMsSUFBSUQsTUFBTUMsR0FBRyxPQUFPO0lBRXBCLElBQUlELEtBQUtDLEtBQUssT0FBT0QsS0FBSyxZQUFZLE9BQU9DLEtBQUssVUFBVTtRQUMxRCxJQUFJRCxFQUFFNFEsV0FBVyxLQUFLM1EsRUFBRTJRLFdBQVcsRUFBRSxPQUFPO1FBRTVDLElBQUlsVCxRQUFRRCxHQUFHa0c7UUFDZixJQUFJb0MsTUFBTUMsT0FBTyxDQUFDaEcsSUFBSTtZQUNwQnRDLFNBQVNzQyxFQUFFdEMsTUFBTTtZQUNqQixJQUFJQSxVQUFVdUMsRUFBRXZDLE1BQU0sRUFBRSxPQUFPO1lBQy9CLElBQUtELElBQUlDLFFBQVFELFFBQVEsR0FDdkIsSUFBSSxDQUFDbXBCLE1BQU01bUIsQ0FBQyxDQUFDdkMsRUFBRSxFQUFFd0MsQ0FBQyxDQUFDeEMsRUFBRSxHQUFHLE9BQU87WUFDakMsT0FBTztRQUNUO1FBSUEsSUFBSXVDLEVBQUU0USxXQUFXLEtBQUtpVyxRQUFRLE9BQU83bUIsRUFBRStXLE1BQU0sS0FBSzlXLEVBQUU4VyxNQUFNLElBQUkvVyxFQUFFOG1CLEtBQUssS0FBSzdtQixFQUFFNm1CLEtBQUs7UUFDakYsSUFBSTltQixFQUFFK21CLE9BQU8sS0FBSzVwQixPQUFPQyxTQUFTLENBQUMycEIsT0FBTyxFQUFFLE9BQU8vbUIsRUFBRSttQixPQUFPLE9BQU85bUIsRUFBRThtQixPQUFPO1FBQzVFLElBQUkvbUIsRUFBRXlQLFFBQVEsS0FBS3RTLE9BQU9DLFNBQVMsQ0FBQ3FTLFFBQVEsRUFBRSxPQUFPelAsRUFBRXlQLFFBQVEsT0FBT3hQLEVBQUV3UCxRQUFRO1FBRWhGOUwsT0FBT3hHLE9BQU93RyxJQUFJLENBQUMzRDtRQUNuQnRDLFNBQVNpRyxLQUFLakcsTUFBTTtRQUNwQixJQUFJQSxXQUFXUCxPQUFPd0csSUFBSSxDQUFDMUQsR0FBR3ZDLE1BQU0sRUFBRSxPQUFPO1FBRTdDLElBQUtELElBQUlDLFFBQVFELFFBQVEsR0FDdkIsSUFBSSxDQUFDTixPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDMkMsR0FBRzBELElBQUksQ0FBQ2xHLEVBQUUsR0FBRyxPQUFPO1FBRWhFLElBQUtBLElBQUlDLFFBQVFELFFBQVEsR0FBSTtZQUMzQixJQUFJMFgsTUFBTXhSLElBQUksQ0FBQ2xHLEVBQUU7WUFFakIsSUFBSSxDQUFDbXBCLE1BQU01bUIsQ0FBQyxDQUFDbVYsSUFBSSxFQUFFbFYsQ0FBQyxDQUFDa1YsSUFBSSxHQUFHLE9BQU87UUFDckM7UUFFQSxPQUFPO0lBQ1Q7SUFFQSxvQ0FBb0M7SUFDcEMsT0FBT25WLE1BQUlBLEtBQUtDLE1BQUlBO0FBQ3RCO0FBRUEsdURBQXVEO0FBQ3ZELE1BQU0rbUIsNEJBQTRCLE1BQWtCLEdBQWN4cUIsQ0FBZUEsR0FBR1AsNENBQVNBO0FBRTdGOzs7OztDQUtDLEdBQUcsU0FBU2dyQixhQUFhMVEsT0FBTyxFQUFFMlEsT0FBTyxFQUFFQyxRQUFRO0lBQ2hELE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHcnJCLCtDQUFRQSxDQUFDLElBQUlrckIsUUFBUTNRO0lBRXZELE1BQU0rUSxrQkFBa0I3cUIsa0RBQVdBLENBQUM7UUFDaEMsTUFBTThxQixZQUFZTCxRQUFRM1E7UUFDMUIsK0VBQStFO1FBQy9FLHFGQUFxRjtRQUNyRixJQUFJLENBQUNvUSxjQUFjUyxXQUFXRyxZQUFZO1lBQ3RDRixhQUFhRTtZQUNiLElBQUlKLFVBQVU7Z0JBQ1ZBO1lBQ0o7UUFDSjtJQUNKLEdBQUc7UUFDQ0M7UUFDQTdRO1FBQ0E0UTtLQUNIO0lBQ0QsdURBQXVEO0lBQ3ZELDJEQUEyRDtJQUMzRCxrQ0FBa0M7SUFDbENILDBCQUEwQk07SUFDMUIsT0FBTztRQUNIRjtRQUNBRTtLQUNIO0FBQ0w7QUFFQSxTQUFTRSxpQkFBaUJqUixPQUFPLEVBQUUyUSxPQUFPLEVBQUVPLFNBQVM7SUFDakQsTUFBTSxDQUFDTCxXQUFXRSxnQkFBZ0IsR0FBR0wsYUFBYTFRLFNBQVMyUSxTQUFTTztJQUNwRVQsMEJBQTBCLFNBQVNVO1FBQy9CLE1BQU1wRixZQUFZL0wsUUFBUW9SLFlBQVk7UUFDdEMsSUFBSXJGLGFBQWEsTUFBTTtZQUNuQjtRQUNKO1FBQ0EsT0FBTy9MLFFBQVFpRyxzQkFBc0IsQ0FBQzhLLGlCQUFpQjtZQUNuRGpMLFlBQVk7Z0JBQ1JpRzthQUNIO1FBQ0w7SUFDSixHQUFHO1FBQ0MvTDtRQUNBK1E7S0FDSDtJQUNELE9BQU9GO0FBQ1g7QUFFQSxTQUFTUSxrQkFBa0JDLFNBQVMsRUFBRXRSLE9BQU8sRUFBRXVSLFNBQVM7SUFDcEQsT0FBT04saUJBQWlCalIsU0FBU3NSLGFBQWMsS0FBSyxFQUFDLEVBQUMsR0FDbkQsSUFBSUMsVUFBVUMsU0FBUztBQUU5QjtBQUVBLFNBQVNDLG1CQUFtQkMsR0FBRyxFQUFFQyxJQUFJO0lBQ2pDLE1BQU1DLFdBQVc7V0FDVkQsUUFBUSxFQUFFO0tBQ2hCO0lBQ0QsSUFBSUEsUUFBUSxRQUFRLE9BQU9ELFFBQVEsWUFBWTtRQUMzQ0UsU0FBU3ZiLElBQUksQ0FBQ3FiO0lBQ2xCO0lBQ0EsT0FBT3ZyQiw4Q0FBT0EsQ0FBQztRQUNYLE9BQU8sT0FBT3VyQixRQUFRLGFBQWFBLFFBQVFBO0lBQy9DLEdBQUdFO0FBQ1A7QUFFQSxTQUFTQyxxQkFBcUJOLFNBQVM7SUFDbkMsT0FBT3ByQiw4Q0FBT0EsQ0FBQyxJQUFJb3JCLFVBQVVPLEtBQUssQ0FBQ0MsVUFBVSxJQUMzQztRQUNFUjtLQUNIO0FBQ0w7QUFDQSxTQUFTUyxzQkFBc0JULFNBQVM7SUFDcEMsT0FBT3ByQiw4Q0FBT0EsQ0FBQyxJQUFJb3JCLFVBQVVPLEtBQUssQ0FBQ0csV0FBVyxJQUM1QztRQUNFVjtLQUNIO0FBQ0w7QUFFQSxJQUFJVyxtQkFBbUI7QUFDdkIsSUFBSUMsc0JBQXNCO0FBQzFCLE1BQU1DO0lBQ0ZDLGlCQUFpQmhTLFFBQVEsRUFBRTtRQUN2QixJQUFJLENBQUNBLFFBQVEsR0FBR0E7SUFDcEI7SUFDQStRLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQy9RLFFBQVE7SUFDeEI7SUFDQXVHLFVBQVU7UUFDTjFKLFVBQVUsQ0FBQ2dWLGtCQUFrQiw4RUFBOEU7UUFDM0csSUFBSTtZQUNBQSxtQkFBbUI7WUFDbkIsT0FBTyxJQUFJLENBQUNJLGVBQWUsQ0FBQ3RSLGFBQWEsQ0FBQyxJQUFJLENBQUNYLFFBQVE7UUFDM0QsU0FBUztZQUNMNlIsbUJBQW1CO1FBQ3ZCO0lBQ0o7SUFDQW5SLGFBQWE7UUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDVixRQUFRLEVBQUU7WUFDaEIsT0FBTztRQUNYO1FBQ0FuRCxVQUFVLENBQUNpVixxQkFBcUIsb0ZBQW9GO1FBQ3BILElBQUk7WUFDQUEsc0JBQXNCO1lBQ3RCLE9BQU8sSUFBSSxDQUFDRyxlQUFlLENBQUN2TCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMxRyxRQUFRO1FBQzlELFNBQVM7WUFDTDhSLHNCQUFzQjtRQUMxQjtJQUNKO0lBQ0FsTSx1QkFBdUJsSyxRQUFRLEVBQUU4RCxPQUFPLEVBQUU7UUFDdEMsT0FBTyxJQUFJLENBQUN5UyxlQUFlLENBQUNyTSxzQkFBc0IsQ0FBQ2xLLFVBQVU4RDtJQUNqRTtJQUNBa0gsaUJBQWlCMUcsUUFBUSxFQUFFO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDaVMsZUFBZSxDQUFDdkwsZ0JBQWdCLENBQUMxRztJQUNqRDtJQUNBNEcsYUFBYWhGLFFBQVEsRUFBRXBDLE9BQU8sRUFBRTtRQUM1QixPQUFPLElBQUksQ0FBQ3lTLGVBQWUsQ0FBQ3JMLFlBQVksQ0FBQ2hGLFVBQVVwQztJQUN2RDtJQUNBMkMsZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDOFAsZUFBZSxDQUFDOVAsWUFBWTtJQUM1QztJQUNBMUIsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUN3UixlQUFlLENBQUN4UixjQUFjO0lBQzlDO0lBQ0FnQyxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUN3UCxlQUFlLENBQUN4UCxXQUFXO0lBQzNDO0lBQ0EwRCx3QkFBd0J6SyxRQUFRLEVBQUU7UUFDOUIsT0FBTyxJQUFJLENBQUN1VyxlQUFlLENBQUM5TCx1QkFBdUIsQ0FBQ3pLO0lBQ3hEO0lBQ0FpRixjQUFjWCxRQUFRLEVBQUU7UUFDcEIsT0FBTyxJQUFJLENBQUNpUyxlQUFlLENBQUN0UixhQUFhLENBQUNYO0lBQzlDO0lBQ0FvQyxnQkFBZ0JSLFFBQVEsRUFBRTtRQUN0QixPQUFPLElBQUksQ0FBQ3FRLGVBQWUsQ0FBQzdQLGVBQWUsQ0FBQ1I7SUFDaEQ7SUFDQXVCLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQzhPLGVBQWUsQ0FBQzlPLFdBQVc7SUFDM0M7SUFDQTRELFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ2tMLGVBQWUsQ0FBQ2xMLE9BQU87SUFDdkM7SUFDQTdFLGdCQUFnQjtRQUNaLE9BQU8sSUFBSSxDQUFDK1AsZUFBZSxDQUFDL1AsYUFBYTtJQUM3QztJQUNBSCxVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNrUSxlQUFlLENBQUNsUSxPQUFPO0lBQ3ZDO0lBQ0FpRix5QkFBeUI7UUFDckIsT0FBTyxJQUFJLENBQUNpTCxlQUFlLENBQUNqTCxzQkFBc0I7SUFDdEQ7SUFDQUMsK0JBQStCO1FBQzNCLE9BQU8sSUFBSSxDQUFDZ0wsZUFBZSxDQUFDaEwsNEJBQTRCO0lBQzVEO0lBQ0F2SCx3QkFBd0I7UUFDcEIsT0FBTyxJQUFJLENBQUN1UyxlQUFlLENBQUN2UyxxQkFBcUI7SUFDckQ7SUFDQXdILGtCQUFrQjtRQUNkLE9BQU8sSUFBSSxDQUFDK0ssZUFBZSxDQUFDL0ssZUFBZTtJQUMvQztJQUNBaEMsaUNBQWlDO1FBQzdCLE9BQU8sSUFBSSxDQUFDK00sZUFBZSxDQUFDL00sOEJBQThCO0lBQzlEO0lBQ0FsTCxZQUFZcUYsT0FBTyxDQUFDO1FBQ2hCLElBQUksQ0FBQ1csUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ2lTLGVBQWUsR0FBRzVTLFFBQVFPLFVBQVU7SUFDN0M7QUFDSjtBQUVBLElBQUlzUyxtQkFBbUI7QUFDdkIsTUFBTUM7SUFDRkgsaUJBQWlCcFEsUUFBUSxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNwQjtJQUNBbVAsZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDblAsUUFBUTtJQUN4QjtJQUNBZ0UsdUJBQXVCbEssUUFBUSxFQUFFOEQsT0FBTyxFQUFFO1FBQ3RDLE9BQU8sSUFBSSxDQUFDeVMsZUFBZSxDQUFDck0sc0JBQXNCLENBQUNsSyxVQUFVOEQ7SUFDakU7SUFDQWdILFVBQVU7UUFDTiw4RUFBOEU7UUFDOUUsMERBQTBEO1FBQzFELHFEQUFxRDtRQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDNUUsUUFBUSxFQUFFO1lBQ2hCLE9BQU87UUFDWDtRQUNBL0UsVUFBVSxDQUFDcVYsa0JBQWtCLDhFQUE4RTtRQUMzRyxJQUFJO1lBQ0FBLG1CQUFtQjtZQUNuQixPQUFPLElBQUksQ0FBQ0QsZUFBZSxDQUFDN1AsZUFBZSxDQUFDLElBQUksQ0FBQ1IsUUFBUTtRQUM3RCxTQUFTO1lBQ0xzUSxtQkFBbUI7UUFDdkI7SUFDSjtJQUNBRSxPQUFPNVMsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDLElBQUksQ0FBQ29DLFFBQVEsRUFBRTtZQUNoQixPQUFPO1FBQ1g7UUFDQSxPQUFPLElBQUksQ0FBQ3FRLGVBQWUsQ0FBQ3JMLFlBQVksQ0FBQyxJQUFJLENBQUNoRixRQUFRLEVBQUVwQztJQUM1RDtJQUNBMkQsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDOE8sZUFBZSxDQUFDOU8sV0FBVztJQUMzQztJQUNBNEQsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDa0wsZUFBZSxDQUFDbEwsT0FBTztJQUN2QztJQUNBN0UsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJLENBQUMrUCxlQUFlLENBQUMvUCxhQUFhO0lBQzdDO0lBQ0FILFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQ2tRLGVBQWUsQ0FBQ2xRLE9BQU87SUFDdkM7SUFDQWlGLHlCQUF5QjtRQUNyQixPQUFPLElBQUksQ0FBQ2lMLGVBQWUsQ0FBQ2pMLHNCQUFzQjtJQUN0RDtJQUNBQywrQkFBK0I7UUFDM0IsT0FBTyxJQUFJLENBQUNnTCxlQUFlLENBQUNoTCw0QkFBNEI7SUFDNUQ7SUFDQXZILHdCQUF3QjtRQUNwQixPQUFPLElBQUksQ0FBQ3VTLGVBQWUsQ0FBQ3ZTLHFCQUFxQjtJQUNyRDtJQUNBd0gsa0JBQWtCO1FBQ2QsT0FBTyxJQUFJLENBQUMrSyxlQUFlLENBQUMvSyxlQUFlO0lBQy9DO0lBQ0FoQyxpQ0FBaUM7UUFDN0IsT0FBTyxJQUFJLENBQUMrTSxlQUFlLENBQUMvTSw4QkFBOEI7SUFDOUQ7SUFDQWxMLFlBQVlxRixPQUFPLENBQUM7UUFDaEIsSUFBSSxDQUFDdUMsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ3FRLGVBQWUsR0FBRzVTLFFBQVFPLFVBQVU7SUFDN0M7QUFDSjtBQUVBLFNBQVN5UyxlQUFlM1ksSUFBSSxFQUFFd0gsTUFBTSxFQUFFN0IsT0FBTztJQUN6QyxNQUFNUSxXQUFXUixRQUFRUyxXQUFXO0lBQ3BDLE1BQU04QixXQUFXL0IsU0FBUzhLLFNBQVMsQ0FBQ2pSLE1BQU13SDtJQUMxQyxPQUFPO1FBQ0hVO1FBQ0EsSUFBSS9CLFNBQVNnTCxZQUFZLENBQUNqSjtLQUM3QjtBQUNMO0FBQ0EsU0FBUzBRLGVBQWU1WSxJQUFJLEVBQUV5RyxNQUFNLEVBQUVkLE9BQU87SUFDekMsTUFBTVEsV0FBV1IsUUFBUVMsV0FBVztJQUNwQyxNQUFNRSxXQUFXSCxTQUFTNkssU0FBUyxDQUFDaFIsTUFBTXlHO0lBQzFDLE9BQU87UUFDSEg7UUFDQSxJQUFJSCxTQUFTK0ssWUFBWSxDQUFDNUs7S0FDN0I7QUFDTDtBQUVBLFNBQVN1UyxhQUFhQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxjQUFjO0lBQ3JELElBQUlDLGdCQUFnQkYsVUFBVUEsUUFBUWhzQixJQUFJLENBQUNpc0IsZ0JBQWdCSCxNQUFNQyxRQUFRLEtBQUs7SUFDOUUsSUFBSUcsa0JBQWtCLEtBQUssR0FBRztRQUMxQixPQUFPLENBQUMsQ0FBQ0E7SUFDYjtJQUNBLElBQUlKLFNBQVNDLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxJQUFJLE9BQU9ELFNBQVMsWUFBWSxDQUFDQSxRQUFRLE9BQU9DLFNBQVMsWUFBWSxDQUFDQSxNQUFNO1FBQ3hFLE9BQU87SUFDWDtJQUNBLE1BQU1JLFFBQVF0c0IsT0FBT3dHLElBQUksQ0FBQ3lsQjtJQUMxQixNQUFNTSxRQUFRdnNCLE9BQU93RyxJQUFJLENBQUMwbEI7SUFDMUIsSUFBSUksTUFBTS9yQixNQUFNLEtBQUtnc0IsTUFBTWhzQixNQUFNLEVBQUU7UUFDL0IsT0FBTztJQUNYO0lBQ0EsTUFBTWlzQixrQkFBa0J4c0IsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUN1c0IsSUFBSSxDQUFDUDtJQUM3RCxzQ0FBc0M7SUFDdEMsSUFBSSxJQUFJUSxNQUFNLEdBQUdBLE1BQU1KLE1BQU0vckIsTUFBTSxFQUFFbXNCLE1BQU07UUFDdkMsTUFBTTFVLE1BQU1zVSxLQUFLLENBQUNJLElBQUk7UUFDdEIsSUFBSSxDQUFDRixnQkFBZ0J4VSxNQUFNO1lBQ3ZCLE9BQU87UUFDWDtRQUNBLE1BQU0yVSxTQUFTVixJQUFJLENBQUNqVSxJQUFJO1FBQ3hCLE1BQU00VSxTQUFTVixJQUFJLENBQUNsVSxJQUFJO1FBQ3hCcVUsZ0JBQWdCRixVQUFVQSxRQUFRaHNCLElBQUksQ0FBQ2lzQixnQkFBZ0JPLFFBQVFDLFFBQVE1VSxPQUFPLEtBQUs7UUFDbkYsSUFBSXFVLGtCQUFrQixTQUFTQSxrQkFBa0IsS0FBSyxLQUFLTSxXQUFXQyxRQUFRO1lBQzFFLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBRUEsU0FBU0MsTUFBTS9aLEdBQUc7SUFDZCxPQUNBQSxRQUFRLFFBQVEsT0FBT0EsUUFBUSxZQUFZOVMsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQzJTLEtBQUs7QUFDekY7QUFFQSxTQUFTZ2EsaUNBQWlDQyxPQUFPO0lBQzdDLHVFQUF1RTtJQUN2RSxtRUFBbUU7SUFDbkUsSUFBSSxPQUFPQSxRQUFRNVosSUFBSSxLQUFLLFVBQVU7UUFDbEM7SUFDSjtJQUNBLE1BQU02WixjQUFjRCxRQUFRNVosSUFBSSxDQUFDNlosV0FBVyxJQUFJRCxRQUFRNVosSUFBSSxDQUFDTyxJQUFJLElBQUk7SUFDckUsTUFBTSxJQUFJQyxNQUFNLHlFQUF5RSxDQUFDLG9CQUFvQixFQUFFcVosWUFBWSxpQ0FBaUMsQ0FBQyxHQUFHO0FBQ3JLO0FBQ0EsU0FBU0MsMkJBQTJCQyxJQUFJO0lBQ3BDLE9BQU8sQ0FBQ0MsZ0JBQWdCLElBQUksRUFBRWxVLFVBQVUsSUFBSTtRQUN4QyxtREFBbUQ7UUFDbkQsSUFBSSxlQUFDeloscURBQWNBLENBQUMydEIsZ0JBQWdCO1lBQ2hDLE1BQU12TCxPQUFPdUw7WUFDYkQsS0FBS3RMLE1BQU0zSTtZQUNYLHVFQUF1RTtZQUN2RSxrRUFBa0U7WUFDbEUsT0FBTzJJO1FBQ1g7UUFDQSx3RUFBd0U7UUFDeEUsMEVBQTBFO1FBQzFFLGlDQUFpQztRQUNqQyxNQUFNbUwsVUFBVUk7UUFDaEJMLGlDQUFpQ0M7UUFDakMsb0RBQW9EO1FBQ3BELE1BQU1wZ0IsTUFBTXNNLFVBQVUsQ0FBQzJJLE9BQU9zTCxLQUFLdEwsTUFBTTNJLFdBQ3RDaVU7UUFDSCxPQUFPRSxhQUFhTCxTQUFTcGdCO0lBQ2pDO0FBQ0o7QUFDQSxTQUFTMGdCLG1CQUFtQm5DLEtBQUs7SUFDN0IsTUFBTW9DLGVBQWUsQ0FBQztJQUN0QnR0QixPQUFPd0csSUFBSSxDQUFDMGtCLE9BQU96a0IsT0FBTyxDQUFDLENBQUN1UjtRQUN4QixNQUFNa1YsT0FBT2hDLEtBQUssQ0FBQ2xULElBQUk7UUFDdkIsaUVBQWlFO1FBQ2pFLElBQUlBLElBQUl1VixRQUFRLENBQUMsUUFBUTtZQUNyQkQsWUFBWSxDQUFDdFYsSUFBSSxHQUFHa1QsS0FBSyxDQUFDbFQsSUFBSTtRQUNsQyxPQUFPO1lBQ0gsTUFBTXdWLGNBQWNQLDJCQUEyQkM7WUFDL0NJLFlBQVksQ0FBQ3RWLElBQUksR0FBRyxJQUFJd1Y7UUFFNUI7SUFDSjtJQUNBLE9BQU9GO0FBQ1g7QUFDQSxTQUFTRyxPQUFPOWdCLEdBQUcsRUFBRWlWLElBQUk7SUFDckIsSUFBSSxPQUFPalYsUUFBUSxZQUFZO1FBQzNCQSxJQUFJaVY7SUFDUixPQUFPO1FBQ0hqVixJQUFJNEMsT0FBTyxHQUFHcVM7SUFDbEI7QUFDSjtBQUNBLFNBQVN3TCxhQUFhTCxPQUFPLEVBQUVXLE1BQU07SUFDakMsTUFBTUMsY0FBY1osUUFBUXBnQixHQUFHO0lBQy9CMkosVUFBVSxPQUFPcVgsZ0JBQWdCLFVBQVUseUVBQXlFLHlGQUF5RjtJQUM3TSxJQUFJLENBQUNBLGFBQWE7UUFDZCxnRUFBZ0U7UUFDaEUscUJBQU9sdUIsbURBQVlBLENBQUNzdEIsU0FBUztZQUN6QnBnQixLQUFLK2dCO1FBQ1Q7SUFDSixPQUFPO1FBQ0gscUJBQU9qdUIsbURBQVlBLENBQUNzdEIsU0FBUztZQUN6QnBnQixLQUFLLENBQUNpVjtnQkFDRjZMLE9BQU9FLGFBQWEvTDtnQkFDcEI2TCxPQUFPQyxRQUFROUw7WUFDbkI7UUFDSjtJQUNKO0FBQ0o7QUFFQSxNQUFNZ007SUFDRm5DLGlCQUFpQm9DLFlBQVksRUFBRTtRQUMzQixJQUFJLElBQUksQ0FBQzFJLFNBQVMsS0FBSzBJLGNBQWM7WUFDakM7UUFDSjtRQUNBLElBQUksQ0FBQzFJLFNBQVMsR0FBRzBJO1FBQ2pCLElBQUksQ0FBQ2pELFNBQVM7SUFDbEI7SUFDQSxJQUFJa0QsZ0JBQWdCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDM0MsVUFBVTtJQUMxQjtJQUNBLElBQUk0QyxvQkFBb0I7UUFDcEIsT0FBTyxJQUFJLENBQUNDLHlCQUF5QjtJQUN6QztJQUNBLElBQUlELGtCQUFrQjlVLE9BQU8sRUFBRTtRQUMzQixJQUFJLENBQUMrVSx5QkFBeUIsR0FBRy9VO0lBQ3JDO0lBQ0EsSUFBSWdWLHFCQUFxQjtRQUNyQixPQUFPLElBQUksQ0FBQ0MsMEJBQTBCO0lBQzFDO0lBQ0EsSUFBSUQsbUJBQW1CaFYsT0FBTyxFQUFFO1FBQzVCLElBQUksQ0FBQ2lWLDBCQUEwQixHQUFHalY7SUFDdEM7SUFDQTJSLFlBQVk7UUFDUixNQUFNN0QsWUFBWSxJQUFJLENBQUNvSCxtQkFBbUI7UUFDMUMsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ3JIO0lBQzlCO0lBQ0FvSCxzQkFBc0I7UUFDbEIsTUFBTWhELGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDLGdEQUFnRDtRQUNoRCxNQUFNcEUsWUFBWSxJQUFJLENBQUNzSCxrQkFBa0IsTUFBTSxJQUFJLENBQUNDLDRCQUE0QixNQUFNLElBQUksQ0FBQ0MsMEJBQTBCO1FBQ3JILElBQUl4SCxXQUFXO1lBQ1gsSUFBSSxDQUFDeUgsb0JBQW9CO1FBQzdCO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3JKLFNBQVMsRUFBRTtZQUNqQixPQUFPNEI7UUFDWDtRQUNBLElBQUksQ0FBQ29FLFlBQVk7WUFDYixJQUFJLENBQUNzRCx1QkFBdUIsR0FBR3REO1lBQy9CLE9BQU9wRTtRQUNYO1FBQ0EsSUFBSUEsV0FBVztZQUNYLElBQUksQ0FBQzJILHNCQUFzQixHQUFHLElBQUksQ0FBQ3ZKLFNBQVM7WUFDNUMsSUFBSSxDQUFDc0osdUJBQXVCLEdBQUd0RDtZQUMvQixJQUFJLENBQUN3RCw4QkFBOEIsR0FBRyxJQUFJLENBQUNaLGlCQUFpQjtZQUM1RCxJQUFJLENBQUNhLHFCQUFxQixHQUFHLElBQUksQ0FBQ3JSLE9BQU8sQ0FBQ3NSLGlCQUFpQixDQUFDLElBQUksQ0FBQzFKLFNBQVMsRUFBRWdHLFlBQVksSUFBSSxDQUFDNEMsaUJBQWlCO1FBQ2xIO1FBQ0EsT0FBT2hIO0lBQ1g7SUFDQXFILHFCQUFxQlUsaUJBQWlCLEtBQUssRUFBRTtRQUN6QyxNQUFNekQsY0FBYyxJQUFJLENBQUNBLFdBQVc7UUFDcEMsZ0RBQWdEO1FBQ2hELE1BQU10RSxZQUFZK0gsa0JBQWtCLElBQUksQ0FBQ1Qsa0JBQWtCLE1BQU0sSUFBSSxDQUFDVSw2QkFBNkIsTUFBTSxJQUFJLENBQUNDLDJCQUEyQjtRQUN6SSxJQUFJakksV0FBVztZQUNYLElBQUksQ0FBQ2tJLHFCQUFxQjtRQUM5QjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUM5SixTQUFTLEVBQUU7WUFDakI7UUFDSjtRQUNBLElBQUksQ0FBQ2tHLGFBQWE7WUFDZCxJQUFJLENBQUM2RCx3QkFBd0IsR0FBRzdEO1lBQ2hDO1FBQ0o7UUFDQSxJQUFJdEUsV0FBVztZQUNYLElBQUksQ0FBQzJILHNCQUFzQixHQUFHLElBQUksQ0FBQ3ZKLFNBQVM7WUFDNUMsSUFBSSxDQUFDK0osd0JBQXdCLEdBQUc3RDtZQUNoQyxJQUFJLENBQUM4RCwrQkFBK0IsR0FBRyxJQUFJLENBQUNsQixrQkFBa0I7WUFDOUQsSUFBSSxDQUFDbUIsc0JBQXNCLEdBQUcsSUFBSSxDQUFDN1IsT0FBTyxDQUFDOFIsa0JBQWtCLENBQUMsSUFBSSxDQUFDbEssU0FBUyxFQUFFa0csYUFBYSxJQUFJLENBQUM0QyxrQkFBa0I7UUFDdEg7SUFDSjtJQUNBSSxxQkFBcUI7UUFDakIsT0FBTyxJQUFJLENBQUNLLHNCQUFzQixLQUFLLElBQUksQ0FBQ3ZKLFNBQVM7SUFDekQ7SUFDQW1KLCtCQUErQjtRQUMzQixPQUFPLElBQUksQ0FBQ0csdUJBQXVCLEtBQUssSUFBSSxDQUFDdEQsVUFBVTtJQUMzRDtJQUNBNEQsZ0NBQWdDO1FBQzVCLE9BQU8sSUFBSSxDQUFDRyx3QkFBd0IsS0FBSyxJQUFJLENBQUM3RCxXQUFXO0lBQzdEO0lBQ0FrRCw2QkFBNkI7UUFDekIsT0FBTyxDQUFDdkMsYUFBYSxJQUFJLENBQUMyQyw4QkFBOEIsRUFBRSxJQUFJLENBQUNaLGlCQUFpQjtJQUNwRjtJQUNBaUIsOEJBQThCO1FBQzFCLE9BQU8sQ0FBQ2hELGFBQWEsSUFBSSxDQUFDbUQsK0JBQStCLEVBQUUsSUFBSSxDQUFDbEIsa0JBQWtCO0lBQ3RGO0lBQ0FPLHVCQUF1QjtRQUNuQixJQUFJLElBQUksQ0FBQ0kscUJBQXFCLEVBQUU7WUFDNUIsSUFBSSxDQUFDQSxxQkFBcUI7WUFDMUIsSUFBSSxDQUFDQSxxQkFBcUIsR0FBRzNsQjtRQUNqQztJQUNKO0lBQ0FnbUIsd0JBQXdCO1FBQ3BCLElBQUksSUFBSSxDQUFDRyxzQkFBc0IsRUFBRTtZQUM3QixJQUFJLENBQUNBLHNCQUFzQjtZQUMzQixJQUFJLENBQUNBLHNCQUFzQixHQUFHbm1CO1lBQzlCLElBQUksQ0FBQ3FtQixlQUFlLEdBQUc7WUFDdkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDMUI7SUFDSjtJQUNBLElBQUlwRSxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNxRSxjQUFjLElBQUksSUFBSSxDQUFDQyxhQUFhLElBQUksSUFBSSxDQUFDQSxhQUFhLENBQUNsZ0IsT0FBTztJQUNsRjtJQUNBLElBQUk4YixjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUNpRSxlQUFlLElBQUksSUFBSSxDQUFDQyxjQUFjLElBQUksSUFBSSxDQUFDQSxjQUFjLENBQUNoZ0IsT0FBTztJQUNyRjtJQUNBbWdCLGtCQUFrQjtRQUNkLElBQUksQ0FBQ0YsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO0lBQ3pCO0lBQ0FFLG1CQUFtQjtRQUNmLElBQUksQ0FBQ0wsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQzFCO0lBQ0E5YixZQUFZOEosT0FBTyxDQUFDO1FBQ2hCLElBQUksQ0FBQzJOLEtBQUssR0FBR21DLG1CQUFtQjtZQUM1QmxDLFlBQVksQ0FBQ3ZKLE1BQU0zSTtnQkFDZixJQUFJLENBQUN5VyxlQUFlO2dCQUNwQixJQUFJLENBQUMzQixpQkFBaUIsR0FBRzlVLFdBQVc7Z0JBQ3BDLElBQUk0VCxNQUFNakwsT0FBTztvQkFDYixJQUFJLENBQUM2TixhQUFhLEdBQUc3TjtnQkFDekIsT0FBTztvQkFDSCxJQUFJLENBQUM0TixjQUFjLEdBQUc1TjtnQkFDMUI7Z0JBQ0EsSUFBSSxDQUFDdU0sbUJBQW1CO1lBQzVCO1lBQ0E5QyxhQUFhLENBQUN6SixNQUFNM0k7Z0JBQ2hCLElBQUksQ0FBQzBXLGdCQUFnQjtnQkFDckIsSUFBSSxDQUFDMUIsa0JBQWtCLEdBQUdoVixXQUFXO2dCQUNyQyxJQUFJNFQsTUFBTWpMLE9BQU87b0JBQ2IsSUFBSSxDQUFDMk4sY0FBYyxHQUFHM047Z0JBQzFCLE9BQU87b0JBQ0gsSUFBSSxDQUFDME4sZUFBZSxHQUFHMU47Z0JBQzNCO2dCQUNBLElBQUksQ0FBQ3dNLG9CQUFvQjtZQUM3QjtRQUNKO1FBQ0EsSUFBSSxDQUFDakosU0FBUyxHQUFHO1FBQ2pCLHFFQUFxRTtRQUNyRSxJQUFJLENBQUNzSyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDekIseUJBQXlCLEdBQUc7UUFDakMsc0VBQXNFO1FBQ3RFLElBQUksQ0FBQ3VCLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNyQiwwQkFBMEIsR0FBRztRQUNsQyxJQUFJLENBQUNRLHNCQUFzQixHQUFHO1FBQzlCLElBQUksQ0FBQ0QsdUJBQXVCLEdBQUc7UUFDL0IsSUFBSSxDQUFDRSw4QkFBOEIsR0FBRztRQUN0QyxJQUFJLENBQUNPLHdCQUF3QixHQUFHO1FBQ2hDLElBQUksQ0FBQ0MsK0JBQStCLEdBQUc7UUFDdkMsSUFBSSxDQUFDNVIsT0FBTyxHQUFHQTtJQUNuQjtBQUNKO0FBRUEsTUFBTXFTO0lBQ0YsSUFBSTlCLGdCQUFnQjtRQUNoQixPQUFPLElBQUksQ0FBQytCLFVBQVU7SUFDMUI7SUFDQWpGLFlBQVk7UUFDUixnREFBZ0Q7UUFDaEQsTUFBTTdELFlBQVksSUFBSSxDQUFDc0gsa0JBQWtCLE1BQU0sSUFBSSxDQUFDeUIsbUJBQW1CLE1BQU0sSUFBSSxDQUFDQyxnQkFBZ0I7UUFDbEcsSUFBSWhKLFdBQVc7WUFDWCxJQUFJLENBQUNpSixvQkFBb0I7UUFDN0I7UUFDQSxNQUFNSCxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDMUssU0FBUyxFQUFFO1lBQ2pCO1FBQ0o7UUFDQSxJQUFJLENBQUMwSyxZQUFZO1lBQ2IsSUFBSSxDQUFDSSx1QkFBdUIsR0FBR0o7WUFDL0I7UUFDSjtRQUNBLElBQUk5SSxXQUFXO1lBQ1gsSUFBSSxDQUFDMkgsc0JBQXNCLEdBQUcsSUFBSSxDQUFDdkosU0FBUztZQUM1QyxJQUFJLENBQUM4Syx1QkFBdUIsR0FBR0o7WUFDL0IsSUFBSSxDQUFDSyw4QkFBOEIsR0FBRyxJQUFJLENBQUNDLGlCQUFpQjtZQUM1RCxJQUFJLENBQUNDLHFCQUFxQixHQUFHLElBQUksQ0FBQzdTLE9BQU8sQ0FBQzhTLGlCQUFpQixDQUFDLElBQUksQ0FBQ2xMLFNBQVMsRUFBRTBLLFlBQVksSUFBSSxDQUFDTSxpQkFBaUI7UUFDbEg7SUFDSjtJQUNBMUUsaUJBQWlCb0MsWUFBWSxFQUFFO1FBQzNCLElBQUlBLGlCQUFpQixJQUFJLENBQUMxSSxTQUFTLEVBQUU7WUFDakM7UUFDSjtRQUNBLElBQUksQ0FBQ0EsU0FBUyxHQUFHMEk7UUFDakIsSUFBSSxDQUFDakQsU0FBUztJQUNsQjtJQUNBLElBQUl1RixvQkFBb0I7UUFDcEIsT0FBTyxJQUFJLENBQUNHLHlCQUF5QjtJQUN6QztJQUNBLElBQUlILGtCQUFrQmxYLE9BQU8sRUFBRTtRQUMzQixJQUFJLENBQUNxWCx5QkFBeUIsR0FBR3JYO0lBQ3JDO0lBQ0FvVixxQkFBcUI7UUFDakIsT0FBTyxJQUFJLENBQUNLLHNCQUFzQixLQUFLLElBQUksQ0FBQ3ZKLFNBQVM7SUFDekQ7SUFDQTJLLHNCQUFzQjtRQUNsQixPQUFPLElBQUksQ0FBQ0csdUJBQXVCLEtBQUssSUFBSSxDQUFDSixVQUFVO0lBQzNEO0lBQ0FFLG1CQUFtQjtRQUNmLE9BQU8sQ0FBQy9ELGFBQWEsSUFBSSxDQUFDa0UsOEJBQThCLEVBQUUsSUFBSSxDQUFDQyxpQkFBaUI7SUFDcEY7SUFDQUgsdUJBQXVCO1FBQ25CLElBQUksSUFBSSxDQUFDSSxxQkFBcUIsRUFBRTtZQUM1QixJQUFJLENBQUNBLHFCQUFxQjtZQUMxQixJQUFJLENBQUNBLHFCQUFxQixHQUFHbm5CO1FBQ2pDO0lBQ0o7SUFDQSxJQUFJNG1CLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ1UsY0FBYyxJQUFJLElBQUksQ0FBQ0MsYUFBYSxJQUFJLElBQUksQ0FBQ0EsYUFBYSxDQUFDamhCLE9BQU87SUFDbEY7SUFDQWtoQixrQkFBa0I7UUFDZCxJQUFJLENBQUNELGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNELGNBQWMsR0FBRztJQUMxQjtJQUNBOWMsWUFBWThKLE9BQU8sQ0FBQztRQUNoQixJQUFJLENBQUMyTixLQUFLLEdBQUdtQyxtQkFBbUI7WUFDNUJ3QyxZQUFZLENBQUNqTyxNQUFNM0k7Z0JBQ2YsSUFBSSxDQUFDd1gsZUFBZTtnQkFDcEIsSUFBSSxDQUFDTixpQkFBaUIsR0FBR2xYO2dCQUN6QixJQUFJNFQsTUFBTWpMLE9BQU87b0JBQ2IsSUFBSSxDQUFDNE8sYUFBYSxHQUFHNU87Z0JBQ3pCLE9BQU87b0JBQ0gsSUFBSSxDQUFDMk8sY0FBYyxHQUFHM087Z0JBQzFCO2dCQUNBLElBQUksQ0FBQ2dKLFNBQVM7WUFDbEI7UUFDSjtRQUNBLElBQUksQ0FBQ3pGLFNBQVMsR0FBRztRQUNqQixxRUFBcUU7UUFDckUsSUFBSSxDQUFDcUwsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0YseUJBQXlCLEdBQUc7UUFDakMsSUFBSSxDQUFDNUIsc0JBQXNCLEdBQUc7UUFDOUIsSUFBSSxDQUFDdUIsdUJBQXVCLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyw4QkFBOEIsR0FBRztRQUN0QyxJQUFJLENBQUMzUyxPQUFPLEdBQUdBO0lBQ25CO0FBQ0o7QUFFQTs7Q0FFQyxHQUFHLFNBQVNtVDtJQUNULE1BQU0sRUFBRTVlLGVBQWUsRUFBRyxHQUFHM1MsaURBQVVBLENBQUMwUztJQUN4Q3lFLFVBQVV4RSxtQkFBbUIsTUFBTTtJQUNuQyxPQUFPQTtBQUNYO0FBRUEsU0FBUzZlLHVCQUF1QjVDLGlCQUFpQixFQUFFRSxrQkFBa0I7SUFDakUsTUFBTW5WLFVBQVU0WDtJQUNoQixNQUFNL0YsWUFBWXByQiw4Q0FBT0EsQ0FBQyxJQUFJLElBQUlxdUIsZ0JBQWdCOVUsUUFBUTBFLFVBQVUsS0FDbEU7UUFDRTFFO0tBQ0g7SUFDRCtRLDBCQUEwQjtRQUN0QmMsVUFBVW9ELGlCQUFpQixHQUFHQSxxQkFBcUI7UUFDbkRwRCxVQUFVQyxTQUFTO1FBQ25CLE9BQU8sSUFBSUQsVUFBVTZELG9CQUFvQjtJQUU3QyxHQUFHO1FBQ0M3RDtRQUNBb0Q7S0FDSDtJQUNEbEUsMEJBQTBCO1FBQ3RCYyxVQUFVc0Qsa0JBQWtCLEdBQUdBLHNCQUFzQjtRQUNyRHRELFVBQVVDLFNBQVM7UUFDbkIsT0FBTyxJQUFJRCxVQUFVc0UscUJBQXFCO0lBRTlDLEdBQUc7UUFDQ3RFO1FBQ0FzRDtLQUNIO0lBQ0QsT0FBT3REO0FBQ1g7QUFFQSxTQUFTaUc7SUFDTCxNQUFNOVgsVUFBVTRYO0lBQ2hCLE9BQU9ueEIsOENBQU9BLENBQUMsSUFBSSxJQUFJaXNCLHNCQUFzQjFTLFVBQzNDO1FBQ0VBO0tBQ0g7QUFDTDtBQUVBLE1BQU0rWDtJQUNGOVgsWUFBWTtRQUNSLE1BQU0rWCxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNMVgsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSXRCLFNBQVM7UUFDYixJQUFJLE9BQU9nWixLQUFLM1osSUFBSSxLQUFLLFVBQVU7WUFDL0JXLFNBQVNnWixLQUFLM1osSUFBSTtRQUN0QixPQUFPLElBQUksT0FBTzJaLEtBQUszWixJQUFJLEtBQUssWUFBWTtZQUN4Q1csU0FBU2daLEtBQUszWixJQUFJLENBQUNpQztRQUN2QixPQUFPO1lBQ0h0QixTQUFTLENBQUM7UUFDZDtRQUNBLE9BQU9BLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUlBLFNBQVM7SUFDM0Q7SUFDQWtJLFVBQVU7UUFDTixNQUFNOFEsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTTFYLFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBQzVCLElBQUksT0FBTzBYLEtBQUs5USxPQUFPLEtBQUssV0FBVztZQUNuQyxPQUFPOFEsS0FBSzlRLE9BQU87UUFDdkIsT0FBTyxJQUFJLE9BQU84USxLQUFLOVEsT0FBTyxLQUFLLFlBQVk7WUFDM0MsT0FBTzhRLEtBQUs5USxPQUFPLENBQUM1RztRQUN4QixPQUFPO1lBQ0gsT0FBTztRQUNYO0lBQ0o7SUFDQWUsV0FBVzRXLGFBQWEsRUFBRXBXLE1BQU0sRUFBRTtRQUM5QixNQUFNbVcsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTTFYLFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBQzVCLE1BQU0sRUFBRWUsVUFBVSxFQUFHLEdBQUcyVztRQUN4QixPQUFPM1csYUFBYUEsV0FBV2YsV0FBV3VCLFdBQVdvVyxjQUFjN1UsV0FBVztJQUNsRjtJQUNBRixVQUFVO1FBQ04sTUFBTThVLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU0xWCxVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUM1QixNQUFNdVIsWUFBWSxJQUFJLENBQUNBLFNBQVM7UUFDaEMsTUFBTSxFQUFFcUcsR0FBRyxFQUFHLEdBQUdGO1FBQ2pCLElBQUlFLEtBQUs7WUFDTEEsSUFBSTVYLFFBQVFvSCxPQUFPLElBQUlwSDtRQUMzQjtRQUNBdVIsVUFBVUMsU0FBUztJQUN2QjtJQUNBblgsWUFBWXFkLElBQUksRUFBRTFYLE9BQU8sRUFBRXVSLFNBQVMsQ0FBQztRQUNqQyxJQUFJLENBQUNtRyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDMVgsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ3VSLFNBQVMsR0FBR0E7SUFDckI7QUFDSjtBQUVBLFNBQVNzRyxjQUFjSCxJQUFJLEVBQUUxWCxPQUFPLEVBQUV1UixTQUFTO0lBQzNDLE1BQU1oRixVQUFVcG1CLDhDQUFPQSxDQUFDLElBQUksSUFBSXN4QixlQUFlQyxNQUFNMVgsU0FBU3VSLFlBQzVEO1FBQ0V2UjtRQUNBdVI7S0FDSDtJQUNEN3JCLGdEQUFTQSxDQUFDO1FBQ042bUIsUUFBUW1MLElBQUksR0FBR0E7SUFDbkIsR0FBRztRQUNDQTtLQUNIO0lBQ0QsT0FBT25MO0FBQ1g7QUFFQSxTQUFTdUwsWUFBWUosSUFBSTtJQUNyQixPQUFPdnhCLDhDQUFPQSxDQUFDO1FBQ1gsTUFBTXVZLFNBQVNnWixLQUFLM2QsSUFBSTtRQUN4Qm1ELFVBQVV3QixVQUFVLE1BQU07UUFDMUIsT0FBT0E7SUFDWCxHQUFHO1FBQ0NnWjtLQUNIO0FBQ0w7QUFFQSxTQUFTSyx3QkFBd0JMLElBQUksRUFBRTFYLE9BQU8sRUFBRXVSLFNBQVM7SUFDckQsTUFBTTdSLFVBQVU0WDtJQUNoQixNQUFNL0ssVUFBVXNMLGNBQWNILE1BQU0xWCxTQUFTdVI7SUFDN0MsTUFBTTNRLFdBQVdrWCxZQUFZSjtJQUM3QmpILDBCQUEwQixTQUFTdUg7UUFDL0IsSUFBSXBYLFlBQVksTUFBTTtZQUNsQixNQUFNLENBQUNtTCxXQUFXa00sV0FBVyxHQUFHdEYsZUFBZS9SLFVBQVUyTCxTQUFTN007WUFDbEVNLFFBQVFxUyxnQkFBZ0IsQ0FBQ3RHO1lBQ3pCd0YsVUFBVWMsZ0JBQWdCLENBQUN0RztZQUMzQixPQUFPa007UUFDWDtRQUNBO0lBQ0osR0FBRztRQUNDdlk7UUFDQU07UUFDQXVSO1FBQ0FoRjtRQUNBM0w7S0FDSDtBQUNMO0FBRUE7Ozs7Q0FJQyxHQUFHLFNBQVNzWCxRQUFRQyxPQUFPLEVBQUV4RyxJQUFJO0lBQzlCLE1BQU0rRixPQUFPakcsbUJBQW1CMEcsU0FBU3hHO0lBQ3pDelUsVUFBVSxDQUFDd2EsS0FBS1UsS0FBSyxFQUFFLENBQUMsMkpBQTJKLENBQUM7SUFDcEwsTUFBTXBZLFVBQVV3WDtJQUNoQixNQUFNakcsWUFBWWdHLHVCQUF1QkcsS0FBSzdYLE9BQU8sRUFBRTZYLEtBQUtXLGNBQWM7SUFDMUVOLHdCQUF3QkwsTUFBTTFYLFNBQVN1UjtJQUN2QyxPQUFPO1FBQ0hGLGtCQUFrQnFHLEtBQUsvRyxPQUFPLEVBQUUzUSxTQUFTdVI7UUFDekNNLHFCQUFxQk47UUFDckJTLHNCQUFzQlQ7S0FDekI7QUFDTDtBQUVBOzs7Q0FHQyxHQUFHLFNBQVMrRyxhQUFhM0gsT0FBTztJQUM3QixNQUFNalksa0JBQWtCNGU7SUFDeEIsTUFBTXRYLFVBQVV0SCxnQkFBZ0J1SCxVQUFVO0lBQzFDLE1BQU0sQ0FBQzRRLFdBQVdFLGdCQUFnQixHQUFHTCxhQUFhMVEsU0FBUzJRO0lBQzNEanJCLGdEQUFTQSxDQUFDLElBQUlzYSxRQUFRd0csdUJBQXVCLENBQUN1SztJQUU5Q3JyQixnREFBU0EsQ0FBQyxJQUFJc2EsUUFBUWlHLHNCQUFzQixDQUFDOEs7SUFFN0MsT0FBT0Y7QUFDWDtBQUVBLFNBQVMwSCxxQkFBcUJoSCxTQUFTO0lBQ25DLE9BQU9wckIsOENBQU9BLENBQUMsSUFBSW9yQixVQUFVTyxLQUFLLENBQUMyRSxVQUFVLElBQzNDO1FBQ0VsRjtLQUNIO0FBQ0w7QUFFQSxTQUFTaUgsdUJBQXVCM1ksT0FBTztJQUNuQyxNQUFNSCxVQUFVNFg7SUFDaEIsTUFBTS9GLFlBQVlwckIsOENBQU9BLENBQUMsSUFBSSxJQUFJcXdCLGdCQUFnQjlXLFFBQVEwRSxVQUFVLEtBQ2xFO1FBQ0UxRTtLQUNIO0lBQ0QrUSwwQkFBMEI7UUFDdEJjLFVBQVV3RixpQkFBaUIsR0FBR2xYLFdBQVc7UUFDekMwUixVQUFVQyxTQUFTO1FBQ25CLE9BQU8sSUFBSUQsVUFBVXFGLG9CQUFvQjtJQUU3QyxHQUFHO1FBQ0MvVztLQUNIO0lBQ0QsT0FBTzBSO0FBQ1g7QUFFQSxTQUFTa0g7SUFDTCxNQUFNL1ksVUFBVTRYO0lBQ2hCLE9BQU9ueEIsOENBQU9BLENBQUMsSUFBSSxJQUFJcXNCLHNCQUFzQjlTLFVBQzNDO1FBQ0VBO0tBQ0g7QUFDTDtBQUVBOzs7O0NBSUMsR0FBRyxTQUFTZ1osVUFBVWhCLElBQUk7SUFDdkIsTUFBTSxFQUFFaUIsTUFBTSxFQUFHLEdBQUdqQjtJQUNwQixPQUFPdnhCLDhDQUFPQSxDQUFDO1FBQ1grVyxVQUFVd2EsS0FBS2lCLE1BQU0sSUFBSSxNQUFNO1FBQy9CLE9BQU9ucEIsTUFBTUMsT0FBTyxDQUFDa3BCLFVBQVVBLFNBQVM7WUFDcENBO1NBQ0g7SUFDTCxHQUFHO1FBQ0NBO0tBQ0g7QUFDTDtBQUVBLE1BQU1DO0lBQ0YvUixVQUFVO1FBQ04sTUFBTTZRLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU0xWCxVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUM1QixPQUFPMFgsS0FBSzdRLE9BQU8sR0FBRzZRLEtBQUs3USxPQUFPLENBQUM3RyxRQUFRb0gsT0FBTyxJQUFJcEgsV0FBVztJQUNyRTtJQUNBcUQsUUFBUTtRQUNKLE1BQU1xVSxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNMVgsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSTBYLEtBQUtyVSxLQUFLLEVBQUU7WUFDWnFVLEtBQUtyVSxLQUFLLENBQUNyRCxRQUFRb0gsT0FBTyxJQUFJcEg7UUFDbEM7SUFDSjtJQUNBNkIsT0FBTztRQUNILE1BQU02VixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNMVgsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSTBYLEtBQUs3VixJQUFJLEVBQUU7WUFDWCxPQUFPNlYsS0FBSzdWLElBQUksQ0FBQzdCLFFBQVFvSCxPQUFPLElBQUlwSDtRQUN4QztRQUNBO0lBQ0o7SUFDQTNGLFlBQVlxZCxJQUFJLEVBQUUxWCxPQUFPLENBQUM7UUFDdEIsSUFBSSxDQUFDMFgsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzFYLE9BQU8sR0FBR0E7SUFDbkI7QUFDSjtBQUVBLFNBQVM2WSxjQUFjbkIsSUFBSSxFQUFFMVgsT0FBTztJQUNoQyxNQUFNeVcsYUFBYXR3Qiw4Q0FBT0EsQ0FBQyxJQUFJLElBQUl5eUIsZUFBZWxCLE1BQU0xWCxVQUN0RDtRQUNFQTtLQUNIO0lBQ0R0YSxnREFBU0EsQ0FBQztRQUNOK3dCLFdBQVdpQixJQUFJLEdBQUdBO0lBQ3RCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE9BQU9qQjtBQUNYO0FBRUEsU0FBU3FDLHdCQUF3QnBCLElBQUksRUFBRTFYLE9BQU8sRUFBRXVSLFNBQVM7SUFDckQsTUFBTTdSLFVBQVU0WDtJQUNoQixNQUFNYixhQUFhb0MsY0FBY25CLE1BQU0xWDtJQUN2QyxNQUFNMlksU0FBU0QsVUFBVWhCO0lBQ3pCakgsMEJBQTBCLFNBQVNzSTtRQUMvQixNQUFNLENBQUNoTixXQUFXa00sV0FBVyxHQUFHdkYsZUFBZWlHLFFBQVFsQyxZQUFZL1c7UUFDbkVNLFFBQVFxUyxnQkFBZ0IsQ0FBQ3RHO1FBQ3pCd0YsVUFBVWMsZ0JBQWdCLENBQUN0RztRQUMzQixPQUFPa007SUFDWCxHQUFHO1FBQ0N2WTtRQUNBTTtRQUNBeVc7UUFDQWxGO1FBQ0FvSCxPQUFPdGEsR0FBRyxDQUFDLENBQUM1VSxJQUFJQSxFQUFFeVAsUUFBUSxJQUN4QkUsSUFBSSxDQUFDO0tBQ1Y7QUFDTDtBQUVBOzs7O0NBSUMsR0FBRyxTQUFTNGYsUUFBUWIsT0FBTyxFQUFFeEcsSUFBSTtJQUM5QixNQUFNK0YsT0FBT2pHLG1CQUFtQjBHLFNBQVN4RztJQUN6QyxNQUFNM1IsVUFBVXlZO0lBQ2hCLE1BQU1sSCxZQUFZaUgsdUJBQXVCZCxLQUFLN1gsT0FBTztJQUNyRGlaLHdCQUF3QnBCLE1BQU0xWCxTQUFTdVI7SUFDdkMsT0FBTztRQUNIRixrQkFBa0JxRyxLQUFLL0csT0FBTyxFQUFFM1EsU0FBU3VSO1FBQ3pDZ0gscUJBQXFCaEg7S0FDeEI7QUFDTDtBQUVBLDRCQUE0QjtBQUM1QixTQUFTMEgsUUFBUUMsRUFBRTtJQUNmLElBQUl4YSxTQUFTO0lBQ2IsTUFBTXlhLFdBQVc7UUFDYixJQUFJemEsVUFBVSxNQUFNO1lBQ2hCQSxTQUFTd2E7UUFDYjtRQUNBLE9BQU94YTtJQUNYO0lBQ0EsT0FBT3lhO0FBQ1g7QUFDQTs7Q0FFQyxHQUFHLFNBQVNDLFFBQVF0YixLQUFLLEVBQUVDLElBQUk7SUFDNUIsT0FBT0QsTUFBTW5PLE1BQU0sQ0FBQyxDQUFDekksSUFBSUEsTUFBTTZXO0FBRW5DO0FBQ0EsU0FBU3NiLE1BQU1sYixNQUFNLEVBQUVDLE1BQU07SUFDekIsTUFBTUksTUFBTSxJQUFJOGE7SUFDaEIsTUFBTS9hLGFBQWEsQ0FBQ1IsT0FBT1MsSUFBSTBHLEdBQUcsQ0FBQ25IO0lBRW5DSSxPQUFPOVEsT0FBTyxDQUFDa1I7SUFDZkgsT0FBTy9RLE9BQU8sQ0FBQ2tSO0lBQ2YsTUFBTUcsU0FBUyxFQUFFO0lBQ2pCRixJQUFJblIsT0FBTyxDQUFDLENBQUN1UixNQUFNRixPQUFPckksSUFBSSxDQUFDdUk7SUFFL0IsT0FBT0Y7QUFDWDtBQUVBLE1BQU02YTtJQUNGQyxNQUFNQyxZQUFZLEVBQUU7UUFDaEIsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsT0FBTyxDQUFDeHlCLE1BQU07UUFDMUMsTUFBTXl5QixnQkFBZ0IsQ0FBQ3BSLE9BQU8sSUFBSSxDQUFDcVIsZ0JBQWdCLENBQUNyUixTQUFVLEVBQUNBLEtBQUtzUixRQUFRLElBQUl0UixLQUFLc1IsUUFBUSxDQUFDTCxhQUFZO1FBRTFHLElBQUksQ0FBQ0UsT0FBTyxHQUFHTixNQUFNLElBQUksQ0FBQ00sT0FBTyxDQUFDaHFCLE1BQU0sQ0FBQ2lxQixnQkFBZ0I7WUFDckRIO1NBQ0g7UUFDRCxPQUFPQyxtQkFBbUIsS0FBSyxJQUFJLENBQUNDLE9BQU8sQ0FBQ3h5QixNQUFNLEdBQUc7SUFDekQ7SUFDQTR5QixNQUFNQyxXQUFXLEVBQUU7UUFDZixNQUFNTixpQkFBaUIsSUFBSSxDQUFDQyxPQUFPLENBQUN4eUIsTUFBTTtRQUMxQyxJQUFJLENBQUN3eUIsT0FBTyxHQUFHUCxRQUFRLElBQUksQ0FBQ08sT0FBTyxDQUFDaHFCLE1BQU0sQ0FBQyxJQUFJLENBQUNrcUIsZ0JBQWdCLEdBQUdHO1FBQ25FLE9BQU9OLGlCQUFpQixLQUFLLElBQUksQ0FBQ0MsT0FBTyxDQUFDeHlCLE1BQU0sS0FBSztJQUN6RDtJQUNBOHlCLFFBQVE7UUFDSixJQUFJLENBQUNOLE9BQU8sR0FBRyxFQUFFO0lBQ3JCO0lBQ0F0ZixZQUFZd2YsZ0JBQWdCLENBQUM7UUFDekIsSUFBSSxDQUFDRixPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNFLGdCQUFnQixHQUFHQTtJQUM1QjtBQUNKO0FBRUEsTUFBTUs7SUFDRkMsOEJBQThCO1FBQzFCdnpCLE9BQU93RyxJQUFJLENBQUMsSUFBSSxDQUFDZ3RCLE1BQU0sQ0FBQ0MsZ0JBQWdCLEVBQUVodEIsT0FBTyxDQUFDLENBQUNpdEI7WUFDL0MxekIsT0FBT3NhLGNBQWMsQ0FBQyxJQUFJLENBQUNuRCxJQUFJLEVBQUV1YyxVQUFVO2dCQUN2Q2xaLGNBQWM7Z0JBQ2RELFlBQVk7Z0JBQ1oxRDtvQkFDSSxzQ0FBc0M7b0JBQ3RDVixRQUFRd2QsSUFBSSxDQUFDLENBQUMsK0JBQStCLEVBQUVELFNBQVMsdUJBQXVCLENBQUM7b0JBQ2hGLE9BQU87Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQUUsaUJBQWlCQyxZQUFZLEVBQUU7UUFDM0IsSUFBSUEsY0FBYztZQUNkLE1BQU1DLGdCQUFnQixDQUFDO1lBQ3ZCOXpCLE9BQU93RyxJQUFJLENBQUMsSUFBSSxDQUFDZ3RCLE1BQU0sQ0FBQ0MsZ0JBQWdCLEVBQUVodEIsT0FBTyxDQUFDLENBQUNpdEI7Z0JBQy9DLE1BQU1LLGFBQWEsSUFBSSxDQUFDUCxNQUFNLENBQUNDLGdCQUFnQixDQUFDQyxTQUFTO2dCQUN6RCxJQUFJSyxjQUFjLE1BQU07b0JBQ3BCRCxhQUFhLENBQUNKLFNBQVMsR0FBRzt3QkFDdEJuakIsT0FBT3dqQixXQUFXRixjQUFjLElBQUksQ0FBQ0wsTUFBTSxDQUFDUSxZQUFZO3dCQUN4RHhaLGNBQWM7d0JBQ2RELFlBQVk7b0JBQ2hCO2dCQUNKO1lBQ0o7WUFDQXZhLE9BQU9pMEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDOWMsSUFBSSxFQUFFMmM7UUFDdkM7SUFDSjtJQUNBOVQsVUFBVTtRQUNOLE9BQU87SUFDWDtJQUNBakgsWUFBWTtRQUNSLE9BQU8sSUFBSSxDQUFDNUIsSUFBSTtJQUNwQjtJQUNBZ0QsV0FBV2YsT0FBTyxFQUFFOGEsTUFBTSxFQUFFO1FBQ3hCLE9BQU9BLFdBQVc5YSxRQUFROEMsV0FBVztJQUN6QztJQUNBRixVQUFVO0lBQ1YsUUFBUTtJQUNSO0lBQ0F2SSxZQUFZK2YsTUFBTSxDQUFDO1FBQ2YsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDcmMsSUFBSSxHQUFHLENBQUM7UUFDYixJQUFJLENBQUNvYywyQkFBMkI7SUFDcEM7QUFDSjtBQUVBLE1BQU1ZLE9BQU87QUFDYixNQUFNQyxNQUFNO0FBQ1osTUFBTUMsT0FBTztBQUNiLE1BQU1DLE9BQU87QUFFYixJQUFJQyxjQUFjLFdBQVcsR0FBRXYwQixPQUFPdzBCLE1BQU0sQ0FBQztJQUN6Q0MsV0FBVztJQUNYTixNQUFNQTtJQUNORyxNQUFNQTtJQUNORCxNQUFNQTtJQUNORCxLQUFLQTtBQUNUO0FBRUEsU0FBU00sd0JBQXdCYixZQUFZLEVBQUVjLFVBQVUsRUFBRTVkLFlBQVk7SUFDbkUsTUFBTWUsU0FBUzZjLFdBQVczZCxNQUFNLENBQUMsQ0FBQzRkLGFBQWFDLFlBQVlELGVBQWVmLGFBQWFpQixPQUFPLENBQUNELFlBQzdGO0lBQ0YsT0FBTy9jLFVBQVUsT0FBT0EsU0FBU2Y7QUFDckM7QUFFQSxNQUFNZ2Usb0JBQW9CO0lBQ3RCLENBQUNaLEtBQUssRUFBRTtRQUNKVixrQkFBa0I7WUFDZHVCLE9BQU8sQ0FBQ25CLGVBQWVqckIsTUFBTTNJLFNBQVMsQ0FBQ3VULEtBQUssQ0FBQ3JULElBQUksQ0FBQzB6QixhQUFhbUIsS0FBSztZQUVwRTlkLE9BQU8sQ0FBQzJjLGVBQWVBLGFBQWEzYyxLQUFLO1lBRXpDMmMsY0FBYyxDQUFDQSxlQUFlQTtRQUNsQztRQUNBRyxjQUFjO1lBQ1Y7U0FDSDtJQUNMO0lBQ0EsQ0FBQ00sS0FBSyxFQUFFO1FBQ0piLGtCQUFrQjtZQUNkd0IsTUFBTSxDQUFDcEIsY0FBY0csZUFBZVUsd0JBQXdCYixjQUFjRyxjQUFjO1lBRXhGSCxjQUFjLENBQUNBLGVBQWVBO1FBQ2xDO1FBQ0FHLGNBQWM7WUFDVjtZQUNBO1NBQ0g7SUFDTDtJQUNBLENBQUNJLElBQUksRUFBRTtRQUNIWCxrQkFBa0I7WUFDZHlCLE1BQU0sQ0FBQ3JCLGNBQWNHLGVBQWVVLHdCQUF3QmIsY0FBY0csY0FBYyxJQUFJdHpCLEtBQUssQ0FBQztZQUVsR216QixjQUFjLENBQUNBLGVBQWVBO1FBQ2xDO1FBQ0FHLGNBQWM7WUFDVjtZQUNBO1NBQ0g7SUFDTDtJQUNBLENBQUNLLEtBQUssRUFBRTtRQUNKWixrQkFBa0I7WUFDZDBCLE1BQU0sQ0FBQ3RCLGNBQWNHLGVBQWVVLHdCQUF3QmIsY0FBY0csY0FBYztZQUV4RkgsY0FBYyxDQUFDQSxlQUFlQTtRQUNsQztRQUNBRyxjQUFjO1lBQ1Y7WUFDQTtTQUNIO0lBQ0w7QUFDSjtBQUVBLFNBQVNvQix1QkFBdUJqaUIsSUFBSSxFQUFFMGdCLFlBQVk7SUFDOUMsTUFBTUwsU0FBU3VCLGlCQUFpQixDQUFDNWhCLEtBQUs7SUFDdEMsSUFBSSxDQUFDcWdCLFFBQVE7UUFDVCxNQUFNLElBQUk3ZixNQUFNLENBQUMsWUFBWSxFQUFFUixLQUFLLHFCQUFxQixDQUFDO0lBQzlEO0lBQ0EsTUFBTTJFLFNBQVMsSUFBSXdiLGlCQUFpQkU7SUFDcEMxYixPQUFPOGIsZ0JBQWdCLENBQUNDO0lBQ3hCLE9BQU8vYjtBQUNYO0FBQ0EsU0FBU3VkLG9CQUFvQnhCLFlBQVk7SUFDckMsSUFBSSxDQUFDQSxjQUFjO1FBQ2YsT0FBTztJQUNYO0lBQ0EsTUFBTXlCLG9CQUFvQjFzQixNQUFNM0ksU0FBUyxDQUFDdVQsS0FBSyxDQUFDclQsSUFBSSxDQUFDMHpCLGFBQWF6TixLQUFLLElBQUksRUFBRTtJQUM3RSxPQUFPcG1CLE9BQU93RyxJQUFJLENBQUN1dUIsbUJBQW1CaHNCLE1BQU0sQ0FBQyxDQUFDd3NCO1FBQzFDLE1BQU1DLGFBQWFULGlCQUFpQixDQUFDUSxlQUFlO1FBQ3BELElBQUksQ0FBRUMsQ0FBQUEsZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSSxLQUFLLElBQUlBLFdBQVd4QixZQUFZLEdBQUc7WUFDcEYsT0FBTztRQUNYO1FBQ0EsT0FBT3dCLFdBQVd4QixZQUFZLENBQUN6WCxJQUFJLENBQUMsQ0FBQ3pjLElBQUl3MUIsa0JBQWtCbDFCLE9BQU8sQ0FBQ04sS0FBSyxDQUFDO0lBRTdFLEVBQUUsQ0FBQyxFQUFFLElBQUk7QUFDYjtBQUVBLE1BQU0yMUIsWUFBWXBELFFBQVEsSUFBSSxXQUFXcUQsSUFBSSxDQUFDQyxVQUFVQyxTQUFTO0FBRWpFLE1BQU1DLFdBQVd4RCxRQUFRLElBQUluUyxRQUFRbUksT0FBT3lOLE1BQU07QUFHbEQsTUFBTUM7SUFDRkMsWUFBWTl2QixDQUFDLEVBQUU7UUFDWCxNQUFNLEVBQUUrdkIsRUFBRSxFQUFHQyxFQUFFLEVBQUdDLEdBQUcsRUFBR0MsR0FBRyxFQUFHQyxHQUFHLEVBQUcsR0FBRyxJQUFJO1FBQzNDLGlFQUFpRTtRQUNqRSxJQUFJLzFCLElBQUkyMUIsR0FBRzExQixNQUFNLEdBQUc7UUFDcEIsSUFBSTJGLE1BQU0rdkIsRUFBRSxDQUFDMzFCLEVBQUUsRUFBRTtZQUNiLE9BQU80MUIsRUFBRSxDQUFDNTFCLEVBQUU7UUFDaEI7UUFDQSxnR0FBZ0c7UUFDaEcsSUFBSWcyQixNQUFNO1FBQ1YsSUFBSUMsT0FBT0YsSUFBSTkxQixNQUFNLEdBQUc7UUFDeEIsSUFBSWkyQjtRQUNKLE1BQU1GLE9BQU9DLEtBQUs7WUFDZEMsTUFBTXpxQixLQUFLMHFCLEtBQUssQ0FBQyxNQUFPSCxDQUFBQSxNQUFNQyxJQUFHO1lBQ2pDLE1BQU1HLFFBQVFULEVBQUUsQ0FBQ08sSUFBSTtZQUNyQixJQUFJRSxRQUFReHdCLEdBQUc7Z0JBQ1hvd0IsTUFBTUUsTUFBTTtZQUNoQixPQUFPLElBQUlFLFFBQVF4d0IsR0FBRztnQkFDbEJxd0IsT0FBT0MsTUFBTTtZQUNqQixPQUFPO2dCQUNILE9BQU9OLEVBQUUsQ0FBQ00sSUFBSTtZQUNsQjtRQUNKO1FBQ0FsMkIsSUFBSXlMLEtBQUs0cUIsR0FBRyxDQUFDLEdBQUdKO1FBQ2hCLGNBQWM7UUFDZCxNQUFNSyxPQUFPMXdCLElBQUkrdkIsRUFBRSxDQUFDMzFCLEVBQUU7UUFDdEIsTUFBTXUyQixTQUFTRCxPQUFPQTtRQUN0QixPQUFPVixFQUFFLENBQUM1MUIsRUFBRSxHQUFHNjFCLEdBQUcsQ0FBQzcxQixFQUFFLEdBQUdzMkIsT0FBT1IsR0FBRyxDQUFDOTFCLEVBQUUsR0FBR3UyQixTQUFTUixHQUFHLENBQUMvMUIsRUFBRSxHQUFHczJCLE9BQU9DO0lBQ3JFO0lBQ0FwakIsWUFBWXdpQixFQUFFLEVBQUVDLEVBQUUsQ0FBQztRQUNmLE1BQU0sRUFBRTMxQixNQUFNLEVBQUcsR0FBRzAxQjtRQUNwQiwyQ0FBMkM7UUFDM0MsTUFBTWEsVUFBVSxFQUFFO1FBQ2xCLElBQUksSUFBSXgyQixJQUFJLEdBQUdBLElBQUlDLFFBQVFELElBQUk7WUFDM0J3MkIsUUFBUXJuQixJQUFJLENBQUNuUDtRQUNqQjtRQUNBdzJCLFFBQVFDLElBQUksQ0FBQyxDQUFDbDBCLEdBQUdDLElBQUltekIsRUFBRSxDQUFDcHpCLEVBQUUsR0FBR296QixFQUFFLENBQUNuekIsRUFBRSxHQUFHLENBQUMsSUFBSTtRQUUxQyxNQUFNazBCLE1BQU0sRUFBRTtRQUNkLE1BQU1DLEtBQUssRUFBRTtRQUNiLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJLElBQUlDLEtBQUssR0FBR0EsS0FBSzcyQixTQUFTLEdBQUc2MkIsS0FBSztZQUNsQ0YsS0FBS2pCLEVBQUUsQ0FBQ21CLEtBQUssRUFBRSxHQUFHbkIsRUFBRSxDQUFDbUIsR0FBRztZQUN4QkQsS0FBS2pCLEVBQUUsQ0FBQ2tCLEtBQUssRUFBRSxHQUFHbEIsRUFBRSxDQUFDa0IsR0FBRztZQUN4QkosSUFBSXZuQixJQUFJLENBQUN5bkI7WUFDVEQsR0FBR3huQixJQUFJLENBQUMwbkIsS0FBS0Q7UUFDakI7UUFDQSw0QkFBNEI7UUFDNUIsTUFBTWYsTUFBTTtZQUNSYyxFQUFFLENBQUMsRUFBRTtTQUNSO1FBQ0QsSUFBSSxJQUFJSSxLQUFLLEdBQUdBLEtBQUtMLElBQUl6MkIsTUFBTSxHQUFHLEdBQUc4MkIsS0FBSztZQUN0QyxNQUFNQyxLQUFLTCxFQUFFLENBQUNJLEdBQUc7WUFDakIsTUFBTUUsUUFBUU4sRUFBRSxDQUFDSSxLQUFLLEVBQUU7WUFDeEIsSUFBSUMsS0FBS0MsU0FBUyxHQUFHO2dCQUNqQnBCLElBQUkxbUIsSUFBSSxDQUFDO1lBQ2IsT0FBTztnQkFDSHluQixLQUFLRixHQUFHLENBQUNLLEdBQUc7Z0JBQ1osTUFBTUcsU0FBU1IsR0FBRyxDQUFDSyxLQUFLLEVBQUU7Z0JBQzFCLE1BQU1JLFNBQVNQLEtBQUtNO2dCQUNwQnJCLElBQUkxbUIsSUFBSSxDQUFDLElBQUlnb0IsU0FBVSxFQUFDQSxTQUFTRCxNQUFLLElBQUtGLEtBQUssQ0FBQ0csU0FBU1AsRUFBQyxJQUFLSyxLQUFJO1lBQ3hFO1FBQ0o7UUFDQXBCLElBQUkxbUIsSUFBSSxDQUFDd25CLEVBQUUsQ0FBQ0EsR0FBRzEyQixNQUFNLEdBQUcsRUFBRTtRQUMxQix5Q0FBeUM7UUFDekMsTUFBTTYxQixNQUFNLEVBQUU7UUFDZCxNQUFNQyxNQUFNLEVBQUU7UUFDZCxJQUFJcUI7UUFDSixJQUFJLElBQUlDLEtBQUssR0FBR0EsS0FBS3hCLElBQUk1MUIsTUFBTSxHQUFHLEdBQUdvM0IsS0FBSztZQUN0Q0QsSUFBSVQsRUFBRSxDQUFDVSxHQUFHO1lBQ1YsTUFBTXIxQixLQUFLNnpCLEdBQUcsQ0FBQ3dCLEdBQUc7WUFDbEIsTUFBTUMsUUFBUSxJQUFJWixHQUFHLENBQUNXLEdBQUc7WUFDekIsTUFBTUYsU0FBU24xQixLQUFLNnpCLEdBQUcsQ0FBQ3dCLEtBQUssRUFBRSxHQUFHRCxJQUFJQTtZQUN0Q3RCLElBQUkzbUIsSUFBSSxDQUFDLENBQUNpb0IsSUFBSXAxQixLQUFLbTFCLE1BQUssSUFBS0c7WUFDN0J2QixJQUFJNW1CLElBQUksQ0FBQ2dvQixTQUFTRyxRQUFRQTtRQUM5QjtRQUNBLElBQUksQ0FBQzNCLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBR0E7SUFDZjtBQUNKO0FBRUEsTUFBTXdCLGlCQUFpQjtBQUN2QixTQUFTQyxzQkFBc0JsVyxJQUFJO0lBQy9CLE1BQU1tVyxLQUFLblcsS0FBS29XLFFBQVEsS0FBS0gsaUJBQWlCalcsT0FBT0EsS0FBS3FXLGFBQWE7SUFDdkUsSUFBSSxDQUFDRixJQUFJO1FBQ0wsT0FBTztJQUNYO0lBQ0EsTUFBTSxFQUFFRyxHQUFHLEVBQUdDLElBQUksRUFBRyxHQUFHSixHQUFHSyxxQkFBcUI7SUFDaEQsT0FBTztRQUNIbHlCLEdBQUdpeUI7UUFDSGh5QixHQUFHK3hCO0lBQ1A7QUFDSjtBQUNBLFNBQVNHLHVCQUF1Qng0QixDQUFDO0lBQzdCLE9BQU87UUFDSHFHLEdBQUdyRyxFQUFFeTRCLE9BQU87UUFDWm55QixHQUFHdEcsRUFBRTA0QixPQUFPO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTQyxZQUFZNVcsSUFBSTtJQUNyQixJQUFJalY7SUFDSixPQUFPaVYsS0FBSzZXLFFBQVEsS0FBSyxTQUFVaEQsQ0FBQUEsZUFBZSxDQUFFLEVBQUM5b0IsTUFBTWtWLFNBQVM2VyxlQUFlLE1BQU0sUUFBUS9yQixRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUl1bUIsUUFBUSxDQUFDdFIsS0FBSSxDQUFDO0FBQ2pKO0FBQ0EsU0FBUytXLG1CQUFtQkMsT0FBTyxFQUFFdk4sV0FBVyxFQUFFd04sV0FBVyxFQUFFQyxZQUFZO0lBQ3ZFLElBQUlDLG1CQUFtQkgsVUFBVXZOLFlBQVl6bkIsS0FBSyxHQUFHaTFCO0lBQ3JELElBQUlHLG9CQUFvQkosVUFBVXZOLFlBQVl4bkIsTUFBTSxHQUFHaTFCO0lBQ3ZELHVEQUF1RDtJQUN2RCxJQUFJakQsY0FBYytDLFNBQVM7UUFDdkJJLHFCQUFxQjNRLE9BQU80USxnQkFBZ0I7UUFDNUNGLG9CQUFvQjFRLE9BQU80USxnQkFBZ0I7SUFDL0M7SUFDQSxPQUFPO1FBQ0hGO1FBQ0FDO0lBQ0o7QUFDSjtBQUNBLFNBQVNFLHFCQUFxQkMsVUFBVSxFQUFFOU4sV0FBVyxFQUFFNVMsWUFBWSxFQUFFMmdCLFdBQVcsRUFBRUMsV0FBVztJQUN6Riw2RUFBNkU7SUFDN0UsZ0ZBQWdGO0lBQ2hGLE1BQU1ULFVBQVVKLFlBQVluTjtJQUM1QixNQUFNaUUsa0JBQWtCc0osVUFBVU8sYUFBYTlOO0lBQy9DLE1BQU1pTyxrQ0FBa0N4QixzQkFBc0J4STtJQUM5RCxNQUFNaUssd0JBQXdCO1FBQzFCcnpCLEdBQUd1UyxhQUFhdlMsQ0FBQyxHQUFHb3pCLGdDQUFnQ3B6QixDQUFDO1FBQ3JEQyxHQUFHc1MsYUFBYXRTLENBQUMsR0FBR216QixnQ0FBZ0NuekIsQ0FBQztJQUN6RDtJQUNBLE1BQU0sRUFBRXF6QixhQUFhWCxXQUFXLEVBQUdZLGNBQWNYLFlBQVksRUFBRyxHQUFHSztJQUNuRSxNQUFNLEVBQUVPLE9BQU8sRUFBR0MsT0FBTyxFQUFHLEdBQUdQO0lBQy9CLE1BQU0sRUFBRUwsZ0JBQWdCLEVBQUdDLGlCQUFpQixFQUFHLEdBQUdMLG1CQUFtQkMsU0FBU3ZOLGFBQWF3TixhQUFhQztJQUN4RyxNQUFNYyxtQkFBbUI7UUFDckIsTUFBTUMsZUFBZSxJQUFJOUQscUJBQXFCO1lBQzFDO1lBQ0E7WUFDQTtTQUNILEVBQUU7WUFDQyxrQkFBa0I7WUFDbEJ3RCxzQkFBc0JwekIsQ0FBQztZQUN2QixzQkFBc0I7WUFDckJvekIsc0JBQXNCcHpCLENBQUMsR0FBRzJ5QixlQUFnQkU7WUFDM0MscUJBQXFCO1lBQ3JCTyxzQkFBc0JwekIsQ0FBQyxHQUFHNnlCLG9CQUFvQkY7U0FDakQ7UUFDRCxJQUFJM3lCLElBQUkwekIsYUFBYTdELFdBQVcsQ0FBQzJEO1FBQ2pDLHVDQUF1QztRQUN2QyxJQUFJOUQsY0FBYytDLFNBQVM7WUFDdkIsZ0VBQWdFO1lBQ2hFenlCLEtBQUssQ0FBQ2tpQixPQUFPNFEsZ0JBQWdCLEdBQUcsS0FBS0Q7UUFDekM7UUFDQSxPQUFPN3lCO0lBQ1g7SUFDQSxNQUFNMnpCLG1CQUFtQjtRQUNyQixvREFBb0Q7UUFDcEQsb0RBQW9EO1FBQ3BELE1BQU1DLGVBQWUsSUFBSWhFLHFCQUFxQjtZQUMxQztZQUNBO1lBQ0E7U0FDSCxFQUFFO1lBQ0MsbUJBQW1CO1lBQ25Cd0Qsc0JBQXNCcnpCLENBQUM7WUFDdkIsc0JBQXNCO1lBQ3JCcXpCLHNCQUFzQnJ6QixDQUFDLEdBQUcyeUIsY0FBZUU7WUFDMUMsb0JBQW9CO1lBQ3BCUSxzQkFBc0JyekIsQ0FBQyxHQUFHNnlCLG1CQUFtQkY7U0FDaEQ7UUFDRCxPQUFPa0IsYUFBYS9ELFdBQVcsQ0FBQzBEO0lBQ3BDO0lBQ0EsNkNBQTZDO0lBQzdDLE1BQU0sRUFBRU0sT0FBTyxFQUFHQyxPQUFPLEVBQUcsR0FBR1o7SUFDL0IsTUFBTWEsa0JBQWtCRixZQUFZLEtBQUtBO0lBQ3pDLE1BQU1HLGtCQUFrQkYsWUFBWSxLQUFLQTtJQUN6QyxPQUFPO1FBQ0gvekIsR0FBR2cwQixrQkFBa0JGLFVBQVVGO1FBQy9CM3pCLEdBQUdnMEIsa0JBQWtCRixVQUFVTDtJQUNuQztBQUNKO0FBRUEsSUFBSVEsa0JBQWtCLE1BQU1DO0lBQ3hCLElBQUloUyxTQUFTO1FBQ1QsSUFBSSxJQUFJLENBQUNMLGFBQWEsRUFBRTtZQUNwQixPQUFPLElBQUksQ0FBQ0EsYUFBYTtRQUM3QixPQUFPLElBQUksS0FBa0IsRUFBYSxFQUV6QztRQUNELE9BQU8vZTtJQUNYO0lBQ0EsSUFBSTRZLFdBQVc7UUFDWCxJQUFJbFY7UUFDSixJQUFJLENBQUNBLE1BQU0sSUFBSSxDQUFDcWIsYUFBYSxNQUFNLFFBQVFyYixRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUlrVixRQUFRLEVBQUU7WUFDL0UsT0FBTyxJQUFJLENBQUNtRyxhQUFhLENBQUNuRyxRQUFRO1FBQ3RDLE9BQU8sSUFBSSxJQUFJLENBQUN3RyxNQUFNLEVBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUNBLE1BQU0sQ0FBQ3hHLFFBQVE7UUFDL0IsT0FBTztZQUNILE9BQU81WTtRQUNYO0lBQ0o7SUFDQSxJQUFJcXhCLGNBQWM7UUFDZCxJQUFJM3RCO1FBQ0osT0FBTyxDQUFDLENBQUNBLE1BQU0sSUFBSSxDQUFDNHRCLFdBQVcsTUFBTSxRQUFRNXRCLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSTJ0QixXQUFXLEtBQUssSUFBSSxDQUFDalMsTUFBTTtJQUMxRztJQUNBNVUsWUFBWXVVLGFBQWEsRUFBRS9PLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUN1aEIsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ3hTLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDdVMsV0FBVyxHQUFHdGhCO0lBQ3ZCO0FBQ0o7QUFFQSxTQUFTd2hCLGdCQUFnQjNuQixHQUFHLEVBQUVrRixHQUFHLEVBQUV6SCxLQUFLO0lBQ3BDLElBQUl5SCxPQUFPbEYsS0FBSztRQUNaOVMsT0FBT3NhLGNBQWMsQ0FBQ3hILEtBQUtrRixLQUFLO1lBQzVCekgsT0FBT0E7WUFDUGdLLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ2Q7SUFDSixPQUFPO1FBQ0gzSCxHQUFHLENBQUNrRixJQUFJLEdBQUd6SDtJQUNmO0lBQ0EsT0FBT3VDO0FBQ1g7QUFDQSxTQUFTNG5CLGNBQWMvZixNQUFNO0lBQ3pCLElBQUksSUFBSXJhLElBQUksR0FBR0EsSUFBSW9VLFVBQVVuVSxNQUFNLEVBQUVELElBQUk7UUFDckMsSUFBSXNaLFNBQVNsRixTQUFTLENBQUNwVSxFQUFFLElBQUksT0FBT29VLFNBQVMsQ0FBQ3BVLEVBQUUsR0FBRyxDQUFDO1FBQ3BELElBQUlzYSxVQUFVNWEsT0FBT3dHLElBQUksQ0FBQ29UO1FBQzFCLElBQUksT0FBTzVaLE9BQU9LLHFCQUFxQixLQUFLLFlBQVk7WUFDcER1YSxVQUFVQSxRQUFRQyxNQUFNLENBQUM3YSxPQUFPSyxxQkFBcUIsQ0FBQ3VaLFFBQVE3USxNQUFNLENBQUMsU0FBUytSLEdBQUc7Z0JBQzdFLE9BQU85YSxPQUFPK2Esd0JBQXdCLENBQUNuQixRQUFRa0IsS0FBS1AsVUFBVTtZQUNsRTtRQUNKO1FBQ0FLLFFBQVFuVSxPQUFPLENBQUMsU0FBU3VSLEdBQUc7WUFDeEJ5aUIsZ0JBQWdCOWYsUUFBUTNDLEtBQUs0QixNQUFNLENBQUM1QixJQUFJO1FBQzVDO0lBQ0o7SUFDQSxPQUFPMkM7QUFDWDtBQUNBLE1BQU1nZ0I7SUFDRjs7RUFFRixHQUFHQyxVQUFVO1FBQ1AsSUFBSWp1QixLQUFLa3VCO1FBQ1QsT0FBTztZQUNIQyxvQkFBb0IsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQ0MsSUFBSTtZQUNoREMsMEJBQTBCLElBQUksQ0FBQ0Esd0JBQXdCLENBQUNELElBQUk7WUFDNURFLG1CQUFtQixJQUFJLENBQUNBLGlCQUFpQixDQUFDRixJQUFJO1lBQzlDRyxhQUFhLElBQUksQ0FBQ0EsV0FBVyxDQUFDSCxJQUFJO1lBQ2xDSSxvQkFBb0IsQ0FBQyxDQUFDeHVCLE1BQU0sSUFBSSxDQUFDd3VCLGtCQUFrQixNQUFNLFFBQVF4dUIsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJcE0sTUFBTSxLQUFLO1lBQzFHNjZCLGVBQWUsSUFBSSxDQUFDQSxhQUFhLENBQUM3NkIsTUFBTTtZQUN4Qzg2QixvQkFBb0IsSUFBSSxDQUFDQSxrQkFBa0IsQ0FBQzk2QixNQUFNO1lBQ2xEKzZCLG1CQUFtQixDQUFDLENBQUNULE9BQU8sSUFBSSxDQUFDUyxpQkFBaUIsTUFBTSxRQUFRVCxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUt0NkIsTUFBTSxLQUFLO1FBQy9HO0lBQ0o7SUFDQSxrQkFBa0I7SUFDbEIsSUFBSThuQixTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUNwUCxPQUFPLENBQUNvUCxNQUFNO0lBQzlCO0lBQ0EsSUFBSXhHLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQzVJLE9BQU8sQ0FBQzRJLFFBQVE7SUFDaEM7SUFDQTs7RUFFRixHQUFHLElBQUl5WSxjQUFjO1FBQ2YsT0FBTyxJQUFJLENBQUNyaEIsT0FBTyxDQUFDcWhCLFdBQVc7SUFDbkM7SUFDQWxjLFFBQVE7UUFDSixNQUFNbWQsT0FBTyxJQUFJLENBQUNqQixXQUFXO1FBQzdCLElBQUlpQixTQUFTdHlCLFdBQVc7WUFDcEI7UUFDSjtRQUNBLElBQUlzeUIsS0FBS0Msd0JBQXdCLEVBQUU7WUFDL0IsTUFBTSxJQUFJN25CLE1BQU07UUFDcEI7UUFDQTRuQixLQUFLQyx3QkFBd0IsR0FBRztRQUNoQyxJQUFJLENBQUNDLGlCQUFpQixDQUFDRjtJQUMzQjtJQUNBbGQsV0FBVztRQUNQLE1BQU1rZCxPQUFPLElBQUksQ0FBQ2pCLFdBQVc7UUFDN0IsSUFBSWlCLFNBQVN0eUIsV0FBVztZQUNwQjtRQUNKO1FBQ0FzeUIsS0FBS0Msd0JBQXdCLEdBQUc7UUFDaEMsSUFBSSxDQUFDRSxvQkFBb0IsQ0FBQyxJQUFJLENBQUNwQixXQUFXO1FBQzFDLElBQUksQ0FBQ3FCLDBCQUEwQjtRQUMvQixJQUFJLElBQUksQ0FBQ0MsbUJBQW1CLEVBQUU7WUFDMUIsSUFBSWp2QjtZQUNIQSxDQUFBQSxNQUFNLElBQUksQ0FBQzBiLE1BQU0sTUFBTSxRQUFRMWIsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJa3ZCLG9CQUFvQixDQUFDLElBQUksQ0FBQ0QsbUJBQW1CO1FBQy9HO0lBQ0o7SUFDQXZNLG1CQUFtQjVWLFFBQVEsRUFBRW1JLElBQUksRUFBRTNJLE9BQU8sRUFBRTtRQUN4QyxJQUFJLENBQUMraEIsd0JBQXdCLENBQUNwakIsR0FBRyxDQUFDNkIsVUFBVVI7UUFDNUMsSUFBSSxDQUFDNmhCLGtCQUFrQixDQUFDbGpCLEdBQUcsQ0FBQzZCLFVBQVVtSTtRQUN0QyxPQUFPO1lBQ0gsSUFBSSxDQUFDa1osa0JBQWtCLENBQUN6VSxNQUFNLENBQUM1TTtZQUMvQixJQUFJLENBQUN1aEIsd0JBQXdCLENBQUMzVSxNQUFNLENBQUM1TTtRQUN6QztJQUNKO0lBQ0FvVixrQkFBa0JwVixRQUFRLEVBQUVtSSxJQUFJLEVBQUUzSSxPQUFPLEVBQUU7UUFDdkMsSUFBSSxDQUFDaWlCLFdBQVcsQ0FBQ3RqQixHQUFHLENBQUM2QixVQUFVbUk7UUFDL0IsSUFBSSxDQUFDcVosaUJBQWlCLENBQUNyakIsR0FBRyxDQUFDNkIsVUFBVVI7UUFDckMsTUFBTTZpQixrQkFBa0IsQ0FBQ2o4QixJQUFJLElBQUksQ0FBQ2k4QixlQUFlLENBQUNqOEIsR0FBRzRaO1FBRXJELE1BQU1zaUIsb0JBQW9CLENBQUNsOEIsSUFBSSxJQUFJLENBQUNrOEIsaUJBQWlCLENBQUNsOEI7UUFFdEQraEIsS0FBS29hLFlBQVksQ0FBQyxhQUFhO1FBQy9CcGEsS0FBS3FhLGdCQUFnQixDQUFDLGFBQWFIO1FBQ25DbGEsS0FBS3FhLGdCQUFnQixDQUFDLGVBQWVGO1FBQ3JDLE9BQU87WUFDSCxJQUFJLENBQUNiLFdBQVcsQ0FBQzdVLE1BQU0sQ0FBQzVNO1lBQ3hCLElBQUksQ0FBQ3doQixpQkFBaUIsQ0FBQzVVLE1BQU0sQ0FBQzVNO1lBQzlCbUksS0FBS3NhLG1CQUFtQixDQUFDLGFBQWFKO1lBQ3RDbGEsS0FBS3NhLG1CQUFtQixDQUFDLGVBQWVIO1lBQ3hDbmEsS0FBS29hLFlBQVksQ0FBQyxhQUFhO1FBQ25DO0lBQ0o7SUFDQTNMLGtCQUFrQmhWLFFBQVEsRUFBRXVHLElBQUksRUFBRTtRQUM5QixNQUFNdWEsa0JBQWtCLENBQUN0OEIsSUFBSSxJQUFJLENBQUNzOEIsZUFBZSxDQUFDdDhCLEdBQUd3YjtRQUVyRCxNQUFNK2dCLGlCQUFpQixDQUFDdjhCLElBQUksSUFBSSxDQUFDdThCLGNBQWMsQ0FBQ3Y4QixHQUFHd2I7UUFFbkQsTUFBTWdoQixhQUFhLENBQUN4OEIsSUFBSSxJQUFJLENBQUN3OEIsVUFBVSxDQUFDeDhCLEdBQUd3YjtRQUUzQ3VHLEtBQUtxYSxnQkFBZ0IsQ0FBQyxhQUFhRTtRQUNuQ3ZhLEtBQUtxYSxnQkFBZ0IsQ0FBQyxZQUFZRztRQUNsQ3hhLEtBQUtxYSxnQkFBZ0IsQ0FBQyxRQUFRSTtRQUM5QixPQUFPO1lBQ0h6YSxLQUFLc2EsbUJBQW1CLENBQUMsYUFBYUM7WUFDdEN2YSxLQUFLc2EsbUJBQW1CLENBQUMsWUFBWUU7WUFDckN4YSxLQUFLc2EsbUJBQW1CLENBQUMsUUFBUUc7UUFDckM7SUFDSjtJQUNBWixrQkFBa0I5Z0IsTUFBTSxFQUFFO1FBQ3RCLDJEQUEyRDtRQUMzRCxJQUFJLENBQUNBLE9BQU9zaEIsZ0JBQWdCLEVBQUU7WUFDMUI7UUFDSjtRQUNBdGhCLE9BQU9zaEIsZ0JBQWdCLENBQUMsYUFBYSxJQUFJLENBQUNLLGtCQUFrQjtRQUM1RDNoQixPQUFPc2hCLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDTSx5QkFBeUIsRUFBRTtRQUNyRTVoQixPQUFPc2hCLGdCQUFnQixDQUFDLFdBQVcsSUFBSSxDQUFDTyx1QkFBdUIsRUFBRTtRQUNqRTdoQixPQUFPc2hCLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDUSxrQkFBa0I7UUFDNUQ5aEIsT0FBT3NoQixnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ1MseUJBQXlCLEVBQUU7UUFDckUvaEIsT0FBT3NoQixnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ1UseUJBQXlCLEVBQUU7UUFDckVoaUIsT0FBT3NoQixnQkFBZ0IsQ0FBQyxZQUFZLElBQUksQ0FBQ1csaUJBQWlCO1FBQzFEamlCLE9BQU9zaEIsZ0JBQWdCLENBQUMsWUFBWSxJQUFJLENBQUNZLHdCQUF3QixFQUFFO1FBQ25FbGlCLE9BQU9zaEIsZ0JBQWdCLENBQUMsUUFBUSxJQUFJLENBQUNhLGFBQWE7UUFDbERuaUIsT0FBT3NoQixnQkFBZ0IsQ0FBQyxRQUFRLElBQUksQ0FBQ2Msb0JBQW9CLEVBQUU7SUFDL0Q7SUFDQXJCLHFCQUFxQi9nQixNQUFNLEVBQUU7UUFDekIsMkRBQTJEO1FBQzNELElBQUksQ0FBQ0EsT0FBT3VoQixtQkFBbUIsRUFBRTtZQUM3QjtRQUNKO1FBQ0F2aEIsT0FBT3VoQixtQkFBbUIsQ0FBQyxhQUFhLElBQUksQ0FBQ0ksa0JBQWtCO1FBQy9EM2hCLE9BQU91aEIsbUJBQW1CLENBQUMsYUFBYSxJQUFJLENBQUNLLHlCQUF5QixFQUFFO1FBQ3hFNWhCLE9BQU91aEIsbUJBQW1CLENBQUMsV0FBVyxJQUFJLENBQUNNLHVCQUF1QixFQUFFO1FBQ3BFN2hCLE9BQU91aEIsbUJBQW1CLENBQUMsYUFBYSxJQUFJLENBQUNPLGtCQUFrQjtRQUMvRDloQixPQUFPdWhCLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDUSx5QkFBeUIsRUFBRTtRQUN4RS9oQixPQUFPdWhCLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDUyx5QkFBeUIsRUFBRTtRQUN4RWhpQixPQUFPdWhCLG1CQUFtQixDQUFDLFlBQVksSUFBSSxDQUFDVSxpQkFBaUI7UUFDN0RqaUIsT0FBT3VoQixtQkFBbUIsQ0FBQyxZQUFZLElBQUksQ0FBQ1csd0JBQXdCLEVBQUU7UUFDdEVsaUIsT0FBT3VoQixtQkFBbUIsQ0FBQyxRQUFRLElBQUksQ0FBQ1ksYUFBYTtRQUNyRG5pQixPQUFPdWhCLG1CQUFtQixDQUFDLFFBQVEsSUFBSSxDQUFDYSxvQkFBb0IsRUFBRTtJQUNsRTtJQUNBQyw4QkFBOEI7UUFDMUIsTUFBTXZqQixXQUFXLElBQUksQ0FBQ0wsT0FBTyxDQUFDOEMsV0FBVztRQUN6QyxNQUFNK2Usb0JBQW9CLElBQUksQ0FBQ0EsaUJBQWlCLENBQUNwa0IsR0FBRyxDQUFDNEM7UUFDckQsT0FBT2loQixjQUFjO1lBQ2pCdUMsWUFBWSxJQUFJLENBQUNDLGFBQWEsR0FBRyxTQUFTO1FBQzlDLEdBQUdqQyxxQkFBcUIsQ0FBQztJQUM3QjtJQUNBa0MsdUJBQXVCO1FBQ25CLElBQUksSUFBSSxDQUFDQyxvQkFBb0IsSUFBSTtZQUM3QixnRUFBZ0U7WUFDaEUsT0FBTztRQUNYO1FBQ0EsT0FBTyxJQUFJLENBQUNKLDJCQUEyQixHQUFHQyxVQUFVO0lBQ3hEO0lBQ0FJLHFDQUFxQztRQUNqQyxNQUFNNWpCLFdBQVcsSUFBSSxDQUFDTCxPQUFPLENBQUM4QyxXQUFXO1FBQ3pDLE1BQU04ZSwyQkFBMkIsSUFBSSxDQUFDQSx3QkFBd0IsQ0FBQ25rQixHQUFHLENBQUM0QztRQUNuRSxPQUFPaWhCLGNBQWM7WUFDakJoQixTQUFTO1lBQ1RDLFNBQVM7WUFDVDJELHNCQUFzQjtRQUMxQixHQUFHdEMsNEJBQTRCLENBQUM7SUFDcEM7SUFDQW9DLHVCQUF1QjtRQUNuQixNQUFNcGpCLFdBQVcsSUFBSSxDQUFDWixPQUFPLENBQUN3RCxXQUFXO1FBQ3pDLE9BQU81YyxPQUFPd0csSUFBSSxDQUFDK3RCLGFBQWFoWSxJQUFJLENBQUMsQ0FBQ3ZFLE1BQU11YyxXQUFXLENBQUN2YyxJQUFJLEtBQUtnQztJQUVyRTtJQUNBdWpCLG9CQUFvQnBxQixJQUFJLEVBQUUwZ0IsWUFBWSxFQUFFO1FBQ3BDLElBQUksQ0FBQzhILDBCQUEwQjtRQUMvQixJQUFJLENBQUM2QixtQkFBbUIsR0FBR3BJLHVCQUF1QmppQixNQUFNMGdCO1FBQ3hELElBQUksQ0FBQzRKLG1CQUFtQixHQUFHLElBQUksQ0FBQ25rQixRQUFRLENBQUM2SyxTQUFTLENBQUNoUixNQUFNLElBQUksQ0FBQ3FxQixtQkFBbUI7UUFDakYsSUFBSSxDQUFDMWYsT0FBTyxDQUFDL0UsU0FBUyxDQUFDO1lBQ25CLElBQUksQ0FBQzBrQixtQkFBbUI7U0FDM0I7SUFDTDtJQUNBQyx5QkFBeUI5YixJQUFJLEVBQUU7UUFDM0IsSUFBSSxDQUFDK1osMEJBQTBCO1FBQy9CLElBQUksQ0FBQ2dDLHFCQUFxQixHQUFHL2I7UUFDN0Isb0VBQW9FO1FBQ3BFLE9BQU87UUFDUCxzREFBc0Q7UUFDdEQsd0RBQXdEO1FBQ3hELE1BQU1nYyxxQkFBcUI7UUFDM0IsZ0VBQWdFO1FBQ2hFLG9FQUFvRTtRQUNwRSxvREFBb0Q7UUFDcEQsRUFBRTtRQUNGLGtFQUFrRTtRQUNsRSxrR0FBa0c7UUFDbEcsZ0NBQWdDO1FBQ2hDLEVBQUU7UUFDRixPQUFPO1FBQ1Asc0RBQXNEO1FBQ3RELHdEQUF3RDtRQUN4RCxFQUFFO1FBQ0YsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRzN1QixXQUFXO1lBQ3BDLElBQUl2QztZQUNKLE9BQU8sQ0FBQ0EsTUFBTSxJQUFJLENBQUMydEIsV0FBVyxNQUFNLFFBQVEzdEIsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJc3ZCLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDNkIsZ0NBQWdDLEVBQUU7UUFDbkosR0FBR0Y7SUFDUDtJQUNBakMsNkJBQTZCO1FBQ3pCLElBQUksSUFBSSxDQUFDZ0MscUJBQXFCLEVBQUU7WUFDNUIsSUFBSSxDQUFDQSxxQkFBcUIsR0FBRztZQUM3QixJQUFJLElBQUksQ0FBQ3JELFdBQVcsRUFBRTtnQkFDbEIsSUFBSTN0QjtnQkFDSEEsQ0FBQUEsTUFBTSxJQUFJLENBQUMwYixNQUFNLE1BQU0sUUFBUTFiLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSXFDLFlBQVksQ0FBQyxJQUFJLENBQUM2dUIscUJBQXFCLElBQUk1MEI7Z0JBQ3pHLElBQUksQ0FBQ3F4QixXQUFXLENBQUM0QixtQkFBbUIsQ0FBQyxhQUFhLElBQUksQ0FBQzRCLGdDQUFnQyxFQUFFO1lBQzdGO1lBQ0EsSUFBSSxDQUFDRCxxQkFBcUIsR0FBRztZQUM3QixPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQS9CLGdCQUFnQmo4QixDQUFDLEVBQUU0WixRQUFRLEVBQUU7UUFDekIsSUFBSTVaLEVBQUVrK0IsZ0JBQWdCLEVBQUU7WUFDcEI7UUFDSjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUM1QyxrQkFBa0IsRUFBRTtZQUMxQixJQUFJLENBQUNBLGtCQUFrQixHQUFHLEVBQUU7UUFDaEM7UUFDQSxJQUFJLENBQUNBLGtCQUFrQixDQUFDNkMsT0FBTyxDQUFDdmtCO0lBQ3BDO0lBQ0EwaUIsZ0JBQWdCOEIsRUFBRSxFQUFFNWlCLFFBQVEsRUFBRTtRQUMxQixJQUFJLENBQUNnZ0Isa0JBQWtCLENBQUMyQyxPQUFPLENBQUMzaUI7SUFDcEM7SUFDQStnQixlQUFlNkIsRUFBRSxFQUFFNWlCLFFBQVEsRUFBRTtRQUN6QixJQUFJLElBQUksQ0FBQ2lnQixpQkFBaUIsS0FBSyxNQUFNO1lBQ2pDLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUcsRUFBRTtRQUMvQjtRQUNBLElBQUksQ0FBQ0EsaUJBQWlCLENBQUMwQyxPQUFPLENBQUMzaUI7SUFDbkM7SUFDQWdoQixXQUFXNEIsRUFBRSxFQUFFNWlCLFFBQVEsRUFBRTtRQUNyQixJQUFJLENBQUMrZixhQUFhLENBQUM0QyxPQUFPLENBQUMzaUI7SUFDL0I7SUFDQTVILFlBQVlxRixPQUFPLEVBQUVrUCxhQUFhLEVBQUUvTyxPQUFPLENBQUM7UUFDeEMsSUFBSSxDQUFDNmhCLGtCQUFrQixHQUFHLElBQUlwakI7UUFDOUIsSUFBSSxDQUFDc2pCLHdCQUF3QixHQUFHLElBQUl0akI7UUFDcEMsSUFBSSxDQUFDd2pCLFdBQVcsR0FBRyxJQUFJeGpCO1FBQ3ZCLElBQUksQ0FBQ3VqQixpQkFBaUIsR0FBRyxJQUFJdmpCO1FBQzdCLElBQUksQ0FBQ3lqQixrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsRUFBRTtRQUM1QixJQUFJLENBQUNtQyxtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNDLG1CQUFtQixHQUFHO1FBQzNCLElBQUksQ0FBQ0UscUJBQXFCLEdBQUc7UUFDN0IsSUFBSSxDQUFDVCxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDVyxxQkFBcUIsR0FBRztRQUM3QixJQUFJLENBQUNqQyxtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNOLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQzRDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ2hsQixxQkFBcUIsR0FBRyxDQUFDTTtZQUMxQixNQUFNRyxTQUFTLElBQUksQ0FBQ3NoQixXQUFXLENBQUNya0IsR0FBRyxDQUFDNEM7WUFDcEMsT0FBT0csVUFBVWtlLHNCQUFzQmxlLFdBQVc7UUFDdEQ7UUFDQSxJQUFJLENBQUN3a0IsaUJBQWlCLEdBQUc7WUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQ2hCLG9CQUFvQixJQUFJO2dCQUM5QjtZQUNKO1lBQ0EsSUFBSSxDQUFDdGYsT0FBTyxDQUFDOUIsT0FBTztZQUNwQixJQUFJLElBQUksQ0FBQ3loQixtQkFBbUIsRUFBRTtnQkFDMUIsSUFBSSxDQUFDbmtCLFFBQVEsQ0FBQytLLFlBQVksQ0FBQyxJQUFJLENBQUNvWixtQkFBbUI7WUFDdkQ7WUFDQSxJQUFJLENBQUNBLG1CQUFtQixHQUFHO1lBQzNCLElBQUksQ0FBQ0QsbUJBQW1CLEdBQUc7UUFDL0I7UUFDQSxJQUFJLENBQUN2SyxnQkFBZ0IsR0FBRyxDQUFDclI7WUFDckIsdUVBQXVFO1lBQ3ZFLE9BQU8xQixRQUFRMEIsUUFBUSxJQUFJLENBQUNDLFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVEsQ0FBQ3djLElBQUksSUFBSSxJQUFJLENBQUN4YyxRQUFRLENBQUN3YyxJQUFJLENBQUNuTCxRQUFRLENBQUN0UjtRQUM5RjtRQUNBLElBQUksQ0FBQ2tjLGdDQUFnQyxHQUFHO1lBQ3BDLE1BQU1sYyxPQUFPLElBQUksQ0FBQytiLHFCQUFxQjtZQUN2QyxJQUFJL2IsUUFBUSxRQUFRLElBQUksQ0FBQ3FSLGdCQUFnQixDQUFDclIsT0FBTztnQkFDN0M7WUFDSjtZQUNBLElBQUksSUFBSSxDQUFDK1osMEJBQTBCLE1BQU0sSUFBSSxDQUFDdmlCLE9BQU8sQ0FBQ2UsVUFBVSxJQUFJO2dCQUNoRSxJQUFJLENBQUMyRCxPQUFPLENBQUM5QixPQUFPO1lBQ3hCO1lBQ0EsSUFBSSxDQUFDc2lCLFdBQVc7UUFDcEI7UUFDQSxJQUFJLENBQUNDLGFBQWEsR0FBRyxDQUFDakQ7WUFDbEIsSUFBSSxJQUFJLENBQUM2QyxVQUFVLEtBQUssUUFBUSxPQUFPSywwQkFBMEIsYUFBYTtnQkFDMUUsSUFBSSxDQUFDTCxVQUFVLEdBQUdLLHNCQUFzQjtvQkFDcEMsSUFBSSxJQUFJLENBQUNwbEIsT0FBTyxDQUFDZSxVQUFVLElBQUk7d0JBQzNCLElBQUksQ0FBQzJELE9BQU8sQ0FBQ3JCLEtBQUssQ0FBQzZlLHFCQUFxQixFQUFFLEVBQUU7NEJBQ3hDN2lCLGNBQWMsSUFBSSxDQUFDeWxCLGdCQUFnQjt3QkFDdkM7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUc7Z0JBQ3RCO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ0csV0FBVyxHQUFHO1lBQ2YsSUFBSSxJQUFJLENBQUNILFVBQVUsS0FBSyxRQUFRLE9BQU90Qyx5QkFBeUIsYUFBYTtnQkFDekVBLHFCQUFxQixJQUFJLENBQUNzQyxVQUFVO2dCQUNwQyxJQUFJLENBQUNBLFVBQVUsR0FBRztZQUN0QjtRQUNKO1FBQ0EsSUFBSSxDQUFDNUIseUJBQXlCLEdBQUc7WUFDN0IsSUFBSSxDQUFDWiwwQkFBMEI7WUFDL0IsSUFBSSxDQUFDUixrQkFBa0IsR0FBRyxFQUFFO1FBQ2hDO1FBQ0EsSUFBSSxDQUFDbUIsa0JBQWtCLEdBQUcsQ0FBQ3o4QjtZQUN2QixJQUFJQSxFQUFFaytCLGdCQUFnQixFQUFFO2dCQUNwQjtZQUNKO1lBQ0EsTUFBTSxFQUFFNUMsa0JBQWtCLEVBQUcsR0FBRyxJQUFJO1lBQ3BDLElBQUksQ0FBQ0Esa0JBQWtCLEdBQUc7WUFDMUIsTUFBTTFpQixlQUFlNGYsdUJBQXVCeDRCO1lBQzVDLHFFQUFxRTtZQUNyRSxJQUFJLElBQUksQ0FBQ3VaLE9BQU8sQ0FBQ2UsVUFBVSxJQUFJO2dCQUMzQixJQUFJLENBQUMyRCxPQUFPLENBQUM5QixPQUFPO2dCQUNwQixJQUFJLENBQUNzaUIsV0FBVztZQUNwQjtZQUNBLG9EQUFvRDtZQUNwRCxJQUFJLENBQUN4Z0IsT0FBTyxDQUFDL0UsU0FBUyxDQUFDb2lCLHNCQUFzQixFQUFFLEVBQUU7Z0JBQzdDamlCLGVBQWU7Z0JBQ2ZDLHVCQUF1QixJQUFJLENBQUNBLHFCQUFxQjtnQkFDakRWO1lBQ0o7WUFDQSxNQUFNLEVBQUVvYixZQUFZLEVBQUcsR0FBR2gwQjtZQUMxQixNQUFNNCtCLGFBQWFwSixvQkFBb0J4QjtZQUN2QyxJQUFJLElBQUksQ0FBQ3phLE9BQU8sQ0FBQ2UsVUFBVSxJQUFJO2dCQUMzQixJQUFJMFosZ0JBQWdCLE9BQU9BLGFBQWE2SyxZQUFZLEtBQUssWUFBWTtvQkFDakUsOENBQThDO29CQUM5Qyx1REFBdUQ7b0JBQ3ZELCtEQUErRDtvQkFDL0QsTUFBTWpsQixXQUFXLElBQUksQ0FBQ0wsT0FBTyxDQUFDOEMsV0FBVztvQkFDekMsTUFBTWlkLGFBQWEsSUFBSSxDQUFDK0IsV0FBVyxDQUFDcmtCLEdBQUcsQ0FBQzRDO29CQUN4QyxNQUFNNFIsY0FBYyxJQUFJLENBQUN5UCxrQkFBa0IsQ0FBQ2prQixHQUFHLENBQUM0QyxhQUFhMGY7b0JBQzdELElBQUk5TixhQUFhO3dCQUNiLE1BQU0sRUFBRXFPLE9BQU8sRUFBR0MsT0FBTyxFQUFHSyxPQUFPLEVBQUdDLE9BQU8sRUFBRyxHQUFHLElBQUksQ0FBQ29ELGtDQUFrQzt3QkFDMUYsTUFBTWpFLGNBQWM7NEJBQ2hCTTs0QkFDQUM7d0JBQ0o7d0JBQ0EsTUFBTU4sY0FBYzs0QkFDaEJXOzRCQUNBQzt3QkFDSjt3QkFDQSxNQUFNMEUsb0JBQW9CekYscUJBQXFCQyxZQUFZOU4sYUFBYTVTLGNBQWMyZ0IsYUFBYUM7d0JBQ25HeEYsYUFBYTZLLFlBQVksQ0FBQ3JULGFBQWFzVCxrQkFBa0J6NEIsQ0FBQyxFQUFFeTRCLGtCQUFrQng0QixDQUFDO29CQUNuRjtnQkFDSjtnQkFDQSxJQUFJO29CQUNBLDBDQUEwQztvQkFDMUMwdEIsaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhK0ssT0FBTyxDQUFDLG9CQUFvQixDQUFDO2dCQUMxRyxFQUFFLE9BQU8zYixLQUFLO2dCQUNkLDJDQUEyQztnQkFDM0M7Z0JBQ0EsaURBQWlEO2dCQUNqRCx1REFBdUQ7Z0JBQ3ZELElBQUksQ0FBQ3lhLHdCQUF3QixDQUFDNzlCLEVBQUU4YSxNQUFNO2dCQUN0QywrREFBK0Q7Z0JBQy9ELE1BQU0sRUFBRTJpQixvQkFBb0IsRUFBRyxHQUFHLElBQUksQ0FBQ0Qsa0NBQWtDO2dCQUN6RSxJQUFJLENBQUNDLHNCQUFzQjtvQkFDdkIsaUVBQWlFO29CQUNqRSw4REFBOEQ7b0JBQzlELEVBQUU7b0JBQ0YsZ0VBQWdFO29CQUNoRSxtRUFBbUU7b0JBQ25FcHVCLFdBQVcsSUFBSSxJQUFJLENBQUM0TyxPQUFPLENBQUNYLGlCQUFpQixJQUMzQztnQkFDTixPQUFPO29CQUNILGtFQUFrRTtvQkFDbEUseURBQXlEO29CQUN6RCxFQUFFO29CQUNGLDBEQUEwRDtvQkFDMUQsK0RBQStEO29CQUMvRCwrREFBK0Q7b0JBQy9ELGlFQUFpRTtvQkFDakUsd0RBQXdEO29CQUN4RCxFQUFFO29CQUNGLHVEQUF1RDtvQkFDdkQsSUFBSSxDQUFDVyxPQUFPLENBQUNYLGlCQUFpQjtnQkFDbEM7WUFDSixPQUFPLElBQUlzaEIsWUFBWTtnQkFDbkIsK0RBQStEO2dCQUMvRCxJQUFJLENBQUNsQixtQkFBbUIsQ0FBQ2tCO1lBQzdCLE9BQU8sSUFBSTVLLGdCQUFnQixDQUFDQSxhQUFhek4sS0FBSyxJQUFLdm1CLENBQUFBLEVBQUU4YSxNQUFNLElBQUksQ0FBQzlhLEVBQUU4YSxNQUFNLENBQUNra0IsWUFBWSxJQUFJLENBQUNoL0IsRUFBRThhLE1BQU0sQ0FBQ2trQixZQUFZLENBQUMsWUFBVyxHQUFJO2dCQUMzSCxtRkFBbUY7Z0JBQ25GLDhFQUE4RTtnQkFDOUUscUJBQXFCO2dCQUNyQjtZQUNKLE9BQU87Z0JBQ0gsb0VBQW9FO2dCQUNwRWgvQixFQUFFaS9CLGNBQWM7WUFDcEI7UUFDSjtRQUNBLElBQUksQ0FBQ3RDLHVCQUF1QixHQUFHO1lBQzNCLElBQUksSUFBSSxDQUFDYiwwQkFBMEIsTUFBTSxJQUFJLENBQUN2aUIsT0FBTyxDQUFDZSxVQUFVLElBQUk7Z0JBQ2hFLHNEQUFzRDtnQkFDdEQsMkRBQTJEO2dCQUMzRCxrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQzJELE9BQU8sQ0FBQzlCLE9BQU87WUFDeEI7WUFDQSxJQUFJLENBQUNzaUIsV0FBVztRQUNwQjtRQUNBLElBQUksQ0FBQzVCLHlCQUF5QixHQUFHLENBQUM3OEI7WUFDOUIsSUFBSSxDQUFDdzdCLGtCQUFrQixHQUFHLEVBQUU7WUFDNUIsSUFBSSxJQUFJLENBQUMrQixvQkFBb0IsSUFBSTtnQkFDN0IsSUFBSXp3QjtnQkFDSEEsQ0FBQUEsTUFBTSxJQUFJLENBQUM2d0IsbUJBQW1CLE1BQU0sUUFBUTd3QixRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUlpbkIsZ0JBQWdCLENBQUMvekIsRUFBRWcwQixZQUFZO1lBQzlHO1lBQ0EsTUFBTWtMLGVBQWUsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ3BNLEtBQUssQ0FBQy95QixFQUFFOGEsTUFBTTtZQUMxRCxJQUFJLENBQUNva0IsZ0JBQWdCLElBQUksQ0FBQzNsQixPQUFPLENBQUNlLFVBQVUsSUFBSTtnQkFDNUM7WUFDSjtZQUNBLE1BQU0sRUFBRTBaLFlBQVksRUFBRyxHQUFHaDBCO1lBQzFCLE1BQU00K0IsYUFBYXBKLG9CQUFvQnhCO1lBQ3ZDLElBQUk0SyxZQUFZO2dCQUNaLHdFQUF3RTtnQkFDeEUsSUFBSSxDQUFDbEIsbUJBQW1CLENBQUNrQixZQUFZNUs7WUFDekM7UUFDSjtRQUNBLElBQUksQ0FBQzRJLGtCQUFrQixHQUFHLENBQUM1OEI7WUFDdkIsTUFBTSxFQUFFdzdCLGtCQUFrQixFQUFHLEdBQUcsSUFBSTtZQUNwQyxJQUFJLENBQUNBLGtCQUFrQixHQUFHLEVBQUU7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQ2ppQixPQUFPLENBQUNlLFVBQVUsSUFBSTtnQkFDNUIsMkRBQTJEO2dCQUMzRDtZQUNKO1lBQ0EsSUFBSSxDQUFDK2lCLGFBQWEsR0FBR3I5QixFQUFFby9CLE1BQU07WUFDN0Isc0ZBQXNGO1lBQ3RGLHFGQUFxRjtZQUNyRiw0REFBNEQ7WUFDNUQsSUFBSTVELG1CQUFtQjk2QixNQUFNLEdBQUcsR0FBRztnQkFDL0IsSUFBSSxDQUFDdWQsT0FBTyxDQUFDckIsS0FBSyxDQUFDNGUsb0JBQW9CO29CQUNuQzVpQixjQUFjNGYsdUJBQXVCeDRCO2dCQUN6QztZQUNKO1lBQ0EsTUFBTW9nQixVQUFVb2IsbUJBQW1COWUsSUFBSSxDQUFDLENBQUNsQixXQUFXLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ3lDLGVBQWUsQ0FBQ1I7WUFFakYsSUFBSTRFLFNBQVM7Z0JBQ1QsMkNBQTJDO2dCQUMzQ3BnQixFQUFFaS9CLGNBQWM7Z0JBQ2hCLElBQUlqL0IsRUFBRWcwQixZQUFZLEVBQUU7b0JBQ2hCaDBCLEVBQUVnMEIsWUFBWSxDQUFDb0osVUFBVSxHQUFHLElBQUksQ0FBQ0Usb0JBQW9CO2dCQUN6RDtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNOLHdCQUF3QixHQUFHLENBQUNoOUI7WUFDN0IsSUFBSSxDQUFDeTdCLGlCQUFpQixHQUFHLEVBQUU7WUFDM0IsSUFBSSxJQUFJLENBQUM4QixvQkFBb0IsSUFBSTtnQkFDN0IsSUFBSXp3QjtnQkFDSEEsQ0FBQUEsTUFBTSxJQUFJLENBQUM2d0IsbUJBQW1CLE1BQU0sUUFBUTd3QixRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUlpbkIsZ0JBQWdCLENBQUMvekIsRUFBRWcwQixZQUFZO1lBQzlHO1FBQ0o7UUFDQSxJQUFJLENBQUMrSSxpQkFBaUIsR0FBRyxDQUFDLzhCO1lBQ3RCLE1BQU0sRUFBRXk3QixpQkFBaUIsRUFBRyxHQUFHLElBQUk7WUFDbkMsSUFBSSxDQUFDQSxpQkFBaUIsR0FBRyxFQUFFO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNsaUIsT0FBTyxDQUFDZSxVQUFVLElBQUk7Z0JBQzVCLDJEQUEyRDtnQkFDM0Qsa0VBQWtFO2dCQUNsRXRhLEVBQUVpL0IsY0FBYztnQkFDaEIsSUFBSWovQixFQUFFZzBCLFlBQVksRUFBRTtvQkFDaEJoMEIsRUFBRWcwQixZQUFZLENBQUNvSixVQUFVLEdBQUc7Z0JBQ2hDO2dCQUNBO1lBQ0o7WUFDQSxJQUFJLENBQUNDLGFBQWEsR0FBR3I5QixFQUFFby9CLE1BQU07WUFDN0IsSUFBSSxDQUFDZixnQkFBZ0IsR0FBRzdGLHVCQUF1Qng0QjtZQUMvQyxJQUFJLENBQUMwK0IsYUFBYSxDQUFDakQ7WUFDbkIsTUFBTXJiLFVBQVUsQ0FBQ3FiLHFCQUFxQixFQUFFLEVBQUUvZSxJQUFJLENBQUMsQ0FBQ2xCLFdBQVcsSUFBSSxDQUFDakMsT0FBTyxDQUFDeUMsZUFBZSxDQUFDUjtZQUV4RixJQUFJNEUsU0FBUztnQkFDVCxtQ0FBbUM7Z0JBQ25DcGdCLEVBQUVpL0IsY0FBYztnQkFDaEIsSUFBSWovQixFQUFFZzBCLFlBQVksRUFBRTtvQkFDaEJoMEIsRUFBRWcwQixZQUFZLENBQUNvSixVQUFVLEdBQUcsSUFBSSxDQUFDRSxvQkFBb0I7Z0JBQ3pEO1lBQ0osT0FBTyxJQUFJLElBQUksQ0FBQ0Msb0JBQW9CLElBQUk7Z0JBQ3BDLHFEQUFxRDtnQkFDckQsa0RBQWtEO2dCQUNsRHY5QixFQUFFaS9CLGNBQWM7WUFDcEIsT0FBTztnQkFDSGovQixFQUFFaS9CLGNBQWM7Z0JBQ2hCLElBQUlqL0IsRUFBRWcwQixZQUFZLEVBQUU7b0JBQ2hCaDBCLEVBQUVnMEIsWUFBWSxDQUFDb0osVUFBVSxHQUFHO2dCQUNoQztZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNOLHlCQUF5QixHQUFHLENBQUM5OEI7WUFDOUIsSUFBSSxJQUFJLENBQUN1OUIsb0JBQW9CLElBQUk7Z0JBQzdCdjlCLEVBQUVpL0IsY0FBYztZQUNwQjtZQUNBLE1BQU1JLGNBQWMsSUFBSSxDQUFDRixpQkFBaUIsQ0FBQzdMLEtBQUssQ0FBQ3R6QixFQUFFOGEsTUFBTTtZQUN6RCxJQUFJLENBQUN1a0IsYUFBYTtnQkFDZDtZQUNKO1lBQ0EsSUFBSSxJQUFJLENBQUM5QixvQkFBb0IsSUFBSTtnQkFDN0JsdUIsV0FBVyxJQUFJLElBQUksQ0FBQ2t2QixpQkFBaUIsSUFDbkM7WUFDTjtZQUNBLElBQUksQ0FBQ0UsV0FBVztRQUNwQjtRQUNBLElBQUksQ0FBQ3ZCLG9CQUFvQixHQUFHLENBQUNsOUI7WUFDekIsSUFBSSxDQUFDdTdCLGFBQWEsR0FBRyxFQUFFO1lBQ3ZCLElBQUksSUFBSSxDQUFDZ0Msb0JBQW9CLElBQUk7Z0JBQzdCLElBQUl6d0I7Z0JBQ0o5TSxFQUFFaS9CLGNBQWM7Z0JBQ2ZueUIsQ0FBQUEsTUFBTSxJQUFJLENBQUM2d0IsbUJBQW1CLE1BQU0sUUFBUTd3QixRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUlpbkIsZ0JBQWdCLENBQUMvekIsRUFBRWcwQixZQUFZO1lBQzlHLE9BQU8sSUFBSXdCLG9CQUFvQngxQixFQUFFZzBCLFlBQVksR0FBRztnQkFDNUMsd0ZBQXdGO2dCQUN4Riw4REFBOEQ7Z0JBQzlELGtGQUFrRjtnQkFDbEZoMEIsRUFBRWkvQixjQUFjO1lBQ3BCO1lBQ0EsSUFBSSxDQUFDRSxpQkFBaUIsQ0FBQzNMLEtBQUs7UUFDaEM7UUFDQSxJQUFJLENBQUN5SixhQUFhLEdBQUcsQ0FBQ2o5QjtZQUNsQixNQUFNLEVBQUV1N0IsYUFBYSxFQUFHLEdBQUcsSUFBSTtZQUMvQixJQUFJLENBQUNBLGFBQWEsR0FBRyxFQUFFO1lBQ3ZCLElBQUksQ0FBQ3RkLE9BQU8sQ0FBQ3JCLEtBQUssQ0FBQzJlLGVBQWU7Z0JBQzlCM2lCLGNBQWM0Zix1QkFBdUJ4NEI7WUFDekM7WUFDQSxJQUFJLENBQUNpZSxPQUFPLENBQUM3QyxJQUFJLENBQUM7Z0JBQ2RnaUIsWUFBWSxJQUFJLENBQUNFLG9CQUFvQjtZQUN6QztZQUNBLElBQUksSUFBSSxDQUFDQyxvQkFBb0IsSUFBSTtnQkFDN0IsSUFBSSxDQUFDZ0IsaUJBQWlCO1lBQzFCLE9BQU8sSUFBSSxJQUFJLENBQUNobEIsT0FBTyxDQUFDZSxVQUFVLElBQUk7Z0JBQ2xDLElBQUksQ0FBQzJELE9BQU8sQ0FBQzlCLE9BQU87WUFDeEI7WUFDQSxJQUFJLENBQUNzaUIsV0FBVztRQUNwQjtRQUNBLElBQUksQ0FBQ3ZDLGlCQUFpQixHQUFHLENBQUNsOEI7WUFDdEIsTUFBTThhLFNBQVM5YSxFQUFFOGEsTUFBTTtZQUN2Qix3Q0FBd0M7WUFDeEMsdUNBQXVDO1lBQ3ZDLElBQUksT0FBT0EsT0FBT3drQixRQUFRLEtBQUssWUFBWTtnQkFDdkM7WUFDSjtZQUNBLDRDQUE0QztZQUM1QyxJQUFJeGtCLE9BQU95a0IsT0FBTyxLQUFLLFdBQVd6a0IsT0FBT3lrQixPQUFPLEtBQUssWUFBWXprQixPQUFPeWtCLE9BQU8sS0FBSyxjQUFjemtCLE9BQU8wa0IsaUJBQWlCLEVBQUU7Z0JBQ3hIO1lBQ0o7WUFDQSw0QkFBNEI7WUFDNUIsMEJBQTBCO1lBQzFCeC9CLEVBQUVpL0IsY0FBYztZQUNoQm5rQixPQUFPd2tCLFFBQVE7UUFDbkI7UUFDQSxJQUFJLENBQUNsbUIsT0FBTyxHQUFHLElBQUltaEIsZ0JBQWdCcFMsZUFBZS9PO1FBQ2xELElBQUksQ0FBQzZFLE9BQU8sR0FBR2hGLFFBQVEyRSxVQUFVO1FBQ2pDLElBQUksQ0FBQ3JFLE9BQU8sR0FBR04sUUFBUU8sVUFBVTtRQUNqQyxJQUFJLENBQUNDLFFBQVEsR0FBR1IsUUFBUVMsV0FBVztRQUNuQyxJQUFJLENBQUN5bEIsaUJBQWlCLEdBQUcsSUFBSXJNLGtCQUFrQixJQUFJLENBQUNNLGdCQUFnQjtJQUN4RTtBQUNKO0FBRUEsSUFBSXFNO0FBQ0osU0FBU0M7SUFDTCxJQUFJLENBQUNELFlBQVk7UUFDYkEsYUFBYSxJQUFJRTtRQUNqQkYsV0FBV0csR0FBRyxHQUFHO0lBQ3JCO0lBQ0EsT0FBT0g7QUFDWDtBQUVBLE1BQU1JLGVBQWUsU0FBU0MsY0FBYzdtQixPQUFPLEVBQUVzUSxPQUFPLEVBQUVuUSxPQUFPO0lBQ2pFLE9BQU8sSUFBSTBoQixpQkFBaUI3aEIsU0FBU3NRLFNBQVNuUTtBQUNsRDtBQUVBLFNBQVMybUIsTUFBTSxFQUFFQyxrQkFBa0IsS0FBSyxFQUFFLzNCLEtBQUssRUFBRWhDLE1BQU0sRUFBRWc2QixPQUFPLEVBQUc7SUFDL0QsTUFBTSxFQUFFOTFCLGlCQUFpQixFQUFFQyxrQkFBa0IsRUFBRXBFLFVBQVUsRUFBRUQsZ0JBQWdCLEVBQUVnSSxXQUFXLEVBQUVqSCxlQUFlLEVBQUVpSixxQkFBcUIsRUFBRTNFLGtCQUFrQixFQUFFdkYsRUFBRSxFQUFFd0YsZ0JBQWdCLEVBQUVnRCxxQkFBcUIsRUFBRTNDLFlBQVksRUFBRUMsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRUUsbUJBQW1CLEVBQUVDLGdCQUFnQixFQUFFaUIsbUJBQW1CLEVBQUcsR0FBR2hEO0lBQ25ULE1BQU0sQ0FBQ2syQixZQUFZQyxjQUFjLEdBQUduaEMsK0NBQVFBLENBQUM7UUFDekNtRixTQUFTO1FBQ1RrTixRQUFRO1FBQ1IrdUIsYUFBYTtRQUNiQyxRQUFRajJCLHNCQUFzQmlCLGlCQUFpQjtZQUFFcEQ7WUFBTytELGNBQWMvRjtRQUFPLEtBQ3ZFLGlCQUNBO0lBQ1Y7SUFDQSxNQUFNLENBQUMsRUFBRWthLE9BQU8sRUFBRTdGLFVBQVUsRUFBRSxFQUFFZ21CLE1BQU05VSxZQUFZLEdBQUdpRyxRQUFRLElBQU87WUFDaEVuZSxNQUFNO1lBQ05nRSxNQUFNO2dCQUNGM0wsaUJBQWlCMUQsT0FBT2hDO2dCQUN4QixPQUFPO29CQUFFZ0M7b0JBQU9oQztvQkFBUUo7Z0JBQUc7WUFDL0I7WUFDQXNyQixLQUFLLENBQUM3WixNQUFNaUM7Z0JBQ1IzTixlQUFlM0QsT0FBT2hDO2dCQUN0QixNQUFNczZCLHlCQUF5QixDQUFDaG5CLFFBQVFvQyxPQUFPO2dCQUMvQyxJQUFJNGtCLHdCQUF3QjtvQkFDeEIsSUFBSW4xQix1QkFBdUIsU0FBUzt3QkFDaEMyRSxzQkFBc0I5SjtvQkFDMUI7b0JBQ0E2Rix3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssSUFBSSxLQUFLLElBQUlBLG9CQUFvQjdGLFFBQVFnQztnQkFDMUc7WUFDSjtZQUNBaWlCLFNBQVMsQ0FBQzNRLFVBQWE7b0JBQ25CNEcsU0FBUzlVLGlCQUFpQjt3QkFBRXBEO3dCQUFPK0QsY0FBYy9GO29CQUFPO29CQUN4RHFVLFlBQVksQ0FBQyxDQUFDZixRQUFRZSxVQUFVO2dCQUNwQztRQUNKLElBQUk7UUFBQ3JTO1FBQU9oQztRQUFRYTtRQUFpQmpCO0tBQUc7SUFDeEMsMkJBQTJCO0lBQzNCMmxCLFlBQVlrVSxpQkFBaUI7UUFBRWpDLHNCQUFzQjtJQUFLO0lBQzFELHFCQUFxQjtJQUNyQngrQixnREFBU0EsQ0FBQztRQUNOa2hDLGNBQWMsQ0FBQ0ssZ0JBQW1CcmdDLE9BQU95RCxNQUFNLENBQUN6RCxPQUFPeUQsTUFBTSxDQUFDLENBQUMsR0FBRzQ4QixnQkFBZ0I7Z0JBQUVyOEIsU0FBU21XLGFBQWEsSUFBSTtZQUFFO0lBQ3BILEdBQUc7UUFBQ0E7S0FBVztJQUNmLHVCQUF1QjtJQUN2QixvRkFBb0Y7SUFDcEYsb0dBQW9HO0lBQ3BHcmIsZ0RBQVNBLENBQUM7UUFDTixJQUFJMFA7UUFDSixNQUFNOHhCLGVBQWUsQ0FBQzl4QixLQUFLM0Isb0JBQW9CaEcsT0FBTyxNQUFNLFFBQVEySCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQzFJLE9BQU87UUFDdkcsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQytHLG9CQUFvQi9GLEtBQUssSUFBSSxDQUFDdzVCLGNBQy9CO1FBQ0oseUdBQXlHO1FBQ3pHLE1BQU1DLFlBQVl2Z0MsT0FBTzhPLE9BQU8sQ0FBQ2pDLG9CQUFvQi9GLEtBQUssRUFBRTA1QixJQUFJLENBQUMsQ0FBQyxDQUFDNWdDLEdBQUdHLEVBQUUsR0FBS0EsTUFBTXVnQyxnQkFBZ0IxMEIsaUJBQWlCOUYsUUFBUWxHLEdBQUcwZ0M7UUFDL0gsNEhBQTRIO1FBQzVILElBQUlweUIseUJBQ0FveUIsZ0JBQ0FDLGFBQ0EsQ0FBQ1YsaUJBQWlCO1lBQ2xCLE1BQU16d0IsV0FBV3RKO1lBQ2pCLE1BQU11SixXQUFXa3hCLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLElBQUlueEIsWUFBWUMsVUFBVTtnQkFDdEIsTUFBTXRKLGNBQWNGLGFBQWE7Z0JBQ2pDbTZCLGNBQWMsQ0FBQ0ssZ0JBQW1CcmdDLE9BQU95RCxNQUFNLENBQUN6RCxPQUFPeUQsTUFBTSxDQUFDLENBQUMsR0FBRzQ4QixnQkFBZ0I7d0JBQUV4N0IsV0FBVyxDQUFDLFVBQVUsRUFBRSxDQUFDZSxxQkFBcUIsVUFBVSxDQUFDLElBQUksS0FDeEl5SixDQUFBQSxTQUFTcEQsVUFBVSxDQUFDLEtBQUttRCxTQUFTbkQsVUFBVSxDQUFDLEVBQUMsSUFDL0NsRyxZQUFZLElBQUksRUFBRSxDQUFDSCxxQkFBcUIsVUFBVSxDQUFDLElBQUksS0FDdEQ2NkIsQ0FBQUEsT0FBT3J4QixRQUFRLENBQUMsRUFBRSxJQUFJcXhCLE9BQU9weEIsUUFBUSxDQUFDLEVBQUUsS0FDekN0SixZQUFZLEdBQUcsQ0FBQzt3QkFBRTI2QixZQUFZLENBQUMsVUFBVSxFQUFFMTJCLGtCQUFrQixFQUFFLENBQUM7d0JBQUVrSCxRQUFRO29CQUFFO1lBQ3hGO1FBQ0o7SUFDSixHQUFHO1FBQUNyRTtLQUFvQjtJQUN4QixxREFBcUQ7SUFDckQvTixnREFBU0EsQ0FBQztRQUNOLE1BQU0sRUFBRXNRLFFBQVEsRUFBRSxHQUFHdXhCO1FBQ3JCLElBQUl2eEIsVUFBVTtZQUNWNHdCLGNBQWMsQ0FBQ0ssZ0JBQW1CcmdDLE9BQU95RCxNQUFNLENBQUN6RCxPQUFPeUQsTUFBTSxDQUFDLENBQUMsR0FBRzQ4QixnQkFBZ0I7b0JBQUV4N0IsV0FBVyxDQUFDLFVBQVUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEdBQUcsQ0FBQztvQkFBRTY3QixZQUFZLENBQUMsVUFBVSxFQUFFLEVBQUUsRUFBRSxDQUFDO2dCQUFDO1FBQy9KO0lBQ0osR0FBRztRQUFDLzVCO0tBQWdCO0lBQ3BCLDRCQUE0QjtJQUM1QjdILGdEQUFTQSxDQUFDO1FBQ05raEMsY0FBYyxDQUFDSyxnQkFBbUJyZ0MsT0FBT3lELE1BQU0sQ0FBQ3pELE9BQU95RCxNQUFNLENBQUMsQ0FBQyxHQUFHNDhCLGdCQUFnQjtnQkFBRUgsUUFBUWoyQixzQkFBc0JpQixpQkFBaUI7b0JBQUVwRDtvQkFBTytELGNBQWMvRjtnQkFBTyxLQUN2SixpQkFDQTtZQUFVO0lBQ3hCLEdBQUc7UUFBQ0E7UUFBUWE7UUFBaUJzRDtLQUFtQjtJQUNoRCxTQUFTMDJCO1FBQ0wsT0FBTztZQUFFdnhCLFVBQVUwd0IsT0FBTyxDQUFDaDZCLE9BQU87UUFBQztJQUN2QztJQUNBLE9BQVFwSCxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFa0osS0FBSzFDLHNCQUFzQitWLFVBQVVtZ0IsT0FBTztRQUFNUyxTQUFTLElBQU1yMUIsYUFBYXpELE9BQU9oQztRQUFTLGNBQWNnQztRQUFPL0QsT0FBT2c4QjtJQUFXLEdBQUc7UUFBRWo4QixVQUFVLE9BQU84SixXQUFXLENBQUM5RixNQUFNLEtBQUssYUFBYzhGLFdBQVcsQ0FBQzlGLE1BQU0sQ0FBQztZQUM5Ty9CLGFBQWFGLGFBQWE7WUFDMUJzVTtZQUNBclU7UUFDSixLQUFPcEgsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7WUFBRW85QixTQUFTO1lBQWFqOUIsT0FBT2lDLGFBQWE7WUFBR2hDLFFBQVFnQyxhQUFhO1lBQUc5QixPQUFPO2dCQUFFKzhCLFNBQVM7WUFBUTtRQUFFLEdBQUc7WUFBRWg5QixVQUFVcEYsc0RBQUdBLENBQUMsS0FBSztnQkFBRW9GLFVBQVU4SixXQUFXLENBQUM5RixNQUFNO1lBQUM7UUFBRztJQUFLO0FBQzFNO0FBRUEsU0FBU2k1QixPQUFPLEVBQUVqN0IsTUFBTSxFQUFFazdCLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxnQkFBZ0IsRUFBRXA5QixRQUFRLEVBQUc7SUFDNUUsTUFBTXE5QixZQUFZbGlDLDZDQUFNQSxDQUFDO0lBQ3pCLE1BQU0sRUFBRWtMLGtCQUFrQixFQUFFdEUsVUFBVSxFQUFFRCxnQkFBZ0IsRUFBRWtELFdBQVcsRUFBRW5DLGVBQWUsRUFBRStHLHFCQUFxQixFQUFFckQsZ0JBQWdCLEVBQUVFLHFCQUFxQixFQUFFRSxxQkFBcUIsRUFBRUUsc0JBQXNCLEVBQUVFLDRCQUE0QixFQUFFQyw2QkFBNkIsRUFBRUMsY0FBY3EyQixZQUFZLEVBQUVwMkIsa0JBQWtCLEVBQUU5QixZQUFZLEVBQUVpRyxpQkFBaUIsRUFBRWEsb0JBQW9CLEVBQUU5QixxQkFBcUIsRUFBRW5CLGVBQWUsRUFBRXFCLHFCQUFxQixFQUFFOUUsY0FBYyxFQUFFOEIsZ0JBQWdCLEVBQUVDLGdCQUFnQixFQUFFQyxpQkFBaUIsRUFBRUksV0FBVyxFQUFFRSxnQkFBZ0IsRUFBRXNFLGdCQUFnQixFQUFFQyxjQUFjLEVBQUUvRCxhQUFhLEVBQUVpQyx3QkFBd0IsRUFBRWpCLG9CQUFvQixFQUFFRSxrQkFBa0IsRUFBRUosb0JBQW9CLEVBQUcsR0FBR3JEO0lBQy9wQixNQUFNLENBQUMsRUFBRWdpQixNQUFNLEVBQUUsRUFBRTVRLEtBQUssR0FBR21YLFFBQVEsSUFBTztZQUN0Q0wsUUFBUTtZQUNSOVcsTUFBTW9oQjtZQUNOdFMsU0FBUyxDQUFDM1EsVUFBYTtvQkFDbkJ5UyxRQUFRLENBQUMsQ0FBQ3pTLFFBQVF5UyxNQUFNO2dCQUM1QjtRQUNKLElBQUk7UUFDQS9sQjtRQUNBYTtRQUNBK0U7UUFDQXdDO1FBQ0FuQjtLQUNIO0lBQ0QsU0FBU3N2QixXQUFXbGxCLElBQUk7UUFDcEIsSUFBSUEsS0FBS2txQixPQUFPLEVBQUU7WUFDZHJ4QixxQkFBcUJtSCxLQUFLclAsS0FBSyxFQUFFaEM7WUFDakM7UUFDSjtRQUNBLElBQUk4RixpQkFBaUJ1TCxLQUFLclIsTUFBTSxFQUFFQSxRQUFRcVIsS0FBS3JQLEtBQUssR0FBRztZQUNuRCxJQUFJcUMsb0JBQW9CO2dCQUNwQmdGLGtCQUFrQmdJLEtBQUtyUixNQUFNLEVBQUVBLFFBQVFxUixLQUFLclAsS0FBSyxDQUFDLEVBQUUsS0FBSyxNQUFNLE9BQU87WUFDMUUsT0FDSztnQkFDRHNGLHFCQUFxQitKLEtBQUtyUixNQUFNO2dCQUNoQ3dILG1CQUFtQnhIO2dCQUNuQm9ILHFCQUFxQjtZQUN6QjtRQUNKLE9BQ0s7WUFDRGlDLGtCQUFrQmdJLEtBQUtyUixNQUFNLEVBQUVBLFFBQVFxUixLQUFLclAsS0FBSyxFQUFFO1FBQ3ZEO0lBQ0o7SUFDQWhKLGdEQUFTQSxDQUFDO1FBQ04sSUFBSXFpQyxVQUFVNXhCLE9BQU8sRUFBRTtZQUNuQixNQUFNLEVBQUVySixDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHZzdCLFVBQVU1eEIsT0FBTyxDQUFDNm9CLHFCQUFxQjtZQUN4RDZJLFdBQVcsQ0FBQ0ssYUFBZ0J0aEMsT0FBT3lELE1BQU0sQ0FBQ3pELE9BQU95RCxNQUFNLENBQUMsQ0FBQyxHQUFHNjlCLGFBQWE7b0JBQUUsQ0FBQ3g3QixPQUFPLEVBQUU7d0JBQUVJO3dCQUFHQztvQkFBRTtnQkFBRTtRQUNsRztJQUNKLEdBQUc7UUFBQ047UUFBWUQ7S0FBaUI7SUFDakMsTUFBTTI3QixxQkFBcUJ2aEMsT0FBT3lELE1BQU0sQ0FBQ3pELE9BQU95RCxNQUFNLENBQUN6RCxPQUFPeUQsTUFBTSxDQUFDekQsT0FBT3lELE1BQU0sQ0FBQyxDQUFDLEdBQUcrOUIsYUFBYTE3QixRQUFRRixrQkFBa0J5RSxvQkFBcUIyMkIsZ0JBQWdCLFVBQzdKejJCLHdCQUNBSSx5QkFBMkJ1MkIsb0JBQzVCRixDQUFBQSxnQkFBZ0IsVUFDWG4yQiwrQkFDQUMsNkJBQTRCLElBQU8rZ0IsVUFBVXBoQjtJQUN2RCxPQUFRL0wsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRWtKLEtBQUtzTztRQUFNbFgsT0FBT3c5QjtRQUFvQixxQkFBcUJQO1FBQWEsZUFBZWw3QjtRQUFRMjdCLGFBQWEsQ0FBQzVoQztZQUN4SSxJQUFJMk87WUFDSixrRkFBa0Y7WUFDbEYsTUFBTWt6QixnQkFBZ0I3aEMsRUFBRThoQyxPQUFPLENBQUMsRUFBRTtZQUNsQyxNQUFNQyxlQUFlL2YsU0FBU2dnQixpQkFBaUIsQ0FBQ0gsY0FBY3BKLE9BQU8sRUFBRW9KLGNBQWNuSixPQUFPO1lBQzVGLE1BQU11SixvQkFBb0IsQ0FBQ3R6QixLQUFLb3pCLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYXBCLElBQUksQ0FBQyxDQUFDekksS0FBT0EsR0FBR2dLLFlBQVksQ0FBQyxlQUFjLE1BQU8sUUFBUXZ6QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1ekIsWUFBWSxDQUFDO1lBQzVNLElBQUlELHFCQUFxQkEsc0JBQXNCMXpCLHVCQUF1QjtnQkFDbEVDLHlCQUF5Qnl6QjtnQkFDekIxMkIsaUJBQWlCMDJCO1lBQ3JCO1FBQ0o7UUFBR0UsYUFBYSxDQUFDbmlDO1lBQ2IsbURBQW1EO1lBQ25ELElBQUlBLEVBQUVvaUMsT0FBTyxLQUFLLEtBQUt2MEIsdUJBQXVCO2dCQUMxQ3hFLGFBQWF3RSx1QkFBdUI1SDtZQUN4QztZQUNBLElBQUlqRyxFQUFFcWlDLGFBQWEsSUFDZnJpQyxFQUFFc2lDLGFBQWEsQ0FBQ2pQLFFBQVEsQ0FBQ3J6QixFQUFFcWlDLGFBQWEsR0FBRztnQkFDM0M7WUFDSjtZQUNBNTJCLGtCQUFrQnhGO1FBQ3RCO1FBQUdzOEIsWUFBWSxDQUFDdmlDO1lBQ1oscURBQXFEO1lBQ3JELElBQUlBLEVBQUVxaUMsYUFBYSxJQUNmcmlDLEVBQUVzaUMsYUFBYSxDQUFDalAsUUFBUSxDQUFDcnpCLEVBQUVxaUMsYUFBYSxHQUN4QztZQUNKNzJCLGlCQUFpQnZGO1FBQ3JCO1FBQUd1OEIsYUFBYSxDQUFDeGlDO1lBQ2IsSUFBSUEsRUFBRXlpQyxNQUFNLEtBQUssR0FDYnB5QixpQkFBaUJwSztRQUN6QjtRQUFHeThCLFdBQVcsQ0FBQzFpQztZQUNYLElBQUlBLEVBQUV5aUMsTUFBTSxLQUFLLEdBQUc7Z0JBQ2hCLElBQUk1MEIsdUJBQ0FwRSxlQUFlb0UsdUJBQXVCNUg7Z0JBQzFDcUssZUFBZXJLO1lBQ25CO1FBQ0o7UUFBRzA4QixhQUFhLElBQU1wM0IsaUJBQWlCdEY7UUFBUzg2QixTQUFTO1lBQ3JELE1BQU05NEIsUUFBUW5CLGVBQWUsQ0FBQ2IsT0FBTztZQUNyQ3NHLGNBQWN0RyxRQUFRZ0M7WUFDdEJnQjtRQUNKO1FBQUcyNUIsZUFBZSxDQUFDNWlDO1lBQ2ZBLEVBQUVpL0IsY0FBYztRQUNwQjtJQUFFLEdBQUc7UUFBRWg3QixVQUFVLE9BQU9zOUIsaUJBQWlCLFdBQVkxaUMsc0RBQUdBLENBQUMwaUMsY0FHdkRwaEMsT0FBT3lELE1BQU0sQ0FBQztZQUNaLGlFQUFpRTtZQUNqRSxhQUFhO1lBQ2JrSixLQUFLdzBCO1lBQVdwOUIsT0FBTy9ELE9BQU95RCxNQUFNLENBQUN6RCxPQUFPeUQsTUFBTSxDQUFDekQsT0FBT3lELE1BQU0sQ0FBQyxDQUFDLEdBQUdzM0IsS0FBS2wxQixjQUFjNjhCLFNBQVUsQ0FBQ3hCLG9CQUFxQmwyQixDQUFBQSx1QkFBdUIsUUFBUUEsdUJBQXVCLEtBQUssSUFBSSxLQUFLLElBQUlBLGtCQUFrQixDQUFDbEYsT0FBTztRQUFJLEdBQUc7WUFBRWhDLFVBQVVBO1FBQVMsTUFBUXBGLHNEQUFHQSxDQUFDMGlDLGNBQWNwaEMsT0FBT3lELE1BQU0sQ0FBQztZQUFFa0osS0FBS3cwQjtZQUFXcjdCLFFBQVFBO1lBQVFrN0IsYUFBYUE7WUFBYWo5QixPQUFPL0QsT0FBT3lELE1BQU0sQ0FBQ3pELE9BQU95RCxNQUFNLENBQUN6RCxPQUFPeUQsTUFBTSxDQUFDLENBQUMsR0FBR3MzQixLQUFLbDFCLGNBQWM2OEIsU0FBVSxDQUFDeEIsb0JBQXFCbDJCLENBQUFBLHVCQUF1QixRQUFRQSx1QkFBdUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsa0JBQWtCLENBQUNsRixPQUFPO1FBQUksR0FBRztZQUFFaEMsVUFBVUE7UUFBUztJQUFLO0FBQ2psQjtBQUNBLE1BQU00K0IsU0FBUztJQUNYNUIsU0FBUztJQUNUNkIsZ0JBQWdCO0FBQ3BCO0FBQ0EsTUFBTTVILE9BQU8sQ0FBQ24zQixRQUFXO1FBQ3JCQSxPQUFPQSxRQUFRO1FBQ2ZDLFFBQVFELFFBQVE7SUFDcEI7QUFDQSxNQUFNNDlCLGVBQWUsQ0FBQzE3QixRQUFRRixrQkFBa0J5RTtJQUM1QyxJQUFJLENBQUVBLENBQUFBLHFCQUFxQixRQUFRQSxxQkFBcUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsaUJBQWlCbTNCLFlBQVksR0FDbkcsT0FBTyxDQUFDO0lBQ1osSUFBSTE3QixXQUFXLE1BQU07UUFDakIsT0FBT0YscUJBQXFCLFVBQ3RCO1lBQUVnOUIsd0JBQXdCdjRCLGlCQUFpQm0zQixZQUFZO1FBQUMsSUFDeEQ7WUFBRXFCLHNCQUFzQng0QixpQkFBaUJtM0IsWUFBWTtRQUFDO0lBQ2hFO0lBQ0EsSUFBSTE3QixXQUFXLE1BQU07UUFDakIsT0FBT0YscUJBQXFCLFVBQ3RCO1lBQUVrOUIscUJBQXFCejRCLGlCQUFpQm0zQixZQUFZO1FBQUMsSUFDckQ7WUFBRXVCLHlCQUF5QjE0QixpQkFBaUJtM0IsWUFBWTtRQUFDO0lBQ25FO0lBQ0EsSUFBSTE3QixXQUFXLE1BQU07UUFDakIsT0FBT0YscUJBQXFCLFVBQ3RCO1lBQUVtOUIseUJBQXlCMTRCLGlCQUFpQm0zQixZQUFZO1FBQUMsSUFDekQ7WUFBRXNCLHFCQUFxQno0QixpQkFBaUJtM0IsWUFBWTtRQUFDO0lBQy9EO0lBQ0EsSUFBSTE3QixXQUFXLE1BQU07UUFDakIsT0FBT0YscUJBQXFCLFVBQ3RCO1lBQUVpOUIsc0JBQXNCeDRCLGlCQUFpQm0zQixZQUFZO1FBQUMsSUFDdEQ7WUFBRW9CLHdCQUF3QnY0QixpQkFBaUJtM0IsWUFBWTtRQUFDO0lBQ2xFO0lBQ0EsT0FBTyxDQUFDO0FBQ1o7QUFFQSxTQUFTd0I7SUFDTCxNQUFNLENBQUNsRCxTQUFTbUIsV0FBVyxHQUFHcGlDLCtDQUFRQSxDQUFDLENBQUM7SUFDeEMsTUFBTSxFQUFFcUwsa0JBQWtCLEVBQUV0RSxnQkFBZ0IsRUFBRUMsVUFBVSxFQUFFYyxlQUFlLEVBQUVqQixFQUFFLEVBQUU2SCxRQUFRLEVBQUVmLGlCQUFpQixFQUFHLEdBQUczQztJQUNoSCxNQUFNbzVCLGtCQUFrQjFqQyw4Q0FBT0EsQ0FBQztRQUM1QixNQUFNdVksU0FBUyxFQUFFO1FBQ2pCLCtEQUErRDtRQUMvRCxJQUFJLENBQUM1TixvQkFDRCxPQUFPLEVBQUU7UUFDYnFELFNBQVM5RyxPQUFPLENBQUMsQ0FBQ3FKLFNBQVN3RjtZQUN2QixNQUFNLEVBQUVsRyxRQUFRLEVBQUVDLFFBQVEsRUFBRXZILEtBQUssRUFBRSxHQUFHZ0k7WUFDdEMsZ0VBQWdFO1lBQ2hFLE1BQU1vekIsdUJBQXVCcHJCLE9BQU8wb0IsSUFBSSxDQUFDLENBQUN6Z0M7Z0JBQVEsSUFBSXlPO2dCQUFJLE9BQU96TyxFQUFFK0gsS0FBSyxLQUFLQSxTQUFTLENBQUMsQ0FBQzBHLEtBQUt6TyxFQUFFb2pDLGFBQWEsQ0FBQ0MsRUFBRSxDQUFDLENBQUMsRUFBQyxNQUFPLFFBQVE1MEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYSxRQUFRLE1BQU1EO1lBQVU7WUFDckwsa0pBQWtKO1lBQ2xKLElBQUk4ekIsc0JBQXNCO2dCQUN0QkEscUJBQXFCQyxhQUFhLENBQUMxekIsSUFBSSxDQUFDO29CQUFFTDtvQkFBVUM7b0JBQVVpRztnQkFBTTtZQUN4RSxPQUVLO2dCQUNEd0MsT0FBT3JJLElBQUksQ0FBQztvQkFDUjNIO29CQUNBLHVGQUF1RjtvQkFDdkZxN0IsZUFBZTt3QkFBQzs0QkFBRS96Qjs0QkFBVUM7NEJBQVVpRzt3QkFBTTtxQkFBRTtnQkFDbEQ7WUFDSjtRQUNKO1FBQ0EsT0FBT3dDO0lBQ1gsR0FBRztRQUFDdks7S0FBUztJQUNiLE9BQVE3TyxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFLGdCQUFnQmlDO0lBQUcsR0FBRztRQUFFNUIsVUFBVTtlQUFJOEUsTUFBTTtTQUFHLENBQUM2TyxHQUFHLENBQUMsQ0FBQzRyQixHQUFHbitCO1lBQ25GLE9BQVF4RyxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztnQkFBRU0sT0FBTztvQkFDbEMrOEIsU0FBUztvQkFDVHdDLFVBQVU7b0JBQ1YxL0IsT0FBT2lDO2dCQUNYO1lBQUUsR0FBRztnQkFBRS9CLFVBQVU7dUJBQUk4RSxNQUFNO2lCQUFHLENBQUM2TyxHQUFHLENBQUMsQ0FBQzRyQixHQUFHdGdDO29CQUNuQyxNQUFNK0MsU0FBU0YscUJBQXFCLFVBQzdCbkYsT0FBTyxDQUFDLElBQUlzQyxFQUFFLEdBQUltQyxDQUFBQSxJQUFJLEtBQ3RCekUsT0FBTyxDQUFDc0MsRUFBRSxHQUFJLEtBQUltQyxDQUFBQTtvQkFDekIsTUFBTTg3QixjQUFjaitCLElBQUksTUFBTW1DLElBQUksSUFBSSxVQUFVO29CQUNoRCxNQUFNZzhCLG1CQUFtQjN6QixTQUFTaXpCLElBQUksQ0FBQyxDQUFDemdDLElBQU1BLEVBQUVxUCxRQUFRLEtBQUt0SixVQUFVL0YsRUFBRXNQLFFBQVEsS0FBS3ZKO29CQUN0RixNQUFNeTlCLHlCQUF5Qk4sZ0JBQzFCbDZCLE1BQU0sQ0FBQyxDQUFDLEVBQUVvNkIsYUFBYSxFQUFFO3dCQUFPLElBQUkzMEI7d0JBQUksT0FBTyxDQUFDLENBQUNBLEtBQUsyMEIsY0FBY0MsRUFBRSxDQUFDLENBQUMsRUFBQyxNQUFPLFFBQVE1MEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYSxRQUFRLE1BQU12SjtvQkFBUSxFQUMzSSxpRkFBaUY7cUJBQ2hGaXhCLElBQUksQ0FBQyxDQUFDbDBCLEdBQUdDO3dCQUNWLElBQUkwTCxJQUFJQzt3QkFDUixPQUFPLENBQUMsQ0FBQ0QsS0FBSzFMLEVBQUVxZ0MsYUFBYSxDQUFDQyxFQUFFLENBQUMsQ0FBQyxFQUFDLE1BQU8sUUFBUTUwQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc4RyxLQUFLLElBQzlFLEVBQUM3RyxLQUFLNUwsRUFBRXNnQyxhQUFhLENBQUNDLEVBQUUsQ0FBQyxDQUFDLEVBQUMsTUFBTyxRQUFRMzBCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzZHLEtBQUs7b0JBQ3BGLEdBQ0s4dEIsRUFBRSxDQUFDO29CQUNSLE9BQVF6a0MsdURBQUlBLENBQUNvaUMsUUFBUS9nQyxPQUFPeUQsTUFBTSxDQUFDO3dCQUFFcUMsUUFBUUE7d0JBQVFrN0IsYUFBYUE7d0JBQWFDLFlBQVlBO3dCQUFZQyxrQkFBa0IsQ0FBQyxDQUFDQTtvQkFBaUIsR0FBRzt3QkFBRXA5QixVQUFVOzRCQUFDLENBQUNvOUIsb0JBQW9CdjZCLGVBQWUsQ0FBQ2IsT0FBTyxJQUFLcEgsc0RBQUdBLENBQUNraEMsT0FBTztnQ0FBRTkzQixPQUFPbkIsZUFBZSxDQUFDYixPQUFPO2dDQUFFQSxRQUFRQTtnQ0FBUWc2QixTQUFTQTs0QkFBUTs0QkFBS3lELDBCQUEyQjdrQyxzREFBR0EsQ0FBQ2toQyxPQUFPO2dDQUFFQyxpQkFBaUI7Z0NBQU0vM0IsT0FBT3k3Qix1QkFBdUJ6N0IsS0FBSztnQ0FBRWhDLFFBQVFBO2dDQUFRZzZCLFNBQVNBOzRCQUFROzRCQUFLdHpCLHFCQUFxQjlOLHNEQUFHQSxDQUFDOFIsVUFBVTtnQ0FBRWxKLEtBQUtwQztnQ0FBR3VMLEtBQUsxTjs0QkFBRTt5QkFBRztvQkFBQyxJQUFJLENBQUMsRUFBRUEsRUFBRSxFQUFFbUMsRUFBRSxDQUFDO2dCQUNwZjtZQUFHLElBQUlBLEVBQUVvTixRQUFRO1FBQ3pCO0lBQUc7QUFDWDtBQUVBLE1BQU1reEIsU0FBUztJQUNYLE1BQU0sRUFBRWg3QixNQUFNLEVBQUVFLFFBQVEsRUFBRTlDLGdCQUFnQixFQUFFQyxVQUFVLEVBQUV3QyxrQkFBa0JvN0Isa0JBQWtCLEVBQUcsR0FBRzU1QjtJQUNsRyxNQUFNNjVCLGFBQWE7V0FBSWw3QjtRQUFRRTtLQUFTLENBQUNLLE1BQU0sQ0FBQ21YO0lBQ2hELE9BQVF4aEIsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRUcsT0FBT2lDO1FBQVloQyxRQUFRZ0M7UUFBWTlCLE9BQU87WUFDekVpRCxVQUFVO1lBQ1ZreEIsS0FBSztZQUNMQyxNQUFNO1lBQ053TCxlQUFlO1lBQ2Z6eUIsUUFBUTtRQUNaO0lBQUUsR0FBRztRQUFFcE4sVUFBVTQvQixXQUFXanNCLEdBQUcsQ0FBQyxDQUFDek8sT0FBTzFJO1lBQ3BDLE1BQU0sQ0FBQ3NqQyxpQkFBaUJDLGVBQWVDLFdBQVcsR0FBRzk2QjtZQUNyRCxJQUFJNDZCLG9CQUFvQkMsZUFDcEIsT0FBTztZQUNYLE1BQU1FLE9BQU9wK0Isa0JBQWtCQyxrQkFBa0JDLFlBQVkrOUI7WUFDN0QsTUFBTUksS0FBS3IrQixrQkFBa0JDLGtCQUFrQkMsWUFBWWcrQjtZQUMzRCxJQUFJSSx1QkFBdUJwK0IsYUFBYTtZQUN4QyxNQUFNcStCLGdCQUFnQjVqQyxNQUFNa0ksT0FBT2pJLE1BQU07WUFDekMsMEZBQTBGO1lBQzFGLElBQUlpSSxPQUFPK1QsSUFBSSxDQUFDLENBQUM0bkIsWUFBY0EsU0FBUyxDQUFDLEVBQUUsS0FBS1AsbUJBQW1CTyxTQUFTLENBQUMsRUFBRSxLQUFLTixrQkFDaEYsQ0FBQ0ssZUFBZTtnQkFDaEJELHVCQUF1QnArQixhQUFhO1lBQ3hDO1lBQ0EsTUFBTXF4QixLQUFLOE0sR0FBRzk5QixDQUFDLEdBQUc2OUIsS0FBSzc5QixDQUFDO1lBQ3hCLE1BQU1peEIsS0FBSzZNLEdBQUc3OUIsQ0FBQyxHQUFHNDlCLEtBQUs1OUIsQ0FBQztZQUN4QixNQUFNakIsSUFBSTZHLEtBQUtxNEIsS0FBSyxDQUFDak4sSUFBSUQ7WUFDekIsTUFBTWxHLE1BQU07Z0JBQ1I5cUIsR0FBRzY5QixLQUFLNzlCLENBQUMsR0FBRyxLQUFPaEIsQ0FBQUEsSUFBSSsrQixvQkFBbUIsSUFBTS8rQjtnQkFDaERpQixHQUFHNDlCLEtBQUs1OUIsQ0FBQyxHQUFHLEtBQU9qQixDQUFBQSxJQUFJKytCLG9CQUFtQixJQUFNLytCO1lBQ3BEO1lBQ0EsT0FBUXZHLHVEQUFJQSxDQUFDZSwyQ0FBVUEsRUFBRTtnQkFBRW9FLFVBQVU7b0JBQUNwRixzREFBR0EsQ0FBQyxVQUFVc0IsT0FBT3lELE1BQU0sQ0FBQzt3QkFBRWlDLElBQUksQ0FBQyxVQUFVLEVBQUVwRixFQUFFLENBQUM7d0JBQUUrakMsYUFBYTt3QkFBS0MsY0FBYzt3QkFBT0MsTUFBTTt3QkFBUUMsTUFBTTt3QkFBUUMsUUFBUTtvQkFBTyxHQUFHO3dCQUFFM2dDLFVBQVVwRixzREFBR0EsQ0FBQyxXQUFXOzRCQUFFZ21DLFFBQVE7NEJBQTBCemdDLE1BQU02L0IsZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSUEsYUFBYUw7d0JBQW1CO29CQUFHO29CQUFLL2tDLHNEQUFHQSxDQUFDLFFBQVE7d0JBQUVpbUMsSUFBSVosS0FBSzc5QixDQUFDO3dCQUFFMCtCLElBQUliLEtBQUs1OUIsQ0FBQzt3QkFBRTArQixJQUFJN1QsSUFBSTlxQixDQUFDO3dCQUFFNCtCLElBQUk5VCxJQUFJN3FCLENBQUM7d0JBQUVuQyxTQUFTa2dDLGdCQUFnQixRQUFRO3dCQUFROS9CLFFBQVEwL0IsZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSUEsYUFBYUw7d0JBQW9CcC9CLGFBQWE2L0IsZ0JBQWdCLE1BQU9yK0IsYUFBYyxLQUFLQSxhQUFhO3dCQUFJay9CLFdBQVcsQ0FBQyxlQUFlLEVBQUV6a0MsRUFBRSxDQUFDLENBQUM7b0JBQUM7aUJBQUc7WUFBQyxHQUFHLENBQUMsRUFBRXNqQyxnQkFBZ0IsQ0FBQyxFQUFFQyxjQUFjLEVBQUVLLGdCQUFnQixZQUFZLEdBQUcsQ0FBQztRQUNuc0I7SUFBRztBQUNYO0FBRUEsU0FBU2MsZ0JBQWdCLEVBQUVDLE1BQU0sRUFBRTtJQUMvQixNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR3RtQywrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLEVBQUVnSCxVQUFVLEVBQUUrSCxXQUFXLEVBQUVyRCxxQkFBcUIsRUFBRUksc0JBQXNCLEVBQUV3RSxpQkFBaUIsRUFBRWpELHNCQUFzQixFQUFFaUIsaUJBQWlCLEVBQUVFLGVBQWUsRUFBRWYsc0JBQXNCLEVBQUcsR0FBR3pDO0lBQzNMLE1BQU1XLGtCQUFrQjtRQUNwQixPQUFReTZCLE1BQU0sQ0FBQyxFQUFFO1lBQ2IsS0FBSztnQkFDRCxPQUFPMTZCLHNCQUFzQkMsZUFBZTtZQUNoRCxLQUFLO2dCQUNELE9BQU9HLHVCQUF1QkgsZUFBZTtZQUNqRCxLQUFLO2dCQUNELE9BQU84QiwyQkFBMkIsWUFDNUIzQix1QkFBdUJILGVBQWUsR0FDdENELHNCQUFzQkMsZUFBZTtZQUMvQyxLQUFLO2dCQUNELE9BQU84QiwyQkFBMkIsWUFDNUIvQixzQkFBc0JDLGVBQWUsR0FDckNHLHVCQUF1QkgsZUFBZTtRQUNwRDtJQUNKO0lBQ0EsT0FBUTlMLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1FBQUVtOUIsU0FBUztZQUNwQyxJQUFJMTBCLHVCQUF1Qis0QixRQUFROTNCLHNCQUFzQixRQUFRQSxzQkFBc0IsS0FBSyxJQUFJQSxvQkFBb0JsRSxXQUFXb0Usb0JBQW9CLFFBQVFBLG9CQUFvQixLQUFLLElBQUlBLGtCQUFrQnBFLFlBQ3RNa0csa0JBQWtCaEMsbUJBQW1CRSxpQkFBaUI0M0IsUUFBUTtRQUN0RTtRQUFHakQsYUFBYSxJQUFNbUQsV0FBVztRQUFPL0MsWUFBWSxJQUFNK0MsV0FBVztRQUFRLGNBQWNGO1FBQVFsaEMsT0FBTztZQUN0R204QixRQUFRO1lBQ1IxMUIsaUJBQWlCMDZCLFVBQVUxNkIsb0JBQW9CLENBQUMsRUFBRUEsa0JBQWtCLEVBQUUsQ0FBQztZQUN2RWczQixjQUFjO1lBQ2RkLFlBQVk7UUFDaEI7SUFBRSxHQUFHO1FBQUU1OEIsVUFBVSxPQUFPOEosV0FBVyxDQUFDcTNCLE9BQU8sS0FBSyxhQUFjdm1DLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1lBQUVNLE9BQU87Z0JBQ3hGMjhCLFlBQVk7Z0JBQ1o3N0IsV0FBV3FnQyxVQUFVLGFBQWE7WUFDdEM7UUFBRSxHQUFHO1lBQUVwaEMsVUFBVThKLFdBQVcsQ0FBQ3EzQixPQUFPLENBQUM7Z0JBQ2pDbC9CLGFBQWFGLGFBQWE7Z0JBQzFCc1UsWUFBWTtZQUNoQjtRQUFHLE1BQVF6YixzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztZQUFFbzlCLFNBQVM7WUFBYWo5QixPQUFPaUMsYUFBYTtZQUFHaEMsUUFBUWdDLGFBQWE7WUFBRzlCLE9BQU87Z0JBQzlHMjhCLFlBQVk7Z0JBQ1o3N0IsV0FBV3FnQyxVQUFVLGFBQWE7WUFDdEM7UUFBRSxHQUFHO1lBQUVwaEMsVUFBVXBGLHNEQUFHQSxDQUFDLEtBQUs7Z0JBQUVvRixVQUFVOEosV0FBVyxDQUFDcTNCLE9BQU87WUFBQztRQUFHO0lBQUs7QUFDOUU7QUFFQSxTQUFTRztJQUNMLE1BQU0sRUFBRXgvQixnQkFBZ0IsRUFBRUMsVUFBVSxFQUFFeUcsc0JBQXNCLEVBQUVlLGVBQWUsRUFBRyxHQUFHeEQ7SUFDbkYsTUFBTXc3QixvQkFBb0IsQ0FBQ2g0QixvQkFBb0IsUUFBUUEsb0JBQW9CLEtBQUssSUFBSSxLQUFLLElBQUlBLGVBQWUsQ0FBQyxFQUFFLE1BQU0sTUFBTSxNQUFNO0lBQ2pJLE1BQU1pNEIsbUJBQW1CO1FBQ3JCLENBQUMsRUFBRUQsc0JBQXNCLFFBQVFBLHNCQUFzQixLQUFLLElBQUlBLG9CQUFvQixJQUFJLENBQUMsQ0FBQztRQUMxRixDQUFDLEVBQUVBLHNCQUFzQixRQUFRQSxzQkFBc0IsS0FBSyxJQUFJQSxvQkFBb0IsSUFBSSxDQUFDLENBQUM7UUFDMUYsQ0FBQyxFQUFFQSxzQkFBc0IsUUFBUUEsc0JBQXNCLEtBQUssSUFBSUEsb0JBQW9CLElBQUksQ0FBQyxDQUFDO1FBQzFGLENBQUMsRUFBRUEsc0JBQXNCLFFBQVFBLHNCQUFzQixLQUFLLElBQUlBLG9CQUFvQixJQUFJLENBQUMsQ0FBQztLQUM3RjtJQUNELE1BQU1FLGVBQWU7UUFDakJDLFNBQVM7WUFDTDFFLFNBQVM7WUFDVDJFLHFCQUFxQjtZQUNyQjVnQyxXQUFXLENBQUMsVUFBVSxFQUFFLENBQUNnQixhQUFhLEVBQUUsSUFBSSxFQUFFLENBQUNBLGFBQWEsRUFBRSxHQUFHLENBQUM7UUFDdEU7UUFDQTYvQixVQUFVO1lBQ043Z0MsV0FBVyxDQUFDLFVBQVUsRUFBRSxDQUFDZ0IsYUFBYSxHQUFHLElBQUksRUFBRSxDQUFDQSxhQUFhLEdBQUcsR0FBRyxDQUFDO1FBQ3hFO1FBQ0E4L0IsT0FBTztZQUNIN0UsU0FBUztZQUNUNkIsZ0JBQWdCO1lBQ2hCaUQsWUFBWTtZQUNaL2dDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsSUFBS2dCLGFBQWMsRUFBRSxHQUFHLENBQUM7WUFDdERqQyxPQUFPO1lBQ1BDLFFBQVEsQ0FBQyxFQUFFZ0MsYUFBYSxFQUFFLEVBQUUsQ0FBQztZQUM3QnF5QixLQUFLO1lBQ0wxdEIsaUJBQWlCO1lBQ2pCMnRCLE1BQU07UUFDVjtJQUNKO0lBQ0EsTUFBTTBOLGVBQWVsZ0Msa0JBQWtCQyxrQkFBa0JDLFlBQVl3SCxtQkFBbUI7SUFDeEYsT0FBUTNPLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1FBQUVNLE9BQU8vRCxPQUFPeUQsTUFBTSxDQUFDO1lBQUV1RCxVQUFVO1lBQVlreEIsS0FBSyxDQUFDLEVBQUUyTixpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWExL0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUFFZ3lCLE1BQU0sQ0FBQyxFQUFFME4saUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhMy9CLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFBRWdMLFFBQVE7UUFBSyxHQUFHcTBCLFlBQVksQ0FBQ2o1Qix1QkFBdUI7UUFBR3c1QixPQUFPO0lBQXlCLEdBQUc7UUFBRWhpQyxVQUFVd2hDLGlCQUFpQjd0QixHQUFHLENBQUMsQ0FBQ3d0QixTQUFZdm1DLHNEQUFHQSxDQUFDc21DLGlCQUFpQjtnQkFBRUMsUUFBUUE7WUFBTyxHQUFHQTtJQUFVO0FBQ2hjO0FBRUEsTUFBTWMsYUFBYTtJQUNmQyxXQUFZdG5DLHNEQUFHQSxDQUFDLE9BQU9zQixPQUFPeUQsTUFBTSxDQUFDO1FBQUVDLE9BQU87UUFBOEJDLFNBQVM7UUFBT0ksT0FBTztZQUMzRmtpQyxnQkFBZ0I7WUFDaEJDLGVBQWU7WUFDZkMsZ0JBQWdCO1FBQ3BCO1FBQUd0RixTQUFTO1FBQWtCMzZCLEdBQUc7UUFBT0MsR0FBRztRQUFPaEMsVUFBVTtRQUFXaWlDLFVBQVU7UUFBV3hpQyxPQUFPO1FBQU9DLFFBQVE7SUFBTSxHQUFHO1FBQUVDLFVBQVVwRixzREFBR0EsQ0FBQyxLQUFLO1lBQUVvRixVQUFVcEYsc0RBQUdBLENBQUMsUUFBUTtnQkFBRXFGLE9BQU87b0JBQ3JLRSxNQUFNO29CQUNORSxVQUFVO2dCQUNkO2dCQUFHbkIsR0FBRztZQUFnbUQ7UUFBRztJQUFHO0FBQzVuRDtBQUVBLFNBQVNxakMsY0FBYyxFQUFFdmlDLFFBQVEsRUFBRTtJQUMvQixJQUFJO1FBQ0EsT0FBT3BGLHNEQUFHQSxDQUFDRSx1REFBUUEsRUFBRTtZQUFFa0YsVUFBVUE7UUFBUztJQUM5QyxFQUNBLE9BQU9zUyxPQUFPO1FBQ1ZELFFBQVFtd0IsR0FBRyxDQUFDbHdCO1FBQ1osT0FBTzFYLHNEQUFHQSxDQUFDNm5DLFdBQVc7WUFBRUMsV0FBVztRQUFLO0lBQzVDO0FBQ0o7QUFDQSxTQUFTRCxVQUFVLEVBQUVDLFlBQVksS0FBSyxFQUFFO0lBQ3BDLE9BQVE3bkMsdURBQUlBLENBQUMsT0FBT3FCLE9BQU95RCxNQUFNLENBQUM7UUFBRU0sT0FBTztZQUNuQys4QixTQUFTO1lBQ1Q2QixnQkFBZ0I7WUFDaEJpRCxZQUFZO1lBQ1phLGVBQWU7UUFDbkI7SUFBRSxHQUFHO1FBQUUzaUMsVUFBVTtZQUFDcEYsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7Z0JBQUVNLE9BQU87b0JBQ3hDSCxPQUFPO29CQUNQQyxRQUFRO29CQUNSZ0IsV0FBVztnQkFDZjtZQUFFLEdBQUc7Z0JBQUVmLFVBQVVpaUMsV0FBV0MsU0FBUztZQUFDO1lBQUtRLGFBQWE5bkMsc0RBQUdBLENBQUMsTUFBTTtnQkFBRW9GLFVBQVU7WUFBdUI7U0FBRztJQUFDO0FBQ3pIO0FBRUEsU0FBUzRpQztJQUNMLE1BQU1DLFdBQVcxbkMsNkNBQU1BLENBQUM7SUFDeEIsTUFBTSxFQUFFNEcsVUFBVSxFQUFFdUssMEJBQTBCLEVBQUVsRSxzQkFBc0IsRUFBRWdCLG9CQUFvQixFQUFFRCxpQkFBaUIsRUFBRTVDLGdCQUFnQixFQUFHLEdBQUdSO0lBQ3ZJL0ssZ0RBQVNBLENBQUM7UUFDTixTQUFTOG5DLG1CQUFtQkMsS0FBSztZQUM3QixJQUFJRixTQUFTcDNCLE9BQU8sSUFDaEIsQ0FBQ28zQixTQUFTcDNCLE9BQU8sQ0FBQzJqQixRQUFRLENBQUMyVCxNQUFNbHNCLE1BQU0sR0FBRztnQkFDMUN2SztZQUNKO1FBQ0o7UUFDQXlSLFNBQVNvYSxnQkFBZ0IsQ0FBQyxXQUFXMks7UUFDckMsT0FBTztZQUNIL2tCLFNBQVNxYSxtQkFBbUIsQ0FBQyxXQUFXMEs7UUFDNUM7SUFDSixHQUFHLEVBQUU7SUFDTCxPQUFPL2dDLGFBQWNuSCxzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFTSxPQUFPO1lBQUUraUMsYUFBYTtRQUFTO0lBQUUsR0FBRztRQUFFaGpDLFVBQVVuRix1REFBSUEsQ0FBQyxPQUFPcUIsT0FBT3lELE1BQU0sQ0FBQztZQUFFa0osS0FBS2c2QjtZQUFVNWlDLE9BQU8vRCxPQUFPeUQsTUFBTSxDQUFDekQsT0FBT3lELE1BQU0sQ0FBQztnQkFBRXVELFVBQVU7WUFBVyxHQUFHKy9CLFlBQVlsaEMsY0FBY3dFO1FBQWtCLEdBQUc7WUFBRXZHLFVBQVU7Z0JBQUNwRixzREFBR0EsQ0FBQ3NrQyxTQUFTLENBQUM7Z0JBQUl0a0Msc0RBQUdBLENBQUM4a0MsUUFBUSxDQUFDO2dCQUFJdjJCLHFCQUFzQnRPLHVEQUFJQSxDQUFDQyx1REFBUUEsRUFBRTtvQkFBRWtGLFVBQVU7d0JBQUNwRixzREFBR0EsQ0FBQyxPQUFPOzRCQUFFa2lDLFNBQVM7Z0NBQ25WMXpCLHFCQUFxQjtnQ0FDckJoQiwyQkFBMkIsUUFBUUEsMkJBQTJCLEtBQUssSUFBSSxLQUFLLElBQUlBOzRCQUNwRjs0QkFBR25JLE9BQU87Z0NBQ05pRCxVQUFVO2dDQUNWa3hCLEtBQUs7Z0NBQ0xDLE1BQU07Z0NBQ05qbkIsUUFBUTtnQ0FDUjFHLGlCQUFpQjtnQ0FDakI1RyxPQUFPaUM7Z0NBQ1BoQyxRQUFRZ0M7NEJBQ1o7d0JBQUU7d0JBQUluSCxzREFBR0EsQ0FBQzBtQyxpQkFBaUIsQ0FBQztxQkFBRztnQkFBQzthQUFJO1FBQUM7SUFBSSxNQUFRMW1DLHNEQUFHQSxDQUFDNm5DLFdBQVcsQ0FBQztBQUM3RjtBQUNBLE1BQU1RLGNBQWMsQ0FBQ25qQyxRQUFXO1FBQzVCczhCLFFBQVE7UUFDUnI4QixRQUFRRDtRQUNSQTtJQUNKO0FBRUEsSUFBSW9qQztBQUNILFVBQVNBLFlBQVk7SUFDbEJBLFlBQVksQ0FBQyxRQUFRLEdBQUc7SUFDeEJBLFlBQVksQ0FBQyxRQUFRLEdBQUc7SUFDeEJBLFlBQVksQ0FBQyxXQUFXLEdBQUc7QUFDL0IsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFFcEMsTUFBTTNNO0lBQ0YsSUFBSTRNLFFBQVE7UUFDUixJQUFJQztRQUNKLE9BQU8sQ0FBQ0EsU0FBUyxJQUFJLENBQUN6d0IsSUFBSSxDQUFDd3dCLEtBQUssTUFBTSxRQUFRQyxXQUFXLEtBQUssSUFBSUEsU0FBUztJQUMvRTtJQUNBLElBQUlDLG9CQUFvQjtRQUNwQixPQUFPLElBQUksQ0FBQzF3QixJQUFJLENBQUMwd0IsaUJBQWlCO0lBQ3RDO0lBQ0EsSUFBSUMsK0JBQStCO1FBQy9CLE9BQU8sSUFBSSxDQUFDM3dCLElBQUksQ0FBQzJ3Qiw0QkFBNEI7SUFDakQ7SUFDQSxJQUFJQyxvQkFBb0I7UUFDcEIsSUFBSUM7UUFDSixPQUFPLENBQUNBLHFCQUFxQixJQUFJLENBQUM3d0IsSUFBSSxDQUFDNHdCLGlCQUFpQixNQUFNLFFBQVFDLHVCQUF1QixLQUFLLElBQUlBLHFCQUFxQjtJQUMvSDtJQUNBLElBQUlDLDJCQUEyQjtRQUMzQixJQUFJQztRQUNKLE9BQU8sQ0FBQ0EsNEJBQTRCLElBQUksQ0FBQy93QixJQUFJLENBQUM4d0Isd0JBQXdCLE1BQU0sUUFBUUMsOEJBQThCLEtBQUssSUFBSUEsNEJBQTRCO0lBQzNKO0lBQ0EsSUFBSUMsdUJBQXVCO1FBQ3ZCLElBQUlDO1FBQ0osT0FBTyxDQUFDQSx3QkFBd0IsSUFBSSxDQUFDanhCLElBQUksQ0FBQ2d4QixvQkFBb0IsTUFBTSxRQUFRQywwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7SUFDM0k7SUFDQSxJQUFJQyxvQkFBb0I7UUFDcEIsSUFBSUM7UUFDSixPQUFPLENBQUNBLHFCQUFxQixJQUFJLENBQUNueEIsSUFBSSxDQUFDa3hCLGlCQUFpQixNQUFNLFFBQVFDLHVCQUF1QixLQUFLLElBQUlBLHFCQUFxQjtJQUMvSDtJQUNBLElBQUlDLG9CQUFvQjtRQUNwQixJQUFJQztRQUNKLE9BQU8sQ0FBQ0EscUJBQXFCLElBQUksQ0FBQ3J4QixJQUFJLENBQUNveEIsaUJBQWlCLE1BQU0sUUFBUUMsdUJBQXVCLEtBQUssSUFBSUEscUJBQXFCO0lBQy9IO0lBQ0EsSUFBSUMsWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDdHhCLElBQUksQ0FBQ3N4QixTQUFTLElBQUk7SUFDbEM7SUFDQSxJQUFJQyxrQkFBa0I7UUFDbEIsSUFBSXI3QixLQUFLa3VCO1FBQ1QsSUFBSW9OLE1BQU1DO1FBQ1YsT0FBTyxDQUFDQSxPQUFPLENBQUNELE9BQU8sQ0FBQ3Q3QixNQUFNLElBQUksQ0FBQzhKLElBQUksTUFBTSxRQUFROUosUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJcTdCLGVBQWUsTUFBTSxRQUFRQyxTQUFTLEtBQUssSUFBSUEsT0FBTyxDQUFDcE4sT0FBTyxJQUFJLENBQUNwa0IsSUFBSSxNQUFNLFFBQVFva0IsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLb00sS0FBSyxNQUFNLFFBQVFpQixTQUFTLEtBQUssSUFBSUEsT0FBTztJQUN4UDtJQUNBLElBQUlDLGtCQUFrQjtRQUNsQixJQUFJeDdCLEtBQUt5N0I7UUFDVCxJQUFJQyxNQUFNQztRQUNWLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDRCxPQUFPLENBQUMxN0IsTUFBTSxJQUFJLENBQUM4SixJQUFJLE1BQU0sUUFBUTlKLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSXc3QixlQUFlLE1BQU0sUUFBUUUsU0FBUyxLQUFLLElBQUlBLE9BQU8sQ0FBQ0QsT0FBTyxJQUFJLENBQUMzeEIsSUFBSSxNQUFNLFFBQVEyeEIsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLbkIsS0FBSyxNQUFNLFFBQVFxQixTQUFTLEtBQUssSUFBSUEsT0FBTztJQUN4UDtJQUNBLElBQUlqZ0IsU0FBUztRQUNULElBQUksSUFBSSxDQUFDZSxPQUFPLElBQUksSUFBSSxDQUFDQSxPQUFPLENBQUNmLE1BQU0sRUFBRTtZQUNyQyxPQUFPLElBQUksQ0FBQ2UsT0FBTyxDQUFDZixNQUFNO1FBQzlCLE9BQU8sSUFBSSxLQUFrQixFQUFhLEVBRXpDO1FBQ0QsT0FBT3BmO0lBQ1g7SUFDQSxJQUFJNFksV0FBVztRQUNYLElBQUlsVjtRQUNKLElBQUksQ0FBQ0EsTUFBTSxJQUFJLENBQUN5YyxPQUFPLE1BQU0sUUFBUXpjLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSWtWLFFBQVEsRUFBRTtZQUN6RSxPQUFPLElBQUksQ0FBQ3VILE9BQU8sQ0FBQ3ZILFFBQVE7UUFDaEM7UUFDQSxJQUFJLElBQUksQ0FBQ3dHLE1BQU0sRUFBRTtZQUNiLE9BQU8sSUFBSSxDQUFDQSxNQUFNLENBQUN4RyxRQUFRO1FBQy9CO1FBQ0EsT0FBTzVZO0lBQ1g7SUFDQSxJQUFJcXhCLGNBQWM7UUFDZCxJQUFJM3RCO1FBQ0osT0FBTyxDQUFDLENBQUNBLE1BQU0sSUFBSSxDQUFDOEosSUFBSSxNQUFNLFFBQVE5SixRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUkydEIsV0FBVyxLQUFLLElBQUksQ0FBQ3pZLFFBQVE7SUFDckc7SUFDQXBPLFlBQVlnRCxJQUFJLEVBQUUyUyxPQUFPLENBQUM7UUFDdEIsSUFBSSxDQUFDM1MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzJTLE9BQU8sR0FBR0E7SUFDbkI7QUFDSjtBQUVBLFNBQVNtZixTQUFTNUQsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRTtJQUM1QixPQUFPLzRCLEtBQUt5OEIsSUFBSSxDQUFDejhCLEtBQUswOEIsR0FBRyxDQUFDMThCLEtBQUtDLEdBQUcsQ0FBQzY0QixLQUFLRixLQUFLLEtBQUs1NEIsS0FBSzA4QixHQUFHLENBQUMxOEIsS0FBS0MsR0FBRyxDQUFDODRCLEtBQUtGLEtBQUs7QUFDbEY7QUFDQSxTQUFTOEQsY0FBYy9ELEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTZELFdBQVc7SUFDOUMsSUFBSSxDQUFDQSxhQUFhO1FBQ2QsT0FBTztJQUNYO0lBQ0EsTUFBTUMsUUFBUTc4QixLQUFLODhCLEtBQUssQ0FBQy9ELEtBQUtGLElBQUlDLEtBQUtGLE1BQU0sTUFBTTU0QixLQUFLKzhCLEVBQUUsR0FBRztJQUM3RCxJQUFJLElBQUl4b0MsSUFBSSxHQUFHQSxJQUFJcW9DLFlBQVlwb0MsTUFBTSxFQUFFLEVBQUVELEVBQUU7UUFDdkMsTUFBTXlvQyxLQUFLSixXQUFXLENBQUNyb0MsRUFBRTtRQUN6QixJQUFJeW9DLE1BQU9BLENBQUFBLEdBQUdDLEtBQUssSUFBSSxRQUFRSixTQUFTRyxHQUFHQyxLQUFLLEtBQU1ELENBQUFBLEdBQUcvWCxHQUFHLElBQUksUUFBUTRYLFNBQVNHLEdBQUcvWCxHQUFHLEdBQUc7WUFDdEYsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFFQSx1REFBdUQ7QUFDdkQsTUFBTWlZLGVBQWU7SUFDakJDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxRQUFRO0FBQ1o7QUFDQSx3REFBd0Q7QUFDeEQsTUFBTUMsY0FBYztJQUNoQkgsTUFBTTtJQUNORSxRQUFRO0lBQ1JELE9BQU87QUFDWDtBQUNBOzs7Q0FHQyxHQUFHLFNBQVNHLHFCQUFxQnpwQyxDQUFDO0lBQy9CLHNFQUFzRTtJQUN0RSxzQ0FBc0M7SUFDdEMsT0FBT0EsRUFBRXlpQyxNQUFNLEtBQUtyNUIsYUFBYXBKLEVBQUV5aUMsTUFBTSxLQUFLK0csWUFBWUgsSUFBSTtBQUNsRTtBQUNBOzs7OztDQUtDLEdBQUcsU0FBU0ssbUJBQW1CMXBDLENBQUM7SUFDN0Isb0dBQW9HO0lBQ3BHLDZEQUE2RDtJQUM3RCxPQUFPQSxFQUFFb2lDLE9BQU8sS0FBS2g1QixhQUFhLENBQUNwSixFQUFFb2lDLE9BQU8sR0FBR2dILGFBQWFDLElBQUksTUFBTTtBQUMxRTtBQUNBLFNBQVNNLGFBQWEzcEMsQ0FBQztJQUNuQixPQUFPLENBQUMsQ0FBQ0EsRUFBRTRwQyxhQUFhO0FBQzVCO0FBRUEsTUFBTUMsZUFBZTtBQUNyQixTQUFTQyxvQkFBb0IvbkIsSUFBSTtJQUM3QixNQUFNbVcsS0FBS25XLEtBQUtvVyxRQUFRLEtBQUswUixlQUFlOW5CLE9BQU9BLEtBQUtxVyxhQUFhO0lBQ3JFLElBQUksQ0FBQ0YsSUFBSTtRQUNMLE9BQU85dUI7SUFDWDtJQUNBLE1BQU0sRUFBRWl2QixHQUFHLEVBQUdDLElBQUksRUFBRyxHQUFHSixHQUFHSyxxQkFBcUI7SUFDaEQsT0FBTztRQUNIbHlCLEdBQUdpeUI7UUFDSGh5QixHQUFHK3hCO0lBQ1A7QUFDSjtBQUNBLFNBQVMwUiwwQkFBMEIvcEMsQ0FBQyxFQUFFZ3FDLHVCQUF1QjtJQUN6RCxJQUFJaHFDLEVBQUU0cEMsYUFBYSxDQUFDbHBDLE1BQU0sS0FBSyxHQUFHO1FBQzlCLE9BQU91cEMscUJBQXFCanFDLEVBQUU0cEMsYUFBYSxDQUFDLEVBQUU7SUFDbEQsT0FBTyxJQUFJSSwyQkFBMkJocUMsRUFBRThoQyxPQUFPLENBQUNwaEMsTUFBTSxLQUFLLEdBQUc7UUFDMUQsSUFBSVYsRUFBRThoQyxPQUFPLENBQUMsRUFBRSxDQUFDaG5CLE1BQU0sS0FBS2t2Qix3QkFBd0JsdkIsTUFBTSxFQUFFO1lBQ3hELE9BQU9tdkIscUJBQXFCanFDLEVBQUU4aEMsT0FBTyxDQUFDLEVBQUU7UUFDNUM7SUFDSjtJQUNBO0FBQ0o7QUFDQSxTQUFTbUkscUJBQXFCanFDLENBQUMsRUFBRWdxQyx1QkFBdUI7SUFDcEQsSUFBSUwsYUFBYTNwQyxJQUFJO1FBQ2pCLE9BQU8rcEMsMEJBQTBCL3BDLEdBQUdncUM7SUFDeEMsT0FBTztRQUNILE9BQU87WUFDSDNqQyxHQUFHckcsRUFBRXk0QixPQUFPO1lBQ1pueUIsR0FBR3RHLEVBQUUwNEIsT0FBTztRQUNoQjtJQUNKO0FBQ0o7QUFFQSxNQUFNd1Isa0JBQWtCLENBQUM7SUFDckIsMkJBQTJCO0lBQzNCLElBQUlDLFlBQVk7SUFDaEIsSUFBSTtRQUNBL04saUJBQWlCLFFBQVE7UUFDekIsYUFBYTtRQUNiLEdBQUdqOEIsT0FBT3NhLGNBQWMsQ0FBQyxDQUFDLEdBQUcsV0FBVztZQUNwQ3pEO2dCQUNJbXpCLFlBQVk7Z0JBQ1osT0FBTztZQUNYO1FBQ0o7SUFDSixFQUFFLE9BQU9ucUMsR0FBRztJQUNaLGFBQWE7SUFDYjtJQUNBLE9BQU9tcUM7QUFDWDtBQUVBLE1BQU1DLGFBQWE7SUFDZixDQUFDakQsYUFBYWtELEtBQUssQ0FBQyxFQUFFO1FBQ2xCbEIsT0FBTztRQUNQbUIsTUFBTTtRQUNOblosS0FBSztRQUNMb1osYUFBYTtJQUNqQjtJQUNBLENBQUNwRCxhQUFhcUQsS0FBSyxDQUFDLEVBQUU7UUFDbEJyQixPQUFPO1FBQ1BtQixNQUFNO1FBQ05uWixLQUFLO0lBQ1Q7SUFDQSxDQUFDZ1csYUFBYXNELFFBQVEsQ0FBQyxFQUFFO1FBQ3JCQyxTQUFTO0lBQ2I7QUFDSjtBQUNBLE1BQU1DO0lBQ0Y7O0VBRUYsR0FBRzVQLFVBQVU7UUFDUCxJQUFJanVCO1FBQ0osT0FBTztZQUNIdXVCLGFBQWEsSUFBSSxDQUFDQSxXQUFXLENBQUNILElBQUk7WUFDbENELG9CQUFvQixJQUFJLENBQUNBLGtCQUFrQixDQUFDQyxJQUFJO1lBQ2hEQywwQkFBMEIsSUFBSSxDQUFDQSx3QkFBd0IsQ0FBQ0QsSUFBSTtZQUM1RDBQLGFBQWEsSUFBSSxDQUFDQSxXQUFXLENBQUMxUCxJQUFJO1lBQ2xDTyxtQkFBbUIsQ0FBQyxDQUFDM3VCLE1BQU0sSUFBSSxDQUFDMnVCLGlCQUFpQixNQUFNLFFBQVEzdUIsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJcE0sTUFBTSxLQUFLO1FBQzVHO0lBQ0o7SUFDQSxrQkFBa0I7SUFDbEIsSUFBSXNoQixXQUFXO1FBQ1gsT0FBTyxJQUFJLENBQUM1SSxPQUFPLENBQUM0SSxRQUFRO0lBQ2hDO0lBQ0F6RCxRQUFRO1FBQ0osTUFBTW1kLE9BQU8sSUFBSSxDQUFDdGlCLE9BQU8sQ0FBQ3FoQixXQUFXO1FBQ3JDLElBQUksQ0FBQ2lCLE1BQU07WUFDUDtRQUNKO1FBQ0FqbEIsVUFBVSxDQUFDazBCLGlCQUFpQnhzQixPQUFPLEVBQUU7UUFDckN3c0IsaUJBQWlCeHNCLE9BQU8sR0FBRztRQUMzQixJQUFJLENBQUNpZSxnQkFBZ0IsQ0FBQ1YsTUFBTSxTQUFTLElBQUksQ0FBQ21QLHNCQUFzQjtRQUNoRSxJQUFJLENBQUN6TyxnQkFBZ0IsQ0FBQ1YsTUFBTSxTQUFTLElBQUksQ0FBQ29QLHlCQUF5QixFQUFFO1FBQ3JFLElBQUksQ0FBQzFPLGdCQUFnQixDQUFDVixNQUFNLFFBQVEsSUFBSSxDQUFDcVAsYUFBYTtRQUN0RCxJQUFJLENBQUMzTyxnQkFBZ0IsQ0FBQ1YsTUFBTSxRQUFRLElBQUksQ0FBQ3NQLG9CQUFvQixFQUFFO1FBQy9ELElBQUksQ0FBQzVPLGdCQUFnQixDQUFDVixNQUFNLE9BQU8sSUFBSSxDQUFDdVAsdUJBQXVCLEVBQUU7UUFDakUsSUFBSSxJQUFJLENBQUM3eEIsT0FBTyxDQUFDMHVCLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDMXVCLE9BQU8sQ0FBQ291QixpQkFBaUIsRUFBRTtZQUNuRSxJQUFJLENBQUNwTCxnQkFBZ0IsQ0FBQ1YsTUFBTSxlQUFlLElBQUksQ0FBQ3VQLHVCQUF1QjtRQUMzRTtRQUNBLElBQUksSUFBSSxDQUFDN3hCLE9BQU8sQ0FBQ3d1QixvQkFBb0IsRUFBRTtZQUNuQyxJQUFJLENBQUN4TCxnQkFBZ0IsQ0FBQ1YsTUFBTSxXQUFXLElBQUksQ0FBQ3dQLG9CQUFvQixFQUFFO1FBQ3RFO0lBQ0o7SUFDQTFzQixXQUFXO1FBQ1AsTUFBTWtkLE9BQU8sSUFBSSxDQUFDdGlCLE9BQU8sQ0FBQ3FoQixXQUFXO1FBQ3JDLElBQUksQ0FBQ2lCLE1BQU07WUFDUDtRQUNKO1FBQ0FpUCxpQkFBaUJ4c0IsT0FBTyxHQUFHO1FBQzNCLElBQUksQ0FBQ2d0QixrQkFBa0IsR0FBRyxDQUFDO1FBQzNCLElBQUksQ0FBQzlPLG1CQUFtQixDQUFDWCxNQUFNLFNBQVMsSUFBSSxDQUFDb1AseUJBQXlCLEVBQUU7UUFDeEUsSUFBSSxDQUFDek8sbUJBQW1CLENBQUNYLE1BQU0sU0FBUyxJQUFJLENBQUMwUCxrQkFBa0I7UUFDL0QsSUFBSSxDQUFDL08sbUJBQW1CLENBQUNYLE1BQU0sUUFBUSxJQUFJLENBQUNzUCxvQkFBb0IsRUFBRTtRQUNsRSxJQUFJLENBQUMzTyxtQkFBbUIsQ0FBQ1gsTUFBTSxRQUFRLElBQUksQ0FBQ3FQLGFBQWE7UUFDekQsSUFBSSxDQUFDMU8sbUJBQW1CLENBQUNYLE1BQU0sT0FBTyxJQUFJLENBQUN1UCx1QkFBdUIsRUFBRTtRQUNwRSxJQUFJLElBQUksQ0FBQzd4QixPQUFPLENBQUMwdUIsaUJBQWlCLElBQUksQ0FBQyxJQUFJLENBQUMxdUIsT0FBTyxDQUFDb3VCLGlCQUFpQixFQUFFO1lBQ25FLElBQUksQ0FBQ25MLG1CQUFtQixDQUFDWCxNQUFNLGVBQWUsSUFBSSxDQUFDdVAsdUJBQXVCO1FBQzlFO1FBQ0EsSUFBSSxJQUFJLENBQUM3eEIsT0FBTyxDQUFDd3VCLG9CQUFvQixFQUFFO1lBQ25DLElBQUksQ0FBQ3ZMLG1CQUFtQixDQUFDWCxNQUFNLFdBQVcsSUFBSSxDQUFDd1Asb0JBQW9CLEVBQUU7UUFDekU7UUFDQSxJQUFJLENBQUNHLGtDQUFrQztJQUMzQztJQUNBalAsaUJBQWlCa1AsT0FBTyxFQUFFdEUsS0FBSyxFQUFFbGhCLE9BQU8sRUFBRXlsQixVQUFVLEtBQUssRUFBRTtRQUN2RCxNQUFNbnlCLFVBQVU4d0Isa0JBQWtCO1lBQzlCcUI7WUFDQUMsU0FBUztRQUNiLElBQUlEO1FBQ0osSUFBSSxDQUFDRSxhQUFhLENBQUM3a0MsT0FBTyxDQUFDLFNBQVM4a0MsWUFBWTtZQUM1QyxNQUFNQyxNQUFNdkIsVUFBVSxDQUFDc0IsYUFBYSxDQUFDMUUsTUFBTTtZQUMzQyxJQUFJMkUsS0FBSztnQkFDTEwsUUFBUWxQLGdCQUFnQixDQUFDdVAsS0FBSzdsQixTQUFTMU07WUFDM0M7UUFDSjtJQUNKO0lBQ0FpakIsb0JBQW9CaVAsT0FBTyxFQUFFdEUsS0FBSyxFQUFFbGhCLE9BQU8sRUFBRXlsQixVQUFVLEtBQUssRUFBRTtRQUMxRCxNQUFNbnlCLFVBQVU4d0Isa0JBQWtCO1lBQzlCcUI7WUFDQUMsU0FBUztRQUNiLElBQUlEO1FBQ0osSUFBSSxDQUFDRSxhQUFhLENBQUM3a0MsT0FBTyxDQUFDLFNBQVM4a0MsWUFBWTtZQUM1QyxNQUFNQyxNQUFNdkIsVUFBVSxDQUFDc0IsYUFBYSxDQUFDMUUsTUFBTTtZQUMzQyxJQUFJMkUsS0FBSztnQkFDTEwsUUFBUWpQLG1CQUFtQixDQUFDc1AsS0FBSzdsQixTQUFTMU07WUFDOUM7UUFDSjtJQUNKO0lBQ0E0VixrQkFBa0JwVixRQUFRLEVBQUVtSSxJQUFJLEVBQUU7UUFDOUIsTUFBTTZwQixrQkFBa0IsSUFBSSxDQUFDQSxlQUFlLENBQUNoZixJQUFJLENBQUMsSUFBSSxFQUFFaFQ7UUFDeEQsSUFBSSxDQUFDeWhCLFdBQVcsQ0FBQ3RqQixHQUFHLENBQUM2QixVQUFVbUk7UUFDL0IsSUFBSSxDQUFDcWEsZ0JBQWdCLENBQUNyYSxNQUFNLFNBQVM2cEI7UUFDckMsT0FBTztZQUNILElBQUksQ0FBQ3ZRLFdBQVcsQ0FBQzdVLE1BQU0sQ0FBQzVNO1lBQ3hCLElBQUksQ0FBQ3lpQixtQkFBbUIsQ0FBQ3RhLE1BQU0sU0FBUzZwQjtRQUM1QztJQUNKO0lBQ0FwYyxtQkFBbUI1VixRQUFRLEVBQUVtSSxJQUFJLEVBQUUzSSxPQUFPLEVBQUU7UUFDeEMsSUFBSSxDQUFDK2hCLHdCQUF3QixDQUFDcGpCLEdBQUcsQ0FBQzZCLFVBQVVSO1FBQzVDLElBQUksQ0FBQzZoQixrQkFBa0IsQ0FBQ2xqQixHQUFHLENBQUM2QixVQUFVbUk7UUFDdEMsT0FBTztZQUNILElBQUksQ0FBQ2taLGtCQUFrQixDQUFDelUsTUFBTSxDQUFDNU07WUFDL0IsSUFBSSxDQUFDdWhCLHdCQUF3QixDQUFDM1UsTUFBTSxDQUFDNU07UUFDekM7SUFDSjtJQUNBNFcsa0JBQWtCaFYsUUFBUSxFQUFFdUcsSUFBSSxFQUFFO1FBQzlCLE1BQU0yWixPQUFPLElBQUksQ0FBQ3RpQixPQUFPLENBQUNxaEIsV0FBVztRQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDelksUUFBUSxJQUFJLENBQUMwWixNQUFNO1lBQ3pCLE9BQU87WUFDUCxRQUFRLEdBQUc7UUFDZjtRQUNBLE1BQU1tUSxhQUFhLENBQUM3ckM7WUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQ2dpQixRQUFRLElBQUksQ0FBQzBaLFFBQVEsQ0FBQyxJQUFJLENBQUNuaUIsT0FBTyxDQUFDZSxVQUFVLElBQUk7Z0JBQ3ZEO1lBQ0o7WUFDQSxJQUFJd3hCO1lBQ0o7O0lBRVIsR0FBRyxPQUFPOXJDLEVBQUVzVCxJQUFJO2dCQUNKLEtBQUs4MkIsV0FBV0MsS0FBSyxDQUFDQyxJQUFJO29CQUN0QndCLFNBQVM7d0JBQ0x6bEMsR0FBR3JHLEVBQUV5NEIsT0FBTzt3QkFDWm55QixHQUFHdEcsRUFBRTA0QixPQUFPO29CQUNoQjtvQkFDQTtnQkFDSixLQUFLMFIsV0FBV0ksS0FBSyxDQUFDRixJQUFJO29CQUN0QixJQUFJeDlCLEtBQUtrdUI7b0JBQ1Q4USxTQUFTO3dCQUNMemxDLEdBQUcsQ0FBQyxDQUFDeUcsTUFBTTlNLEVBQUU4aEMsT0FBTyxDQUFDLEVBQUUsTUFBTSxRQUFRaDFCLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSTJyQixPQUFPLEtBQUs7d0JBQy9FbnlCLEdBQUcsQ0FBQyxDQUFDMDBCLE9BQU9oN0IsRUFBRThoQyxPQUFPLENBQUMsRUFBRSxNQUFNLFFBQVE5RyxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUt0QyxPQUFPLEtBQUs7b0JBQ3RGO29CQUNBO1lBQ1I7WUFDQTs7O0lBR1IsR0FBRyxNQUFNcVQsWUFBWUQsVUFBVSxPQUFPLElBQUksQ0FBQzlwQixRQUFRLENBQUNncUIsZ0JBQWdCLENBQUNGLE9BQU96bEMsQ0FBQyxFQUFFeWxDLE9BQU94bEMsQ0FBQyxJQUFJOEM7WUFDbkYsTUFBTTZpQyxhQUFhRixhQUFhaHFCLEtBQUtzUixRQUFRLENBQUMwWTtZQUM5QyxJQUFJQSxjQUFjaHFCLFFBQVFrcUIsWUFBWTtnQkFDbEMsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQzdyQyxHQUFHd2I7WUFDOUI7UUFDSjtRQUNBOztHQUVMLEdBQUcsSUFBSSxDQUFDNGdCLGdCQUFnQixDQUFDLElBQUksQ0FBQ3BhLFFBQVEsQ0FBQ3djLElBQUksRUFBRSxRQUFRcU47UUFDaEQsSUFBSSxDQUFDakIsV0FBVyxDQUFDN3lCLEdBQUcsQ0FBQ3lELFVBQVV1RztRQUMvQixPQUFPO1lBQ0gsSUFBSSxJQUFJLENBQUNDLFFBQVEsRUFBRTtnQkFDZixJQUFJLENBQUM0b0IsV0FBVyxDQUFDcGtCLE1BQU0sQ0FBQ2hMO2dCQUN4QixJQUFJLENBQUM2Z0IsbUJBQW1CLENBQUMsSUFBSSxDQUFDcmEsUUFBUSxDQUFDd2MsSUFBSSxFQUFFLFFBQVFxTjtZQUN6RDtRQUNKO0lBQ0o7SUFDQWhCLHlCQUF5QjtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDenhCLE9BQU8sQ0FBQyt1QixlQUFlLElBQUksQ0FBQyxJQUFJLENBQUMvdUIsT0FBTyxDQUFDa3ZCLGVBQWUsRUFBRTtZQUNoRSxPQUFPLElBQUksQ0FBQzhDLGtCQUFrQjtRQUNsQztRQUNBLE9BQU8sSUFBSSxDQUFDYyx1QkFBdUI7SUFDdkM7SUFDQUMsaUNBQWlDcHFCLElBQUksRUFBRTtRQUNuQyxJQUFJLENBQUNzcEIsa0NBQWtDO1FBQ3ZDLElBQUksQ0FBQ2UsaUJBQWlCLEdBQUdycUI7UUFDekIsSUFBSSxDQUFDc3FCLGdDQUFnQyxHQUFHLElBQUlsckIsaUJBQWlCO1lBQ3pELElBQUlZLFFBQVEsQ0FBQ0EsS0FBS3FXLGFBQWEsRUFBRTtnQkFDN0IsSUFBSSxDQUFDa1UsbUJBQW1CO2dCQUN4QixJQUFJLENBQUNqQixrQ0FBa0M7WUFDM0M7UUFDSjtRQUNBLElBQUksQ0FBQ3RwQixRQUFRLENBQUNBLEtBQUtxVyxhQUFhLEVBQUU7WUFDOUI7UUFDSjtRQUNBLElBQUksQ0FBQ2lVLGdDQUFnQyxDQUFDbnFCLE9BQU8sQ0FBQ0gsS0FBS3FXLGFBQWEsRUFBRTtZQUM5RG1VLFdBQVc7UUFDZjtJQUNKO0lBQ0FELHNCQUFzQjtRQUNsQixJQUFJLElBQUksQ0FBQ3RxQixRQUFRLElBQUksSUFBSSxDQUFDb3FCLGlCQUFpQixFQUFFO1lBQ3pDLElBQUksQ0FBQ0EsaUJBQWlCLENBQUNsb0MsS0FBSyxDQUFDKzhCLE9BQU8sR0FBRztZQUN2QyxJQUFJLENBQUNtTCxpQkFBaUIsQ0FBQ0ksZUFBZSxDQUFDO1lBQ3ZDLElBQUksQ0FBQ3hxQixRQUFRLENBQUN3YyxJQUFJLENBQUNpTyxXQUFXLENBQUMsSUFBSSxDQUFDTCxpQkFBaUI7UUFDekQ7SUFDSjtJQUNBZixxQ0FBcUM7UUFDakMsSUFBSSxJQUFJLENBQUNnQixnQ0FBZ0MsRUFBRTtZQUN2QyxJQUFJLENBQUNBLGdDQUFnQyxDQUFDSyxVQUFVO1FBQ3BEO1FBQ0EsSUFBSSxDQUFDTCxnQ0FBZ0MsR0FBR2pqQztRQUN4QyxJQUFJLENBQUNnakMsaUJBQWlCLEdBQUdoakM7SUFDN0I7SUFDQXdLLFlBQVlxRixPQUFPLEVBQUVzUSxPQUFPLEVBQUVuUSxPQUFPLENBQUM7UUFDbEMsSUFBSSxDQUFDRSxxQkFBcUIsR0FBRyxDQUFDTTtZQUMxQixNQUFNc1QsVUFBVSxJQUFJLENBQUNtTyxXQUFXLENBQUNya0IsR0FBRyxDQUFDNEM7WUFDckMsT0FBT3NULFdBQVc0YyxvQkFBb0I1YztRQUMxQztRQUNBLElBQUksQ0FBQzRkLHlCQUF5QixHQUFHLENBQUM5cUM7WUFDOUIsSUFBSSxDQUFDeXBDLHFCQUFxQnpwQyxJQUFJO2dCQUMxQjtZQUNKO1lBQ0EsSUFBSSxDQUFDMnNDLGtCQUFrQixHQUFHLEVBQUU7UUFDaEM7UUFDQSxJQUFJLENBQUNmLGVBQWUsR0FBRyxDQUFDaHlCO1lBQ3BCLDhGQUE4RjtZQUM5RixnRkFBZ0Y7WUFDaEYsSUFBSTdRLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUMyakMsa0JBQWtCLEdBQUc7Z0JBQ3hDLElBQUksQ0FBQ0Esa0JBQWtCLENBQUN4TyxPQUFPLENBQUN2a0I7WUFDcEM7UUFDSjtRQUNBLElBQUksQ0FBQ3d4QixrQkFBa0IsR0FBRyxDQUFDcHJDO1lBQ3ZCLElBQUksQ0FBQ3lwQyxxQkFBcUJ6cEMsSUFBSTtnQkFDMUI7WUFDSjtZQUNBLDBEQUEwRDtZQUMxRCx1QkFBdUI7WUFDdkIscURBQXFEO1lBQ3JELDBFQUEwRTtZQUMxRSxNQUFNNFksZUFBZXF4QixxQkFBcUJqcUM7WUFDMUMsSUFBSTRZLGNBQWM7Z0JBQ2QsSUFBSSt3QixhQUFhM3BDLElBQUk7b0JBQ2pCLElBQUksQ0FBQ2dxQyx1QkFBdUIsR0FBR2hxQyxFQUFFNHBDLGFBQWEsQ0FBQyxFQUFFO2dCQUNyRDtnQkFDQSxJQUFJLENBQUN1QixrQkFBa0IsR0FBR3Z5QjtZQUM5QjtZQUNBLElBQUksQ0FBQ2cwQixlQUFlLEdBQUc7UUFDM0I7UUFDQSxJQUFJLENBQUNWLHVCQUF1QixHQUFHLENBQUNsc0M7WUFDNUIsSUFBSSxDQUFDeXBDLHFCQUFxQnpwQyxJQUFJO2dCQUMxQjtZQUNKO1lBQ0EsTUFBTW9uQyxRQUFRcG5DLEVBQUVzVCxJQUFJLEtBQUs4MkIsV0FBV0ksS0FBSyxDQUFDckIsS0FBSyxHQUFHLElBQUksQ0FBQy92QixPQUFPLENBQUMrdUIsZUFBZSxHQUFHLElBQUksQ0FBQy91QixPQUFPLENBQUNrdkIsZUFBZTtZQUM3RyxJQUFJLENBQUN1RSxPQUFPLEdBQUd4OUIsV0FBVyxJQUFJLENBQUMrN0Isa0JBQWtCLENBQUN4ZSxJQUFJLENBQUMsSUFBSSxFQUFFNXNCLElBQUlvbkM7WUFDakUsSUFBSSxDQUFDd0YsZUFBZSxHQUFHO1FBQzNCO1FBQ0EsSUFBSSxDQUFDNUIsb0JBQW9CLEdBQUc7WUFDeEIsSUFBSSxDQUFDdlAsaUJBQWlCLEdBQUcsRUFBRTtRQUMvQjtRQUNBLElBQUksQ0FBQ29RLFVBQVUsR0FBRyxDQUFDaUIsTUFBTXR4QjtZQUNyQixJQUFJLElBQUksQ0FBQ2lnQixpQkFBaUIsRUFBRTtnQkFDeEIsSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQzBDLE9BQU8sQ0FBQzNpQjtZQUNuQztRQUNKO1FBQ0EsSUFBSSxDQUFDdXZCLGFBQWEsR0FBRyxDQUFDcG9DO1lBQ2xCLElBQUksSUFBSSxDQUFDa3FDLE9BQU8sRUFBRTtnQkFDZDE5QixhQUFhLElBQUksQ0FBQzA5QixPQUFPO1lBQzdCO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQzdxQixRQUFRLElBQUksSUFBSSxDQUFDNHFCLGVBQWUsRUFBRTtnQkFDeEM7WUFDSjtZQUNBLE1BQU0sRUFBRUQsa0JBQWtCLEVBQUdsUixpQkFBaUIsRUFBRyxHQUFHLElBQUk7WUFDeEQsTUFBTWlNLDJCQUEyQixJQUFJLENBQUN0dUIsT0FBTyxDQUFDc3VCLHdCQUF3QjtZQUN0RSxNQUFNOXVCLGVBQWVxeEIscUJBQXFCdG5DLElBQUksSUFBSSxDQUFDcW5DLHVCQUF1QjtZQUMxRSxJQUFJLENBQUNweEIsY0FBYztnQkFDZjtZQUNKO1lBQ0EsNEVBQTRFO1lBQzVFLElBQUksSUFBSSxDQUFDbTBCLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQ3h6QixPQUFPLENBQUNlLFVBQVUsTUFBTXV1QixjQUFjLElBQUksQ0FBQ3NDLGtCQUFrQixDQUFDOWtDLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzhrQyxrQkFBa0IsQ0FBQzdrQyxDQUFDLElBQUksR0FBR3NTLGFBQWF2UyxDQUFDLEVBQUV1UyxhQUFhdFMsQ0FBQyxFQUFFLElBQUksQ0FBQzhTLE9BQU8sQ0FBQ2t1QixpQkFBaUIsR0FBRztnQkFDbE0sSUFBSSxDQUFDeUYsWUFBWSxHQUFHO2dCQUNwQjtZQUNKO1lBQ0EsOEVBQThFO1lBQzlFLElBQUksQ0FBQyxJQUFJLENBQUN4ekIsT0FBTyxDQUFDZSxVQUFVLE1BQU0saURBQWlEO1lBQ25GLElBQUksQ0FBQzZ3QixrQkFBa0IsQ0FBQzlxQyxjQUFjLENBQUMsUUFBUXNzQyxzQkFBc0JqRSxTQUFTLElBQUksQ0FBQ3lDLGtCQUFrQixDQUFDOWtDLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzhrQyxrQkFBa0IsQ0FBQzdrQyxDQUFDLElBQUksR0FBR3NTLGFBQWF2UyxDQUFDLEVBQUV1UyxhQUFhdFMsQ0FBQyxJQUFLLEtBQUksQ0FBQzhTLE9BQU8sQ0FBQzh1QixTQUFTLEdBQUcsSUFBSSxDQUFDOXVCLE9BQU8sQ0FBQzh1QixTQUFTLEdBQUcsSUFBSTtnQkFDbk8sSUFBSSxDQUFDeUUsa0JBQWtCLEdBQUd2akM7Z0JBQzFCLElBQUksQ0FBQzZVLE9BQU8sQ0FBQy9FLFNBQVMsQ0FBQ3l6QixvQkFBb0I7b0JBQ3ZDL3pCLGNBQWMsSUFBSSxDQUFDdXlCLGtCQUFrQjtvQkFDckM3eEIsdUJBQXVCLElBQUksQ0FBQ0EscUJBQXFCO29CQUNqREQsZUFBZTtnQkFDbkI7WUFDSjtZQUNBLElBQUksQ0FBQyxJQUFJLENBQUNFLE9BQU8sQ0FBQ2UsVUFBVSxJQUFJO2dCQUM1QjtZQUNKO1lBQ0EsTUFBTWdmLGFBQWEsSUFBSSxDQUFDK0IsV0FBVyxDQUFDcmtCLEdBQUcsQ0FBQyxJQUFJLENBQUN1QyxPQUFPLENBQUM4QyxXQUFXO1lBQ2hFLElBQUksQ0FBQzh2QixnQ0FBZ0MsQ0FBQzdTO1lBQ3RDLElBQUksQ0FBQ3JiLE9BQU8sQ0FBQ1gsaUJBQWlCO1lBQzlCLElBQUkzYSxHQUFHcXFDLFVBQVUsRUFBRXJxQyxHQUFHczhCLGNBQWM7WUFDcEMsbURBQW1EO1lBQ25ELE1BQU1nTyxzQkFBc0IsQ0FBQ3hSLHFCQUFxQixFQUFFLEVBQUU3akIsR0FBRyxDQUFDLENBQUNPLE1BQU0sSUFBSSxDQUFDeXlCLFdBQVcsQ0FBQzV6QixHQUFHLENBQUNtQixNQUNwRmpQLE1BQU0sQ0FBQyxDQUFDbEosSUFBSSxDQUFDLENBQUNBO1lBRWhCLHNEQUFzRDtZQUN0RCxNQUFNa3RDLGtCQUFrQixJQUFJLENBQUM5ekIsT0FBTyxDQUFDbXVCLDRCQUE0QixHQUFHLElBQUksQ0FBQ251QixPQUFPLENBQUNtdUIsNEJBQTRCLENBQUMzdUIsYUFBYXZTLENBQUMsRUFBRXVTLGFBQWF0UyxDQUFDLEVBQUUybUMsdUJBQXVCLElBQUksQ0FBQ2pyQixRQUFRLENBQUNnZ0IsaUJBQWlCLENBQUNwcEIsYUFBYXZTLENBQUMsRUFBRXVTLGFBQWF0UyxDQUFDO1lBQ25PLDRHQUE0RztZQUM1RyxNQUFNNm1DLDBCQUEwQixFQUFFO1lBQ2xDLElBQUksTUFBTUMsVUFBVUYsZ0JBQWdCO2dCQUNoQyxpREFBaUQ7Z0JBQ2pELElBQUksQ0FBQ0EsZ0JBQWdCN3NDLGNBQWMsQ0FBQytzQyxTQUFTO29CQUN6QztnQkFDSjtnQkFDQSxJQUFJQyxjQUFjSCxlQUFlLENBQUNFLE9BQU87Z0JBQ3pDLElBQUlDLGVBQWUsTUFBTTtvQkFDckJGLHdCQUF3QnY5QixJQUFJLENBQUN5OUI7Z0JBQ2pDO2dCQUNBLE1BQU1BLFlBQVk7b0JBQ2RBLGNBQWNBLFlBQVlqVixhQUFhO29CQUN2QyxJQUFJaVYsZUFBZUYsd0JBQXdCNXNDLE9BQU8sQ0FBQzhzQyxpQkFBaUIsQ0FBQyxHQUFHO3dCQUNwRUYsd0JBQXdCdjlCLElBQUksQ0FBQ3k5QjtvQkFDakM7Z0JBQ0o7WUFDSjtZQUNBLE1BQU1DLDJCQUEyQkgsd0JBQXVCLDBEQUEwRDthQUNqSGprQyxNQUFNLENBQUMsQ0FBQzZZLE9BQU9rckIsb0JBQW9CMXNDLE9BQU8sQ0FBQ3doQixRQUFRLENBQUMsR0FDcEQsMkNBQTJDO2FBQzNDbkssR0FBRyxDQUFDLENBQUNtSyxPQUFPLElBQUksQ0FBQ3dyQixnQkFBZ0IsQ0FBQ3hyQixPQUNsQyxnQ0FBZ0M7YUFDaEM3WSxNQUFNLENBQUMsQ0FBQzZZLE9BQU8sQ0FBQyxDQUFDQSxNQUNoQjdZLE1BQU0sQ0FBQyxDQUFDckQsSUFBSTRQLE9BQU8rM0IsTUFBTUEsSUFBSWp0QyxPQUFPLENBQUNzRixRQUFRNFA7WUFFL0Msc0ZBQXNGO1lBQ3RGLElBQUlpeUIsMEJBQTBCO2dCQUMxQixJQUFJLE1BQU1sc0IsWUFBWSxJQUFJLENBQUNvdkIsV0FBVyxDQUFDO29CQUNuQyxNQUFNNkMsYUFBYSxJQUFJLENBQUM3QyxXQUFXLENBQUM1ekIsR0FBRyxDQUFDd0U7b0JBQ3hDLElBQUk4ZCxjQUFjbVUsY0FBY0EsV0FBV3BhLFFBQVEsQ0FBQ2lHLGVBQWVnVSx5QkFBeUIvc0MsT0FBTyxDQUFDaWIsY0FBYyxDQUFDLEdBQUc7d0JBQ2xIOHhCLHlCQUF5Qm5QLE9BQU8sQ0FBQzNpQjt3QkFDakM7b0JBQ0o7Z0JBQ0o7WUFDSjtZQUNBLHVGQUF1RjtZQUN2Rjh4Qix5QkFBeUJyeEIsT0FBTztZQUNoQyxJQUFJLENBQUNnQyxPQUFPLENBQUNyQixLQUFLLENBQUMwd0IsMEJBQTBCO2dCQUN6QzEwQixjQUFjQTtZQUNsQjtRQUNKO1FBQ0E7OztFQUdOLEdBQUcsSUFBSSxDQUFDMjBCLGdCQUFnQixHQUFHLENBQUN4ckI7WUFDbEIsTUFBTXBiLE9BQU8sSUFBSSxDQUFDaWtDLFdBQVcsQ0FBQ2prQyxJQUFJO1lBQ2xDLElBQUl5UCxPQUFPelAsS0FBS3lQLElBQUk7WUFDcEIsTUFBTUEsS0FBS3NQLElBQUksS0FBSyxNQUFNO2dCQUN0QixNQUFNbEssV0FBV3BGLEtBQUsxRixLQUFLO2dCQUMzQixJQUFJcVIsU0FBUyxJQUFJLENBQUM2b0IsV0FBVyxDQUFDNXpCLEdBQUcsQ0FBQ3dFLFdBQVc7b0JBQ3pDLE9BQU9BO2dCQUNYLE9BQU87b0JBQ0hwRixPQUFPelAsS0FBS3lQLElBQUk7Z0JBQ3BCO1lBQ0o7WUFDQSxPQUFPaE47UUFDWDtRQUNBLElBQUksQ0FBQzZoQyx1QkFBdUIsR0FBRyxDQUFDanJDO1lBQzVCLElBQUksQ0FBQytzQyxZQUFZLEdBQUc7WUFDcEIsSUFBSSxDQUFDL0MsdUJBQXVCLEdBQUc1Z0M7WUFDL0IsSUFBSSxDQUFDc2dDLG1CQUFtQjFwQyxJQUFJO2dCQUN4QjtZQUNKO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3VaLE9BQU8sQ0FBQ2UsVUFBVSxNQUFNLElBQUksQ0FBQ2YsT0FBTyxDQUFDb0MsT0FBTyxJQUFJO2dCQUN0RCxJQUFJLENBQUNneEIsa0JBQWtCLEdBQUd2akM7Z0JBQzFCO1lBQ0o7WUFDQSxJQUFJcEosRUFBRWd0QyxVQUFVLEVBQUVodEMsRUFBRWkvQixjQUFjO1lBQ2xDLElBQUksQ0FBQ2tNLGtCQUFrQixHQUFHLENBQUM7WUFDM0IsSUFBSSxDQUFDRSxrQ0FBa0M7WUFDdkMsSUFBSSxDQUFDcHRCLE9BQU8sQ0FBQzdDLElBQUk7WUFDakIsSUFBSSxDQUFDNkMsT0FBTyxDQUFDOUIsT0FBTztRQUN4QjtRQUNBLElBQUksQ0FBQyt1QixvQkFBb0IsR0FBRyxDQUFDbHJDO1lBQ3pCLElBQUlBLEVBQUVtWSxHQUFHLEtBQUssWUFBWSxJQUFJLENBQUNvQixPQUFPLENBQUNlLFVBQVUsSUFBSTtnQkFDakQsSUFBSSxDQUFDNndCLGtCQUFrQixHQUFHLENBQUM7Z0JBQzNCLElBQUksQ0FBQ0Usa0NBQWtDO2dCQUN2QyxJQUFJLENBQUNwdEIsT0FBTyxDQUFDOUIsT0FBTztZQUN4QjtRQUNKO1FBQ0EsSUFBSSxDQUFDL0MsT0FBTyxHQUFHLElBQUlvaEIsY0FBY3BoQixTQUFTbVE7UUFDMUMsSUFBSSxDQUFDdEwsT0FBTyxHQUFHaEYsUUFBUTJFLFVBQVU7UUFDakMsSUFBSSxDQUFDckUsT0FBTyxHQUFHTixRQUFRTyxVQUFVO1FBQ2pDLElBQUksQ0FBQzZoQixXQUFXLEdBQUcsSUFBSXhqQjtRQUN2QixJQUFJLENBQUNvakIsa0JBQWtCLEdBQUcsSUFBSXBqQjtRQUM5QixJQUFJLENBQUNzakIsd0JBQXdCLEdBQUcsSUFBSXRqQjtRQUNwQyxJQUFJLENBQUMreUIsV0FBVyxHQUFHLElBQUkveUI7UUFDdkIsSUFBSSxDQUFDNHpCLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ04sa0JBQWtCLEdBQUcsQ0FBQztRQUMzQixJQUFJLENBQUM0QixZQUFZLEdBQUc7UUFDcEIsSUFBSSxJQUFJLENBQUMzekIsT0FBTyxDQUFDMHVCLGlCQUFpQixFQUFFO1lBQ2hDLElBQUksQ0FBQzJELGFBQWEsQ0FBQzc3QixJQUFJLENBQUN1M0IsYUFBYWtELEtBQUs7UUFDOUM7UUFDQSxJQUFJLElBQUksQ0FBQ2p4QixPQUFPLENBQUM0dUIsaUJBQWlCLEVBQUU7WUFDaEMsSUFBSSxDQUFDeUQsYUFBYSxDQUFDNzdCLElBQUksQ0FBQ3UzQixhQUFhcUQsS0FBSztRQUM5QztRQUNBLElBQUksSUFBSSxDQUFDcHhCLE9BQU8sQ0FBQ3d1QixvQkFBb0IsRUFBRTtZQUNuQyxJQUFJLENBQUM2RCxhQUFhLENBQUM3N0IsSUFBSSxDQUFDdTNCLGFBQWFzRCxRQUFRO1FBQ2pEO0lBQ0o7QUFDSjtBQUVBLE1BQU1pRCxlQUFlLFNBQVM1TixjQUFjN21CLE9BQU8sRUFBRXNRLFVBQVUsQ0FBQyxDQUFDLEVBQUVuUSxVQUFVLENBQUMsQ0FBQztJQUMzRSxPQUFPLElBQUl1eEIsaUJBQWlCMXhCLFNBQVNzUSxTQUFTblE7QUFDbEQ7QUFFQSxNQUFNdTBCLHFDQUF1Qnp1QyxvREFBYUEsQ0FBQztJQUFFMHVDLHdCQUF3QjtBQUFNO0FBQzNFLE1BQU1DLGdCQUFnQixDQUFDLEVBQUU1cEMsUUFBUSxFQUFFO0lBQy9CLE9BQU9wRixzREFBR0EsQ0FBQ0UsdURBQVFBLEVBQUU7UUFBRWtGLFVBQVVBO0lBQVM7QUFDOUM7QUFDQSxNQUFNNnBDLHdCQUF3QixDQUFDLEVBQUU3cEMsUUFBUSxFQUFFeVosT0FBTyxFQUFFNkwsT0FBTyxFQUFFblEsT0FBTyxFQUFFaVAsU0FBUyxFQUFHO0lBQzlFLE9BQVF4cEIsc0RBQUdBLENBQUM4dUMscUJBQXFCbDlCLFFBQVEsRUFBRXRRLE9BQU95RCxNQUFNLENBQUM7UUFBRThNLE9BQU87WUFBRWs5Qix3QkFBd0I7UUFBSztJQUFFLEdBQUc7UUFBRTNwQyxVQUFVcEYsc0RBQUdBLENBQUNxcUIsYUFBYS9vQixPQUFPeUQsTUFBTSxDQUFDO1lBQUU4WixTQUFTQSxXQUFZLG1CQUFrQjhLLFNBQVNrbEIsZUFBZTdOLFlBQVc7WUFBSXRXLFNBQVNBO1lBQVNuUSxTQUFTQTtZQUFTaVAsV0FBV0EsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSUEsWUFBWTtRQUFNLEdBQUc7WUFBRXBrQixVQUFVQTtRQUFTO0lBQUk7QUFDL1c7QUFDQSxNQUFNOHBDLG9CQUFvQixDQUFDLEVBQUVDLGdCQUFnQixFQUFFQyx1QkFBdUIsRUFBRWhxQyxRQUFRLEVBQUc7SUFDL0UsTUFBTSxDQUFDaXFDLGNBQWNDLGdCQUFnQixHQUFHbnZDLCtDQUFRQTtJQUNoRCxNQUFNLENBQUNvdkMsWUFBWUMsY0FBYyxHQUFHcnZDLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ3N2QyxVQUFVQyxZQUFZLEdBQUd2dkMsK0NBQVFBLENBQUM7SUFDekMsTUFBTSxFQUFFNHVDLHNCQUFzQixFQUFFLEdBQUd0dUMsaURBQVVBLENBQUNxdUM7SUFDOUMxdUMsZ0RBQVNBLENBQUM7UUFDTnN2QyxZQUFZLGtCQUFrQi9sQjtRQUM5QjZsQixjQUFjO1FBQ2RGLGdCQUFnQjNsQjtJQUNwQixHQUFHLEVBQUU7SUFDTCxzR0FBc0c7SUFDdEcsTUFBTWdtQixhQUFhWix5QkFBeUJDLGdCQUFnQjNrQjtJQUM1RCxJQUFJLENBQUNrbEIsWUFBWTtRQUNiLE9BQU87SUFDWDtJQUNBLE9BQU9GLGVBQWdCcnZDLHNEQUFHQSxDQUFDMnZDLFlBQVlydUMsT0FBT3lELE1BQU0sQ0FBQztRQUFFOFosU0FBU3N3QixvQkFBcUJNLENBQUFBLFdBQVdaLGVBQWU3TixZQUFXO1FBQUl0VyxTQUFTMmtCO1FBQWM5MEIsU0FBUzQwQixtQkFBbUJDLDBCQUEwQjdrQztJQUFVLEdBQUc7UUFBRW5GLFVBQVVBO0lBQVMsTUFBUXBGLHNEQUFHQSxDQUFDRSx1REFBUUEsRUFBRTtRQUFFa0YsVUFBVUE7SUFBUztBQUM1UjtBQUVBLFNBQVN3cUMsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRTtJQUN2QyxNQUFNLEVBQUUxb0MsVUFBVSxFQUFFK0gsV0FBVyxFQUFFbEksRUFBRSxFQUFFZ0gsWUFBWSxFQUFFM0MscUJBQXFCLEVBQUUsR0FBR0Y7SUFDN0UsTUFBTTJrQyxpQkFBaUI5YyxhQUFhLENBQUN0WSxVQUFhO1lBQzlDakMsTUFBTWlDLFFBQVFvSCxPQUFPO1lBQ3JCL0gsY0FBY1csUUFBUXVILGVBQWU7WUFDckNqSSxvQkFBb0JVLFFBQVFELHFCQUFxQjtZQUNqRGdCLFlBQVlmLFFBQVFlLFVBQVU7UUFDbEM7SUFDQSxNQUFNLEVBQUVBLFVBQVUsRUFBRWhELElBQUksRUFBRXNCLFlBQVksRUFBRUMsa0JBQWtCLEVBQUcsR0FBRzgxQjtJQUNoRSxNQUFNQyxlQUFlbnZDLGtEQUFXQSxDQUFDLENBQUNtWixjQUFjQztRQUM1QyxJQUFJLENBQUNELGdCQUFnQixDQUFDQyxvQkFDbEIsT0FBTztZQUFFb29CLFNBQVM7UUFBTztRQUM3QixJQUFJLEVBQUU1NkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR3VHLGVBQWUrTCxlQUFlQztRQUM3QyxNQUFNZzJCLGtCQUFrQjdvQyxhQUFhLElBQUk7UUFDekMsSUFBSTZHLGNBQWM7WUFDZHhHLEtBQUt3b0M7WUFDTHZvQyxLQUFLdW9DO1FBQ1Q7UUFDQSxJQUFJLENBQUMza0MsdUJBQXVCO1lBQ3hCLE1BQU0sRUFBRW91QixJQUFJLEVBQUVELEdBQUcsRUFBRSxHQUFHcVc7WUFDdEIsNkNBQTZDO1lBQzdDLE1BQU1JLFVBQVV4VyxPQUFPdVc7WUFDdkIsTUFBTUUsU0FBUzFXLE1BQU13VztZQUNyQixNQUFNRyxXQUFXMVcsT0FBT3R5QixhQUFhNm9DO1lBQ3JDLE1BQU1JLFlBQVk1VyxNQUFNcnlCLGFBQWE2b0M7WUFDckN4b0MsSUFBSTZGLEtBQUs0cUIsR0FBRyxDQUFDZ1ksU0FBUzVpQyxLQUFLZ2pDLEdBQUcsQ0FBQzdvQyxHQUFHMm9DO1lBQ2xDMW9DLElBQUk0RixLQUFLNHFCLEdBQUcsQ0FBQ2lZLFFBQVE3aUMsS0FBS2dqQyxHQUFHLENBQUM1b0MsR0FBRzJvQztRQUNyQztRQUNBLE1BQU1qcUMsWUFBWSxDQUFDLFVBQVUsRUFBRXFCLEVBQUUsSUFBSSxFQUFFQyxFQUFFLEdBQUcsQ0FBQztRQUM3QyxPQUFPO1lBQ0h0QjtZQUNBbXFDLGlCQUFpQm5xQztZQUNqQm83QixhQUFhO1FBQ2pCO0lBQ0osR0FBRztRQUFDcDZCO1FBQVlrRTtRQUF1QjJDO1FBQWM2aEM7S0FBZTtJQUNwRSxPQUFPcDBCLGNBQWNoRCxLQUFLelIsRUFBRSxLQUFLQSxLQUFNaEgsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7UUFBRU0sT0FBTztZQUNqRWlELFVBQVU7WUFDVjI4QixlQUFlO1lBQ2Z6eUIsUUFBUTtZQUNSaW5CLE1BQU07WUFDTkQsS0FBSztRQUNUO0lBQUUsR0FBRztRQUFFcDBCLFVBQVVwRixzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztZQUFFTSxPQUFPMHFDLGFBQWFoMkIsY0FBY0M7UUFBb0IsR0FBRztZQUFFNVUsVUFBVSxPQUFPOEosV0FBVyxDQUFDdUosS0FBS3JQLEtBQUssQ0FBQyxLQUFLLGFBQWM4RixXQUFXLENBQUN1SixLQUFLclAsS0FBSyxDQUFDLENBQUM7Z0JBQ2xML0IsYUFBYUYsYUFBYTtnQkFDMUJzVSxZQUFZO1lBQ2hCLEtBQU96YixzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztnQkFBRW85QixTQUFTO2dCQUFhajlCLE9BQU9pQyxhQUFhO2dCQUFHaEMsUUFBUWdDLGFBQWE7WUFBRSxHQUFHO2dCQUFFL0IsVUFBVXBGLHNEQUFHQSxDQUFDLEtBQUs7b0JBQUVvRixVQUFVOEosV0FBVyxDQUFDdUosS0FBS3JQLEtBQUssQ0FBQztnQkFBQztZQUFHO1FBQUs7SUFBSSxNQUFPO0FBQ2pNO0FBRUEsTUFBTW1uQyxhQUFhLENBQUMsRUFBRW5uQyxLQUFLLEVBQUVsRSxLQUFLLEVBQUVzckMsY0FBYyxFQUFFQyxLQUFLLEVBQUc7SUFDeEQsTUFBTUMsY0FBY0YsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUlBLGlCQUFpQjNyQyxhQUFhLENBQUN1RSxNQUFNO0lBQ2hILE1BQU0sQ0FBQyxFQUFFa1ksT0FBTyxFQUFFN0YsVUFBVSxFQUFFLEVBQUVnbUIsTUFBTTlVLFlBQVksR0FBR2lHLFFBQVEsSUFBTztZQUNoRW5lLE1BQU07WUFDTmdFLE1BQU07Z0JBQ0YsT0FBTztvQkFBRXJQO29CQUFPdTVCLFNBQVM7b0JBQU0zN0IsSUFBSXlwQztnQkFBTTtZQUM3QztZQUNBcGxCLFNBQVMsQ0FBQzNRLFVBQWE7b0JBQ25CNEcsU0FBUztvQkFDVDdGLFlBQVksQ0FBQyxDQUFDZixRQUFRZSxVQUFVO2dCQUNwQztRQUNKLElBQUk7UUFBQ3JTO1FBQU9xbkM7S0FBTTtJQUNsQiwyQkFBMkI7SUFDM0I5akIsWUFBWWtVLGlCQUFpQjtRQUFFakMsc0JBQXNCO0lBQUs7SUFDMUQsT0FBUTUrQixzREFBR0EsQ0FBQyxPQUFPc0IsT0FBT3lELE1BQU0sQ0FBQztRQUFFa0osS0FBS3FULFVBQVVtZ0IsT0FBTztRQUFNLGNBQWNyNEI7UUFBTy9ELE9BQU87WUFBRW04QixRQUFRO1FBQU87SUFBRSxHQUFHO1FBQUVwOEIsVUFBVSxPQUFPc3JDLGdCQUFnQixhQUFjQSxZQUFZO1lBQ3RLcnBDLGFBQWFuQztZQUNidVc7UUFDSixLQUFPemIsc0RBQUdBLENBQUMsT0FBT3NCLE9BQU95RCxNQUFNLENBQUM7WUFBRW85QixTQUFTO1lBQWFqOUIsT0FBT0E7WUFBT0MsUUFBUUQ7UUFBTSxHQUFHO1lBQUVFLFVBQVVwRixzREFBR0EsQ0FBQyxLQUFLO2dCQUFFb0YsVUFBVXNyQztZQUFZO1FBQUc7SUFBSztBQUNwSjtBQUVBLE1BQU1DLDJCQUFhcndDLGlEQUFVQSxDQUFDLENBQUNpcUIsT0FBT3RjO0lBQ2xDLE1BQU0sRUFBRWtoQyxnQkFBZ0IsRUFBRUMsdUJBQXVCLEVBQUV3QixrQkFBa0IsRUFBRSxHQUFHcm1CLE9BQU9zbUIsYUFBYTV2QyxPQUFPc3BCLE9BQU87UUFBQztRQUFvQjtRQUEyQjtLQUFxQjtJQUNqTCxNQUFNLENBQUNwakIsWUFBWTJwQyxjQUFjLEdBQUczd0MsK0NBQVFBLENBQUNvcUIsTUFBTXBqQixVQUFVO0lBQzdELE1BQU04Z0MsV0FBVzFuQyw2Q0FBTUEsQ0FBQztJQUN4QixNQUFNd3dDLG9CQUFvQnh3Qyw2Q0FBTUEsQ0FBQztJQUNqQyxNQUFNLENBQUN5d0MsbUJBQW1CQyxxQkFBcUIsR0FBRzl3QywrQ0FBUUEsQ0FBQztRQUN2RHM1QixNQUFNO1FBQ05ELEtBQUs7SUFDVDtJQUNBLE1BQU0wWCxVQUFVcndDLDhDQUFPQSxDQUFDO1FBQVEsSUFBSWlQO1FBQUksT0FBTyxDQUFDQSxLQUFLbTRCLFNBQVNwM0IsT0FBTyxNQUFNLFFBQVFmLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRwQixxQkFBcUI7SUFBSSxHQUFHO1FBQUN1TyxTQUFTcDNCLE9BQU87S0FBQztJQUM3SnpRLGdEQUFTQSxDQUFDO1FBQ04rRyxjQUFleXBDLENBQUFBLHVCQUF1QixRQUFRQSx1QkFBdUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsbUJBQW1CenBDLFdBQVU7SUFDeEgsR0FBRztRQUFDQTtLQUFXO0lBQ2YvRyxnREFBU0EsQ0FBQztRQUNONndDLHFCQUFxQjtZQUNqQnhYLE1BQU0sQ0FBQ3lYLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRelgsSUFBSSxJQUFJeVgsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVF6WCxJQUFJLEdBQUc7WUFDMUlELEtBQUssQ0FBQzBYLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRMVgsR0FBRyxJQUFJMFgsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVExWCxHQUFHLEdBQUc7UUFDM0k7SUFDSixHQUFHO1FBQUMwWDtLQUFRO0lBQ1o5d0MsZ0RBQVNBLENBQUM7UUFDTixJQUFJMFA7UUFDSixJQUFJeWEsTUFBTXBqQixVQUFVLEtBQUtvRCxhQUFjLEVBQUN1RixLQUFLbTRCLFNBQVNwM0IsT0FBTyxNQUFNLFFBQVFmLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2dyQixXQUFXLEdBQUc7WUFDakgsTUFBTXFXLGlCQUFpQixJQUFJQyxlQUFlO2dCQUN0QyxJQUFJdGhDO2dCQUNKZ2hDLGNBQWMsQ0FBQ2hoQyxLQUFLbTRCLFNBQVNwM0IsT0FBTyxNQUFNLFFBQVFmLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2dyQixXQUFXO1lBQzdGO1lBQ0FxVyxlQUFlOXRCLE9BQU8sQ0FBQzRrQixTQUFTcDNCLE9BQU87WUFDdkMsT0FBTztnQkFDSHNnQyxlQUFldEQsVUFBVTtZQUM3QjtRQUNKO0lBQ0osR0FBRztRQUFDNUYsU0FBU3AzQixPQUFPO0tBQUM7SUFDckIsT0FBUTdRLHNEQUFHQSxDQUFDMm5DLGVBQWU7UUFBRXZpQyxVQUFVbkYsdURBQUlBLENBQUMsT0FBT3FCLE9BQU95RCxNQUFNLENBQUM7WUFBRWtKLEtBQUs4aUM7WUFBbUIxckMsT0FBTztnQkFDdEYrOEIsU0FBUztnQkFDVDJGLGVBQWU7Z0JBQ2Y3aUMsT0FBTztZQUNYO1FBQUUsR0FBRztZQUFFRSxVQUFVO2dCQUFDcEYsc0RBQUdBLENBQUMsT0FBTztvQkFBRWlPLEtBQUtnNkI7b0JBQVU1aUMsT0FBTzt3QkFBRUgsT0FBTztvQkFBTztnQkFBRTtnQkFBSWxGLHNEQUFHQSxDQUFDa3ZDLG1CQUFtQjV0QyxPQUFPeUQsTUFBTSxDQUFDO29CQUFFb3FDLGtCQUFrQkE7b0JBQWtCQyx5QkFBeUJBO2dCQUF3QixHQUFHO29CQUFFaHFDLFVBQVUrQixjQUFlbEgsdURBQUlBLENBQUNtTCxvQkFBb0I5SixPQUFPeUQsTUFBTSxDQUFDO3dCQUFFb0MsWUFBWUE7b0JBQVcsR0FBRzBwQyxZQUFZO3dCQUFFNWlDLEtBQUtBO29CQUFJLEdBQUc7d0JBQUU3SSxVQUFVOzRCQUFDcEYsc0RBQUdBLENBQUM0dkMsaUJBQWlCO2dDQUFFQyxnQkFBZ0JtQjs0QkFBa0I7NEJBQUloeEMsc0RBQUdBLENBQUNnb0MsT0FBTyxDQUFDO3lCQUFHO29CQUFDO2dCQUFLO2FBQUk7UUFBQztJQUFJO0FBQ3RiO0FBRXlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hlc3NtZW50b3IvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2hlc3Nib2FyZC9kaXN0L2luZGV4LmVzbS5qcz8xZjA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwganN4cywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0LCBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUNvbnRleHQsIG1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIGlzVmFsaWRFbGVtZW50LCBjbG9uZUVsZW1lbnQsIEZyYWdtZW50IGFzIEZyYWdtZW50JDEgfSBmcm9tICdyZWFjdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmNvbnN0IENPTFVNTlMgPSBcImFiY2RlZmdoXCIuc3BsaXQoXCJcIik7XHJcbmNvbnN0IFNUQVJUX1BPU0lUSU9OX09CSkVDVCA9IHtcclxuICAgIGE4OiBcImJSXCIsXHJcbiAgICBiODogXCJiTlwiLFxyXG4gICAgYzg6IFwiYkJcIixcclxuICAgIGQ4OiBcImJRXCIsXHJcbiAgICBlODogXCJiS1wiLFxyXG4gICAgZjg6IFwiYkJcIixcclxuICAgIGc4OiBcImJOXCIsXHJcbiAgICBoODogXCJiUlwiLFxyXG4gICAgYTc6IFwiYlBcIixcclxuICAgIGI3OiBcImJQXCIsXHJcbiAgICBjNzogXCJiUFwiLFxyXG4gICAgZDc6IFwiYlBcIixcclxuICAgIGU3OiBcImJQXCIsXHJcbiAgICBmNzogXCJiUFwiLFxyXG4gICAgZzc6IFwiYlBcIixcclxuICAgIGg3OiBcImJQXCIsXHJcbiAgICBhMjogXCJ3UFwiLFxyXG4gICAgYjI6IFwid1BcIixcclxuICAgIGMyOiBcIndQXCIsXHJcbiAgICBkMjogXCJ3UFwiLFxyXG4gICAgZTI6IFwid1BcIixcclxuICAgIGYyOiBcIndQXCIsXHJcbiAgICBnMjogXCJ3UFwiLFxyXG4gICAgaDI6IFwid1BcIixcclxuICAgIGExOiBcIndSXCIsXHJcbiAgICBiMTogXCJ3TlwiLFxyXG4gICAgYzE6IFwid0JcIixcclxuICAgIGQxOiBcIndRXCIsXHJcbiAgICBlMTogXCJ3S1wiLFxyXG4gICAgZjE6IFwid0JcIixcclxuICAgIGcxOiBcIndOXCIsXHJcbiAgICBoMTogXCJ3UlwiLFxyXG59O1xyXG5jb25zdCBXSElURV9DT0xVTU5fVkFMVUVTID0ge1xyXG4gICAgYTogMCxcclxuICAgIGI6IDEsXHJcbiAgICBjOiAyLFxyXG4gICAgZDogMyxcclxuICAgIGU6IDQsXHJcbiAgICBmOiA1LFxyXG4gICAgZzogNixcclxuICAgIGg6IDcsXHJcbn07XHJcbmNvbnN0IEJMQUNLX0NPTFVNTl9WQUxVRVMgPSB7XHJcbiAgICBhOiA3LFxyXG4gICAgYjogNixcclxuICAgIGM6IDUsXHJcbiAgICBkOiA0LFxyXG4gICAgZTogMyxcclxuICAgIGY6IDIsXHJcbiAgICBnOiAxLFxyXG4gICAgaDogMCxcclxufTtcclxuY29uc3QgV0hJVEVfUk9XUyA9IFs3LCA2LCA1LCA0LCAzLCAyLCAxLCAwXTtcclxuY29uc3QgQkxBQ0tfUk9XUyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3XTtcblxuLy8gaHR0cHM6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvd2lraS9DYXRlZ29yeTpTVkdfY2hlc3NfcGllY2VzXHJcbi8vIEJ5IGVuOlVzZXI6Q2J1cm5ldHQgLSBPd24gd29ya1xyXG4vLyBUaGlzIFczQyAtIHVuc3BlY2lmaWVkIHZlY3RvciBpbWFnZSB3YXMgY3JlYXRlZCB3aXRoIElua3NjYXBlLiwgQ0MgQlkgLSBTQSAzLjAsIGh0dHBzOi8vY29tbW9ucy53aWtpbWVkaWEub3JnL3cvaW5kZXgucGhwP2N1cmlkPTE0OTk4MTBcclxuY29uc3QgZGVmYXVsdFBpZWNlcyA9IHtcclxuICAgIHdQOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSkgfSkpKSxcclxuICAgIHdSOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwzOSBMIDM2LDM5IEwgMzYsMzYgTCA5LDM2IEwgOSwzOSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLDM2IEwgMTIsMzIgTCAzMywzMiBMIDMzLDM2IEwgMTIsMzYgeiBcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDExLDkgTCAxNSw5IEwgMTUsMTEgTCAyMCwxMSBMIDIwLDkgTCAyNSw5IEwgMjUsMTEgTCAzMCwxMSBMIDMwLDkgTCAzNCw5IEwgMzQsMTRcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAzNCwxNCBMIDMxLDE3IEwgMTQsMTcgTCAxMSwxNFwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMxLDE3IEwgMzEsMjkuNSBMIDE0LDI5LjUgTCAxNCwxN1wiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMxLDI5LjUgTCAzMi41LDMyIEwgMTIuNSwzMiBMIDE0LDI5LjVcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDM0LDE0XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgd046IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMiwxMCBDIDMyLjUsMTEgMzguNSwxOCAzOCwzOSBMIDE1LDM5IEMgMTUsMzAgMjUsMzIuNSAyMywxOFwiLCBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMFwiLCBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDkuNSAyNS41IEEgMC41IDAuNSAwIDEgMSA4LjUsMjUuNSBBIDAuNSAwLjUgMCAxIDEgOS41IDI1LjUgelwiLCBzdHlsZTogeyBmaWxsOiBcIiMwMDAwMDBcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE1IDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNCwxNS41IEEgMC41IDEuNSAwIDEgMSAgMTUgMTUuNSB6XCIsIHRyYW5zZm9ybTogXCJtYXRyaXgoMC44NjYsMC41LC0wLjUsMC44NjYsOS42OTMsLTUuMTczKVwiLCBzdHlsZTogeyBmaWxsOiBcIiMwMDAwMDBcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIHdCOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDM2IEMgMTIuMzksMzUuMDMgMTkuMTEsMzYuNDMgMjIuNSwzNCBDIDI1Ljg5LDM2LjQzIDMyLjYxLDM1LjAzIDM2LDM2IEMgMzYsMzYgMzcuNjUsMzYuNTQgMzksMzggQyAzOC4zMiwzOC45NyAzNy4zNSwzOC45OSAzNiwzOC41IEMgMzIuNjEsMzcuNTMgMjUuODksMzguOTYgMjIuNSwzNy41IEMgMTkuMTEsMzguOTYgMTIuMzksMzcuNTMgOSwzOC41IEMgNy42NSwzOC45OSA2LjY4LDM4Ljk3IDYsMzggQyA3LjM1LDM2LjU0IDksMzYgOSwzNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUsMzIgQyAxNy41LDM0LjUgMjcuNSwzNC41IDMwLDMyIEMgMzAuNSwzMC41IDMwLDMwIDMwLDMwIEMgMzAsMjcuNSAyNy41LDI2IDI3LjUsMjYgQyAzMywyNC41IDMzLjUsMTQuNSAyMi41LDEwLjUgQyAxMS41LDE0LjUgMTIsMjQuNSAxNy41LDI2IEMgMTcuNSwyNiAxNSwyNy41IDE1LDMwIEMgMTUsMzAgMTQuNSwzMC41IDE1LDMyIHpcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyNSA4IEEgMi41IDIuNSAwIDEgMSAgMjAsOCBBIDIuNSAyLjUgMCAxIDEgIDI1IDggelwiIH0pXSB9KSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTcuNSwyNiBMIDI3LjUsMjYgTSAxNSwzMCBMIDMwLDMwIE0gMjIuNSwxNS41IEwgMjIuNSwyMC41IE0gMjAsMTggTCAyNSwxOFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIHdROiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDI2IEMgMTcuNSwyNC41IDMwLDI0LjUgMzYsMjYgTCAzOC41LDEzLjUgTCAzMSwyNSBMIDMwLjcsMTAuOSBMIDI1LjUsMjQuNSBMIDIyLjUsMTAgTCAxOS41LDI0LjUgTCAxNC4zLDEwLjkgTCAxNCwyNSBMIDYuNSwxMy41IEwgOSwyNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwyNiBDIDksMjggMTAuNSwyOCAxMS41LDMwIEMgMTIuNSwzMS41IDEyLjUsMzEgMTIsMzMuNSBDIDEwLjUsMzQuNSAxMSwzNiAxMSwzNiBDIDkuNSwzNy41IDExLDM4LjUgMTEsMzguNSBDIDE3LjUsMzkuNSAyNy41LDM5LjUgMzQsMzguNSBDIDM0LDM4LjUgMzUuNSwzNy41IDM0LDM2IEMgMzQsMzYgMzQuNSwzNC41IDMzLDMzLjUgQyAzMi41LDMxIDMyLjUsMzEuNSAzMy41LDMwIEMgMzQuNSwyOCAzNiwyOCAzNiwyNiBDIDI3LjUsMjQuNSAxNy41LDI0LjUgOSwyNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEuNSwzMCBDIDE1LDI5IDMwLDI5IDMzLjUsMzBcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMiwzMy41IEMgMTgsMzIuNSAyNywzMi41IDMzLDMzLjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIgfSB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiNlwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMTRcIiwgY3k6IFwiOVwiLCByOiBcIjJcIiB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMjIuNVwiLCBjeTogXCI4XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzMVwiLCBjeTogXCI5XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzOVwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KV0gfSkpIH0pKSksXHJcbiAgICB3SzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDExLjYzIEwgMjIuNSw2XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjAsOCBMIDI1LDhcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIsIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDI1IEMgMjIuNSwyNSAyNywxNy41IDI1LjUsMTQuNSBDIDI1LjUsMTQuNSAyNC41LDEyIDIyLjUsMTIgQyAyMC41LDEyIDE5LjUsMTQuNSAxOS41LDE0LjUgQyAxOCwxNy41IDIyLjUsMjUgMjIuNSwyNVwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIiNmZmZmZmZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsNDAuNSAyNyw0MC41IDMyLjUsMzcgTCAzMi41LDMwIEMgMzIuNSwzMCA0MS41LDI1LjUgMzguNSwxOS41IEMgMzQuNSwxMyAyNSwxNiAyMi41LDIzLjUgTCAyMi41LDI3IEwgMjIuNSwyMy41IEMgMjAsMTYgMTAuNSwxMyA2LjUsMTkuNSBDIDMuNSwyNS41IDEyLjUsMzAgMTIuNSwzMCBMIDEyLjUsMzdcIiwgc3R5bGU6IHsgZmlsbDogXCIjZmZmZmZmXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIGJQOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSkgfSkpKSxcclxuICAgIGJSOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwzOSBMIDM2LDM5IEwgMzYsMzYgTCA5LDM2IEwgOSwzOSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzIgTCAxNCwyOS41IEwgMzEsMjkuNSBMIDMyLjUsMzIgTCAxMi41LDMyIHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIsMzYgTCAxMiwzMiBMIDMzLDMyIEwgMzMsMzYgTCAxMiwzNiB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE0LDI5LjUgTCAxNCwxNi41IEwgMzEsMTYuNSBMIDMxLDI5LjUgTCAxNCwyOS41IHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMTYuNSBMIDExLDE0IEwgMzQsMTQgTCAzMSwxNi41IEwgMTQsMTYuNSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLDE0IEwgMTEsOSBMIDE1LDkgTCAxNSwxMSBMIDIwLDExIEwgMjAsOSBMIDI1LDkgTCAyNSwxMSBMIDMwLDExIEwgMzAsOSBMIDM0LDkgTCAzNCwxNCBMIDExLDE0IHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIsMzUuNSBMIDMzLDM1LjUgTCAzMywzNS41XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMywzMS41IEwgMzIsMzEuNVwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiNmZmZmZmZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMjkuNSBMIDMxLDI5LjVcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE0LDE2LjUgTCAzMSwxNi41XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDM0LDE0XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KV0gfSkpIH0pKSksXHJcbiAgICBiTjogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU1pdGVybGltaXQ6IFwiNFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4XCIsIHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjQsMTggQyAyNC4zOCwyMC45MSAxOC40NSwyNS4zNyAxNiwyNyBDIDEzLDI5IDEzLjE4LDMxLjM0IDExLDMxIEMgOS45NTgsMzAuMDYgMTIuNDEsMjcuOTYgMTEsMjggQyAxMCwyOCAxMS4xOSwyOS4yMyAxMCwzMCBDIDksMzAgNS45OTcsMzEgNiwyNiBDIDYsMjQgMTIsMTQgMTIsMTQgQyAxMiwxNCAxMy44OSwxMi4xIDE0LDEwLjUgQyAxMy4yNyw5LjUwNiAxMy41LDguNSAxMy41LDcuNSBDIDE0LjUsNi41IDE2LjUsMTAgMTYuNSwxMCBMIDE4LjUsMTAgQyAxOC41LDEwIDE5LjI4LDguMDA4IDIxLDcgQyAyMiw3IDIyLDEwIDIyLDEwXCIsIHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gOS41IDI1LjUgQSAwLjUgMC41IDAgMSAxIDguNSwyNS41IEEgMC41IDAuNSAwIDEgMSA5LjUgMjUuNSB6XCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHpcIiwgdHJhbnNmb3JtOiBcIm1hdHJpeCgwLjg2NiwwLjUsLTAuNSwwLjg2Niw5LjY5MywtNS4xNzMpXCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogXCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwibm9uZVwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgYkI6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMzYgQyAxMi4zOSwzNS4wMyAxOS4xMSwzNi40MyAyMi41LDM0IEMgMjUuODksMzYuNDMgMzIuNjEsMzUuMDMgMzYsMzYgQyAzNiwzNiAzNy42NSwzNi41NCAzOSwzOCBDIDM4LjMyLDM4Ljk3IDM3LjM1LDM4Ljk5IDM2LDM4LjUgQyAzMi42MSwzNy41MyAyNS44OSwzOC45NiAyMi41LDM3LjUgQyAxOS4xMSwzOC45NiAxMi4zOSwzNy41MyA5LDM4LjUgQyA3LjY1LDM4Ljk5IDYuNjgsMzguOTcgNiwzOCBDIDcuMzUsMzYuNTQgOSwzNiA5LDM2IHpcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNSwzMiBDIDE3LjUsMzQuNSAyNy41LDM0LjUgMzAsMzIgQyAzMC41LDMwLjUgMzAsMzAgMzAsMzAgQyAzMCwyNy41IDI3LjUsMjYgMjcuNSwyNiBDIDMzLDI0LjUgMzMuNSwxNC41IDIyLjUsMTAuNSBDIDExLjUsMTQuNSAxMiwyNC41IDE3LjUsMjYgQyAxNy41LDI2IDE1LDI3LjUgMTUsMzAgQyAxNSwzMCAxNC41LDMwLjUgMTUsMzIgelwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDI1IDggQSAyLjUgMi41IDAgMSAxICAyMCw4IEEgMi41IDIuNSAwIDEgMSAgMjUgOCB6XCIgfSldIH0pKSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNy41LDI2IEwgMjcuNSwyNiBNIDE1LDMwIEwgMzAsMzAgTSAyMi41LDE1LjUgTCAyMi41LDIwLjUgTSAyMCwxOCBMIDI1LDE4XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgYlE6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMjYgQyAxNy41LDI0LjUgMzAsMjQuNSAzNiwyNiBMIDM4LjUsMTMuNSBMIDMxLDI1IEwgMzAuNywxMC45IEwgMjUuNSwyNC41IEwgMjIuNSwxMCBMIDE5LjUsMjQuNSBMIDE0LjMsMTAuOSBMIDE0LDI1IEwgNi41LDEzLjUgTCA5LDI2IHpcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsIGZpbGw6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIm0gOSwyNiBjIDAsMiAxLjUsMiAyLjUsNCAxLDEuNSAxLDEgMC41LDMuNSAtMS41LDEgLTEsMi41IC0xLDIuNSAtMS41LDEuNSAwLDIuNSAwLDIuNSA2LjUsMSAxNi41LDEgMjMsMCAwLDAgMS41LC0xIDAsLTIuNSAwLDAgMC41LC0xLjUgLTEsLTIuNSAtMC41LC0yLjUgLTAuNSwtMiAwLjUsLTMuNSAxLC0yIDIuNSwtMiAyLjUsLTQgLTguNSwtMS41IC0xOC41LC0xLjUgLTI3LDAgelwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLjUsMzAgQyAxNSwyOSAzMCwyOSAzMy41LDMwXCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIm0gMTIsMzMuNSBjIDYsLTEgMTUsLTEgMjEsMFwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCI2XCIsIGN5OiBcIjEyXCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIxNFwiLCBjeTogXCI5XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIyMi41XCIsIGN5OiBcIjhcIiwgcjogXCIyXCIgfSksIGpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjMxXCIsIGN5OiBcIjlcIiwgcjogXCIyXCIgfSksIGpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjM5XCIsIGN5OiBcIjEyXCIsIHI6IFwiMlwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLDM4LjUgQSAzNSwzNSAxIDAgMCAzNCwzOC41XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjZmZmZmZmXCIgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwyOSBBIDM1LDM1IDEgMCAxIDM0LDI5XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIuNSwzMS41IEwgMzIuNSwzMS41XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEuNSwzNC41IEEgMzUsMzUgMSAwIDAgMzMuNSwzNC41XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTAuNSwzNy41IEEgMzUsMzUgMSAwIDAgMzQuNSwzNy41XCIgfSldIH0pKV0gfSkpIH0pKSksXHJcbiAgICBiSzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDExLjYzIEwgMjIuNSw2XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0sIGlkOiBcInBhdGg2NTcwXCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjIuNSwyNSBDIDIyLjUsMjUgMjcsMTcuNSAyNS41LDE0LjUgQyAyNS41LDE0LjUgMjQuNSwxMiAyMi41LDEyIEMgMjAuNSwxMiAxOS41LDE0LjUgMTkuNSwxNC41IEMgMTgsMTcuNSAyMi41LDI1IDIyLjUsMjVcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsNDAuNSAyNyw0MC41IDMyLjUsMzcgTCAzMi41LDMwIEMgMzIuNSwzMCA0MS41LDI1LjUgMzguNSwxOS41IEMgMzQuNSwxMyAyNSwxNiAyMi41LDIzLjUgTCAyMi41LDI3IEwgMjIuNSwyMy41IEMgMjAsMTYgMTAuNSwxMyA2LjUsMTkuNSBDIDMuNSwyNS41IDEyLjUsMzAgMTIuNSwzMCBMIDEyLjUsMzdcIiwgc3R5bGU6IHsgZmlsbDogXCIjMDAwMDAwXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMCw4IEwgMjUsOFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMyLDI5LjUgQyAzMiwyOS41IDQwLjUsMjUuNSAzOC4wMywxOS44NSBDIDM0LjE1LDE0IDI1LDE4IDIyLjUsMjQuNSBMIDIyLjUsMjYuNiBMIDIyLjUsMjQuNSBDIDIwLDE4IDEwLjg1LDE0IDYuOTcsMTkuODUgQyA0LjUsMjUuNSAxMywyOS41IDEzLDI5LjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjZmZmZmZmXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMCBNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjUgTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiNmZmZmZmZcIiB9IH0pXSB9KSkgfSkpKSxcclxufTtcblxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgY29vcmRpbmF0ZXMgYXQgdGhlIGNlbnRyZSBvZiB0aGUgcmVxdWVzdGVkIHNxdWFyZSwgcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IG9mIHRoZSBib2FyZCAoMCwgMCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBzcXVhcmUpIHtcclxuICAgIGNvbnN0IHNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDg7XHJcbiAgICBjb25zdCBjb2x1bW5zID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiID8gV0hJVEVfQ09MVU1OX1ZBTFVFUyA6IEJMQUNLX0NPTFVNTl9WQUxVRVM7XHJcbiAgICBjb25zdCByb3dzID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiID8gV0hJVEVfUk9XUyA6IEJMQUNLX1JPV1M7XHJcbiAgICBjb25zdCB4ID0gY29sdW1uc1tzcXVhcmVbMF1dICogc3F1YXJlV2lkdGggKyBzcXVhcmVXaWR0aCAvIDI7XHJcbiAgICBjb25zdCB5ID0gcm93c1twYXJzZUludChzcXVhcmVbMV0sIDEwKSAtIDFdICogc3F1YXJlV2lkdGggKyBzcXVhcmVXaWR0aCAvIDI7XHJcbiAgICByZXR1cm4geyB4LCB5IH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGFzc2VkIHBvc2l0aW9uIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBzdGFydCBwb3NpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGlzRGlmZmVyZW50RnJvbVN0YXJ0KG5ld1Bvc2l0aW9uKSB7XHJcbiAgICBsZXQgaXNEaWZmZXJlbnQgPSBmYWxzZTtcclxuICAgIE9iamVjdC5rZXlzKFNUQVJUX1BPU0lUSU9OX09CSkVDVCkuZm9yRWFjaCgoc3F1YXJlKSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1Bvc2l0aW9uW3NxdWFyZV0gIT09IFNUQVJUX1BPU0lUSU9OX09CSkVDVFtzcXVhcmVdKVxyXG4gICAgICAgICAgICBpc0RpZmZlcmVudCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5rZXlzKG5ld1Bvc2l0aW9uKS5mb3JFYWNoKChzcXVhcmUpID0+IHtcclxuICAgICAgICBpZiAoU1RBUlRfUE9TSVRJT05fT0JKRUNUW3NxdWFyZV0gIT09IG5ld1Bvc2l0aW9uW3NxdWFyZV0pXHJcbiAgICAgICAgICAgIGlzRGlmZmVyZW50ID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGlzRGlmZmVyZW50O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoYXQgcGllY2VzIGhhdmUgYmVlbiBhZGRlZCBhbmQgd2hhdCBwaWVjZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYmV0d2VlbiBib2FyZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkRpZmZlcmVuY2VzKGN1cnJlbnRQb3NpdGlvbiwgbmV3UG9zaXRpb24pIHtcclxuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB7XHJcbiAgICAgICAgcmVtb3ZlZDoge30sXHJcbiAgICAgICAgYWRkZWQ6IHt9LFxyXG4gICAgfTtcclxuICAgIC8vIHJlbW92ZWQgZnJvbSBjdXJyZW50XHJcbiAgICBPYmplY3Qua2V5cyhjdXJyZW50UG9zaXRpb24pLmZvckVhY2goKHNxdWFyZSkgPT4ge1xyXG4gICAgICAgIGlmIChuZXdQb3NpdGlvbltzcXVhcmVdICE9PSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSlcclxuICAgICAgICAgICAgZGlmZmVyZW5jZS5yZW1vdmVkW3NxdWFyZV0gPSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXTtcclxuICAgIH0pO1xyXG4gICAgLy8gYWRkZWQgZnJvbSBuZXdcclxuICAgIE9iamVjdC5rZXlzKG5ld1Bvc2l0aW9uKS5mb3JFYWNoKChzcXVhcmUpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uW3NxdWFyZV0gIT09IG5ld1Bvc2l0aW9uW3NxdWFyZV0pXHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UuYWRkZWRbc3F1YXJlXSA9IG5ld1Bvc2l0aW9uW3NxdWFyZV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGZlbiBzdHJpbmcgb3IgZXhpc3RpbmcgcG9zaXRpb24gb2JqZWN0IHRvIGEgcG9zaXRpb24gb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFBvc2l0aW9uVG9PYmplY3QocG9zaXRpb24pIHtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFNUQVJUX1BPU0lUSU9OX09CSkVDVDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAvLyBhdHRlbXB0IHRvIGNvbnZlcnQgZmVuIHRvIHBvc2l0aW9uIG9iamVjdFxyXG4gICAgICAgIHJldHVybiBmZW5Ub09iaihwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgZmVuIHN0cmluZyB0byBhIHBvc2l0aW9uIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGZlblRvT2JqKGZlbikge1xyXG4gICAgaWYgKCFpc1ZhbGlkRmVuKGZlbikpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgLy8gY3V0IG9mZiBhbnkgbW92ZSwgY2FzdGxpbmcsIGV0YyBpbmZvIGZyb20gdGhlIGVuZC4gd2UncmUgb25seSBpbnRlcmVzdGVkIGluIHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICBmZW4gPSBmZW4ucmVwbGFjZSgvIC4rJC8sIFwiXCIpO1xyXG4gICAgY29uc3Qgcm93cyA9IGZlbi5zcGxpdChcIi9cIik7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xyXG4gICAgbGV0IGN1cnJlbnRSb3cgPSA4O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcclxuICAgICAgICBjb25zdCByb3cgPSByb3dzW2ldLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgIGxldCBjb2xJZHggPSAwO1xyXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiB0aGUgRkVOIHNlY3Rpb25cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAvLyBudW1iZXIgLyBlbXB0eSBzcXVhcmVzXHJcbiAgICAgICAgICAgIGlmIChyb3dbal0uc2VhcmNoKC9bMS04XS8pICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRW1wdHlTcXVhcmVzID0gcGFyc2VJbnQocm93W2pdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBjb2xJZHggPSBjb2xJZHggKyBudW1FbXB0eVNxdWFyZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwaWVjZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gQ09MVU1OU1tjb2xJZHhdICsgY3VycmVudFJvdztcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uW3NxdWFyZV0gPSBmZW5Ub1BpZWNlQ29kZShyb3dbal0pO1xyXG4gICAgICAgICAgICAgICAgY29sSWR4ID0gY29sSWR4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Um93ID0gY3VycmVudFJvdyAtIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBzdHJpbmcgaXMgdmFsaWQgZmVuIG5vdGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZEZlbihmZW4pIHtcclxuICAgIC8vIGN1dCBvZmYgYW55IG1vdmUsIGNhc3RsaW5nLCBldGMgaW5mbyBmcm9tIHRoZSBlbmQuIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgZmVuID0gZmVuLnJlcGxhY2UoLyAuKyQvLCBcIlwiKTtcclxuICAgIC8vIGV4cGFuZCB0aGUgZW1wdHkgc3F1YXJlIG51bWJlcnMgdG8ganVzdCAxc1xyXG4gICAgZmVuID0gZXhwYW5kRmVuRW1wdHlTcXVhcmVzKGZlbik7XHJcbiAgICAvLyBmZW4gc2hvdWxkIGJlIDggc2VjdGlvbnMgc2VwYXJhdGVkIGJ5IHNsYXNoZXNcclxuICAgIGNvbnN0IGNodW5rcyA9IGZlbi5zcGxpdChcIi9cIik7XHJcbiAgICBpZiAoY2h1bmtzLmxlbmd0aCAhPT0gOClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBjaGVjayBlYWNoIHNlY3Rpb25cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGNodW5rc1tpXS5sZW5ndGggIT09IDggfHwgY2h1bmtzW2ldLnNlYXJjaCgvW15rcXJuYnBLUVJOQlAxXS8pICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEV4cGFuZCBvdXQgZmVuIG5vdGF0aW9uIHRvIGNvdW50YWJsZSBjaGFyYWN0ZXJzIGZvciB2YWxpZGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBleHBhbmRGZW5FbXB0eVNxdWFyZXMoZmVuKSB7XHJcbiAgICByZXR1cm4gZmVuXHJcbiAgICAgICAgLnJlcGxhY2UoLzgvZywgXCIxMTExMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC83L2csIFwiMTExMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC82L2csIFwiMTExMTExXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoLzUvZywgXCIxMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC80L2csIFwiMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC8zL2csIFwiMTExXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoLzIvZywgXCIxMVwiKTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBmZW4gcGllY2UgY29kZSB0byBjYW1lbCBjYXNlIG5vdGF0aW9uLiBlLmcuIGJQLCB3Sy5cclxuICovXHJcbmZ1bmN0aW9uIGZlblRvUGllY2VDb2RlKHBpZWNlKSB7XHJcbiAgICAvLyBibGFjayBwaWVjZVxyXG4gICAgaWYgKHBpZWNlLnRvTG93ZXJDYXNlKCkgPT09IHBpZWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIChcImJcIiArIHBpZWNlLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgfVxyXG4gICAgLy8gd2hpdGUgcGllY2VcclxuICAgIHJldHVybiAoXCJ3XCIgKyBwaWVjZS50b1VwcGVyQ2FzZSgpKTtcclxufVxuXG5jb25zdCB1c2VBcnJvd3MgPSAoY3VzdG9tQXJyb3dzLCBhcmVBcnJvd3NBbGxvd2VkID0gdHJ1ZSwgb25BcnJvd3NDaGFuZ2UsIGN1c3RvbUFycm93Q29sb3IpID0+IHtcclxuICAgIC8vIGFycm93cyBwYXNzZWQgcHJvZ3JhbWF0aWNhbGx5IHRvIGBDaGVzc0JvYXJkYCBhcyBhIHJlYWN0IHByb3BcclxuICAgIGNvbnN0IFtjdXN0b21BcnJvd3NTZXQsIHNldEN1c3RvbUFycm93c10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgICAvLyBhcnJvd3MgZHJhd24gd2l0aCBtb3VzZSBieSB1c2VyIG9uIHRoZSBib2FyZFxyXG4gICAgY29uc3QgW2Fycm93cywgc2V0QXJyb3dzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIC8vIGFjdGl2ZSBhcnJvdyB3aGljaCB1c2VyIGRyYXdzIHdoaWxlIGRyYWdnaW5nIG1vdXNlXHJcbiAgICBjb25zdCBbbmV3QXJyb3csIHNldE5ld0Fycm93XSA9IHVzZVN0YXRlKCk7XHJcbiAgICAvLyBoYW5kbGUgZXh0ZXJuYWwgYGN1c3RvbUFycm93c2AgcHJvcHMgY2hhbmdlc1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21BcnJvd3MpKSB7XHJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgY3VzdG9tIGFycm93cyBvdmVyd3JpdGUgdGVtcG9yYXJ5IGFycm93c1xyXG4gICAgICAgICAgICBjbGVhckFycm93cygpO1xyXG4gICAgICAgICAgICBzZXRDdXN0b21BcnJvd3MoXHJcbiAgICAgICAgICAgIC8vZmlsdGVyIG91dCBhcnJvd3Mgd2hpY2ggc3RhcnRzIGFuZCBlbmRzIGluIHRoZSBzYW1lIHNxdWFyZVxyXG4gICAgICAgICAgICBjdXN0b21BcnJvd3MgPT09IG51bGwgfHwgY3VzdG9tQXJyb3dzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21BcnJvd3MuZmlsdGVyKChhcnJvdykgPT4gYXJyb3dbMF0gIT09IGFycm93WzFdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1c3RvbUFycm93c10pO1xyXG4gICAgLy8gY2FsbGJhY2sgd2hlbiBhcnJvd3MgY2hhbmdlZCBhZnRlciB1c2VyIGludGVyYWN0aW9uXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIG9uQXJyb3dzQ2hhbmdlID09PSBudWxsIHx8IG9uQXJyb3dzQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkFycm93c0NoYW5nZShhcnJvd3MpO1xyXG4gICAgfSwgW2Fycm93c10pO1xyXG4gICAgLy8gZnVuY3Rpb24gY2xlYXJzIGFsbCBhcnJvd3MgZHJhd2VkIGJ5IHVzZXJcclxuICAgIGZ1bmN0aW9uIGNsZWFyQXJyb3dzKCkge1xyXG4gICAgICAgIHNldEFycm93cyhbXSk7XHJcbiAgICAgICAgc2V0TmV3QXJyb3codW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRyYXdOZXdBcnJvdyA9IChmcm9tU3F1YXJlLCB0b1NxdWFyZSkgPT4ge1xyXG4gICAgICAgIGlmICghYXJlQXJyb3dzQWxsb3dlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHNldE5ld0Fycm93KFtmcm9tU3F1YXJlLCB0b1NxdWFyZSwgY3VzdG9tQXJyb3dDb2xvcl0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGFsbEJvYXJkQXJyb3dzID0gWy4uLmFycm93cywgLi4uY3VzdG9tQXJyb3dzU2V0XTtcclxuICAgIGNvbnN0IG9uQXJyb3dEcmF3RW5kID0gKGZyb21TcXVhcmUsIHRvU3F1YXJlKSA9PiB7XHJcbiAgICAgICAgaWYgKGZyb21TcXVhcmUgPT09IHRvU3F1YXJlIHx8ICFhcmVBcnJvd3NBbGxvd2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGFycm93c0NvcHk7XHJcbiAgICAgICAgY29uc3QgbmV3QXJyb3cgPSBbZnJvbVNxdWFyZSwgdG9TcXVhcmUsIGN1c3RvbUFycm93Q29sb3JdO1xyXG4gICAgICAgIGNvbnN0IGlzTmV3QXJyb3dVbmlxdWUgPSBhbGxCb2FyZEFycm93cy5ldmVyeSgoW2Fycm93RnJvbSwgYXJyb3dUb10pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuICEoYXJyb3dGcm9tID09PSBmcm9tU3F1YXJlICYmIGFycm93VG8gPT09IHRvU3F1YXJlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBhZGQgdGhlIG5ld0Fycm93IHRvIGFycm93cyBhcnJheSBpZiBpdCBpcyB1bmlxdWVcclxuICAgICAgICBpZiAoaXNOZXdBcnJvd1VuaXF1ZSkge1xyXG4gICAgICAgICAgICBhcnJvd3NDb3B5ID0gWy4uLmFycm93cywgbmV3QXJyb3ddO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgYm9hcmQgaWYgd2UgYWxyZWFkeSBoYXZlIHNhbWUgYXJyb3cgaW4gYXJyb3dzIGFycmF5XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFycm93c0NvcHkgPSBhcnJvd3MuZmlsdGVyKChbYXJyb3dGcm9tLCBhcnJvd1RvXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoYXJyb3dGcm9tID09PSBmcm9tU3F1YXJlICYmIGFycm93VG8gPT09IHRvU3F1YXJlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE5ld0Fycm93KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgc2V0QXJyb3dzKGFycm93c0NvcHkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXJyb3dzOiBhbGxCb2FyZEFycm93cyxcclxuICAgICAgICBuZXdBcnJvdyxcclxuICAgICAgICBjbGVhckFycm93cyxcclxuICAgICAgICBkcmF3TmV3QXJyb3csXHJcbiAgICAgICAgc2V0QXJyb3dzLFxyXG4gICAgICAgIG9uQXJyb3dEcmF3RW5kLFxyXG4gICAgfTtcclxufTtcblxuY29uc3QgQ2hlc3Nib2FyZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcclxuY29uc3QgdXNlQ2hlc3Nib2FyZCA9ICgpID0+IHVzZUNvbnRleHQoQ2hlc3Nib2FyZENvbnRleHQpO1xyXG5jb25zdCBDaGVzc2JvYXJkUHJvdmlkZXIgPSBmb3J3YXJkUmVmKCh7IGFsbG93RHJhZ091dHNpZGVCb2FyZCA9IHRydWUsIGFuaW1hdGlvbkR1cmF0aW9uID0gMzAwLCBhcmVBcnJvd3NBbGxvd2VkID0gdHJ1ZSwgYXJlUGllY2VzRHJhZ2dhYmxlID0gdHJ1ZSwgYXJlUHJlbW92ZXNBbGxvd2VkID0gZmFsc2UsIGF1dG9Qcm9tb3RlVG9RdWVlbiA9IGZhbHNlLCBib2FyZE9yaWVudGF0aW9uID0gXCJ3aGl0ZVwiLCBib2FyZFdpZHRoLCBjaGlsZHJlbiwgY2xlYXJQcmVtb3Zlc09uUmlnaHRDbGljayA9IHRydWUsIGN1c3RvbUFycm93cywgY3VzdG9tQXJyb3dDb2xvciA9IFwicmdiKDI1NSwxNzAsMClcIiwgY3VzdG9tQm9hcmRTdHlsZSwgY3VzdG9tTm90YXRpb25TdHlsZSwgY3VzdG9tRGFya1NxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0I1ODg2M1wiIH0sIGN1c3RvbURyb3BTcXVhcmVTdHlsZSA9IHtcclxuICAgIGJveFNoYWRvdzogXCJpbnNldCAwIDAgMXB4IDZweCByZ2JhKDI1NSwyNTUsMjU1LDAuNzUpXCIsXHJcbn0sIGN1c3RvbUxpZ2h0U3F1YXJlU3R5bGUgPSB7IGJhY2tncm91bmRDb2xvcjogXCIjRjBEOUI1XCIgfSwgY3VzdG9tUGllY2VzLCBjdXN0b21QcmVtb3ZlRGFya1NxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0E0MjMyM1wiIH0sIGN1c3RvbVByZW1vdmVMaWdodFNxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0JEMjgyOFwiIH0sIGN1c3RvbVNxdWFyZSA9IFwiZGl2XCIsIGN1c3RvbVNxdWFyZVN0eWxlcywgZHJvcE9mZkJvYXJkQWN0aW9uID0gXCJzbmFwYmFja1wiLCBpZCA9IDAsIGlzRHJhZ2dhYmxlUGllY2UgPSAoKSA9PiB0cnVlLCBnZXRQb3NpdGlvbk9iamVjdCA9ICgpID0+IHsgfSwgb25BcnJvd3NDaGFuZ2UgPSAoKSA9PiB7IH0sIG9uRHJhZ092ZXJTcXVhcmUgPSAoKSA9PiB7IH0sIG9uTW91c2VPdXRTcXVhcmUgPSAoKSA9PiB7IH0sIG9uTW91c2VPdmVyU3F1YXJlID0gKCkgPT4geyB9LCBvblBpZWNlQ2xpY2sgPSAoKSA9PiB7IH0sIG9uUGllY2VEcmFnQmVnaW4gPSAoKSA9PiB7IH0sIG9uUGllY2VEcmFnRW5kID0gKCkgPT4geyB9LCBvblBpZWNlRHJvcCA9ICgpID0+IHRydWUsIG9uUGllY2VEcm9wT2ZmQm9hcmQgPSAoKSA9PiB7IH0sIG9uUHJvbW90aW9uQ2hlY2sgPSAoc291cmNlU3F1YXJlLCB0YXJnZXRTcXVhcmUsIHBpZWNlKSA9PiB7XHJcbiAgICByZXR1cm4gKCgocGllY2UgPT09IFwid1BcIiAmJlxyXG4gICAgICAgIHNvdXJjZVNxdWFyZVsxXSA9PT0gXCI3XCIgJiZcclxuICAgICAgICB0YXJnZXRTcXVhcmVbMV0gPT09IFwiOFwiKSB8fFxyXG4gICAgICAgIChwaWVjZSA9PT0gXCJiUFwiICYmXHJcbiAgICAgICAgICAgIHNvdXJjZVNxdWFyZVsxXSA9PT0gXCIyXCIgJiZcclxuICAgICAgICAgICAgdGFyZ2V0U3F1YXJlWzFdID09PSBcIjFcIikpICYmXHJcbiAgICAgICAgTWF0aC5hYnMoc291cmNlU3F1YXJlLmNoYXJDb2RlQXQoMCkgLSB0YXJnZXRTcXVhcmUuY2hhckNvZGVBdCgwKSkgPD0gMSk7XHJcbn0sIG9uUHJvbW90aW9uUGllY2VTZWxlY3QgPSAoKSA9PiB0cnVlLCBvblNwYXJlUGllY2VEcm9wID0gKCkgPT4gdHJ1ZSwgb25TcXVhcmVDbGljayA9ICgpID0+IHsgfSwgb25TcXVhcmVSaWdodENsaWNrID0gKCkgPT4geyB9LCBwb3NpdGlvbiA9IFwic3RhcnRcIiwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCA9IFwiZGVmYXVsdFwiLCBwcm9tb3Rpb25Ub1NxdWFyZSA9IG51bGwsIHNob3dCb2FyZE5vdGF0aW9uID0gdHJ1ZSwgc2hvd1Byb21vdGlvbkRpYWxvZyA9IGZhbHNlLCBzbmFwVG9DdXJzb3IgPSB0cnVlLCB9LCByZWYpID0+IHtcclxuICAgIC8vIHBvc2l0aW9uIHN0b3JlZCBhbmQgZGlzcGxheWVkIG9uIGJvYXJkXHJcbiAgICBjb25zdCBbY3VycmVudFBvc2l0aW9uLCBzZXRDdXJyZW50UG9zaXRpb25dID0gdXNlU3RhdGUoY29udmVydFBvc2l0aW9uVG9PYmplY3QocG9zaXRpb24pKTtcclxuICAgIC8vIGNhbGN1bGF0ZWQgZGlmZmVyZW5jZXMgYmV0d2VlbiBjdXJyZW50IGFuZCBpbmNvbWluZyBwb3NpdGlvbnNcclxuICAgIGNvbnN0IFtwb3NpdGlvbkRpZmZlcmVuY2VzLCBzZXRQb3NpdGlvbkRpZmZlcmVuY2VzXSA9IHVzZVN0YXRlKHsgcmVtb3ZlZDoge30sIGFkZGVkOiB7fSB9KTtcclxuICAgIC8vIGNvbG91ciBvZiBsYXN0IHBpZWNlIG1vdmVkIHRvIGRldGVybWluZSBpZiBwcmVtb3ZpbmdcclxuICAgIGNvbnN0IFtsYXN0UGllY2VDb2xvdXIsIHNldExhc3RQaWVjZUNvbG91cl0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xyXG4gICAgLy8gc2hvdyAvIGhpZGUgcHJvbW90aW9uIGRpYWxvZ1xyXG4gICAgY29uc3QgW3Nob3dQcm9tb3RlRGlhbG9nLCBzZXRTaG93UHJvbW90ZURpYWxvZ10gPSB1c2VTdGF0ZShzaG93UHJvbW90aW9uRGlhbG9nICYmICFhdXRvUHJvbW90ZVRvUXVlZW4pO1xyXG4gICAgLy8gd2hpY2ggc3F1YXJlIGEgcGF3biBpcyBiZWluZyBwcm9tb3RlZCB0b1xyXG4gICAgY29uc3QgW3Byb21vdGVGcm9tU3F1YXJlLCBzZXRQcm9tb3RlRnJvbVNxdWFyZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtwcm9tb3RlVG9TcXVhcmUsIHNldFByb21vdGVUb1NxdWFyZV0gPSB1c2VTdGF0ZShwcm9tb3Rpb25Ub1NxdWFyZSk7XHJcbiAgICAvLyBjdXJyZW50IHByZW1vdmVzXHJcbiAgICBjb25zdCBbcHJlbW92ZXMsIHNldFByZW1vdmVzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIC8vIHJlZiB1c2VkIHRvIGFjY2VzcyBjdXJyZW50IHZhbHVlIGR1cmluZyB0aW1lb3V0cyAoY2xvc3VyZXMpXHJcbiAgICBjb25zdCBwcmVtb3Zlc1JlZiA9IHVzZVJlZihwcmVtb3Zlcyk7XHJcbiAgICAvLyBjdXJyZW50IHJpZ2h0IG1vdXNlIGRvd24gc3F1YXJlXHJcbiAgICBjb25zdCBbY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzZXRDdXJyZW50UmlnaHRDbGlja0Rvd25dID0gdXNlU3RhdGUoKTtcclxuICAgIC8vIGNoZXNzIHBpZWNlcy9zdHlsaW5nXHJcbiAgICBjb25zdCBbY2hlc3NQaWVjZXMsIHNldENoZXNzUGllY2VzXSA9IHVzZVN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBpZWNlcyksIGN1c3RvbVBpZWNlcykpO1xyXG4gICAgLy8gd2hldGhlciB0aGUgbGFzdCBtb3ZlIHdhcyBhIG1hbnVhbCBkcm9wIG9yIG5vdFxyXG4gICAgY29uc3QgW3dhc01hbnVhbERyb3AsIHNldFdhc01hbnVhbERyb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgLy8gdGhlIG1vc3QgcmVjZW50IHRpbWVvdXQgd2hpbHN0IHdhaXRpbmcgZm9yIGFuaW1hdGlvbiB0byBjb21wbGV0ZVxyXG4gICAgY29uc3QgW3ByZXZpb3VzVGltZW91dCwgc2V0UHJldmlvdXNUaW1lb3V0XSA9IHVzZVN0YXRlKCk7XHJcbiAgICAvLyBpZiBjdXJyZW50bHkgd2FpdGluZyBmb3IgYW4gYW5pbWF0aW9uIHRvIGZpbmlzaFxyXG4gICAgY29uc3QgW2lzV2FpdGluZ0ZvckFuaW1hdGlvbiwgc2V0SXNXYWl0aW5nRm9yQW5pbWF0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIC8vIGxhc3Qgc3F1YXJlIGRyYWdnZWQgb3ZlciBmb3IgY2hlY2tpbmcgaW4gdG91Y2ggZXZlbnRzXHJcbiAgICBjb25zdCBbbGFzdFNxdWFyZURyYWdnZWRPdmVyLCBzZXRMYXN0U3F1YXJlRHJhZ2dlZE92ZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAvLyBvcGVuIGNsZWFyUHJlbW92ZXMoKSB0byBhbGxvdyB1c2VyIHRvIGNhbGwgb24gdW5kby9yZXNldC93aGVuZXZlclxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XHJcbiAgICAgICAgY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91ciA9IHRydWUpIHtcclxuICAgICAgICAgICAgY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91cik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pKTtcclxuICAgIC8vIGhhbmRsZSBjdXN0b20gcGllY2VzIGNoYW5nZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRDaGVzc1BpZWNlcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQaWVjZXMpLCBjdXN0b21QaWVjZXMpKTtcclxuICAgIH0sIFtjdXN0b21QaWVjZXNdKTtcclxuICAgIC8vIGhhbmRsZSBwcm9tb3RlIGNoYW5nZXNcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2coc2hvd1Byb21vdGlvbkRpYWxvZyk7XHJcbiAgICAgICAgc2V0UHJvbW90ZVRvU3F1YXJlKHByb21vdGlvblRvU3F1YXJlKTtcclxuICAgIH0sIFtwcm9tb3Rpb25Ub1NxdWFyZSwgc2hvd1Byb21vdGlvbkRpYWxvZ10pO1xyXG4gICAgLy8gaGFuZGxlIGV4dGVybmFsIHBvc2l0aW9uIGNoYW5nZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAvLyBjbGVhciBhbnkgb3BlbiBwcm9tb3Rpb24gZGlhbG9nc1xyXG4gICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBjb252ZXJ0UG9zaXRpb25Ub09iamVjdChwb3NpdGlvbik7XHJcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZXMgPSBnZXRQb3NpdGlvbkRpZmZlcmVuY2VzKGN1cnJlbnRQb3NpdGlvbiwgbmV3UG9zaXRpb24pO1xyXG4gICAgICAgIGNvbnN0IG5ld1BpZWNlQ29sb3VyID0gKChfYSA9IE9iamVjdC5rZXlzKGRpZmZlcmVuY2VzLmFkZGVkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPD0gMlxyXG4gICAgICAgICAgICA/IChfYyA9IChfYiA9IE9iamVjdC5lbnRyaWVzKGRpZmZlcmVuY2VzLmFkZGVkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMV1bMF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gZXh0ZXJuYWwgbW92ZSBoYXMgY29tZSBpbiBiZWZvcmUgYW5pbWF0aW9uIGlzIG92ZXJcclxuICAgICAgICAvLyBjYW5jZWwgYW5pbWF0aW9uIGFuZCBpbW1lZGlhdGVseSB1cGRhdGUgcG9zaXRpb25cclxuICAgICAgICBpZiAoaXNXYWl0aW5nRm9yQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHNldElzV2FpdGluZ0ZvckFuaW1hdGlvbihmYWxzZSk7XHJcbiAgICAgICAgICAgIGFyZVByZW1vdmVzQWxsb3dlZCAmJiBhdHRlbXB0UHJlbW92ZShuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwcmV2aW91c1RpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBtb3ZlIHdhcyBtYWRlIHVzaW5nIGRyYWcgYW5kIGRyb3BcclxuICAgICAgICAgICAgaWYgKHdhc01hbnVhbERyb3ApIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYXJlUHJlbW92ZXNBbGxvd2VkICYmIGF0dGVtcHRQcmVtb3ZlKG5ld1BpZWNlQ29sb3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgd2FzIG1hZGUgYnkgZXh0ZXJuYWwgcG9zaXRpb24gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBwb3NpdGlvbiA9PT0gc3RhcnQgdGhlbiBkb24ndCBvdmVycmlkZSBuZXdQaWVjZUNvbG91clxyXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgaXNEaWZmZXJlbnRGcm9tU3RhcnQgaW4gc2NlbmFyaW8gd2hlcmUgcHJlbW92ZXMgaGF2ZSBiZWVuIGNsZWFyZWQgdXBvbiBib2FyZCByZXNldCBidXQgZmlyc3QgbW92ZSBpcyBtYWRlIGJ5IGNvbXB1dGVyLCB0aGUgbGFzdCBtb3ZlIGNvbG91ciB3b3VsZCBuZWVkIHRvIGJlIHVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmIChpc0RpZmZlcmVudEZyb21TdGFydChuZXdQb3NpdGlvbikgJiZcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGllY2VDb2xvdXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RQaWVjZUNvbG91cihuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEaWZmZXJlbnRGcm9tU3RhcnQobmV3UG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gPT09IHN0YXJ0LCBsaWtlbHkgYSBib2FyZCByZXNldC4gc2V0IHRvIGJsYWNrIHRvIGFsbG93IGJsYWNrIHRvIG1ha2UgcHJlbW92ZXMgb24gZmlyc3QgbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RQaWVjZUNvbG91cihcImJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRMYXN0UGllY2VDb2xvdXIodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldFBvc2l0aW9uRGlmZmVyZW5jZXMoZGlmZmVyZW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gYW5pbWF0ZSBleHRlcm5hbCBtb3ZlXHJcbiAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZVByZW1vdmVzQWxsb3dlZCAmJiBhdHRlbXB0UHJlbW92ZShuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzZXRQcmV2aW91c1RpbWVvdXQobmV3VGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzZXQgbWFudWFsIGRyb3AsIHJlYWR5IGZvciBuZXh0IG1vdmUgdG8gYmUgbWFkZSBieSB1c2VyIG9yIGV4dGVybmFsXHJcbiAgICAgICAgc2V0V2FzTWFudWFsRHJvcChmYWxzZSk7XHJcbiAgICAgICAgLy8gaW5mb3JtIGxhdGVzdCBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgIGdldFBvc2l0aW9uT2JqZWN0KG5ld1Bvc2l0aW9uKTtcclxuICAgICAgICAvLyBjbGVhciBhcnJvd3NcclxuICAgICAgICBjbGVhckFycm93cygpO1xyXG4gICAgICAgIC8vIGNsZWFyIHRpbWVvdXQgb24gdW5tb3VudFxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwcmV2aW91c1RpbWVvdXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcG9zaXRpb25dKTtcclxuICAgIGNvbnN0IHsgYXJyb3dzLCBuZXdBcnJvdywgY2xlYXJBcnJvd3MsIGRyYXdOZXdBcnJvdywgb25BcnJvd0RyYXdFbmQgfSA9IHVzZUFycm93cyhjdXN0b21BcnJvd3MsIGFyZUFycm93c0FsbG93ZWQsIG9uQXJyb3dzQ2hhbmdlLCBjdXN0b21BcnJvd0NvbG9yKTtcclxuICAgIC8vIGhhbmRsZSBkcm9wIHBvc2l0aW9uIGNoYW5nZVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU2V0UG9zaXRpb24oc291cmNlU3EsIHRhcmdldFNxLCBwaWVjZSwgd2FzTWFudWFsRHJvcE92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy8gaWYgZHJvcHBlZCBiYWNrIGRvd24sIGRvbid0IGRvIGFueXRoaW5nXHJcbiAgICAgICAgaWYgKHNvdXJjZVNxID09PSB0YXJnZXRTcSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyQXJyb3dzKCk7XHJcbiAgICAgICAgLy8gaWYgc2Vjb25kIG1vdmUgaXMgbWFkZSBmb3Igc2FtZSBjb2xvdXIsIG9yIHRoZXJlIGFyZSBzdGlsbCBwcmVtb3ZlcyBxdWV1ZWQsIHRoZW4gdGhpcyBtb3ZlIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHByZW1vdmUgcXVldWUgaW5zdGVhZCBvZiBwbGF5ZWRcclxuICAgICAgICAvLyBwcmVtb3ZlcyBsZW5ndGggY2hlY2sgZm9yIGNvbG91ciBpcyBhZGRlZCBpbiBiZWNhdXNlIHdoaXRlIGNvdWxkIG1ha2UgMyBwcmVtb3ZlcywgYW5kIHRoZW4gYmxhY2sgcmVzcG9uZHMgdG8gdGhlIGZpcnN0IG1vdmUgKGNoYW5naW5nIHRoZSBsYXN0IHBpZWNlIGNvbG91cikgYW5kIHRoZW4gd2hpdGUgcHJlLW1vdmVzIGFnYWluXHJcbiAgICAgICAgaWYgKChhcmVQcmVtb3Zlc0FsbG93ZWQgJiYgaXNXYWl0aW5nRm9yQW5pbWF0aW9uKSB8fFxyXG4gICAgICAgICAgICAoYXJlUHJlbW92ZXNBbGxvd2VkICYmXHJcbiAgICAgICAgICAgICAgICAobGFzdFBpZWNlQ29sb3VyID09PSBwaWVjZVswXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQuZmlsdGVyKChwKSA9PiBwLnBpZWNlWzBdID09PSBwaWVjZVswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCA+IDApKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRQcmVtb3ZlcyA9IFsuLi5wcmVtb3Zlc1JlZi5jdXJyZW50XTtcclxuICAgICAgICAgICAgb2xkUHJlbW92ZXMucHVzaCh7IHNvdXJjZVNxLCB0YXJnZXRTcSwgcGllY2UgfSk7XHJcbiAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQgPSBvbGRQcmVtb3ZlcztcclxuICAgICAgICAgICAgc2V0UHJlbW92ZXMoWy4uLm9sZFByZW1vdmVzXSk7XHJcbiAgICAgICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdHJhbnNpdGlvbmluZywgZG9uJ3QgYWxsb3cgbmV3IGRyb3BcclxuICAgICAgICBpZiAoIWFyZVByZW1vdmVzQWxsb3dlZCAmJiBpc1dhaXRpbmdGb3JBbmltYXRpb24pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBuZXdPbkRyb3BQb3NpdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRQb3NpdGlvbik7XHJcbiAgICAgICAgc2V0V2FzTWFudWFsRHJvcCghIXdhc01hbnVhbERyb3BPdmVycmlkZSk7XHJcbiAgICAgICAgc2V0TGFzdFBpZWNlQ29sb3VyKHBpZWNlWzBdKTtcclxuICAgICAgICAvLyBpZiBvblBpZWNlRHJvcCBmdW5jdGlvbiBwcm92aWRlZCwgZXhlY3V0ZSBpdCwgcG9zaXRpb24gbXVzdCBiZSB1cGRhdGVkIGV4dGVybmFsbHkgYW5kIGNhcHR1cmVkIGJ5IHVzZUVmZmVjdCBhYm92ZSBmb3IgdGhpcyBtb3ZlIHRvIHNob3cgb24gYm9hcmRcclxuICAgICAgICBpZiAob25QaWVjZURyb3AubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRNb3ZlID0gb25QaWVjZURyb3Aoc291cmNlU3EsIHRhcmdldFNxLCBwaWVjZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyUHJlbW92ZXMoKTtcclxuICAgICAgICAgICAgICAgIHNldFdhc01hbnVhbERyb3AoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgc291cmNlIHBpZWNlXHJcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdPbkRyb3BQb3NpdGlvbltzb3VyY2VTcV07XHJcbiAgICAgICAgICAgIC8vIGFkZCBwaWVjZSBpbiBuZXcgcG9zaXRpb25cclxuICAgICAgICAgICAgbmV3T25Ecm9wUG9zaXRpb25bdGFyZ2V0U3FdID0gcGllY2U7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdPbkRyb3BQb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgLy8gaW5mb3JtIGxhdGVzdCBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgIGdldFBvc2l0aW9uT2JqZWN0KG5ld09uRHJvcFBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZShzcXVhcmUpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50UG9zaXRpb24pO1xyXG4gICAgICAgIGRlbGV0ZSBwb3NpdGlvbkNvcHlbc3F1YXJlXTtcclxuICAgICAgICBzZXRDdXJyZW50UG9zaXRpb24ocG9zaXRpb25Db3B5KTtcclxuICAgICAgICAvLyBpbmZvcm0gbGF0ZXN0IHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICAgICAgZ2V0UG9zaXRpb25PYmplY3QocG9zaXRpb25Db3B5KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGF0dGVtcHRQcmVtb3ZlKG5ld1BpZWNlQ29sb3VyKSB7XHJcbiAgICAgICAgaWYgKHByZW1vdmVzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgdmFsdWUgb2YgcHJlbW92ZSBhcyB0aGlzIGlzIGNhbGxlZCBpbiBhIHRpbWVvdXQgc28gdmFsdWUgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB0aW1lb3V0IHdhcyBzZXRcclxuICAgICAgICBjb25zdCBwcmVtb3ZlID0gcHJlbW92ZXNSZWYuY3VycmVudFswXTtcclxuICAgICAgICAvLyBpZiBwcmVtb3ZlIGlzIGEgZGlmZmVyaW5nIGNvbG91ciB0byBsYXN0IG1vdmUgbWFkZSwgdGhlbiB0aGlzIG1vdmUgY2FuIGJlIG1hZGVcclxuICAgICAgICBpZiAocHJlbW92ZS5waWVjZVswXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHByZW1vdmUucGllY2VbMF0gIT09IG5ld1BpZWNlQ29sb3VyICYmXHJcbiAgICAgICAgICAgIG9uUGllY2VEcm9wLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzZXRMYXN0UGllY2VDb2xvdXIocHJlbW92ZS5waWVjZVswXSk7XHJcbiAgICAgICAgICAgIHNldFdhc01hbnVhbERyb3AodHJ1ZSk7IC8vIHByZS1tb3ZlIGRvZXNuJ3QgbmVlZCBhbmltYXRpb25cclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZE1vdmUgPSBvblBpZWNlRHJvcChwcmVtb3ZlLnNvdXJjZVNxLCBwcmVtb3ZlLnRhcmdldFNxLCBwcmVtb3ZlLnBpZWNlKTtcclxuICAgICAgICAgICAgLy8gcHJlbW92ZSB3YXMgc3VjY2Vzc2Z1bCBhbmQgY2FuIGJlIHJlbW92ZWQgZnJvbSBxdWV1ZVxyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFByZW1vdmVzID0gWy4uLnByZW1vdmVzUmVmLmN1cnJlbnRdO1xyXG4gICAgICAgICAgICAgICAgb2xkUHJlbW92ZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQgPSBvbGRQcmVtb3ZlcztcclxuICAgICAgICAgICAgICAgIHNldFByZW1vdmVzKFsuLi5vbGRQcmVtb3Zlc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlbW92ZSB3YXNuJ3Qgc3VjY2Vzc2Z1bCwgY2xlYXIgcHJlbW92ZSBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgY2xlYXJQcmVtb3ZlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU3BhcmVQaWVjZURyb3AocGllY2UsIHRhcmdldFNxKSB7XHJcbiAgICAgICAgY29uc3QgaXNWYWxpZERyb3AgPSBvblNwYXJlUGllY2VEcm9wKHBpZWNlLCB0YXJnZXRTcSk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkRHJvcClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IG5ld09uRHJvcFBvc2l0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFBvc2l0aW9uKTtcclxuICAgICAgICAvLyBhZGQgcGllY2UgaW4gbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgbmV3T25Ecm9wUG9zaXRpb25bdGFyZ2V0U3FdID0gcGllY2U7XHJcbiAgICAgICAgc2V0Q3VycmVudFBvc2l0aW9uKG5ld09uRHJvcFBvc2l0aW9uKTtcclxuICAgICAgICAvLyBpbmZvcm0gbGF0ZXN0IHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICAgICAgZ2V0UG9zaXRpb25PYmplY3QobmV3T25Ecm9wUG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91ciA9IHRydWUpIHtcclxuICAgICAgICAvLyBkb24ndCBjbGVhciB3aGVuIHJpZ2h0IGNsaWNraW5nIHRvIGNsZWFyLCBvdGhlcndpc2UgeW91IHdvbid0IGJlIGFibGUgdG8gcHJlbW92ZSBhZ2FpbiBiZWZvcmUgbmV4dCBnb1xyXG4gICAgICAgIGlmIChjbGVhckxhc3RQaWVjZUNvbG91cilcclxuICAgICAgICAgICAgc2V0TGFzdFBpZWNlQ29sb3VyKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgcHJlbW92ZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICAgIHNldFByZW1vdmVzKFtdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyUHJvbW90aW9uKCkge1xyXG4gICAgICAgIHNldFByb21vdGVGcm9tU3F1YXJlKG51bGwpO1xyXG4gICAgICAgIHNldFByb21vdGVUb1NxdWFyZShudWxsKTtcclxuICAgICAgICBzZXRTaG93UHJvbW90ZURpYWxvZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2tEb3duKHNxdWFyZSkge1xyXG4gICAgICAgIHNldEN1cnJlbnRSaWdodENsaWNrRG93bihzcXVhcmUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25SaWdodENsaWNrVXAoc3F1YXJlKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRSaWdodENsaWNrRG93bikge1xyXG4gICAgICAgICAgICAvLyBzYW1lIHNxdWFyZSwgZG9uJ3QgZHJhdyBhbiBhcnJvdywgYnV0IGRvIGNsZWFyIHByZW1vdmVzIGFuZCBydW4gb25TcXVhcmVSaWdodENsaWNrXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UmlnaHRDbGlja0Rvd24gPT09IHNxdWFyZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFJpZ2h0Q2xpY2tEb3duKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclByZW1vdmVzT25SaWdodENsaWNrICYmIGNsZWFyUHJlbW92ZXMoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgb25TcXVhcmVSaWdodENsaWNrKHNxdWFyZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzZXRDdXJyZW50UmlnaHRDbGlja0Rvd24odW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyQ3VycmVudFJpZ2h0Q2xpY2tEb3duKCkge1xyXG4gICAgICAgIHNldEN1cnJlbnRSaWdodENsaWNrRG93bih1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgQ2hlc3Nib2FyZFByb3ZpZGVyQ29udGV4dFZhbHVlID0ge1xyXG4gICAgICAgIGFsbG93RHJhZ091dHNpZGVCb2FyZCxcclxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICBhcmVQaWVjZXNEcmFnZ2FibGUsXHJcbiAgICAgICAgYXJlUHJlbW92ZXNBbGxvd2VkLFxyXG4gICAgICAgIGFycm93cyxcclxuICAgICAgICBhdXRvUHJvbW90ZVRvUXVlZW4sXHJcbiAgICAgICAgYm9hcmRPcmllbnRhdGlvbixcclxuICAgICAgICBib2FyZFdpZHRoLFxyXG4gICAgICAgIGNoZXNzUGllY2VzLFxyXG4gICAgICAgIGNsZWFyQXJyb3dzLFxyXG4gICAgICAgIGNsZWFyQ3VycmVudFJpZ2h0Q2xpY2tEb3duLFxyXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbixcclxuICAgICAgICBjdXJyZW50UmlnaHRDbGlja0Rvd24sXHJcbiAgICAgICAgY3VzdG9tQXJyb3dDb2xvcixcclxuICAgICAgICBjdXN0b21Cb2FyZFN0eWxlLFxyXG4gICAgICAgIGN1c3RvbURhcmtTcXVhcmVTdHlsZSxcclxuICAgICAgICBjdXN0b21Ecm9wU3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSxcclxuICAgICAgICBjdXN0b21Ob3RhdGlvblN0eWxlLFxyXG4gICAgICAgIGN1c3RvbVByZW1vdmVEYXJrU3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tUHJlbW92ZUxpZ2h0U3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tU3F1YXJlLFxyXG4gICAgICAgIGN1c3RvbVNxdWFyZVN0eWxlcyxcclxuICAgICAgICBkZWxldGVQaWVjZUZyb21TcXVhcmUsXHJcbiAgICAgICAgZHJhd05ld0Fycm93LFxyXG4gICAgICAgIGRyb3BPZmZCb2FyZEFjdGlvbixcclxuICAgICAgICBoYW5kbGVTZXRQb3NpdGlvbixcclxuICAgICAgICBoYW5kbGVTcGFyZVBpZWNlRHJvcCxcclxuICAgICAgICBpZCxcclxuICAgICAgICBpc0RyYWdnYWJsZVBpZWNlLFxyXG4gICAgICAgIGlzV2FpdGluZ0ZvckFuaW1hdGlvbixcclxuICAgICAgICBsYXN0UGllY2VDb2xvdXIsXHJcbiAgICAgICAgbGFzdFNxdWFyZURyYWdnZWRPdmVyLFxyXG4gICAgICAgIG5ld0Fycm93LFxyXG4gICAgICAgIG9uQXJyb3dEcmF3RW5kLFxyXG4gICAgICAgIG9uRHJhZ092ZXJTcXVhcmUsXHJcbiAgICAgICAgb25Nb3VzZU91dFNxdWFyZSxcclxuICAgICAgICBvbk1vdXNlT3ZlclNxdWFyZSxcclxuICAgICAgICBvblBpZWNlQ2xpY2ssXHJcbiAgICAgICAgb25QaWVjZURyYWdCZWdpbixcclxuICAgICAgICBvblBpZWNlRHJhZ0VuZCxcclxuICAgICAgICBvblBpZWNlRHJvcCxcclxuICAgICAgICBvblBpZWNlRHJvcE9mZkJvYXJkLFxyXG4gICAgICAgIG9uUHJvbW90aW9uQ2hlY2ssXHJcbiAgICAgICAgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCxcclxuICAgICAgICBvblJpZ2h0Q2xpY2tEb3duLFxyXG4gICAgICAgIG9uUmlnaHRDbGlja1VwLFxyXG4gICAgICAgIG9uU3BhcmVQaWVjZURyb3AsXHJcbiAgICAgICAgb25TcXVhcmVDbGljayxcclxuICAgICAgICBwb3NpdGlvbkRpZmZlcmVuY2VzLFxyXG4gICAgICAgIHByZW1vdmVzLFxyXG4gICAgICAgIHByb21vdGVGcm9tU3F1YXJlLFxyXG4gICAgICAgIHByb21vdGVUb1NxdWFyZSxcclxuICAgICAgICBwcm9tb3Rpb25EaWFsb2dWYXJpYW50LFxyXG4gICAgICAgIHNldExhc3RTcXVhcmVEcmFnZ2VkT3ZlcixcclxuICAgICAgICBzZXRQcm9tb3RlRnJvbVNxdWFyZSxcclxuICAgICAgICBzZXRQcm9tb3RlVG9TcXVhcmUsXHJcbiAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2csXHJcbiAgICAgICAgc2hvd0JvYXJkTm90YXRpb24sXHJcbiAgICAgICAgc2hvd1Byb21vdGVEaWFsb2csXHJcbiAgICAgICAgc25hcFRvQ3Vyc29yLFxyXG4gICAgfTtcclxuICAgIHJldHVybiAoanN4KENoZXNzYm9hcmRDb250ZXh0LlByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgdmFsdWU6IENoZXNzYm9hcmRQcm92aWRlckNvbnRleHRWYWx1ZSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xyXG59KTtcblxuZnVuY3Rpb24gTm90YXRpb24oeyByb3csIGNvbCB9KSB7XHJcbiAgICBjb25zdCB7IGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1c3RvbURhcmtTcXVhcmVTdHlsZSwgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSwgY3VzdG9tTm90YXRpb25TdHlsZSwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IHdoaXRlQ29sb3IgPSBjdXN0b21MaWdodFNxdWFyZVN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgIGNvbnN0IGJsYWNrQ29sb3IgPSBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgY29uc3QgaXNSb3cgPSBjb2wgPT09IDA7XHJcbiAgICBjb25zdCBpc0NvbHVtbiA9IHJvdyA9PT0gNztcclxuICAgIGNvbnN0IGlzQm90dG9tTGVmdFNxdWFyZSA9IGlzUm93ICYmIGlzQ29sdW1uO1xyXG4gICAgZnVuY3Rpb24gZ2V0Um93KCkge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCIgPyA4IC0gcm93IDogcm93ICsgMTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbHVtbigpIHtcclxuICAgICAgICByZXR1cm4gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gQ09MVU1OU1s3IC0gY29sXSA6IENPTFVNTlNbY29sXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckJvdHRvbUxlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgekluZGV4OiAzLCBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiIH0sIHsgY29sb3I6IHdoaXRlQ29sb3IgfSksIG51bWVyaWNTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Um93KCkgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB6SW5kZXg6IDMsIHBvc2l0aW9uOiBcImFic29sdXRlXCIgfSwgeyBjb2xvcjogd2hpdGVDb2xvciB9KSwgYWxwaGFTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Q29sdW1uKCkgfSkpXSB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJMZXR0ZXJzKCkge1xyXG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdXNlclNlbGVjdDogXCJub25lXCIsIHpJbmRleDogMywgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9LCB7IGNvbG9yOiBjb2wgJSAyICE9PSAwID8gYmxhY2tDb2xvciA6IHdoaXRlQ29sb3IgfSksIGFscGhhU3R5bGUoYm9hcmRXaWR0aCwgY3VzdG9tTm90YXRpb25TdHlsZSkpIH0sIHsgY2hpbGRyZW46IGdldENvbHVtbigpIH0pKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJOdW1iZXJzKCkge1xyXG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdXNlclNlbGVjdDogXCJub25lXCIsIHpJbmRleDogMywgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9LCAoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgICAgICA/IHsgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBibGFja0NvbG9yIDogd2hpdGVDb2xvciB9XHJcbiAgICAgICAgICAgICAgICA6IHsgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBibGFja0NvbG9yIDogd2hpdGVDb2xvciB9KSksIG51bWVyaWNTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Um93KCkgfSkpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0JvdHRvbUxlZnRTcXVhcmUpIHtcclxuICAgICAgICByZXR1cm4gcmVuZGVyQm90dG9tTGVmdCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQ29sdW1uKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckxldHRlcnMoKTtcclxuICAgIH1cclxuICAgIGlmIChpc1Jvdykge1xyXG4gICAgICAgIHJldHVybiByZW5kZXJOdW1iZXJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5jb25zdCBhbHBoYVN0eWxlID0gKHdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbih7IGFsaWduU2VsZjogXCJmbGV4LWVuZFwiLCBwYWRkaW5nTGVmdDogd2lkdGggLyA4IC0gd2lkdGggLyA0OCwgZm9udFNpemU6IHdpZHRoIC8gNDggfSwgY3VzdG9tTm90YXRpb25TdHlsZSkpO1xyXG5jb25zdCBudW1lcmljU3R5bGUgPSAod2lkdGgsIGN1c3RvbU5vdGF0aW9uU3R5bGUpID0+IChPYmplY3QuYXNzaWduKHsgYWxpZ25TZWxmOiBcImZsZXgtc3RhcnRcIiwgcGFkZGluZ1JpZ2h0OiB3aWR0aCAvIDggLSB3aWR0aCAvIDQ4LCBmb250U2l6ZTogd2lkdGggLyA0OCB9LCBjdXN0b21Ob3RhdGlvblN0eWxlKSk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBSZWFjdCBDb250ZXh0XG4gKi8gY29uc3QgRG5kQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGRyYWdEcm9wTWFuYWdlcjogdW5kZWZpbmVkXG59KTtcblxuLyoqXG4gKiBBZGFwdGVkIGZyb20gUmVhY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS5qc1xuICpcbiAqIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIHRocm93IGVycm9yIGNhbGxzLiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgY29kZXNcbiAqIGR1cmluZyBidWlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gXCJNaW5pZmllZCBSZWR1eCBlcnJvciAjXCIgKyBjb2RlICsgXCI7IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPVwiICsgY29kZSArIFwiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIFwiICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuICc7XG59XG5cbi8vIElubGluZWQgdmVyc2lvbiBvZiB0aGUgYHN5bWJvbC1vYnNlcnZhYmxlYCBwb2x5ZmlsbFxudmFyICQkb2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSkoKTtcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciByYW5kb21TdHJpbmcgPSBmdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbn07XG5cbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogXCJAQHJlZHV4L0lOSVRcIiArIHJhbmRvbVN0cmluZygpLFxuICBSRVBMQUNFOiBcIkBAcmVkdXgvUkVQTEFDRVwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFBST0JFX1VOS05PV05fQUNUSU9OOiBmdW5jdGlvbiBQUk9CRV9VTktOT1dOX0FDVElPTigpIHtcbiAgICByZXR1cm4gXCJAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXCIgKyByYW5kb21TdHJpbmcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IG9iajtcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG87XG59XG5cbi8vIElubGluZWQgLyBzaG9ydGVuZWQgdmVyc2lvbiBvZiBga2luZE9mYCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2tpbmQtb2ZcbmZ1bmN0aW9uIG1pbmlLaW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICB2YXIgY29uc3RydWN0b3JOYW1lID0gY3Rvck5hbWUodmFsKTtcblxuICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnTWFwJzpcbiAgICBjYXNlICdTZXQnOlxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfSAvLyBvdGhlclxuXG5cbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn1cblxuZnVuY3Rpb24gY3Rvck5hbWUodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHZhbC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgdmFyIHR5cGVPZlZhbCA9IHR5cGVvZiB2YWw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdHlwZU9mVmFsO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBjb25maWd1cmVTdG9yZWAgbWV0aG9kXG4gKiBvZiB0aGUgYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYC5cbiAqXG4gKiBSZWR1eCBUb29sa2l0IGlzIG91ciByZWNvbW1lbmRlZCBhcHByb2FjaCBmb3Igd3JpdGluZyBSZWR1eCBsb2dpYyB0b2RheSxcbiAqIGluY2x1ZGluZyBzdG9yZSBzZXR1cCwgcmVkdWNlcnMsIGRhdGEgZmV0Y2hpbmcsIGFuZCBtb3JlLlxuICpcbiAqICoqRm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlYWQgdGhpcyBSZWR1eCBkb2NzIHBhZ2U6KipcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIGBjb25maWd1cmVTdG9yZWAgZnJvbSBSZWR1eCBUb29sa2l0IGlzIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgYGNyZWF0ZVN0b3JlYCB0aGF0XG4gKiBzaW1wbGlmaWVzIHNldHVwIGFuZCBoZWxwcyBhdm9pZCBjb21tb24gYnVncy5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5vdCBiZSB1c2luZyB0aGUgYHJlZHV4YCBjb3JlIHBhY2thZ2UgYnkgaXRzZWxmIHRvZGF5LCBleGNlcHQgZm9yIGxlYXJuaW5nIHB1cnBvc2VzLlxuICogVGhlIGBjcmVhdGVTdG9yZWAgbWV0aG9kIGZyb20gdGhlIGNvcmUgYHJlZHV4YCBwYWNrYWdlIHdpbGwgbm90IGJlIHJlbW92ZWQsIGJ1dCB3ZSBlbmNvdXJhZ2VcbiAqIGFsbCB1c2VycyB0byBtaWdyYXRlIHRvIHVzaW5nIFJlZHV4IFRvb2xraXQgZm9yIGFsbCBSZWR1eCBjb2RlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBgY3JlYXRlU3RvcmVgIHdpdGhvdXQgdGhpcyB2aXN1YWwgZGVwcmVjYXRpb24gd2FybmluZywgdXNlXG4gKiB0aGUgYGxlZ2FjeV9jcmVhdGVTdG9yZWAgaW1wb3J0IGluc3RlYWQ6XG4gKlxuICogYGltcG9ydCB7IGxlZ2FjeV9jcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiAnSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gJyArICdjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSAnICsgJ3RvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjY3JlYXRpbmctYS1zdG9yZS13aXRoLWVuaGFuY2VycyBmb3IgYW4gZXhhbXBsZS4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihlbmhhbmNlcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyKSA6IFwiRXhwZWN0ZWQgdGhlIHJvb3QgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKHJlZHVjZXIpICsgXCInXCIpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIGEgc2hhbGxvdyBjb3B5IG9mIGN1cnJlbnRMaXN0ZW5lcnMgc28gd2UgY2FuIHVzZVxuICAgKiBuZXh0TGlzdGVuZXJzIGFzIGEgdGVtcG9yYXJ5IGxpc3Qgd2hpbGUgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIFRoaXMgcHJldmVudHMgYW55IGJ1Z3MgYXJvdW5kIGNvbnN1bWVycyBjYWxsaW5nXG4gICAqIHN1YnNjcmliZS91bnN1YnNjcmliZSBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6ICdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihsaXN0ZW5lcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ0lmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhICcgKyAnY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiAnWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNykgOiBcIkFjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnXCIgKyBraW5kT2YoYWN0aW9uKSArIFwiJy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6ICdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGFuIGFjdGlvbiB0eXBlIHN0cmluZyBjb25zdGFudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOSkgOiAnUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cblxuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2YobmV4dFJlZHVjZXIpKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyOyAvLyBUaGlzIGFjdGlvbiBoYXMgYSBzaW1pbGlhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKG9ic2VydmVyKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9IC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuXG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSk7XG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG4vKlxuICogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuICogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuICovXG5cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBzZXR0aW5nIG1vZGUgdG8gcHJvZHVjdGlvbiBpbiB3ZWJwYWNrIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmNlcHRzL21vZGUvKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovIGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncykge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24oKSkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMSAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgICAgICA7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUHJvZHVjdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52WydOT0RFX0VOViddID09PSAncHJvZHVjdGlvbic7XG59XG5cbi8vIGNoZWFwIGxvZGFzaCByZXBsYWNlbWVudHNcbi8qKlxuICogZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgXy5nZXRcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gKi8gZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKGEsIGMpPT5hICYmIGFbY10gPyBhW2NdIDogZGVmYXVsdFZhbHVlIHx8IG51bGxcbiAgICAsIG9iaik7XG59XG4vKipcbiAqIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIF8ud2l0aG91dFxuICovIGZ1bmN0aW9uIHdpdGhvdXQkMShpdGVtcywgaXRlbSkge1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGkpPT5pICE9PSBpdGVtXG4gICAgKTtcbn1cbi8qKlxuICogZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgXy5pc1N0cmluZ1xuICogQHBhcmFtIGlucHV0XG4gKi8gZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogcmVwbGFjZW1lbnQgZm9yIF8ueG9yXG4gKiBAcGFyYW0gaXRlbXNBXG4gKiBAcGFyYW0gaXRlbXNCXG4gKi8gZnVuY3Rpb24geG9yKGl0ZW1zQSwgaXRlbXNCKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGluc2VydEl0ZW0gPSAoaXRlbSk9PntcbiAgICAgICAgbWFwLnNldChpdGVtLCBtYXAuaGFzKGl0ZW0pID8gbWFwLmdldChpdGVtKSArIDEgOiAxKTtcbiAgICB9O1xuICAgIGl0ZW1zQS5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGl0ZW1zQi5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIG1hcC5mb3JFYWNoKChjb3VudCwga2V5KT0+e1xuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiByZXBsYWNlbWVudCBmb3IgXy5pbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSBpdGVtc0FcbiAqIEBwYXJhbSBpdGVtc0JcbiAqLyBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oaXRlbXNBLCBpdGVtc0IpIHtcbiAgICByZXR1cm4gaXRlbXNBLmZpbHRlcigodCk9Pml0ZW1zQi5pbmRleE9mKHQpID4gLTFcbiAgICApO1xufVxuXG5jb25zdCBJTklUX0NPT1JEUyA9ICdkbmQtY29yZS9JTklUX0NPT1JEUyc7XG5jb25zdCBCRUdJTl9EUkFHID0gJ2RuZC1jb3JlL0JFR0lOX0RSQUcnO1xuY29uc3QgUFVCTElTSF9EUkFHX1NPVVJDRSA9ICdkbmQtY29yZS9QVUJMSVNIX0RSQUdfU09VUkNFJztcbmNvbnN0IEhPVkVSID0gJ2RuZC1jb3JlL0hPVkVSJztcbmNvbnN0IERST1AgPSAnZG5kLWNvcmUvRFJPUCc7XG5jb25zdCBFTkRfRFJBRyA9ICdkbmQtY29yZS9FTkRfRFJBRyc7XG5cbmZ1bmN0aW9uIHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IElOSVRfQ09PUkRTLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBzb3VyY2VDbGllbnRPZmZzZXQ6IHNvdXJjZUNsaWVudE9mZnNldCB8fCBudWxsLFxuICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBjbGllbnRPZmZzZXQgfHwgbnVsbFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3QgUmVzZXRDb29yZGluYXRlc0FjdGlvbiA9IHtcbiAgICB0eXBlOiBJTklUX0NPT1JEUyxcbiAgICBwYXlsb2FkOiB7XG4gICAgICAgIGNsaWVudE9mZnNldDogbnVsbCxcbiAgICAgICAgc291cmNlQ2xpZW50T2Zmc2V0OiBudWxsXG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJlZ2luRHJhZyhtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJlZ2luRHJhZyhzb3VyY2VJZHMgPSBbXSwgb3B0aW9ucyA9IHtcbiAgICAgICAgcHVibGlzaFNvdXJjZTogdHJ1ZVxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgeyBwdWJsaXNoU291cmNlID10cnVlICwgY2xpZW50T2Zmc2V0ICwgZ2V0U291cmNlQ2xpZW50T2Zmc2V0ICwgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBjb29yZGluYXRlcyB1c2luZyB0aGUgY2xpZW50IG9mZnNldFxuICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQpKTtcbiAgICAgICAgdmVyaWZ5SW52YXJpYW50cyQxKHNvdXJjZUlkcywgbW9uaXRvciwgcmVnaXN0cnkpO1xuICAgICAgICAvLyBHZXQgdGhlIGRyYWdnYWJsZSBzb3VyY2VcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSBnZXREcmFnZ2FibGVTb3VyY2Uoc291cmNlSWRzLCBtb25pdG9yKTtcbiAgICAgICAgaWYgKHNvdXJjZUlkID09IG51bGwpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuZGlzcGF0Y2goUmVzZXRDb29yZGluYXRlc0FjdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBzb3VyY2UgY2xpZW50IG9mZnNldFxuICAgICAgICBsZXQgc291cmNlQ2xpZW50T2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKGNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgaWYgKCFnZXRTb3VyY2VDbGllbnRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlcmlmeUdldFNvdXJjZUNsaWVudE9mZnNldElzRnVuY3Rpb24oZ2V0U291cmNlQ2xpZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIHNvdXJjZUNsaWVudE9mZnNldCA9IGdldFNvdXJjZUNsaWVudE9mZnNldChzb3VyY2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnVsbCBjb29yZGluYXRlc1xuICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSByZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpO1xuICAgICAgICBjb25zdCBpdGVtID0gc291cmNlLmJlZ2luRHJhZyhtb25pdG9yLCBzb3VyY2VJZCk7XG4gICAgICAgIC8vIElmIHNvdXJjZS5iZWdpbkRyYWcgcmV0dXJucyBudWxsLCB0aGlzIGlzIGFuIGluZGljYXRvciB0byBjYW5jZWwgdGhlIGRyYWdcbiAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2ZXJpZnlJdGVtSXNPYmplY3QoaXRlbSk7XG4gICAgICAgIHJlZ2lzdHJ5LnBpblNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gcmVnaXN0cnkuZ2V0U291cmNlVHlwZShzb3VyY2VJZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBCRUdJTl9EUkFHLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGl0ZW1UeXBlLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgc291cmNlSWQsXG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBjbGllbnRPZmZzZXQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzb3VyY2VDbGllbnRPZmZzZXQ6IHNvdXJjZUNsaWVudE9mZnNldCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiAhIXB1Ymxpc2hTb3VyY2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5SW52YXJpYW50cyQxKHNvdXJjZUlkcywgbW9uaXRvciwgcmVnaXN0cnkpIHtcbiAgICBpbnZhcmlhbnQoIW1vbml0b3IuaXNEcmFnZ2luZygpLCAnQ2Fubm90IGNhbGwgYmVnaW5EcmFnIHdoaWxlIGRyYWdnaW5nLicpO1xuICAgIHNvdXJjZUlkcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZUlkKSB7XG4gICAgICAgIGludmFyaWFudChyZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpLCAnRXhwZWN0ZWQgc291cmNlSWRzIHRvIGJlIHJlZ2lzdGVyZWQuJyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlHZXRTb3VyY2VDbGllbnRPZmZzZXRJc0Z1bmN0aW9uKGdldFNvdXJjZUNsaWVudE9mZnNldCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID09PSAnZnVuY3Rpb24nLCAnV2hlbiBjbGllbnRPZmZzZXQgaXMgcHJvdmlkZWQsIGdldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG59XG5mdW5jdGlvbiB2ZXJpZnlJdGVtSXNPYmplY3QoaXRlbSkge1xuICAgIGludmFyaWFudChpc09iamVjdChpdGVtKSwgJ0l0ZW0gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG59XG5mdW5jdGlvbiBnZXREcmFnZ2FibGVTb3VyY2Uoc291cmNlSWRzLCBtb25pdG9yKSB7XG4gICAgbGV0IHNvdXJjZUlkID0gbnVsbDtcbiAgICBmb3IobGV0IGkgPSBzb3VyY2VJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBpZiAobW9uaXRvci5jYW5EcmFnU291cmNlKHNvdXJjZUlkc1tpXSkpIHtcbiAgICAgICAgICAgIHNvdXJjZUlkID0gc291cmNlSWRzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUlkO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkkNChvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSQ0KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gY3JlYXRlRHJvcChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRyb3Aob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHZlcmlmeUludmFyaWFudHMobW9uaXRvcik7XG4gICAgICAgIGNvbnN0IHRhcmdldElkcyA9IGdldERyb3BwYWJsZVRhcmdldHMobW9uaXRvcik7XG4gICAgICAgIC8vIE11bHRpcGxlIGFjdGlvbnMgYXJlIGRpc3BhdGNoZWQgaGVyZSwgd2hpY2ggaXMgd2h5IHRoaXMgZG9lc24ndCByZXR1cm4gYW4gYWN0aW9uXG4gICAgICAgIHRhcmdldElkcy5mb3JFYWNoKCh0YXJnZXRJZCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBkcm9wUmVzdWx0ID0gZGV0ZXJtaW5lRHJvcFJlc3VsdCh0YXJnZXRJZCwgaW5kZXgsIHJlZ2lzdHJ5LCBtb25pdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEUk9QLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcFJlc3VsdDogX29iamVjdFNwcmVhZCQ0KHt9LCBvcHRpb25zLCBkcm9wUmVzdWx0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiB2ZXJpZnlJbnZhcmlhbnRzKG1vbml0b3IpIHtcbiAgICBpbnZhcmlhbnQobW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBkcm9wIHdoaWxlIG5vdCBkcmFnZ2luZy4nKTtcbiAgICBpbnZhcmlhbnQoIW1vbml0b3IuZGlkRHJvcCgpLCAnQ2Fubm90IGNhbGwgZHJvcCB0d2ljZSBkdXJpbmcgb25lIGRyYWcgb3BlcmF0aW9uLicpO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lRHJvcFJlc3VsdCh0YXJnZXRJZCwgaW5kZXgsIHJlZ2lzdHJ5LCBtb25pdG9yKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gcmVnaXN0cnkuZ2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICBsZXQgZHJvcFJlc3VsdCA9IHRhcmdldCA/IHRhcmdldC5kcm9wKG1vbml0b3IsIHRhcmdldElkKSA6IHVuZGVmaW5lZDtcbiAgICB2ZXJpZnlEcm9wUmVzdWx0VHlwZShkcm9wUmVzdWx0KTtcbiAgICBpZiAodHlwZW9mIGRyb3BSZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRyb3BSZXN1bHQgPSBpbmRleCA9PT0gMCA/IHt9IDogbW9uaXRvci5nZXREcm9wUmVzdWx0KCk7XG4gICAgfVxuICAgIHJldHVybiBkcm9wUmVzdWx0O1xufVxuZnVuY3Rpb24gdmVyaWZ5RHJvcFJlc3VsdFR5cGUoZHJvcFJlc3VsdCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgZHJvcFJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNPYmplY3QoZHJvcFJlc3VsdCksICdEcm9wIHJlc3VsdCBtdXN0IGVpdGhlciBiZSBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkLicpO1xufVxuZnVuY3Rpb24gZ2V0RHJvcHBhYmxlVGFyZ2V0cyhtb25pdG9yKSB7XG4gICAgY29uc3QgdGFyZ2V0SWRzID0gbW9uaXRvci5nZXRUYXJnZXRJZHMoKS5maWx0ZXIobW9uaXRvci5jYW5Ecm9wT25UYXJnZXQsIG1vbml0b3IpO1xuICAgIHRhcmdldElkcy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHRhcmdldElkcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5kRHJhZyhtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVuZERyYWcoKSB7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHZlcmlmeUlzRHJhZ2dpbmcobW9uaXRvcik7XG4gICAgICAgIGNvbnN0IHNvdXJjZUlkID0gbW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICBpZiAoc291cmNlSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gcmVnaXN0cnkuZ2V0U291cmNlKHNvdXJjZUlkLCB0cnVlKTtcbiAgICAgICAgICAgIHNvdXJjZS5lbmREcmFnKG1vbml0b3IsIHNvdXJjZUlkKTtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LnVucGluU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IEVORF9EUkFHXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUlzRHJhZ2dpbmcobW9uaXRvcikge1xuICAgIGludmFyaWFudChtb25pdG9yLmlzRHJhZ2dpbmcoKSwgJ0Nhbm5vdCBjYWxsIGVuZERyYWcgd2hpbGUgbm90IGRyYWdnaW5nLicpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzVHlwZSh0YXJnZXRUeXBlLCBkcmFnZ2VkSXRlbVR5cGUpIHtcbiAgICBpZiAoZHJhZ2dlZEl0ZW1UeXBlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRUeXBlID09PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXRUeXBlKSA/IHRhcmdldFR5cGUuc29tZSgodCk9PnQgPT09IGRyYWdnZWRJdGVtVHlwZVxuICAgICkgOiB0YXJnZXRUeXBlID09PSBkcmFnZ2VkSXRlbVR5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvdmVyKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaG92ZXIodGFyZ2V0SWRzQXJnLCB7IGNsaWVudE9mZnNldCAgfSA9IHt9KSB7XG4gICAgICAgIHZlcmlmeVRhcmdldElkc0lzQXJyYXkodGFyZ2V0SWRzQXJnKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWRzID0gdGFyZ2V0SWRzQXJnLnNsaWNlKDApO1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbVR5cGUgPSBtb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgICAgIHJlbW92ZU5vbk1hdGNoaW5nVGFyZ2V0SWRzKHRhcmdldElkcywgcmVnaXN0cnksIGRyYWdnZWRJdGVtVHlwZSk7XG4gICAgICAgIGNoZWNrSW52YXJpYW50cyh0YXJnZXRJZHMsIG1vbml0b3IsIHJlZ2lzdHJ5KTtcbiAgICAgICAgaG92ZXJBbGxUYXJnZXRzKHRhcmdldElkcywgbW9uaXRvciwgcmVnaXN0cnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogSE9WRVIsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzLFxuICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogY2xpZW50T2Zmc2V0IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5VGFyZ2V0SWRzSXNBcnJheSh0YXJnZXRJZHNBcmcpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh0YXJnZXRJZHNBcmcpLCAnRXhwZWN0ZWQgdGFyZ2V0SWRzIHRvIGJlIGFuIGFycmF5LicpO1xufVxuZnVuY3Rpb24gY2hlY2tJbnZhcmlhbnRzKHRhcmdldElkcywgbW9uaXRvciwgcmVnaXN0cnkpIHtcbiAgICBpbnZhcmlhbnQobW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBob3ZlciB3aGlsZSBub3QgZHJhZ2dpbmcuJyk7XG4gICAgaW52YXJpYW50KCFtb25pdG9yLmRpZERyb3AoKSwgJ0Nhbm5vdCBjYWxsIGhvdmVyIGFmdGVyIGRyb3AuJyk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRhcmdldElkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0SWRzW2ldO1xuICAgICAgICBpbnZhcmlhbnQodGFyZ2V0SWRzLmxhc3RJbmRleE9mKHRhcmdldElkKSA9PT0gaSwgJ0V4cGVjdGVkIHRhcmdldElkcyB0byBiZSB1bmlxdWUgaW4gdGhlIHBhc3NlZCBhcnJheS4nKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVnaXN0cnkuZ2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaW52YXJpYW50KHRhcmdldCwgJ0V4cGVjdGVkIHRhcmdldElkcyB0byBiZSByZWdpc3RlcmVkLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZU5vbk1hdGNoaW5nVGFyZ2V0SWRzKHRhcmdldElkcywgcmVnaXN0cnksIGRyYWdnZWRJdGVtVHlwZSkge1xuICAgIC8vIFJlbW92ZSB0aG9zZSB0YXJnZXRJZHMgdGhhdCBkb24ndCBtYXRjaCB0aGUgdGFyZ2V0VHlwZS4gIFRoaXNcbiAgICAvLyBmaXhlcyBzaGFsbG93IGlzT3ZlciB3aGljaCB3b3VsZCBvbmx5IGJlIG5vbi1zaGFsbG93IGJlY2F1c2Ugb2ZcbiAgICAvLyBub24tbWF0Y2hpbmcgdGFyZ2V0cy5cbiAgICBmb3IobGV0IGkgPSB0YXJnZXRJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldElkc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHJlZ2lzdHJ5LmdldFRhcmdldFR5cGUodGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIW1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgIHRhcmdldElkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBob3ZlckFsbFRhcmdldHModGFyZ2V0SWRzLCBtb25pdG9yLCByZWdpc3RyeSkge1xuICAgIC8vIEZpbmFsbHkgY2FsbCBob3ZlciBvbiBhbGwgbWF0Y2hpbmcgdGFyZ2V0cy5cbiAgICB0YXJnZXRJZHMuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSByZWdpc3RyeS5nZXRUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXQuaG92ZXIobW9uaXRvciwgdGFyZ2V0SWQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQdWJsaXNoRHJhZ1NvdXJjZShtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHB1Ymxpc2hEcmFnU291cmNlKCkge1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGlmIChtb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQVUJMSVNIX0RSQUdfU09VUkNFXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEcmFnRHJvcEFjdGlvbnMobWFuYWdlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZ2luRHJhZzogY3JlYXRlQmVnaW5EcmFnKG1hbmFnZXIpLFxuICAgICAgICBwdWJsaXNoRHJhZ1NvdXJjZTogY3JlYXRlUHVibGlzaERyYWdTb3VyY2UobWFuYWdlciksXG4gICAgICAgIGhvdmVyOiBjcmVhdGVIb3ZlcihtYW5hZ2VyKSxcbiAgICAgICAgZHJvcDogY3JlYXRlRHJvcChtYW5hZ2VyKSxcbiAgICAgICAgZW5kRHJhZzogY3JlYXRlRW5kRHJhZyhtYW5hZ2VyKVxuICAgIH07XG59XG5cbmNsYXNzIERyYWdEcm9wTWFuYWdlckltcGwge1xuICAgIHJlY2VpdmVCYWNrZW5kKGJhY2tlbmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG4gICAgZ2V0TW9uaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9uaXRvcjtcbiAgICB9XG4gICAgZ2V0QmFja2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZDtcbiAgICB9XG4gICAgZ2V0UmVnaXN0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbml0b3IucmVnaXN0cnk7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyAqLyBjb25zdCBtYW5hZ2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkaXNwYXRjaCAgfSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25DcmVhdG9yLmFwcGx5KG1hbmFnZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGNyZWF0ZURyYWdEcm9wQWN0aW9ucyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFjdGlvbnMpLnJlZHVjZSgoYm91bmRBY3Rpb25zLCBrZXkpPT57XG4gICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW2tleV07XG4gICAgICAgICAgICBib3VuZEFjdGlvbnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRBY3Rpb25zO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0b3JlLCBtb25pdG9yKXtcbiAgICAgICAgdGhpcy5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVmQ291bnRDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2V0VXAgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkucmVmQ291bnQgPiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFja2VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTZXRVcCAmJiAhdGhpcy5pc1NldFVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja2VuZC5zZXR1cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU2V0VXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNob3VsZFNldFVwICYmIHRoaXMuaXNTZXRVcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tlbmQudGVhcmRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgICAgIHN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZVJlZkNvdW50Q2hhbmdlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29vcmRpbmF0ZSBhZGRpdGlvblxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgY29vcmRpbmF0ZVxuICovIGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogYS54ICsgYi54LFxuICAgICAgICB5OiBhLnkgKyBiLnlcbiAgICB9O1xufVxuLyoqXG4gKiBDb29yZGluYXRlIHN1YnRyYWN0aW9uXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgY29vcmRpbmF0ZVxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBjb29yZGluYXRlXG4gKi8gZnVuY3Rpb24gc3VidHJhY3QoYSwgYikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGEueCAtIGIueCxcbiAgICAgICAgeTogYS55IC0gYi55XG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIG9mIHRoZSBkcmFnIHNvdXJjZSBjb21wb25lbnQncyBwb3NpdGlvbiwgYmFzZWQgb24gaXRzIHBvc2l0aW9uXG4gKiBhdCB0aGUgdGltZSB3aGVuIHRoZSBjdXJyZW50IGRyYWcgb3BlcmF0aW9uIGhhcyBzdGFydGVkLCBhbmQgdGhlIG1vdmVtZW50IGRpZmZlcmVuY2UuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIG5vIGl0ZW0gaXMgYmVpbmcgZHJhZ2dlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgVGhlIG9mZnNldCBzdGF0ZSB0byBjb21wdXRlIGZyb21cbiAqLyBmdW5jdGlvbiBnZXRTb3VyY2VDbGllbnRPZmZzZXQoc3RhdGUpIHtcbiAgICBjb25zdCB7IGNsaWVudE9mZnNldCAsIGluaXRpYWxDbGllbnRPZmZzZXQgLCBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0ICB9ID0gc3RhdGU7XG4gICAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIWluaXRpYWxDbGllbnRPZmZzZXQgfHwgIWluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdWJ0cmFjdChhZGQoY2xpZW50T2Zmc2V0LCBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KSwgaW5pdGlhbENsaWVudE9mZnNldCk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHgseSBvZmZzZXQgYmV0d2VlbiB0aGUgY2xpZW50IG9mZnNldCBhbmQgdGhlIGluaXRpYWwgY2xpZW50IG9mZnNldFxuICpcbiAqIEBwYXJhbSBzdGF0ZSBUaGUgb2Zmc2V0IHN0YXRlIHRvIGNvbXB1dGUgZnJvbVxuICovIGZ1bmN0aW9uIGdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldChzdGF0ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50T2Zmc2V0ICwgaW5pdGlhbENsaWVudE9mZnNldCAgfSA9IHN0YXRlO1xuICAgIGlmICghY2xpZW50T2Zmc2V0IHx8ICFpbml0aWFsQ2xpZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3VidHJhY3QoY2xpZW50T2Zmc2V0LCBpbml0aWFsQ2xpZW50T2Zmc2V0KTtcbn1cblxuY29uc3QgTk9ORSA9IFtdO1xuY29uc3QgQUxMID0gW107XG5OT05FLl9fSVNfTk9ORV9fID0gdHJ1ZTtcbkFMTC5fX0lTX0FMTF9fID0gdHJ1ZTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gaGFuZGxlciBJRHMgYXJlIGRpcnR5IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gZGlydHlJZHMgVGhlIHNldCBvZiBkaXJ0eSBoYW5kbGVyIGlkc1xuICogQHBhcmFtIGhhbmRsZXJJZHMgVGhlIHNldCBvZiBoYW5kbGVyIGlkcyB0byBjaGVja1xuICovIGZ1bmN0aW9uIGFyZURpcnR5KGRpcnR5SWRzLCBoYW5kbGVySWRzKSB7XG4gICAgaWYgKGRpcnR5SWRzID09PSBOT05FKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpcnR5SWRzID09PSBBTEwgfHwgdHlwZW9mIGhhbmRsZXJJZHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25JZHMgPSBpbnRlcnNlY3Rpb24oaGFuZGxlcklkcywgZGlydHlJZHMpO1xuICAgIHJldHVybiBjb21tb25JZHMubGVuZ3RoID4gMDtcbn1cblxuY2xhc3MgRHJhZ0Ryb3BNb25pdG9ySW1wbCB7XG4gICAgc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShsaXN0ZW5lciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlcklkcyAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicsICdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgaGFuZGxlcklkcyA9PT0gJ3VuZGVmaW5lZCcgfHwgQXJyYXkuaXNBcnJheShoYW5kbGVySWRzKSwgJ2hhbmRsZXJJZHMsIHdoZW4gc3BlY2lmaWVkLCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuJyk7XG4gICAgICAgIGxldCBwcmV2U3RhdGVJZCA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5zdGF0ZUlkO1xuICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGVJZCA9IHN0YXRlLnN0YXRlSWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhblNraXBMaXN0ZW5lciA9IGN1cnJlbnRTdGF0ZUlkID09PSBwcmV2U3RhdGVJZCB8fCBjdXJyZW50U3RhdGVJZCA9PT0gcHJldlN0YXRlSWQgKyAxICYmICFhcmVEaXJ0eShzdGF0ZS5kaXJ0eUhhbmRsZXJJZHMsIGhhbmRsZXJJZHMpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuU2tpcExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHByZXZTdGF0ZUlkID0gY3VycmVudFN0YXRlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2UpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb09mZnNldENoYW5nZShsaXN0ZW5lcikge1xuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nLCAnbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICBsZXQgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT2Zmc2V0O1xuICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXRlID09PSBwcmV2aW91c1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2UpO1xuICAgIH1cbiAgICBjYW5EcmFnU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIGlmICghc291cmNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlZ2lzdHJ5LmdldFNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAgIGludmFyaWFudChzb3VyY2UsIGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgc291cmNlLiBzb3VyY2VJZD0ke3NvdXJjZUlkfWApO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlLmNhbkRyYWcodGhpcywgc291cmNlSWQpO1xuICAgIH1cbiAgICBjYW5Ecm9wT25UYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIG9uIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIGlmICghdGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnJlZ2lzdHJ5LmdldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGludmFyaWFudCh0YXJnZXQsIGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgdGFyZ2V0LiB0YXJnZXRJZD0ke3RhcmdldElkfWApO1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpIHx8IHRoaXMuZGlkRHJvcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtVHlwZSA9IHRoaXMuZ2V0SXRlbVR5cGUoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkgJiYgdGFyZ2V0LmNhbkRyb3AodGhpcywgdGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldEl0ZW1UeXBlKCkpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBvbiBpbml0aWFsIHJlbmRlclxuICAgICAgICBpZiAoIXNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5yZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQsIHRydWUpO1xuICAgICAgICBpbnZhcmlhbnQoc291cmNlLCBgRXhwZWN0ZWQgdG8gZmluZCBhIHZhbGlkIHNvdXJjZS4gc291cmNlSWQ9JHtzb3VyY2VJZH1gKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhdGhpcy5pc1NvdXJjZVB1YmxpYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlVHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0U291cmNlVHlwZShzb3VyY2VJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtVHlwZSA9IHRoaXMuZ2V0SXRlbVR5cGUoKTtcbiAgICAgICAgaWYgKHNvdXJjZVR5cGUgIT09IGRyYWdnZWRJdGVtVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UuaXNEcmFnZ2luZyh0aGlzLCBzb3VyY2VJZCk7XG4gICAgfVxuICAgIGlzT3ZlclRhcmdldCh0YXJnZXRJZCwgb3B0aW9ucyA9IHtcbiAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICB9KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBvbiBpbml0aWFsIHJlbmRlclxuICAgICAgICBpZiAoIXRhcmdldElkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ICB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSB0aGlzLnJlZ2lzdHJ5LmdldFRhcmdldFR5cGUodGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbVR5cGUgPSB0aGlzLmdldEl0ZW1UeXBlKCk7XG4gICAgICAgIGlmIChkcmFnZ2VkSXRlbVR5cGUgJiYgIW1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJZHMgPSB0aGlzLmdldFRhcmdldElkcygpO1xuICAgICAgICBpZiAoIXRhcmdldElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRhcmdldElkcy5pbmRleE9mKHRhcmdldElkKTtcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gdGFyZ2V0SWRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJdGVtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLml0ZW1UeXBlO1xuICAgIH1cbiAgICBnZXRJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uaXRlbTtcbiAgICB9XG4gICAgZ2V0U291cmNlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5zb3VyY2VJZDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0SWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24udGFyZ2V0SWRzO1xuICAgIH1cbiAgICBnZXREcm9wUmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uZHJvcFJlc3VsdDtcbiAgICB9XG4gICAgZGlkRHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLmRpZERyb3A7XG4gICAgfVxuICAgIGlzU291cmNlUHVibGljKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5pc1NvdXJjZVB1YmxpYyk7XG4gICAgfVxuICAgIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldC5pbml0aWFsQ2xpZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldDtcbiAgICB9XG4gICAgZ2V0Q2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuY2xpZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRTb3VyY2VDbGllbnRPZmZzZXQodGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQpO1xuICAgIH1cbiAgICBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQodGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSwgcmVnaXN0cnkpe1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICB9XG59XG5cbi8vIFNhZmFyaSA2IGFuZCA2LjEgZm9yIGRlc2t0b3AsIGlQYWQsIGFuZCBpUGhvbmUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXRcbi8vIGhhdmUgV2ViS2l0TXV0YXRpb25PYnNlcnZlciBidXQgbm90IHVuLXByZWZpeGVkIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXN0IHVzZSBgZ2xvYmFsYCBvciBgc2VsZmAgaW5zdGVhZCBvZiBgd2luZG93YCB0byB3b3JrIGluIGJvdGggZnJhbWVzIGFuZCB3ZWJcbi8vIHdvcmtlcnMuIGBnbG9iYWxgIGlzIGEgcHJvdmlzaW9uIG9mIEJyb3dzZXJpZnksIE1yLCBNcnMsIG9yIE1vcC5cbi8qIGdsb2JhbHMgc2VsZiAqLyBjb25zdCBzY29wZSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogc2VsZjtcbmNvbnN0IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gc2NvcGUuTXV0YXRpb25PYnNlcnZlciB8fCBzY29wZS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIGNvbnN0IGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoaGFuZGxlVGltZXIsIDUwKTtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRvZ2dsZSA9IDE7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7XG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuY29uc3QgbWFrZVJlcXVlc3RDYWxsID0gdHlwZW9mIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nID8gLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xubWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIgOiAvLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG4vLyBUaW1lcnMgYXJlIGltcGxlbWVudGVkIHVuaXZlcnNhbGx5LlxuLy8gV2UgZmFsbCBiYWNrIHRvIHRpbWVycyBpbiB3b3JrZXJzIGluIG1vc3QgZW5naW5lcywgYW5kIGluIGZvcmVncm91bmRcbi8vIGNvbnRleHRzIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnMuXG4vLyBIb3dldmVyLCBub3RlIHRoYXQgZXZlbiB0aGlzIHNpbXBsZSBjYXNlIHJlcXVpcmVzIG51YW5jZXMgdG8gb3BlcmF0ZSBpbiBhXG4vLyBicm9hZCBzcGVjdHJ1bSBvZiBicm93c2Vycy5cbi8vXG4vLyAtIEZpcmVmb3ggMy0xM1xuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciA2LTlcbi8vIC0gaVBhZCBTYWZhcmkgNC4zXG4vLyAtIEx5bnggMi44Ljdcbm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuY2xhc3MgQXNhcFF1ZXVlIHtcbiAgICAvLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4gICAgLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIElPLCBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlZHJhd1xuICAgIC8vIGV2ZW50cyBpbiBicm93c2Vycy5cbiAgICAvL1xuICAgIC8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4gICAgLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4gICAgLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuICAgIC8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuICAgIC8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4gICAgLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgICBjb25zdCB7IHF1ZXVlOiBxICwgcmVxdWVzdEZsdXNoICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICBxW3EubGVuZ3RoXSA9IHRhc2s7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuICAgICAgICAvLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbiAgICAgICAgdGhpcy5wZW5kaW5nRXJyb3JzID0gW107XG4gICAgICAgIC8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4gICAgICAgIC8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbiAgICAgICAgLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4gICAgICAgIC8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuICAgICAgICAvLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4gICAgICAgIC8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gMTAyNDtcbiAgICAgICAgLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbiAgICAgICAgLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbiAgICAgICAgLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4gICAgICAgIC8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuICAgICAgICAvLyBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICB0aGlzLmZsdXNoID0gKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgcXVldWU6IHEgIH0gPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUodGhpcy5pbmRleCA8IHEubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgIHFbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID4gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxLmxlbmd0aCAtIHRoaXMuaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3NjYW5dID0gcVtzY2FuICsgdGhpcy5pbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcS5sZW5ndGggLT0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHR1cm4uXG4gICAgICAgIHRoaXMucmVnaXN0ZXJQZW5kaW5nRXJyb3IgPSAoZXJyKT0+e1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEVycm9yVGhyb3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYHJlcXVlc3RGbHVzaGAgcmVxdWVzdHMgdGhhdCB0aGUgaGlnaCBwcmlvcml0eSBldmVudCBxdWV1ZSBiZSBmbHVzaGVkIGFzXG4gICAgICAgIC8vIHNvb24gYXMgcG9zc2libGUuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuICAgICAgICAvLyBxdWV1ZSBpZiB0aGUgZXhjZXB0aW9uIGhhbmRsZWQgYnkgTm9kZS5qc+KAmXNcbiAgICAgICAgLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG4gICAgICAgIC8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuICAgICAgICAvLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMW1HLTVVWUd1cDVxeEdkRU1Xa2hQNkJXQ3owNTNOVWIyRTFRb1VUVTE2dUEvZWRpdCNnaWQ9NzgzNzI0NTkzXG4gICAgICAgIHRoaXMucmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsKHRoaXMuZmx1c2gpO1xuICAgICAgICB0aGlzLnJlcXVlc3RFcnJvclRocm93ID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKCgpPT57XG4gICAgICAgICAgICAvLyBUaHJvdyBmaXJzdCBlcnJvclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSAvLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbiAvLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4gLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAvLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4gLy8gcGFnZSdzIGZpcnN0IGxvYWQuIFRoYW5rZnVsbHksIHRoaXMgdmVyc2lvbiBvZiBTYWZhcmkgc3VwcG9ydHNcbiAvLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuIC8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NZXNzYWdlQ2hhbm5lbChjYWxsYmFjaykge1xuIC8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuIC8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuIC8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuIC8vICAgICB9O1xuIC8vIH1cbiAvLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbiAvLyB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbiAvLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuIC8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4gLy8gYHNldEltbWVkaWF0ZWAgbXVzdCBiZSBjYWxsZWQgKmJ5IG5hbWUqIGFuZCB0aGVyZWZvcmUgbXVzdCBiZSB3cmFwcGVkIGluIGFcbiAvLyBjbG9zdXJlLlxuIC8vIE5ldmVyIGZvcmdldC5cbiAvLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAvLyAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gLy8gICAgIH07XG4gLy8gfVxuIC8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuIC8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuIC8vIG11dGF0aW9uIG9ic2VydmVycywgc28gdGhhdCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGluc3RlYWQuXG4gLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuIC8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuIC8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuIC8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3RcbiAvLyBldmVuIHRoZW4uXG4gLy8gVGhpcyBpcyBmb3IgYGFzYXAuanNgIG9ubHkuXG4gLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbiAvLyAvLyBpdHMgZXhpc3RlbmNlLlxuIC8vIHJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyXG4gLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4gLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbiAvLyBhbWVuZG1lbnRzLiBUaGVzZSBkZWNpc2lvbnMsIHBhcnRpY3VsYXJseSB0byBtYXJnaW5hbGl6ZSBNZXNzYWdlQ2hhbm5lbCBhbmRcbiAvLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4gLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9jZGRmNzIzMjU0NmE5Y2Y4NTg1MjRiNzVjZGU2ZjllZGY3MjYyMGE3L2xpYi9yc3ZwL2FzYXAuanNcblxuLy8gYGNhbGxgLCBqdXN0IGxpa2UgYSBmdW5jdGlvbi5cbmNsYXNzIFJhd1Rhc2sge1xuICAgIGNhbGwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRhc2sgJiYgdGhpcy50YXNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9uRXJyb3IsIHJlbGVhc2Upe1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgICB0aGlzLnJlbGVhc2UgPSByZWxlYXNlO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbn1cblxuY2xhc3MgVGFza0ZhY3Rvcnkge1xuICAgIGNyZWF0ZSh0YXNrKSB7XG4gICAgICAgIGNvbnN0IHRhc2tzID0gdGhpcy5mcmVlVGFza3M7XG4gICAgICAgIGNvbnN0IHQxID0gdGFza3MubGVuZ3RoID8gdGFza3MucG9wKCkgOiBuZXcgUmF3VGFzayh0aGlzLm9uRXJyb3IsICh0KT0+dGFza3NbdGFza3MubGVuZ3RoXSA9IHRcbiAgICAgICAgKTtcbiAgICAgICAgdDEudGFzayA9IHRhc2s7XG4gICAgICAgIHJldHVybiB0MTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob25FcnJvcil7XG4gICAgICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG4gICAgICAgIHRoaXMuZnJlZVRhc2tzID0gW107XG4gICAgfVxufVxuXG5jb25zdCBhc2FwUXVldWUgPSBuZXcgQXNhcFF1ZXVlKCk7XG5jb25zdCB0YXNrRmFjdG9yeSA9IG5ldyBUYXNrRmFjdG9yeShhc2FwUXVldWUucmVnaXN0ZXJQZW5kaW5nRXJyb3IpO1xuLyoqXG4gKiBDYWxscyBhIHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciByZXR1cm5pbmcsIGluIGl0cyBvd24gZXZlbnQsIHdpdGggcHJpb3JpdHlcbiAqIG92ZXIgb3RoZXIgZXZlbnRzIGxpa2UgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZXBhaW50LiBBbiBlcnJvciB0aHJvd24gZnJvbSBhblxuICogZXZlbnQgd2lsbCBub3QgaW50ZXJydXB0LCBub3IgZXZlbiBzdWJzdGFudGlhbGx5IHNsb3cgZG93biB0aGUgcHJvY2Vzc2luZyBvZlxuICogb3RoZXIgZXZlbnRzLCBidXQgd2lsbCBiZSByYXRoZXIgcG9zdHBvbmVkIHRvIGEgbG93ZXIgcHJpb3JpdHkgZXZlbnQuXG4gKiBAcGFyYW0ge3tjYWxsfX0gdGFzayBBIGNhbGxhYmxlIG9iamVjdCwgdHlwaWNhbGx5IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzLlxuICovIGZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIGFzYXBRdWV1ZS5lbnF1ZXVlVGFzayh0YXNrRmFjdG9yeS5jcmVhdGUodGFzaykpO1xufVxuXG5jb25zdCBBRERfU09VUkNFID0gJ2RuZC1jb3JlL0FERF9TT1VSQ0UnO1xuY29uc3QgQUREX1RBUkdFVCA9ICdkbmQtY29yZS9BRERfVEFSR0VUJztcbmNvbnN0IFJFTU9WRV9TT1VSQ0UgPSAnZG5kLWNvcmUvUkVNT1ZFX1NPVVJDRSc7XG5jb25zdCBSRU1PVkVfVEFSR0VUID0gJ2RuZC1jb3JlL1JFTU9WRV9UQVJHRVQnO1xuZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogQUREX1NPVVJDRSxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgc291cmNlSWRcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBBRERfVEFSR0VULFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICB0YXJnZXRJZFxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZShzb3VyY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJFTU9WRV9TT1VSQ0UsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHNvdXJjZUlkXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUkVNT1ZFX1RBUkdFVCxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgdGFyZ2V0SWRcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU291cmNlQ29udHJhY3Qoc291cmNlKSB7XG4gICAgaW52YXJpYW50KHR5cGVvZiBzb3VyY2UuY2FuRHJhZyA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIGNhbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHNvdXJjZS5iZWdpbkRyYWcgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBiZWdpbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHNvdXJjZS5lbmREcmFnID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgZW5kRHJhZyB0byBiZSBhIGZ1bmN0aW9uLicpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRDb250cmFjdCh0YXJnZXQpIHtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHRhcmdldC5jYW5Ecm9wID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgY2FuRHJvcCB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIGludmFyaWFudCh0eXBlb2YgdGFyZ2V0LmhvdmVyID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgaG92ZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHRhcmdldC5kcm9wID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgYmVnaW5EcmFnIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZSwgYWxsb3dBcnJheSkge1xuICAgIGlmIChhbGxvd0FycmF5ICYmIEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZS5mb3JFYWNoKCh0KT0+dmFsaWRhdGVUeXBlKHQsIGZhbHNlKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnLCBhbGxvd0FycmF5ID8gJ1R5cGUgY2FuIG9ubHkgYmUgYSBzdHJpbmcsIGEgc3ltYm9sLCBvciBhbiBhcnJheSBvZiBlaXRoZXIuJyA6ICdUeXBlIGNhbiBvbmx5IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sLicpO1xufVxuXG52YXIgSGFuZGxlclJvbGU7XG4oZnVuY3Rpb24oSGFuZGxlclJvbGUpIHtcbiAgICBIYW5kbGVyUm9sZVtcIlNPVVJDRVwiXSA9IFwiU09VUkNFXCI7XG4gICAgSGFuZGxlclJvbGVbXCJUQVJHRVRcIl0gPSBcIlRBUkdFVFwiO1xufSkoSGFuZGxlclJvbGUgfHwgKEhhbmRsZXJSb2xlID0ge30pKTtcblxubGV0IG5leHRVbmlxdWVJZCA9IDA7XG5mdW5jdGlvbiBnZXROZXh0VW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIG5leHRVbmlxdWVJZCsrO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SGFuZGxlcklkKHJvbGUpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRVbmlxdWVJZCgpLnRvU3RyaW5nKCk7XG4gICAgc3dpdGNoKHJvbGUpe1xuICAgICAgICBjYXNlIEhhbmRsZXJSb2xlLlNPVVJDRTpcbiAgICAgICAgICAgIHJldHVybiBgUyR7aWR9YDtcbiAgICAgICAgY2FzZSBIYW5kbGVyUm9sZS5UQVJHRVQ6XG4gICAgICAgICAgICByZXR1cm4gYFQke2lkfWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSGFuZGxlciBSb2xlOiAke3JvbGV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpIHtcbiAgICBzd2l0Y2goaGFuZGxlcklkWzBdKXtcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICByZXR1cm4gSGFuZGxlclJvbGUuU09VUkNFO1xuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHJldHVybiBIYW5kbGVyUm9sZS5UQVJHRVQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBoYW5kbGVyIElEOiAke2hhbmRsZXJJZH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDb250YWluc1ZhbHVlKG1hcCwgc2VhcmNoVmFsdWUpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gbWFwLmVudHJpZXMoKTtcbiAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgZG8ge1xuICAgICAgICBjb25zdCB7IGRvbmUgLCB2YWx1ZTogWywgdmFsdWVdICwgIH0gPSBlbnRyaWVzLm5leHQoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBzZWFyY2hWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNEb25lID0gISFkb25lO1xuICAgIH13aGlsZSAoIWlzRG9uZSlcbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBIYW5kbGVyUmVnaXN0cnlJbXBsIHtcbiAgICBhZGRTb3VyY2UodHlwZSwgc291cmNlKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZSh0eXBlKTtcbiAgICAgICAgdmFsaWRhdGVTb3VyY2VDb250cmFjdChzb3VyY2UpO1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IHRoaXMuYWRkSGFuZGxlcihIYW5kbGVyUm9sZS5TT1VSQ0UsIHR5cGUsIHNvdXJjZSk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWRkU291cmNlKHNvdXJjZUlkKSk7XG4gICAgICAgIHJldHVybiBzb3VyY2VJZDtcbiAgICB9XG4gICAgYWRkVGFyZ2V0KHR5cGUsIHRhcmdldCkge1xuICAgICAgICB2YWxpZGF0ZVR5cGUodHlwZSwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlVGFyZ2V0Q29udHJhY3QodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB0aGlzLmFkZEhhbmRsZXIoSGFuZGxlclJvbGUuVEFSR0VULCB0eXBlLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFkZFRhcmdldCh0YXJnZXRJZCkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgfVxuICAgIGNvbnRhaW5zSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBtYXBDb250YWluc1ZhbHVlKHRoaXMuZHJhZ1NvdXJjZXMsIGhhbmRsZXIpIHx8IG1hcENvbnRhaW5zVmFsdWUodGhpcy5kcm9wVGFyZ2V0cywgaGFuZGxlcik7XG4gICAgfVxuICAgIGdldFNvdXJjZShzb3VyY2VJZCwgaW5jbHVkZVBpbm5lZCA9IGZhbHNlKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmlzU291cmNlSWQoc291cmNlSWQpLCAnRXhwZWN0ZWQgYSB2YWxpZCBzb3VyY2UgSUQuJyk7XG4gICAgICAgIGNvbnN0IGlzUGlubmVkID0gaW5jbHVkZVBpbm5lZCAmJiBzb3VyY2VJZCA9PT0gdGhpcy5waW5uZWRTb3VyY2VJZDtcbiAgICAgICAgY29uc3Qgc291cmNlID0gaXNQaW5uZWQgPyB0aGlzLnBpbm5lZFNvdXJjZSA6IHRoaXMuZHJhZ1NvdXJjZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmlzVGFyZ2V0SWQodGFyZ2V0SWQpLCAnRXhwZWN0ZWQgYSB2YWxpZCB0YXJnZXQgSUQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXRzLmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGdldFNvdXJjZVR5cGUoc291cmNlSWQpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuaXNTb3VyY2VJZChzb3VyY2VJZCksICdFeHBlY3RlZCBhIHZhbGlkIHNvdXJjZSBJRC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5pc1RhcmdldElkKHRhcmdldElkKSwgJ0V4cGVjdGVkIGEgdmFsaWQgdGFyZ2V0IElELicpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlcy5nZXQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpc1NvdXJjZUlkKGhhbmRsZXJJZCkge1xuICAgICAgICBjb25zdCByb2xlID0gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICByZXR1cm4gcm9sZSA9PT0gSGFuZGxlclJvbGUuU09VUkNFO1xuICAgIH1cbiAgICBpc1RhcmdldElkKGhhbmRsZXJJZCkge1xuICAgICAgICBjb25zdCByb2xlID0gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICByZXR1cm4gcm9sZSA9PT0gSGFuZGxlclJvbGUuVEFSR0VUO1xuICAgIH1cbiAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuZ2V0U291cmNlKHNvdXJjZUlkKSwgJ0V4cGVjdGVkIGFuIGV4aXN0aW5nIHNvdXJjZS4nKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChyZW1vdmVTb3VyY2Uoc291cmNlSWQpKTtcbiAgICAgICAgYXNhcCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy50eXBlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmdldFRhcmdldCh0YXJnZXRJZCksICdFeHBlY3RlZCBhbiBleGlzdGluZyB0YXJnZXQuJyk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gocmVtb3ZlVGFyZ2V0KHRhcmdldElkKSk7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgdGhpcy50eXBlcy5kZWxldGUodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBwaW5Tb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRTb3VyY2Uoc291cmNlSWQpO1xuICAgICAgICBpbnZhcmlhbnQoc291cmNlLCAnRXhwZWN0ZWQgYW4gZXhpc3Rpbmcgc291cmNlLicpO1xuICAgICAgICB0aGlzLnBpbm5lZFNvdXJjZUlkID0gc291cmNlSWQ7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICB1bnBpblNvdXJjZSgpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMucGlubmVkU291cmNlLCAnTm8gc291cmNlIGlzIHBpbm5lZCBhdCB0aGUgdGltZS4nKTtcbiAgICAgICAgdGhpcy5waW5uZWRTb3VyY2VJZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihyb2xlLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0TmV4dEhhbmRsZXJJZChyb2xlKTtcbiAgICAgICAgdGhpcy50eXBlcy5zZXQoaWQsIHR5cGUpO1xuICAgICAgICBpZiAocm9sZSA9PT0gSGFuZGxlclJvbGUuU09VUkNFKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAocm9sZSA9PT0gSGFuZGxlclJvbGUuVEFSR0VUKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXRzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSl7XG4gICAgICAgIHRoaXMudHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbm5lZFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG59XG5cbmNvbnN0IHN0cmljdEVxdWFsaXR5ID0gKGEsIGIpPT5hID09PSBiXG47XG4vKipcbiAqIERldGVybWluZSBpZiB0d28gY2FydGVzaWFuIGNvb3JkaW5hdGUgb2Zmc2V0cyBhcmUgZXF1YWxcbiAqIEBwYXJhbSBvZmZzZXRBXG4gKiBAcGFyYW0gb2Zmc2V0QlxuICovIGZ1bmN0aW9uIGFyZUNvb3Jkc0VxdWFsKG9mZnNldEEsIG9mZnNldEIpIHtcbiAgICBpZiAoIW9mZnNldEEgJiYgIW9mZnNldEIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghb2Zmc2V0QSB8fCAhb2Zmc2V0Qikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldEEueCA9PT0gb2Zmc2V0Qi54ICYmIG9mZnNldEEueSA9PT0gb2Zmc2V0Qi55O1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0d28gYXJyYXlzIG9mIGl0ZW1zIGFyZSBlcXVhbFxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGFycmF5IG9mIGl0ZW1zXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGFycmF5IG9mIGl0ZW1zXG4gKi8gZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYiwgaXNFcXVhbCA9IHN0cmljdEVxdWFsaXR5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaWYgKCFpc0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZSQ1KC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9zdGF0ZSA9IE5PTkUsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgSE9WRVI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBRERfU09VUkNFOlxuICAgICAgICBjYXNlIEFERF9UQVJHRVQ6XG4gICAgICAgIGNhc2UgUkVNT1ZFX1RBUkdFVDpcbiAgICAgICAgY2FzZSBSRU1PVkVfU09VUkNFOlxuICAgICAgICAgICAgcmV0dXJuIE5PTkU7XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgY2FzZSBQVUJMSVNIX0RSQUdfU09VUkNFOlxuICAgICAgICBjYXNlIEVORF9EUkFHOlxuICAgICAgICBjYXNlIERST1A6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQUxMO1xuICAgIH1cbiAgICBjb25zdCB7IHRhcmdldElkcyA9W10gLCBwcmV2VGFyZ2V0SWRzID1bXSAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHJlc3VsdCA9IHhvcih0YXJnZXRJZHMsIHByZXZUYXJnZXRJZHMpO1xuICAgIGNvbnN0IGRpZENoYW5nZSA9IHJlc3VsdC5sZW5ndGggPiAwIHx8ICFhcmVBcnJheXNFcXVhbCh0YXJnZXRJZHMsIHByZXZUYXJnZXRJZHMpO1xuICAgIGlmICghZGlkQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBOT05FO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgdGFyZ2V0IGlkcyBhdCB0aGUgaW5uZXJtb3N0IHBvc2l0aW9uLiBJZiB0aGV5IGFyZSB2YWxpZCwgYWRkIHRoZW1cbiAgICAvLyB0byB0aGUgcmVzdWx0XG4gICAgY29uc3QgcHJldklubmVybW9zdFRhcmdldElkID0gcHJldlRhcmdldElkc1twcmV2VGFyZ2V0SWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGlubmVybW9zdFRhcmdldElkID0gdGFyZ2V0SWRzW3RhcmdldElkcy5sZW5ndGggLSAxXTtcbiAgICBpZiAocHJldklubmVybW9zdFRhcmdldElkICE9PSBpbm5lcm1vc3RUYXJnZXRJZCkge1xuICAgICAgICBpZiAocHJldklubmVybW9zdFRhcmdldElkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwcmV2SW5uZXJtb3N0VGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbm5lcm1vc3RUYXJnZXRJZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5uZXJtb3N0VGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQzKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5JDModGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBpbml0aWFsU3RhdGUkMSA9IHtcbiAgICBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0OiBudWxsLFxuICAgIGluaXRpYWxDbGllbnRPZmZzZXQ6IG51bGwsXG4gICAgY2xpZW50T2Zmc2V0OiBudWxsXG59O1xuZnVuY3Rpb24gcmVkdWNlJDQoc3RhdGUgPSBpbml0aWFsU3RhdGUkMSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkICB9ID0gYWN0aW9uO1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgSU5JVF9DT09SRFM6XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldDogcGF5bG9hZC5zb3VyY2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbENsaWVudE9mZnNldDogcGF5bG9hZC5jbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBwYXlsb2FkLmNsaWVudE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBIT1ZFUjpcbiAgICAgICAgICAgIGlmIChhcmVDb29yZHNFcXVhbChzdGF0ZS5jbGllbnRPZmZzZXQsIHBheWxvYWQuY2xpZW50T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBwYXlsb2FkLmNsaWVudE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgRU5EX0RSQUc6XG4gICAgICAgIGNhc2UgRFJPUDpcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsU3RhdGUkMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQyKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5JDIodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgaXRlbVR5cGU6IG51bGwsXG4gICAgaXRlbTogbnVsbCxcbiAgICBzb3VyY2VJZDogbnVsbCxcbiAgICB0YXJnZXRJZHM6IFtdLFxuICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgZGlkRHJvcDogZmFsc2UsXG4gICAgaXNTb3VyY2VQdWJsaWM6IG51bGxcbn07XG5mdW5jdGlvbiByZWR1Y2UkMyhzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkICB9ID0gYWN0aW9uO1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDIoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgaXRlbVR5cGU6IHBheWxvYWQuaXRlbVR5cGUsXG4gICAgICAgICAgICAgICAgaXRlbTogcGF5bG9hZC5pdGVtLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXlsb2FkLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiBwYXlsb2FkLmlzU291cmNlUHVibGljLFxuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlkRHJvcDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIFBVQkxJU0hfRFJBR19TT1VSQ0U6XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBIT1ZFUjpcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDIoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzOiBwYXlsb2FkLnRhcmdldElkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgUkVNT1ZFX1RBUkdFVDpcbiAgICAgICAgICAgIGlmIChzdGF0ZS50YXJnZXRJZHMuaW5kZXhPZihwYXlsb2FkLnRhcmdldElkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIHRhcmdldElkczogd2l0aG91dCQxKHN0YXRlLnRhcmdldElkcywgcGF5bG9hZC50YXJnZXRJZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIERST1A6XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IHBheWxvYWQuZHJvcFJlc3VsdCxcbiAgICAgICAgICAgICAgICBkaWREcm9wOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldElkczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIEVORF9EUkFHOlxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMih7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtOiBudWxsLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBudWxsLFxuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlkRHJvcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNTb3VyY2VQdWJsaWM6IG51bGwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2UkMihzdGF0ZSA9IDAsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQUREX1NPVVJDRTpcbiAgICAgICAgY2FzZSBBRERfVEFSR0VUOlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlICsgMTtcbiAgICAgICAgY2FzZSBSRU1PVkVfU09VUkNFOlxuICAgICAgICBjYXNlIFJFTU9WRV9UQVJHRVQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgLSAxO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlJDEoc3RhdGUgPSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlICsgMTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5JDEob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkkMSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHJlZHVjZShzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXJ0eUhhbmRsZXJJZHM6IHJlZHVjZSQ1KHN0YXRlLmRpcnR5SGFuZGxlcklkcywge1xuICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkOiBfb2JqZWN0U3ByZWFkJDEoe30sIGFjdGlvbi5wYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldElkczogZ2V0KHN0YXRlLCAnZHJhZ09wZXJhdGlvbi50YXJnZXRJZHMnLCBbXSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICBkcmFnT2Zmc2V0OiByZWR1Y2UkNChzdGF0ZS5kcmFnT2Zmc2V0LCBhY3Rpb24pLFxuICAgICAgICByZWZDb3VudDogcmVkdWNlJDIoc3RhdGUucmVmQ291bnQsIGFjdGlvbiksXG4gICAgICAgIGRyYWdPcGVyYXRpb246IHJlZHVjZSQzKHN0YXRlLmRyYWdPcGVyYXRpb24sIGFjdGlvbiksXG4gICAgICAgIHN0YXRlSWQ6IHJlZHVjZSQxKHN0YXRlLnN0YXRlSWQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHJhZ0Ryb3BNYW5hZ2VyKGJhY2tlbmRGYWN0b3J5LCBnbG9iYWxDb250ZXh0ID0gdW5kZWZpbmVkLCBiYWNrZW5kT3B0aW9ucyA9IHt9LCBkZWJ1Z01vZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0b3JlID0gbWFrZVN0b3JlSW5zdGFuY2UoZGVidWdNb2RlKTtcbiAgICBjb25zdCBtb25pdG9yID0gbmV3IERyYWdEcm9wTW9uaXRvckltcGwoc3RvcmUsIG5ldyBIYW5kbGVyUmVnaXN0cnlJbXBsKHN0b3JlKSk7XG4gICAgY29uc3QgbWFuYWdlciA9IG5ldyBEcmFnRHJvcE1hbmFnZXJJbXBsKHN0b3JlLCBtb25pdG9yKTtcbiAgICBjb25zdCBiYWNrZW5kID0gYmFja2VuZEZhY3RvcnkobWFuYWdlciwgZ2xvYmFsQ29udGV4dCwgYmFja2VuZE9wdGlvbnMpO1xuICAgIG1hbmFnZXIucmVjZWl2ZUJhY2tlbmQoYmFja2VuZCk7XG4gICAgcmV0dXJuIG1hbmFnZXI7XG59XG5mdW5jdGlvbiBtYWtlU3RvcmVJbnN0YW5jZShkZWJ1Z01vZGUpIHtcbiAgICAvLyBUT0RPOiBpZiB3ZSBldmVyIG1ha2UgYSByZWFjdC1uYXRpdmUgdmVyc2lvbiBvZiB0aGlzLFxuICAgIC8vIHdlJ2xsIG5lZWQgdG8gY29uc2lkZXIgaG93IHRvIHB1bGwgb2ZmIGRldi10b29saW5nXG4gICAgY29uc3QgcmVkdXhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fO1xuICAgIHJldHVybiBjcmVhdGVTdG9yZShyZWR1Y2UsIGRlYnVnTW9kZSAmJiByZWR1eERldlRvb2xzICYmIHJlZHV4RGV2VG9vbHMoe1xuICAgICAgICBuYW1lOiAnZG5kLWNvcmUnLFxuICAgICAgICBpbnN0YW5jZUlkOiAnZG5kLWNvcmUnXG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5sZXQgcmVmQ291bnQgPSAwO1xuY29uc3QgSU5TVEFOQ0VfU1lNID0gU3ltYm9sLmZvcignX19SRUFDVF9ETkRfQ09OVEVYVF9JTlNUQU5DRV9fJyk7XG52YXIgRG5kUHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovIG1lbW8oZnVuY3Rpb24gRG5kUHJvdmlkZXIoX3BhcmFtKSB7XG4gICAgdmFyIHsgY2hpbGRyZW4gIH0gPSBfcGFyYW0sIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wYXJhbSwgW1xuICAgICAgICBcImNoaWxkcmVuXCJcbiAgICBdKTtcbiAgICBjb25zdCBbbWFuYWdlciwgaXNHbG9iYWxJbnN0YW5jZV0gPSBnZXREbmRDb250ZXh0VmFsdWUocHJvcHMpIC8vIG1lbW9pemVkIGZyb20gcHJvcHNcbiAgICA7XG4gICAgLyoqXG5cdFx0ICogSWYgdGhlIGdsb2JhbCBjb250ZXh0IHdhcyB1c2VkIHRvIHN0b3JlIHRoZSBETkQgY29udGV4dFxuXHRcdCAqIHRoZW4gd2hlcmUgdGhlcmVzIG5vIG1vcmUgcmVmZXJlbmNlcyB0byBpdCB3ZSBzaG91bGRcblx0XHQgKiBjbGVhbiBpdCB1cCB0byBhdm9pZCBtZW1vcnkgbGVha3Ncblx0XHQgKi8gdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChpc0dsb2JhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0R2xvYmFsQ29udGV4dCgpO1xuICAgICAgICAgICAgKytyZWZDb3VudDtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGlmICgtLXJlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRbSU5TVEFOQ0VfU1lNXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIGpzeChEbmRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBtYW5hZ2VyLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn0pO1xuZnVuY3Rpb24gZ2V0RG5kQ29udGV4dFZhbHVlKHByb3BzKSB7XG4gICAgaWYgKCdtYW5hZ2VyJyBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0ge1xuICAgICAgICAgICAgZHJhZ0Ryb3BNYW5hZ2VyOiBwcm9wcy5tYW5hZ2VyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYW5hZ2VyLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgbWFuYWdlciA9IGNyZWF0ZVNpbmdsZXRvbkRuZENvbnRleHQocHJvcHMuYmFja2VuZCwgcHJvcHMuY29udGV4dCwgcHJvcHMub3B0aW9ucywgcHJvcHMuZGVidWdNb2RlKTtcbiAgICBjb25zdCBpc0dsb2JhbEluc3RhbmNlID0gIXByb3BzLmNvbnRleHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFuYWdlcixcbiAgICAgICAgaXNHbG9iYWxJbnN0YW5jZVxuICAgIF07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25EbmRDb250ZXh0KGJhY2tlbmQsIGNvbnRleHQgPSBnZXRHbG9iYWxDb250ZXh0KCksIG9wdGlvbnMsIGRlYnVnTW9kZSkge1xuICAgIGNvbnN0IGN0eCA9IGNvbnRleHQ7XG4gICAgaWYgKCFjdHhbSU5TVEFOQ0VfU1lNXSkge1xuICAgICAgICBjdHhbSU5TVEFOQ0VfU1lNXSA9IHtcbiAgICAgICAgICAgIGRyYWdEcm9wTWFuYWdlcjogY3JlYXRlRHJhZ0Ryb3BNYW5hZ2VyKGJhY2tlbmQsIGNvbnRleHQsIG9wdGlvbnMsIGRlYnVnTW9kZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eFtJTlNUQU5DRV9TWU1dO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG59XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxudmFyIGZhc3REZWVwRXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxuLy8gc3VwcHJlc3MgdGhlIHVzZUxheW91dEVmZmVjdCB3YXJuaW5nIG9uIHNlcnZlciBzaWRlLlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gbW9uaXRvciBUaGUgbW9uaXRvciB0byBjb2xsZWN0IHN0YXRlIGZyb21cbiAqIEBwYXJhbSBjb2xsZWN0IFRoZSBjb2xsZWN0aW5nIGZ1bmN0aW9uXG4gKiBAcGFyYW0gb25VcGRhdGUgQSBtZXRob2QgdG8gaW52b2tlIHdoZW4gdXBkYXRlcyBvY2N1clxuICovIGZ1bmN0aW9uIHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0LCBvblVwZGF0ZSkge1xuICAgIGNvbnN0IFtjb2xsZWN0ZWQsIHNldENvbGxlY3RlZF0gPSB1c2VTdGF0ZSgoKT0+Y29sbGVjdChtb25pdG9yKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlQ29sbGVjdGVkID0gdXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY29sbGVjdChtb25pdG9yKTtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhIGRlZXAtZXF1YWxpdHkgY2hlY2sgYmVjYXVzZSBzb21lIG1vbml0b3ItY29sbGVjdGVkIHZhbHVlc1xuICAgICAgICAvLyBpbmNsdWRlIFhZQ29vcmQgb2JqZWN0cyB0aGF0IG1heSBiZSBlcXVpdmFsZW50LCBidXQgZG8gbm90IGhhdmUgaW5zdGFuY2UgZXF1YWxpdHkuXG4gICAgICAgIGlmICghZmFzdERlZXBFcXVhbChjb2xsZWN0ZWQsIG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHNldENvbGxlY3RlZChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgb25VcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgY29sbGVjdGVkLFxuICAgICAgICBtb25pdG9yLFxuICAgICAgICBvblVwZGF0ZVxuICAgIF0pO1xuICAgIC8vIHVwZGF0ZSB0aGUgY29sbGVjdGVkIHByb3BlcnRpZXMgYWZ0ZXIgcmVhY3QgcmVuZGVycy5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIFwiRHVzdGJpbiBTdHJlc3MgVGVzdFwiIGZhaWxzIGlmIHRoaXMgaXMgbm90XG4gICAgLy8gZG9uZSB3aGVuIHRoZSBjb21wb25lbnQgdXBkYXRlc1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QodXBkYXRlQ29sbGVjdGVkKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb2xsZWN0ZWQsXG4gICAgICAgIHVwZGF0ZUNvbGxlY3RlZFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZU1vbml0b3JPdXRwdXQobW9uaXRvciwgY29sbGVjdCwgb25Db2xsZWN0KSB7XG4gICAgY29uc3QgW2NvbGxlY3RlZCwgdXBkYXRlQ29sbGVjdGVkXSA9IHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0LCBvbkNvbGxlY3QpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gc3Vic2NyaWJlVG9Nb25pdG9yU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJJZCA9IG1vbml0b3IuZ2V0SGFuZGxlcklkKCk7XG4gICAgICAgIGlmIChoYW5kbGVySWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UodXBkYXRlQ29sbGVjdGVkLCB7XG4gICAgICAgICAgICBoYW5kbGVySWRzOiBbXG4gICAgICAgICAgICAgICAgaGFuZGxlcklkXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgbW9uaXRvcixcbiAgICAgICAgdXBkYXRlQ29sbGVjdGVkXG4gICAgXSk7XG4gICAgcmV0dXJuIGNvbGxlY3RlZDtcbn1cblxuZnVuY3Rpb24gdXNlQ29sbGVjdGVkUHJvcHMoY29sbGVjdG9yLCBtb25pdG9yLCBjb25uZWN0b3IpIHtcbiAgICByZXR1cm4gdXNlTW9uaXRvck91dHB1dChtb25pdG9yLCBjb2xsZWN0b3IgfHwgKCgpPT4oe30pXG4gICAgKSwgKCk9PmNvbm5lY3Rvci5yZWNvbm5lY3QoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHVzZU9wdGlvbmFsRmFjdG9yeShhcmcsIGRlcHMpIHtcbiAgICBjb25zdCBtZW1vRGVwcyA9IFtcbiAgICAgICAgLi4uZGVwcyB8fCBbXVxuICAgIF07XG4gICAgaWYgKGRlcHMgPT0gbnVsbCAmJiB0eXBlb2YgYXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1lbW9EZXBzLnB1c2goYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBhcmcoKSA6IGFyZztcbiAgICB9LCBtZW1vRGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbm5lY3REcmFnU291cmNlKGNvbm5lY3Rvcikge1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5jb25uZWN0b3IuaG9va3MuZHJhZ1NvdXJjZSgpXG4gICAgLCBbXG4gICAgICAgIGNvbm5lY3RvclxuICAgIF0pO1xufVxuZnVuY3Rpb24gdXNlQ29ubmVjdERyYWdQcmV2aWV3KGNvbm5lY3Rvcikge1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5jb25uZWN0b3IuaG9va3MuZHJhZ1ByZXZpZXcoKVxuICAgICwgW1xuICAgICAgICBjb25uZWN0b3JcbiAgICBdKTtcbn1cblxubGV0IGlzQ2FsbGluZ0NhbkRyYWcgPSBmYWxzZTtcbmxldCBpc0NhbGxpbmdJc0RyYWdnaW5nID0gZmFsc2U7XG5jbGFzcyBEcmFnU291cmNlTW9uaXRvckltcGwge1xuICAgIHJlY2VpdmVIYW5kbGVySWQoc291cmNlSWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJZCA9IHNvdXJjZUlkO1xuICAgIH1cbiAgICBnZXRIYW5kbGVySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUlkO1xuICAgIH1cbiAgICBjYW5EcmFnKCkge1xuICAgICAgICBpbnZhcmlhbnQoIWlzQ2FsbGluZ0NhbkRyYWcsICdZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuY2FuRHJhZygpIGluc2lkZSB5b3VyIGNhbkRyYWcoKSBpbXBsZW1lbnRhdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcmFnLXNvdXJjZS1tb25pdG9yJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5EcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5EcmFnU291cmNlKHRoaXMuc291cmNlSWQpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5EcmFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KCFpc0NhbGxpbmdJc0RyYWdnaW5nLCAnWW91IG1heSBub3QgY2FsbCBtb25pdG9yLmlzRHJhZ2dpbmcoKSBpbnNpZGUgeW91ciBpc0RyYWdnaW5nKCkgaW1wbGVtZW50YXRpb24uICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy9hcGkvZHJhZy1zb3VyY2UtbW9uaXRvcicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNEcmFnZ2luZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKTtcbiAgICB9XG4gICAgaXNPdmVyVGFyZ2V0KHRhcmdldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc092ZXJUYXJnZXQodGFyZ2V0SWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRJZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRUYXJnZXRJZHMoKTtcbiAgICB9XG4gICAgaXNTb3VyY2VQdWJsaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc1NvdXJjZVB1YmxpYygpO1xuICAgIH1cbiAgICBnZXRTb3VyY2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvT2Zmc2V0Q2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5zdWJzY3JpYmVUb09mZnNldENoYW5nZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIGNhbkRyYWdTb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyYWdTb3VyY2Uoc291cmNlSWQpO1xuICAgIH1cbiAgICBjYW5Ecm9wT25UYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyb3BPblRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGdldEl0ZW1UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SXRlbVR5cGUoKTtcbiAgICB9XG4gICAgZ2V0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW0oKTtcbiAgICB9XG4gICAgZ2V0RHJvcFJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldERyb3BSZXN1bHQoKTtcbiAgICB9XG4gICAgZGlkRHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmRpZERyb3AoKTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldENsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldENsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgICBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWFuYWdlcil7XG4gICAgICAgIHRoaXMuc291cmNlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVybmFsTW9uaXRvciA9IG1hbmFnZXIuZ2V0TW9uaXRvcigpO1xuICAgIH1cbn1cblxubGV0IGlzQ2FsbGluZ0NhbkRyb3AgPSBmYWxzZTtcbmNsYXNzIERyb3BUYXJnZXRNb25pdG9ySW1wbCB7XG4gICAgcmVjZWl2ZUhhbmRsZXJJZCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgfVxuICAgIGdldEhhbmRsZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0SWQ7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYW5Ecm9wKCkge1xuICAgICAgICAvLyBDdXQgb3V0IGVhcmx5IGlmIHRoZSB0YXJnZXQgaWQgaGFzIG5vdCBiZWVuIHNldC4gVGhpcyBzaG91bGQgcHJldmVudCBlcnJvcnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIHVzZXIgaGFzIGFuIG9sZGVyIHZlcnNpb24gb2YgZG5kLWNvcmUgbGlrZSBpblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvMTMxMFxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnZhcmlhbnQoIWlzQ2FsbGluZ0NhbkRyb3AsICdZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuY2FuRHJvcCgpIGluc2lkZSB5b3VyIGNhbkRyb3AoKSBpbXBsZW1lbnRhdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcm9wLXRhcmdldC1tb25pdG9yJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5Ecm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5Ecm9wT25UYXJnZXQodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlzQ2FsbGluZ0NhbkRyb3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc092ZXIob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNPdmVyVGFyZ2V0KHRoaXMudGFyZ2V0SWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRJdGVtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgfVxuICAgIGdldEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJdGVtKCk7XG4gICAgfVxuICAgIGdldERyb3BSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREcm9wUmVzdWx0KCk7XG4gICAgfVxuICAgIGRpZERyb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5kaWREcm9wKCk7XG4gICAgfVxuICAgIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldFNvdXJjZUNsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgICBnZXRDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIpe1xuICAgICAgICB0aGlzLnRhcmdldElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbE1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFyZ2V0KHR5cGUsIHRhcmdldCwgbWFuYWdlcikge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgIGNvbnN0IHRhcmdldElkID0gcmVnaXN0cnkuYWRkVGFyZ2V0KHR5cGUsIHRhcmdldCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGFyZ2V0SWQsXG4gICAgICAgICgpPT5yZWdpc3RyeS5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU291cmNlKHR5cGUsIHNvdXJjZSwgbWFuYWdlcikge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgIGNvbnN0IHNvdXJjZUlkID0gcmVnaXN0cnkuYWRkU291cmNlKHR5cGUsIHNvdXJjZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgICgpPT5yZWdpc3RyeS5yZW1vdmVTb3VyY2Uoc291cmNlSWQpXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG4gICAgbGV0IGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcbiAgICBpZiAoY29tcGFyZVJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiAhIWNvbXBhcmVSZXN1bHQ7XG4gICAgfVxuICAgIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8ICFvYmpBIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCAhb2JqQikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gICAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgICBmb3IobGV0IGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4Kyspe1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzQVtpZHhdO1xuICAgICAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgICAgICBjb25zdCB2YWx1ZUIgPSBvYmpCW2tleV07XG4gICAgICAgIGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IGZhbHNlIHx8IGNvbXBhcmVSZXN1bHQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1JlZihvYmopIHtcbiAgICByZXR1cm4oLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY3VycmVudCcpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dJZkNvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8vIEN1c3RvbSBjb21wb25lbnRzIGNhbiBubyBsb25nZXIgYmUgd3JhcHBlZCBkaXJlY3RseSBpbiBSZWFjdCBEbkQgMi4wXG4gICAgLy8gc28gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIGRlcGVuZCBvbiBmaW5kRE9NTm9kZSgpIGZyb20gcmVhY3QtZG9tLlxuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICd0aGUgY29tcG9uZW50JztcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbmF0aXZlIGVsZW1lbnQgbm9kZXMgY2FuIG5vdyBiZSBwYXNzZWQgdG8gUmVhY3QgRG5EIGNvbm5lY3RvcnMuJyArIGBZb3UgY2FuIGVpdGhlciB3cmFwICR7ZGlzcGxheU5hbWV9IGludG8gYSA8ZGl2Piwgb3IgdHVybiBpdCBpbnRvIGEgYCArICdkcmFnIHNvdXJjZSBvciBhIGRyb3AgdGFyZ2V0IGl0c2VsZi4nKTtcbn1cbmZ1bmN0aW9uIHdyYXBIb29rVG9SZWNvZ25pemVFbGVtZW50KGhvb2spIHtcbiAgICByZXR1cm4gKGVsZW1lbnRPck5vZGUgPSBudWxsLCBvcHRpb25zID0gbnVsbCk9PntcbiAgICAgICAgLy8gV2hlbiBwYXNzZWQgYSBub2RlLCBjYWxsIHRoZSBob29rIHN0cmFpZ2h0IGF3YXkuXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoZWxlbWVudE9yTm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50T3JOb2RlO1xuICAgICAgICAgICAgaG9vayhub2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbm9kZSBzbyBpdCBjYW4gYmUgY2hhaW5lZCAoZS5nLiB3aGVuIHdpdGhpbiBjYWxsYmFjayByZWZzXG4gICAgICAgICAgICAvLyA8ZGl2IHJlZj17bm9kZSA9PiBjb25uZWN0RHJhZ1NvdXJjZShjb25uZWN0RHJvcFRhcmdldChub2RlKSl9Lz5cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHBhc3NlZCBhIFJlYWN0RWxlbWVudCwgY2xvbmUgaXQgYW5kIGF0dGFjaCB0aGlzIGZ1bmN0aW9uIGFzIGEgcmVmLlxuICAgICAgICAvLyBUaGlzIGhlbHBzIHVzIGFjaGlldmUgYSBuZWF0IEFQSSB3aGVyZSB1c2VyIGRvZXNuJ3QgZXZlbiBrbm93IHRoYXQgcmVmc1xuICAgICAgICAvLyBhcmUgYmVpbmcgdXNlZCB1bmRlciB0aGUgaG9vZC5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRPck5vZGU7XG4gICAgICAgIHRocm93SWZDb21wb3NpdGVDb21wb25lbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAvLyBXaGVuIG5vIG9wdGlvbnMgYXJlIHBhc3NlZCwgdXNlIHRoZSBob29rIGRpcmVjdGx5XG4gICAgICAgIGNvbnN0IHJlZiA9IG9wdGlvbnMgPyAobm9kZSk9Pmhvb2sobm9kZSwgb3B0aW9ucylcbiAgICAgICAgIDogaG9vaztcbiAgICAgICAgcmV0dXJuIGNsb25lV2l0aFJlZihlbGVtZW50LCByZWYpO1xuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwQ29ubmVjdG9ySG9va3MoaG9va3MpIHtcbiAgICBjb25zdCB3cmFwcGVkSG9va3MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhob29rcykuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBjb25zdCBob29rID0gaG9va3Nba2V5XTtcbiAgICAgICAgLy8gcmVmIG9iamVjdHMgc2hvdWxkIGJlIHBhc3NlZCBzdHJhaWdodCB0aHJvdWdoIHdpdGhvdXQgd3JhcHBpbmdcbiAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnUmVmJykpIHtcbiAgICAgICAgICAgIHdyYXBwZWRIb29rc1trZXldID0gaG9va3Nba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gd3JhcEhvb2tUb1JlY29nbml6ZUVsZW1lbnQoaG9vayk7XG4gICAgICAgICAgICB3cmFwcGVkSG9va3Nba2V5XSA9ICgpPT53cmFwcGVkSG9va1xuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rcztcbn1cbmZ1bmN0aW9uIHNldFJlZihyZWYsIG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lV2l0aFJlZihlbGVtZW50LCBuZXdSZWYpIHtcbiAgICBjb25zdCBwcmV2aW91c1JlZiA9IGVsZW1lbnQucmVmO1xuICAgIGludmFyaWFudCh0eXBlb2YgcHJldmlvdXNSZWYgIT09ICdzdHJpbmcnLCAnQ2Fubm90IGNvbm5lY3QgUmVhY3QgRG5EIHRvIGFuIGVsZW1lbnQgd2l0aCBhbiBleGlzdGluZyBzdHJpbmcgcmVmLiAnICsgJ1BsZWFzZSBjb252ZXJ0IGl0IHRvIHVzZSBhIGNhbGxiYWNrIHJlZiBpbnN0ZWFkLCBvciB3cmFwIGl0IGludG8gYSA8c3Bhbj4gb3IgPGRpdj4uICcgKyAnUmVhZCBtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVmcy1hbmQtdGhlLWRvbS5odG1sI2NhbGxiYWNrLXJlZnMnKTtcbiAgICBpZiAoIXByZXZpb3VzUmVmKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcmVmIG9uIHRoZSBlbGVtZW50LCB1c2UgdGhlIG5ldyByZWYgZGlyZWN0bHlcbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICByZWY6IG5ld1JlZlxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHJlZjogKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgc2V0UmVmKHByZXZpb3VzUmVmLCBub2RlKTtcbiAgICAgICAgICAgICAgICBzZXRSZWYobmV3UmVmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBTb3VyY2VDb25uZWN0b3Ige1xuICAgIHJlY2VpdmVIYW5kbGVySWQobmV3SGFuZGxlcklkKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXJJZCA9PT0gbmV3SGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBuZXdIYW5kbGVySWQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfVxuICAgIGdldCBjb25uZWN0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU291cmNlO1xuICAgIH1cbiAgICBnZXQgZHJhZ1NvdXJjZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTb3VyY2VPcHRpb25zSW50ZXJuYWw7XG4gICAgfVxuICAgIHNldCBkcmFnU291cmNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZU9wdGlvbnNJbnRlcm5hbCA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBkcmFnUHJldmlld09wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdQcmV2aWV3T3B0aW9uc0ludGVybmFsO1xuICAgIH1cbiAgICBzZXQgZHJhZ1ByZXZpZXdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnNJbnRlcm5hbCA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gdGhpcy5yZWNvbm5lY3REcmFnU291cmNlKCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RHJhZ1ByZXZpZXcoZGlkQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVjb25uZWN0RHJhZ1NvdXJjZSgpIHtcbiAgICAgICAgY29uc3QgZHJhZ1NvdXJjZSA9IHRoaXMuZHJhZ1NvdXJjZTtcbiAgICAgICAgLy8gaWYgbm90aGluZyBoYXMgY2hhbmdlZCB0aGVuIGRvbid0IHJlc3Vic2NyaWJlXG4gICAgICAgIGNvbnN0IGRpZENoYW5nZSA9IHRoaXMuZGlkSGFuZGxlcklkQ2hhbmdlKCkgfHwgdGhpcy5kaWRDb25uZWN0ZWREcmFnU291cmNlQ2hhbmdlKCkgfHwgdGhpcy5kaWREcmFnU291cmNlT3B0aW9uc0NoYW5nZSgpO1xuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3REcmFnU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZENoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBkcmFnU291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIGRpZENoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBkcmFnU291cmNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZU9wdGlvbnMgPSB0aGlzLmRyYWdTb3VyY2VPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmUgPSB0aGlzLmJhY2tlbmQuY29ubmVjdERyYWdTb3VyY2UodGhpcy5oYW5kbGVySWQsIGRyYWdTb3VyY2UsIHRoaXMuZHJhZ1NvdXJjZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWRDaGFuZ2U7XG4gICAgfVxuICAgIHJlY29ubmVjdERyYWdQcmV2aWV3KGZvcmNlRGlkQ2hhbmdlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZHJhZ1ByZXZpZXcgPSB0aGlzLmRyYWdQcmV2aWV3O1xuICAgICAgICAvLyBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkIHRoZW4gZG9uJ3QgcmVzdWJzY3JpYmVcbiAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gZm9yY2VEaWRDaGFuZ2UgfHwgdGhpcy5kaWRIYW5kbGVySWRDaGFuZ2UoKSB8fCB0aGlzLmRpZENvbm5lY3RlZERyYWdQcmV2aWV3Q2hhbmdlKCkgfHwgdGhpcy5kaWREcmFnUHJldmlld09wdGlvbnNDaGFuZ2UoKTtcbiAgICAgICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcmFnUHJldmlldykge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXcgPSBkcmFnUHJldmlldztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3ID0gZHJhZ1ByZXZpZXc7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlld09wdGlvbnMgPSB0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSA9IHRoaXMuYmFja2VuZC5jb25uZWN0RHJhZ1ByZXZpZXcodGhpcy5oYW5kbGVySWQsIGRyYWdQcmV2aWV3LCB0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlkSGFuZGxlcklkQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkICE9PSB0aGlzLmhhbmRsZXJJZDtcbiAgICB9XG4gICAgZGlkQ29ubmVjdGVkRHJhZ1NvdXJjZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgIT09IHRoaXMuZHJhZ1NvdXJjZTtcbiAgICB9XG4gICAgZGlkQ29ubmVjdGVkRHJhZ1ByZXZpZXdDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlldyAhPT0gdGhpcy5kcmFnUHJldmlldztcbiAgICB9XG4gICAgZGlkRHJhZ1NvdXJjZU9wdGlvbnNDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2VPcHRpb25zLCB0aGlzLmRyYWdTb3VyY2VPcHRpb25zKTtcbiAgICB9XG4gICAgZGlkRHJhZ1ByZXZpZXdPcHRpb25zQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlld09wdGlvbnMsIHRoaXMuZHJhZ1ByZXZpZXdPcHRpb25zKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdERyYWdTb3VyY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdTb3VyY2VVbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NvdXJjZVVuc3Vic2NyaWJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3REcmFnUHJldmlldygpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnUHJldmlld1Vuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3VW5zdWJzY3JpYmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZHJhZ1NvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1NvdXJjZU5vZGUgfHwgdGhpcy5kcmFnU291cmNlUmVmICYmIHRoaXMuZHJhZ1NvdXJjZVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBnZXQgZHJhZ1ByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdQcmV2aWV3Tm9kZSB8fCB0aGlzLmRyYWdQcmV2aWV3UmVmICYmIHRoaXMuZHJhZ1ByZXZpZXdSZWYuY3VycmVudDtcbiAgICB9XG4gICAgY2xlYXJEcmFnU291cmNlKCkge1xuICAgICAgICB0aGlzLmRyYWdTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlUmVmID0gbnVsbDtcbiAgICB9XG4gICAgY2xlYXJEcmFnUHJldmlldygpIHtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYmFja2VuZCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSB3cmFwQ29ubmVjdG9ySG9va3Moe1xuICAgICAgICAgICAgZHJhZ1NvdXJjZTogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VPcHRpb25zID0gb3B0aW9ucyB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VSZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NvdXJjZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmFnUHJldmlldzogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWdQcmV2aWV3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnMgPSBvcHRpb25zIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdSZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REcmFnUHJldmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBudWxsO1xuICAgICAgICAvLyBUaGUgZHJvcCB0YXJnZXQgbWF5IGVpdGhlciBiZSBhdHRhY2hlZCB2aWEgcmVmIG9yIGNvbm5lY3QgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5kcmFnU291cmNlUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlT3B0aW9uc0ludGVybmFsID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGRyYWcgcHJldmlldyBtYXkgZWl0aGVyIGJlIGF0dGFjaGVkIHZpYSByZWYgb3IgY29ubmVjdCBmdW5jdGlvblxuICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnNJbnRlcm5hbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcmFnU291cmNlT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXdPcHRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG59XG5cbmNsYXNzIFRhcmdldENvbm5lY3RvciB7XG4gICAgZ2V0IGNvbm5lY3RUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXQ7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgLy8gaWYgbm90aGluZyBoYXMgY2hhbmdlZCB0aGVuIGRvbid0IHJlc3Vic2NyaWJlXG4gICAgICAgIGNvbnN0IGRpZENoYW5nZSA9IHRoaXMuZGlkSGFuZGxlcklkQ2hhbmdlKCkgfHwgdGhpcy5kaWREcm9wVGFyZ2V0Q2hhbmdlKCkgfHwgdGhpcy5kaWRPcHRpb25zQ2hhbmdlKCk7XG4gICAgICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdERyb3BUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gdGhpcy5kcm9wVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMgPSB0aGlzLmRyb3BUYXJnZXRPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZURyb3BUYXJnZXQgPSB0aGlzLmJhY2tlbmQuY29ubmVjdERyb3BUYXJnZXQodGhpcy5oYW5kbGVySWQsIGRyb3BUYXJnZXQsIHRoaXMuZHJvcFRhcmdldE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY2VpdmVIYW5kbGVySWQobmV3SGFuZGxlcklkKSB7XG4gICAgICAgIGlmIChuZXdIYW5kbGVySWQgPT09IHRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBuZXdIYW5kbGVySWQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfVxuICAgIGdldCBkcm9wVGFyZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbDtcbiAgICB9XG4gICAgc2V0IGRyb3BUYXJnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0T3B0aW9uc0ludGVybmFsID0gb3B0aW9ucztcbiAgICB9XG4gICAgZGlkSGFuZGxlcklkQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkICE9PSB0aGlzLmhhbmRsZXJJZDtcbiAgICB9XG4gICAgZGlkRHJvcFRhcmdldENoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgIT09IHRoaXMuZHJvcFRhcmdldDtcbiAgICB9XG4gICAgZGlkT3B0aW9uc0NoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMsIHRoaXMuZHJvcFRhcmdldE9wdGlvbnMpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0RHJvcFRhcmdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVEcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRHJvcFRhcmdldCgpO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZURyb3BUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRyb3BUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXROb2RlIHx8IHRoaXMuZHJvcFRhcmdldFJlZiAmJiB0aGlzLmRyb3BUYXJnZXRSZWYuY3VycmVudDtcbiAgICB9XG4gICAgY2xlYXJEcm9wVGFyZ2V0KCkge1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXROb2RlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYmFja2VuZCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSB3cmFwQ29ubmVjdG9ySG9va3Moe1xuICAgICAgICAgICAgZHJvcFRhcmdldDogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyb3BUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWYobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wVGFyZ2V0UmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcklkID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGRyb3AgdGFyZ2V0IG1heSBlaXRoZXIgYmUgYXR0YWNoZWQgdmlhIHJlZiBvciBjb25uZWN0IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuZHJvcFRhcmdldFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcm9wVGFyZ2V0T3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgaG9vayB0byByZXRyaWV2ZSB0aGUgRHJhZ0Ryb3BNYW5hZ2VyIGZyb20gQ29udGV4dFxuICovIGZ1bmN0aW9uIHVzZURyYWdEcm9wTWFuYWdlcigpIHtcbiAgICBjb25zdCB7IGRyYWdEcm9wTWFuYWdlciAgfSA9IHVzZUNvbnRleHQoRG5kQ29udGV4dCk7XG4gICAgaW52YXJpYW50KGRyYWdEcm9wTWFuYWdlciAhPSBudWxsLCAnRXhwZWN0ZWQgZHJhZyBkcm9wIGNvbnRleHQnKTtcbiAgICByZXR1cm4gZHJhZ0Ryb3BNYW5hZ2VyO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnU291cmNlQ29ubmVjdG9yKGRyYWdTb3VyY2VPcHRpb25zLCBkcmFnUHJldmlld09wdGlvbnMpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlRHJhZ0Ryb3BNYW5hZ2VyKCk7XG4gICAgY29uc3QgY29ubmVjdG9yID0gdXNlTWVtbygoKT0+bmV3IFNvdXJjZUNvbm5lY3RvcihtYW5hZ2VyLmdldEJhY2tlbmQoKSlcbiAgICAsIFtcbiAgICAgICAgbWFuYWdlclxuICAgIF0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgY29ubmVjdG9yLmRyYWdTb3VyY2VPcHRpb25zID0gZHJhZ1NvdXJjZU9wdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gKCk9PmNvbm5lY3Rvci5kaXNjb25uZWN0RHJhZ1NvdXJjZSgpXG4gICAgICAgIDtcbiAgICB9LCBbXG4gICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgZHJhZ1NvdXJjZU9wdGlvbnNcbiAgICBdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGNvbm5lY3Rvci5kcmFnUHJldmlld09wdGlvbnMgPSBkcmFnUHJldmlld09wdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gKCk9PmNvbm5lY3Rvci5kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKVxuICAgICAgICA7XG4gICAgfSwgW1xuICAgICAgICBjb25uZWN0b3IsXG4gICAgICAgIGRyYWdQcmV2aWV3T3B0aW9uc1xuICAgIF0pO1xuICAgIHJldHVybiBjb25uZWN0b3I7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdTb3VyY2VNb25pdG9yKCkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKT0+bmV3IERyYWdTb3VyY2VNb25pdG9ySW1wbChtYW5hZ2VyKVxuICAgICwgW1xuICAgICAgICBtYW5hZ2VyXG4gICAgXSk7XG59XG5cbmNsYXNzIERyYWdTb3VyY2VJbXBsIHtcbiAgICBiZWdpbkRyYWcoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWMuaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNwZWMuaXRlbTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYy5pdGVtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzcGVjLml0ZW0obW9uaXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdm9pZCAwID8gcmVzdWx0IDogbnVsbDtcbiAgICB9XG4gICAgY2FuRHJhZygpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjLmNhbkRyYWcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWMuY2FuRHJhZztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYy5jYW5EcmFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlYy5jYW5EcmFnKG1vbml0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNEcmFnZ2luZyhnbG9iYWxNb25pdG9yLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgY29uc3QgeyBpc0RyYWdnaW5nICB9ID0gc3BlYztcbiAgICAgICAgcmV0dXJuIGlzRHJhZ2dpbmcgPyBpc0RyYWdnaW5nKG1vbml0b3IpIDogdGFyZ2V0ID09PSBnbG9iYWxNb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIGVuZERyYWcoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdG9yO1xuICAgICAgICBjb25zdCB7IGVuZCAgfSA9IHNwZWM7XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZChtb25pdG9yLmdldEl0ZW0oKSwgbW9uaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBtb25pdG9yLCBjb25uZWN0b3Ipe1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBtb25pdG9yO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdTb3VyY2Uoc3BlYywgbW9uaXRvciwgY29ubmVjdG9yKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHVzZU1lbW8oKCk9Pm5ldyBEcmFnU291cmNlSW1wbChzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpXG4gICAgLCBbXG4gICAgICAgIG1vbml0b3IsXG4gICAgICAgIGNvbm5lY3RvclxuICAgIF0pO1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBoYW5kbGVyLnNwZWMgPSBzcGVjO1xuICAgIH0sIFtcbiAgICAgICAgc3BlY1xuICAgIF0pO1xuICAgIHJldHVybiBoYW5kbGVyO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnVHlwZShzcGVjKSB7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlYy50eXBlO1xuICAgICAgICBpbnZhcmlhbnQocmVzdWx0ICE9IG51bGwsICdzcGVjLnR5cGUgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW1xuICAgICAgICBzcGVjXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdGVyZWREcmFnU291cmNlKHNwZWMsIG1vbml0b3IsIGNvbm5lY3Rvcikge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gdXNlRHJhZ1NvdXJjZShzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIGNvbnN0IGl0ZW1UeXBlID0gdXNlRHJhZ1R5cGUoc3BlYyk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiByZWdpc3RlckRyYWdTb3VyY2UoKSB7XG4gICAgICAgIGlmIChpdGVtVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBbaGFuZGxlcklkLCB1bnJlZ2lzdGVyXSA9IHJlZ2lzdGVyU291cmNlKGl0ZW1UeXBlLCBoYW5kbGVyLCBtYW5hZ2VyKTtcbiAgICAgICAgICAgIG1vbml0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICAgICAgY29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgICAgIHJldHVybiB1bnJlZ2lzdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9LCBbXG4gICAgICAgIG1hbmFnZXIsXG4gICAgICAgIG1vbml0b3IsXG4gICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgaXRlbVR5cGVcbiAgICBdKTtcbn1cblxuLyoqXG4gKiB1c2VEcmFnU291cmNlIGhvb2tcbiAqIEBwYXJhbSBzb3VyY2VTcGVjIFRoZSBkcmFnIHNvdXJjZSBzcGVjaWZpY2F0aW9uIChvYmplY3Qgb3IgZnVuY3Rpb24sIGZ1bmN0aW9uIHByZWZlcnJlZClcbiAqIEBwYXJhbSBkZXBzIFRoZSBtZW1vaXphdGlvbiBkZXBzIGFycmF5IHRvIHVzZSB3aGVuIGV2YWx1YXRpbmcgc3BlYyBjaGFuZ2VzXG4gKi8gZnVuY3Rpb24gdXNlRHJhZyhzcGVjQXJnLCBkZXBzKSB7XG4gICAgY29uc3Qgc3BlYyA9IHVzZU9wdGlvbmFsRmFjdG9yeShzcGVjQXJnLCBkZXBzKTtcbiAgICBpbnZhcmlhbnQoIXNwZWMuYmVnaW4sIGB1c2VEcmFnOjpzcGVjLmJlZ2luIHdhcyBkZXByZWNhdGVkIGluIHYxNC4gUmVwbGFjZSBzcGVjLmJlZ2luKCkgd2l0aCBzcGVjLml0ZW0oKS4gKHNlZSBtb3JlIGhlcmUgLSBodHRwczovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MvYXBpL3VzZS1kcmFnKWApO1xuICAgIGNvbnN0IG1vbml0b3IgPSB1c2VEcmFnU291cmNlTW9uaXRvcigpO1xuICAgIGNvbnN0IGNvbm5lY3RvciA9IHVzZURyYWdTb3VyY2VDb25uZWN0b3Ioc3BlYy5vcHRpb25zLCBzcGVjLnByZXZpZXdPcHRpb25zKTtcbiAgICB1c2VSZWdpc3RlcmVkRHJhZ1NvdXJjZShzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHVzZUNvbGxlY3RlZFByb3BzKHNwZWMuY29sbGVjdCwgbW9uaXRvciwgY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyYWdTb3VyY2UoY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyYWdQcmV2aWV3KGNvbm5lY3RvciksIFxuICAgIF07XG59XG5cbi8qKlxuICogdXNlRHJhZ0xheWVyIEhvb2tcbiAqIEBwYXJhbSBjb2xsZWN0b3IgVGhlIHByb3BlcnR5IGNvbGxlY3RvclxuICovIGZ1bmN0aW9uIHVzZURyYWdMYXllcihjb2xsZWN0KSB7XG4gICAgY29uc3QgZHJhZ0Ryb3BNYW5hZ2VyID0gdXNlRHJhZ0Ryb3BNYW5hZ2VyKCk7XG4gICAgY29uc3QgbW9uaXRvciA9IGRyYWdEcm9wTWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgY29uc3QgW2NvbGxlY3RlZCwgdXBkYXRlQ29sbGVjdGVkXSA9IHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0KTtcbiAgICB1c2VFZmZlY3QoKCk9Pm1vbml0b3Iuc3Vic2NyaWJlVG9PZmZzZXRDaGFuZ2UodXBkYXRlQ29sbGVjdGVkKVxuICAgICk7XG4gICAgdXNlRWZmZWN0KCgpPT5tb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UodXBkYXRlQ29sbGVjdGVkKVxuICAgICk7XG4gICAgcmV0dXJuIGNvbGxlY3RlZDtcbn1cblxuZnVuY3Rpb24gdXNlQ29ubmVjdERyb3BUYXJnZXQoY29ubmVjdG9yKSB7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PmNvbm5lY3Rvci5ob29rcy5kcm9wVGFyZ2V0KClcbiAgICAsIFtcbiAgICAgICAgY29ubmVjdG9yXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURyb3BUYXJnZXRDb25uZWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICBjb25zdCBjb25uZWN0b3IgPSB1c2VNZW1vKCgpPT5uZXcgVGFyZ2V0Q29ubmVjdG9yKG1hbmFnZXIuZ2V0QmFja2VuZCgpKVxuICAgICwgW1xuICAgICAgICBtYW5hZ2VyXG4gICAgXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBjb25uZWN0b3IuZHJvcFRhcmdldE9wdGlvbnMgPSBvcHRpb25zIHx8IG51bGw7XG4gICAgICAgIGNvbm5lY3Rvci5yZWNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuICgpPT5jb25uZWN0b3IuZGlzY29ubmVjdERyb3BUYXJnZXQoKVxuICAgICAgICA7XG4gICAgfSwgW1xuICAgICAgICBvcHRpb25zXG4gICAgXSk7XG4gICAgcmV0dXJuIGNvbm5lY3Rvcjtcbn1cblxuZnVuY3Rpb24gdXNlRHJvcFRhcmdldE1vbml0b3IoKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZURyYWdEcm9wTWFuYWdlcigpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5uZXcgRHJvcFRhcmdldE1vbml0b3JJbXBsKG1hbmFnZXIpXG4gICAgLCBbXG4gICAgICAgIG1hbmFnZXJcbiAgICBdKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB1dGlsaXR5IGhvb2sgdG8gZ2V0IGFuIGFycmF5LXZlcnNpb24gb2Ygc3BlYy5hY2NlcHQuXG4gKiBUaGUgbWFpbiB1dGlsaXR5IGhlcmUgaXMgdGhhdCB3ZSBhcmVuJ3QgY3JlYXRpbmcgYSBuZXcgYXJyYXkgb24gZXZlcnkgcmVuZGVyIGlmIGEgbm9uLWFycmF5IHNwZWMuYWNjZXB0IGlzIHBhc3NlZCBpbi5cbiAqIEBwYXJhbSBzcGVjXG4gKi8gZnVuY3Rpb24gdXNlQWNjZXB0KHNwZWMpIHtcbiAgICBjb25zdCB7IGFjY2VwdCAgfSA9IHNwZWM7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgaW52YXJpYW50KHNwZWMuYWNjZXB0ICE9IG51bGwsICdhY2NlcHQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFjY2VwdCkgPyBhY2NlcHQgOiBbXG4gICAgICAgICAgICBhY2NlcHRcbiAgICAgICAgXTtcbiAgICB9LCBbXG4gICAgICAgIGFjY2VwdFxuICAgIF0pO1xufVxuXG5jbGFzcyBEcm9wVGFyZ2V0SW1wbCB7XG4gICAgY2FuRHJvcCgpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgcmV0dXJuIHNwZWMuY2FuRHJvcCA/IHNwZWMuY2FuRHJvcChtb25pdG9yLmdldEl0ZW0oKSwgbW9uaXRvcikgOiB0cnVlO1xuICAgIH1cbiAgICBob3ZlcigpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgaWYgKHNwZWMuaG92ZXIpIHtcbiAgICAgICAgICAgIHNwZWMuaG92ZXIobW9uaXRvci5nZXRJdGVtKCksIG1vbml0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGlmIChzcGVjLmRyb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVjLmRyb3AobW9uaXRvci5nZXRJdGVtKCksIG1vbml0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3BlYywgbW9uaXRvcil7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1c2VEcm9wVGFyZ2V0KHNwZWMsIG1vbml0b3IpIHtcbiAgICBjb25zdCBkcm9wVGFyZ2V0ID0gdXNlTWVtbygoKT0+bmV3IERyb3BUYXJnZXRJbXBsKHNwZWMsIG1vbml0b3IpXG4gICAgLCBbXG4gICAgICAgIG1vbml0b3JcbiAgICBdKTtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgZHJvcFRhcmdldC5zcGVjID0gc3BlYztcbiAgICB9LCBbXG4gICAgICAgIHNwZWNcbiAgICBdKTtcbiAgICByZXR1cm4gZHJvcFRhcmdldDtcbn1cblxuZnVuY3Rpb24gdXNlUmVnaXN0ZXJlZERyb3BUYXJnZXQoc3BlYywgbW9uaXRvciwgY29ubmVjdG9yKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZURyYWdEcm9wTWFuYWdlcigpO1xuICAgIGNvbnN0IGRyb3BUYXJnZXQgPSB1c2VEcm9wVGFyZ2V0KHNwZWMsIG1vbml0b3IpO1xuICAgIGNvbnN0IGFjY2VwdCA9IHVzZUFjY2VwdChzcGVjKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIHJlZ2lzdGVyRHJvcFRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgW2hhbmRsZXJJZCwgdW5yZWdpc3Rlcl0gPSByZWdpc3RlclRhcmdldChhY2NlcHQsIGRyb3BUYXJnZXQsIG1hbmFnZXIpO1xuICAgICAgICBtb25pdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgY29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgcmV0dXJuIHVucmVnaXN0ZXI7XG4gICAgfSwgW1xuICAgICAgICBtYW5hZ2VyLFxuICAgICAgICBtb25pdG9yLFxuICAgICAgICBkcm9wVGFyZ2V0LFxuICAgICAgICBjb25uZWN0b3IsXG4gICAgICAgIGFjY2VwdC5tYXAoKGEpPT5hLnRvU3RyaW5nKClcbiAgICAgICAgKS5qb2luKCd8JyksIFxuICAgIF0pO1xufVxuXG4vKipcbiAqIHVzZURyb3BUYXJnZXQgSG9va1xuICogQHBhcmFtIHNwZWMgVGhlIGRyb3AgdGFyZ2V0IHNwZWNpZmljYXRpb24gKG9iamVjdCBvciBmdW5jdGlvbiwgZnVuY3Rpb24gcHJlZmVycmVkKVxuICogQHBhcmFtIGRlcHMgVGhlIG1lbW9pemF0aW9uIGRlcHMgYXJyYXkgdG8gdXNlIHdoZW4gZXZhbHVhdGluZyBzcGVjIGNoYW5nZXNcbiAqLyBmdW5jdGlvbiB1c2VEcm9wKHNwZWNBcmcsIGRlcHMpIHtcbiAgICBjb25zdCBzcGVjID0gdXNlT3B0aW9uYWxGYWN0b3J5KHNwZWNBcmcsIGRlcHMpO1xuICAgIGNvbnN0IG1vbml0b3IgPSB1c2VEcm9wVGFyZ2V0TW9uaXRvcigpO1xuICAgIGNvbnN0IGNvbm5lY3RvciA9IHVzZURyb3BUYXJnZXRDb25uZWN0b3Ioc3BlYy5vcHRpb25zKTtcbiAgICB1c2VSZWdpc3RlcmVkRHJvcFRhcmdldChzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHVzZUNvbGxlY3RlZFByb3BzKHNwZWMuY29sbGVjdCwgbW9uaXRvciwgY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyb3BUYXJnZXQoY29ubmVjdG9yKSwgXG4gICAgXTtcbn1cblxuLy8gY2hlYXAgbG9kYXNoIHJlcGxhY2VtZW50c1xuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGNvbnN0IG1lbW9pemVkID0gKCk9PntcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG4vKipcbiAqIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIF8ud2l0aG91dFxuICovIGZ1bmN0aW9uIHdpdGhvdXQoaXRlbXMsIGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpKT0+aSAhPT0gaXRlbVxuICAgICk7XG59XG5mdW5jdGlvbiB1bmlvbihpdGVtc0EsIGl0ZW1zQikge1xuICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnNlcnRJdGVtID0gKGl0ZW0pPT5zZXQuYWRkKGl0ZW0pXG4gICAgO1xuICAgIGl0ZW1zQS5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGl0ZW1zQi5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHNldC5mb3JFYWNoKChrZXkpPT5yZXN1bHQucHVzaChrZXkpXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jbGFzcyBFbnRlckxlYXZlQ291bnRlciB7XG4gICAgZW50ZXIoZW50ZXJpbmdOb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gdGhpcy5lbnRlcmVkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNOb2RlRW50ZXJlZCA9IChub2RlKT0+dGhpcy5pc05vZGVJbkRvY3VtZW50KG5vZGUpICYmICghbm9kZS5jb250YWlucyB8fCBub2RlLmNvbnRhaW5zKGVudGVyaW5nTm9kZSkpXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gdW5pb24odGhpcy5lbnRlcmVkLmZpbHRlcihpc05vZGVFbnRlcmVkKSwgW1xuICAgICAgICAgICAgZW50ZXJpbmdOb2RlXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gcHJldmlvdXNMZW5ndGggPT09IDAgJiYgdGhpcy5lbnRlcmVkLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGxlYXZlKGxlYXZpbmdOb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gdGhpcy5lbnRlcmVkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gd2l0aG91dCh0aGlzLmVudGVyZWQuZmlsdGVyKHRoaXMuaXNOb2RlSW5Eb2N1bWVudCksIGxlYXZpbmdOb2RlKTtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTGVuZ3RoID4gMCAmJiB0aGlzLmVudGVyZWQubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gW107XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzTm9kZUluRG9jdW1lbnQpe1xuICAgICAgICB0aGlzLmVudGVyZWQgPSBbXTtcbiAgICAgICAgdGhpcy5pc05vZGVJbkRvY3VtZW50ID0gaXNOb2RlSW5Eb2N1bWVudDtcbiAgICB9XG59XG5cbmNsYXNzIE5hdGl2ZURyYWdTb3VyY2Uge1xuICAgIGluaXRpYWxpemVFeHBvc2VkUHJvcGVydGllcygpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25maWcuZXhwb3NlUHJvcGVydGllcykuZm9yRWFjaCgocHJvcGVydHkpPT57XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5pdGVtLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQnJvd3NlciBkb2Vzbid0IGFsbG93IHJlYWRpbmcgXCIke3Byb3BlcnR5fVwiIHVudGlsIHRoZSBkcm9wIGV2ZW50LmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWREYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLmV4cG9zZVByb3BlcnRpZXMpLmZvckVhY2goKHByb3BlcnR5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5Rm4gPSB0aGlzLmNvbmZpZy5leHBvc2VQcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlGbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNbcHJvcGVydHldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb3BlcnR5Rm4oZGF0YVRyYW5zZmVyLCB0aGlzLmNvbmZpZy5tYXRjaGVzVHlwZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5pdGVtLCBuZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5EcmFnKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVnaW5EcmFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nKG1vbml0b3IsIGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlID09PSBtb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIGVuZERyYWcoKSB7XG4gICAgLy8gZW1wdHlcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZmlnKXtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuaXRlbSA9IHt9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemVFeHBvc2VkUHJvcGVydGllcygpO1xuICAgIH1cbn1cblxuY29uc3QgRklMRSA9ICdfX05BVElWRV9GSUxFX18nO1xuY29uc3QgVVJMID0gJ19fTkFUSVZFX1VSTF9fJztcbmNvbnN0IFRFWFQgPSAnX19OQVRJVkVfVEVYVF9fJztcbmNvbnN0IEhUTUwgPSAnX19OQVRJVkVfSFRNTF9fJztcblxudmFyIE5hdGl2ZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBGSUxFOiBGSUxFLFxuICAgIEhUTUw6IEhUTUwsXG4gICAgVEVYVDogVEVYVCxcbiAgICBVUkw6IFVSTFxufSk7XG5cbmZ1bmN0aW9uIGdldERhdGFGcm9tRGF0YVRyYW5zZmVyKGRhdGFUcmFuc2ZlciwgdHlwZXNUb1RyeSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHlwZXNUb1RyeS5yZWR1Y2UoKHJlc3VsdFNvRmFyLCB0eXBlVG9UcnkpPT5yZXN1bHRTb0ZhciB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSh0eXBlVG9UcnkpXG4gICAgLCAnJyk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogZGVmYXVsdFZhbHVlO1xufVxuXG5jb25zdCBuYXRpdmVUeXBlc0NvbmZpZyA9IHtcbiAgICBbRklMRV06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgZmlsZXM6IChkYXRhVHJhbnNmZXIpPT5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhVHJhbnNmZXIuZmlsZXMpXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBpdGVtczogKGRhdGFUcmFuc2Zlcik9PmRhdGFUcmFuc2Zlci5pdGVtc1xuICAgICAgICAgICAgLFxuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiAoZGF0YVRyYW5zZmVyKT0+ZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNUeXBlczogW1xuICAgICAgICAgICAgJ0ZpbGVzJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICBbSFRNTF06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgaHRtbDogKGRhdGFUcmFuc2ZlciwgbWF0Y2hlc1R5cGVzKT0+Z2V0RGF0YUZyb21EYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMsICcnKVxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiAoZGF0YVRyYW5zZmVyKT0+ZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNUeXBlczogW1xuICAgICAgICAgICAgJ0h0bWwnLFxuICAgICAgICAgICAgJ3RleHQvaHRtbCdcbiAgICAgICAgXVxuICAgIH0sXG4gICAgW1VSTF06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgdXJsczogKGRhdGFUcmFuc2ZlciwgbWF0Y2hlc1R5cGVzKT0+Z2V0RGF0YUZyb21EYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMsICcnKS5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogKGRhdGFUcmFuc2Zlcik9PmRhdGFUcmFuc2ZlclxuICAgICAgICB9LFxuICAgICAgICBtYXRjaGVzVHlwZXM6IFtcbiAgICAgICAgICAgICdVcmwnLFxuICAgICAgICAgICAgJ3RleHQvdXJpLWxpc3QnXG4gICAgICAgIF1cbiAgICB9LFxuICAgIFtURVhUXToge1xuICAgICAgICBleHBvc2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICB0ZXh0OiAoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMpPT5nZXREYXRhRnJvbURhdGFUcmFuc2ZlcihkYXRhVHJhbnNmZXIsIG1hdGNoZXNUeXBlcywgJycpXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IChkYXRhVHJhbnNmZXIpPT5kYXRhVHJhbnNmZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1R5cGVzOiBbXG4gICAgICAgICAgICAnVGV4dCcsXG4gICAgICAgICAgICAndGV4dC9wbGFpbidcbiAgICAgICAgXVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZURyYWdTb3VyY2UodHlwZSwgZGF0YVRyYW5zZmVyKSB7XG4gICAgY29uc3QgY29uZmlnID0gbmF0aXZlVHlwZXNDb25maWdbdHlwZV07XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBuYXRpdmUgdHlwZSAke3R5cGV9IGhhcyBubyBjb25maWd1cmF0aW9uYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBOYXRpdmVEcmFnU291cmNlKGNvbmZpZyk7XG4gICAgcmVzdWx0LmxvYWREYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWF0Y2hOYXRpdmVJdGVtVHlwZShkYXRhVHJhbnNmZXIpIHtcbiAgICBpZiAoIWRhdGFUcmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YVRyYW5zZmVyVHlwZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhVHJhbnNmZXIudHlwZXMgfHwgW10pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhuYXRpdmVUeXBlc0NvbmZpZykuZmlsdGVyKChuYXRpdmVJdGVtVHlwZSk9PntcbiAgICAgICAgY29uc3QgdHlwZUNvbmZpZyA9IG5hdGl2ZVR5cGVzQ29uZmlnW25hdGl2ZUl0ZW1UeXBlXTtcbiAgICAgICAgaWYgKCEodHlwZUNvbmZpZyA9PT0gbnVsbCB8fCB0eXBlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlQ29uZmlnLm1hdGNoZXNUeXBlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZUNvbmZpZy5tYXRjaGVzVHlwZXMuc29tZSgodCk9PmRhdGFUcmFuc2ZlclR5cGVzLmluZGV4T2YodCkgPiAtMVxuICAgICAgICApO1xuICAgIH0pWzBdIHx8IG51bGw7XG59XG5cbmNvbnN0IGlzRmlyZWZveCA9IG1lbW9pemUoKCk9Pi9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuKTtcbmNvbnN0IGlzU2FmYXJpID0gbWVtb2l6ZSgoKT0+Qm9vbGVhbih3aW5kb3cuc2FmYXJpKVxuKTtcblxuY2xhc3MgTW9ub3RvbmljSW50ZXJwb2xhbnQge1xuICAgIGludGVycG9sYXRlKHgpIHtcbiAgICAgICAgY29uc3QgeyB4cyAsIHlzICwgYzFzICwgYzJzICwgYzNzICB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIHJpZ2h0bW9zdCBwb2ludCBpbiB0aGUgZGF0YXNldCBzaG91bGQgZ2l2ZSBhbiBleGFjdCByZXN1bHRcbiAgICAgICAgbGV0IGkgPSB4cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoeCA9PT0geHNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB5c1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBpbnRlcnZhbCB4IGlzIGluLCByZXR1cm5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgeSBpZiB4IGlzIG9uZSBvZiB0aGUgb3JpZ2luYWwgeHNcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gYzNzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBtaWQ7XG4gICAgICAgIHdoaWxlKGxvdyA8PSBoaWdoKXtcbiAgICAgICAgICAgIG1pZCA9IE1hdGguZmxvb3IoMC41ICogKGxvdyArIGhpZ2gpKTtcbiAgICAgICAgICAgIGNvbnN0IHhIZXJlID0geHNbbWlkXTtcbiAgICAgICAgICAgIGlmICh4SGVyZSA8IHgpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4SGVyZSA+IHgpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlzW21pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSA9IE1hdGgubWF4KDAsIGhpZ2gpO1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZVxuICAgICAgICBjb25zdCBkaWZmID0geCAtIHhzW2ldO1xuICAgICAgICBjb25zdCBkaWZmU3EgPSBkaWZmICogZGlmZjtcbiAgICAgICAgcmV0dXJuIHlzW2ldICsgYzFzW2ldICogZGlmZiArIGMyc1tpXSAqIGRpZmZTcSArIGMzc1tpXSAqIGRpZmYgKiBkaWZmU3E7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHhzLCB5cyl7XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoICB9ID0geHM7XG4gICAgICAgIC8vIFJlYXJyYW5nZSB4cyBhbmQgeXMgc28gdGhhdCB4cyBpcyBzb3J0ZWRcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ZXMuc29ydCgoYSwgYik9PnhzW2FdIDwgeHNbYl0gPyAtMSA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZHhzID0gW107XG4gICAgICAgIGNvbnN0IG1zID0gW107XG4gICAgICAgIGxldCBkeDtcbiAgICAgICAgbGV0IGR5O1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBsZW5ndGggLSAxOyBpMSsrKXtcbiAgICAgICAgICAgIGR4ID0geHNbaTEgKyAxXSAtIHhzW2kxXTtcbiAgICAgICAgICAgIGR5ID0geXNbaTEgKyAxXSAtIHlzW2kxXTtcbiAgICAgICAgICAgIGR4cy5wdXNoKGR4KTtcbiAgICAgICAgICAgIG1zLnB1c2goZHkgLyBkeCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGRlZ3JlZS0xIGNvZWZmaWNpZW50c1xuICAgICAgICBjb25zdCBjMXMgPSBbXG4gICAgICAgICAgICBtc1swXVxuICAgICAgICBdO1xuICAgICAgICBmb3IobGV0IGkyID0gMDsgaTIgPCBkeHMubGVuZ3RoIC0gMTsgaTIrKyl7XG4gICAgICAgICAgICBjb25zdCBtMiA9IG1zW2kyXTtcbiAgICAgICAgICAgIGNvbnN0IG1OZXh0ID0gbXNbaTIgKyAxXTtcbiAgICAgICAgICAgIGlmIChtMiAqIG1OZXh0IDw9IDApIHtcbiAgICAgICAgICAgICAgICBjMXMucHVzaCgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHggPSBkeHNbaTJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4TmV4dCA9IGR4c1tpMiArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IGR4ICsgZHhOZXh0O1xuICAgICAgICAgICAgICAgIGMxcy5wdXNoKDMgKiBjb21tb24gLyAoKGNvbW1vbiArIGR4TmV4dCkgLyBtMiArIChjb21tb24gKyBkeCkgLyBtTmV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGMxcy5wdXNoKG1zW21zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gR2V0IGRlZ3JlZS0yIGFuZCBkZWdyZWUtMyBjb2VmZmljaWVudHNcbiAgICAgICAgY29uc3QgYzJzID0gW107XG4gICAgICAgIGNvbnN0IGMzcyA9IFtdO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgZm9yKGxldCBpMyA9IDA7IGkzIDwgYzFzLmxlbmd0aCAtIDE7IGkzKyspe1xuICAgICAgICAgICAgbSA9IG1zW2kzXTtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gYzFzW2kzXTtcbiAgICAgICAgICAgIGNvbnN0IGludkR4ID0gMSAvIGR4c1tpM107XG4gICAgICAgICAgICBjb25zdCBjb21tb24gPSBjMSArIGMxc1tpMyArIDFdIC0gbSAtIG07XG4gICAgICAgICAgICBjMnMucHVzaCgobSAtIGMxIC0gY29tbW9uKSAqIGludkR4KTtcbiAgICAgICAgICAgIGMzcy5wdXNoKGNvbW1vbiAqIGludkR4ICogaW52RHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueHMgPSB4cztcbiAgICAgICAgdGhpcy55cyA9IHlzO1xuICAgICAgICB0aGlzLmMxcyA9IGMxcztcbiAgICAgICAgdGhpcy5jMnMgPSBjMnM7XG4gICAgICAgIHRoaXMuYzNzID0gYzNzO1xuICAgIH1cbn1cblxuY29uc3QgRUxFTUVOVF9OT0RFJDEgPSAxO1xuZnVuY3Rpb24gZ2V0Tm9kZUNsaWVudE9mZnNldCQxKG5vZGUpIHtcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSQxID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHRvcCAsIGxlZnQgIH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBsZWZ0LFxuICAgICAgICB5OiB0b3BcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGllbnRPZmZzZXQkMShlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICB5OiBlLmNsaWVudFlcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNJbWFnZU5vZGUobm9kZSkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdJTUcnICYmIChpc0ZpcmVmb3goKSB8fCAhKChyZWYgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmNvbnRhaW5zKG5vZGUpKSk7XG59XG5mdW5jdGlvbiBnZXREcmFnUHJldmlld1NpemUoaXNJbWFnZSwgZHJhZ1ByZXZpZXcsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpIHtcbiAgICBsZXQgZHJhZ1ByZXZpZXdXaWR0aCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy53aWR0aCA6IHNvdXJjZVdpZHRoO1xuICAgIGxldCBkcmFnUHJldmlld0hlaWdodCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy5oZWlnaHQgOiBzb3VyY2VIZWlnaHQ7XG4gICAgLy8gV29yayBhcm91bmQgQDJ4IGNvb3JkaW5hdGUgZGlzY3JlcGFuY2llcyBpbiBicm93c2Vyc1xuICAgIGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcbiAgICAgICAgZHJhZ1ByZXZpZXdIZWlnaHQgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGRyYWdQcmV2aWV3V2lkdGggLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRyYWdQcmV2aWV3V2lkdGgsXG4gICAgICAgIGRyYWdQcmV2aWV3SGVpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERyYWdQcmV2aWV3T2Zmc2V0KHNvdXJjZU5vZGUsIGRyYWdQcmV2aWV3LCBjbGllbnRPZmZzZXQsIGFuY2hvclBvaW50LCBvZmZzZXRQb2ludCkge1xuICAgIC8vIFRoZSBicm93c2VycyB3aWxsIHVzZSB0aGUgaW1hZ2UgaW50cmluc2ljIHNpemUgdW5kZXIgZGlmZmVyZW50IGNvbmRpdGlvbnMuXG4gICAgLy8gRmlyZWZveCBvbmx5IGNhcmVzIGlmIGl0J3MgYW4gaW1hZ2UsIGJ1dCBXZWJLaXQgYWxzbyB3YW50cyBpdCB0byBiZSBkZXRhY2hlZC5cbiAgICBjb25zdCBpc0ltYWdlID0gaXNJbWFnZU5vZGUoZHJhZ1ByZXZpZXcpO1xuICAgIGNvbnN0IGRyYWdQcmV2aWV3Tm9kZSA9IGlzSW1hZ2UgPyBzb3VyY2VOb2RlIDogZHJhZ1ByZXZpZXc7XG4gICAgY29uc3QgZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudCA9IGdldE5vZGVDbGllbnRPZmZzZXQkMShkcmFnUHJldmlld05vZGUpO1xuICAgIGNvbnN0IG9mZnNldEZyb21EcmFnUHJldmlldyA9IHtcbiAgICAgICAgeDogY2xpZW50T2Zmc2V0LnggLSBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50LngsXG4gICAgICAgIHk6IGNsaWVudE9mZnNldC55IC0gZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudC55XG4gICAgfTtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoOiBzb3VyY2VXaWR0aCAsIG9mZnNldEhlaWdodDogc291cmNlSGVpZ2h0ICB9ID0gc291cmNlTm9kZTtcbiAgICBjb25zdCB7IGFuY2hvclggLCBhbmNob3JZICB9ID0gYW5jaG9yUG9pbnQ7XG4gICAgY29uc3QgeyBkcmFnUHJldmlld1dpZHRoICwgZHJhZ1ByZXZpZXdIZWlnaHQgIH0gPSBnZXREcmFnUHJldmlld1NpemUoaXNJbWFnZSwgZHJhZ1ByZXZpZXcsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVlPZmZzZXQgPSAoKT0+e1xuICAgICAgICBjb25zdCBpbnRlcnBvbGFudFkgPSBuZXcgTW9ub3RvbmljSW50ZXJwb2xhbnQoW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgLy8gRG9jayB0byB0aGUgdG9wXG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSxcbiAgICAgICAgICAgIC8vIEFsaWduIGF0IHRoZSBjZW50ZXJcbiAgICAgICAgICAgIChvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSAvIHNvdXJjZUhlaWdodCkgKiBkcmFnUHJldmlld0hlaWdodCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgb2Zmc2V0RnJvbURyYWdQcmV2aWV3LnkgKyBkcmFnUHJldmlld0hlaWdodCAtIHNvdXJjZUhlaWdodCwgXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgeSA9IGludGVycG9sYW50WS5pbnRlcnBvbGF0ZShhbmNob3JZKTtcbiAgICAgICAgLy8gV29yayBhcm91bmQgU2FmYXJpIDggcG9zaXRpb25pbmcgYnVnXG4gICAgICAgIGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gd2FpdCBmb3IgQDN4IHRvIHNlZSBpZiB0aGlzIGlzIGVudGlyZWx5IGNvcnJlY3RcbiAgICAgICAgICAgIHkgKz0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC0gMSkgKiBkcmFnUHJldmlld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbGN1bGF0ZVhPZmZzZXQgPSAoKT0+e1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gYW5jaG9yIHBvaW50XG4gICAgICAgIC8vIElmIHlvdSBrbm93IGEgc2ltcGxlciB3YXkgdG8gZG8gdGhpcywgbGV0IG1lIGtub3dcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhbnRYID0gbmV3IE1vbm90b25pY0ludGVycG9sYW50KFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICAxXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgIG9mZnNldEZyb21EcmFnUHJldmlldy54LFxuICAgICAgICAgICAgLy8gQWxpZ24gYXQgdGhlIGNlbnRlclxuICAgICAgICAgICAgKG9mZnNldEZyb21EcmFnUHJldmlldy54IC8gc291cmNlV2lkdGgpICogZHJhZ1ByZXZpZXdXaWR0aCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueCArIGRyYWdQcmV2aWV3V2lkdGggLSBzb3VyY2VXaWR0aCwgXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhbnRYLmludGVycG9sYXRlKGFuY2hvclgpO1xuICAgIH07XG4gICAgLy8gRm9yY2Ugb2Zmc2V0cyBpZiBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAgY29uc3QgeyBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IG9mZnNldFBvaW50O1xuICAgIGNvbnN0IGlzTWFudWFsT2Zmc2V0WCA9IG9mZnNldFggPT09IDAgfHwgb2Zmc2V0WDtcbiAgICBjb25zdCBpc01hbnVhbE9mZnNldFkgPSBvZmZzZXRZID09PSAwIHx8IG9mZnNldFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNNYW51YWxPZmZzZXRYID8gb2Zmc2V0WCA6IGNhbGN1bGF0ZVhPZmZzZXQoKSxcbiAgICAgICAgeTogaXNNYW51YWxPZmZzZXRZID8gb2Zmc2V0WSA6IGNhbGN1bGF0ZVlPZmZzZXQoKVxuICAgIH07XG59XG5cbmxldCBPcHRpb25zUmVhZGVyJDEgPSBjbGFzcyBPcHRpb25zUmVhZGVyIHtcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICBpZiAodGhpcy5nbG9iYWxDb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxDb250ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBkb2N1bWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmdsb2JhbENvbnRleHQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxDb250ZXh0LmRvY3VtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2luZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5vcHRpb25zQXJncykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYucm9vdEVsZW1lbnQpIHx8IHRoaXMud2luZG93O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihnbG9iYWxDb250ZXh0LCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5vd25lckRvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcbiAgICAgICAgdGhpcy5vcHRpb25zQXJncyA9IG9wdGlvbnM7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNsYXNzIEhUTUw1QmFja2VuZEltcGwge1xuICAgIC8qKlxuXHQgKiBHZW5lcmF0ZSBwcm9maWxpbmcgc3RhdGlzdGljcyBmb3IgdGhlIEhUTUw1QmFja2VuZC5cblx0ICovIHByb2ZpbGUoKSB7XG4gICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VQcmV2aWV3Tm9kZXM6IHRoaXMuc291cmNlUHJldmlld05vZGVzLnNpemUsXG4gICAgICAgICAgICBzb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnM6IHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zLnNpemUsXG4gICAgICAgICAgICBzb3VyY2VOb2RlT3B0aW9uczogdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5zaXplLFxuICAgICAgICAgICAgc291cmNlTm9kZXM6IHRoaXMuc291cmNlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIGRyYWdTdGFydFNvdXJjZUlkczogKChyZWYgPSB0aGlzLmRyYWdTdGFydFNvdXJjZUlkcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubGVuZ3RoKSB8fCAwLFxuICAgICAgICAgICAgZHJvcFRhcmdldElkczogdGhpcy5kcm9wVGFyZ2V0SWRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdFbnRlclRhcmdldElkczogdGhpcy5kcmFnRW50ZXJUYXJnZXRJZHMubGVuZ3RoLFxuICAgICAgICAgICAgZHJhZ092ZXJUYXJnZXRJZHM6ICgocmVmMSA9IHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEubGVuZ3RoKSB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHB1YmxpYyBmb3IgdGVzdFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud2luZG93O1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBHZXQgdGhlIHJvb3QgZWxlbWVudCB0byB1c2UgZm9yIGV2ZW50IHN1YnNjcmlwdGlvbnNcblx0ICovIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICB9XG4gICAgc2V0dXAoKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIHR3byBIVE1MNSBiYWNrZW5kcyBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycyhyb290KTtcbiAgICB9XG4gICAgdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5fX2lzUmVhY3REbmRCYWNrZW5kU2V0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJvb3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICBpZiAodGhpcy5hc3luY0VuZERyYWdGcmFtZUlkKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgKHJlZiA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFzeW5jRW5kRHJhZ0ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3REcmFnUHJldmlldyhzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5zZXQoc291cmNlSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25uZWN0RHJhZ1NvdXJjZShzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZU5vZGVzLnNldChzb3VyY2VJZCwgbm9kZSk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZU9wdGlvbnMuc2V0KHNvdXJjZUlkLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gKGUpPT50aGlzLmhhbmRsZURyYWdTdGFydChlLCBzb3VyY2VJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVTZWxlY3RTdGFydCA9IChlKT0+dGhpcy5oYW5kbGVTZWxlY3RTdGFydChlKVxuICAgICAgICA7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCAndHJ1ZScpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBoYW5kbGVTZWxlY3RTdGFydCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2Rlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGhhbmRsZVNlbGVjdFN0YXJ0KTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29ubmVjdERyb3BUYXJnZXQodGFyZ2V0SWQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKGUpPT50aGlzLmhhbmRsZURyYWdFbnRlcihlLCB0YXJnZXRJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IChlKT0+dGhpcy5oYW5kbGVEcmFnT3ZlcihlLCB0YXJnZXRJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVEcm9wID0gKGUpPT50aGlzLmhhbmRsZURyb3AoZSwgdGFyZ2V0SWQpXG4gICAgICAgIDtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVEcmFnRW50ZXIpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBoYW5kbGVEcm9wKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIGhhbmRsZURyYWdFbnRlcik7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgaGFuZGxlRHJvcCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCkge1xuICAgICAgICAvLyBTU1IgRml4IChodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9wdWxsLzgxM1xuICAgICAgICBpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdFbnRlcik7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdFbnRlckNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgdGhpcy5oYW5kbGVUb3BEcmFnTGVhdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpcy5oYW5kbGVUb3BEcmFnT3Zlcik7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZVRvcERyb3ApO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUsIHRydWUpO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQpIHtcbiAgICAgICAgLy8gU1NSIEZpeCAoaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvcHVsbC84MTNcbiAgICAgICAgaWYgKCF0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcERyYWdTdGFydCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcERyYWdTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlVG9wRHJhZ0VuZENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIHRoaXMuaGFuZGxlVG9wRHJhZ0xlYXZlQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdPdmVyQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5oYW5kbGVUb3BEcm9wKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZVRvcERyb3BDYXB0dXJlLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IHRoaXMubW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VOb2RlT3B0aW9ucyA9IHRoaXMuc291cmNlTm9kZU9wdGlvbnMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgZHJvcEVmZmVjdDogdGhpcy5hbHRLZXlQcmVzc2VkID8gJ2NvcHknIDogJ21vdmUnXG4gICAgICAgIH0sIHNvdXJjZU5vZGVPcHRpb25zIHx8IHt9KTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudERyb3BFZmZlY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgIC8vIEl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVmYXVsdCB0byAnY29weScgZm9yIG5hdGl2ZSByZXNvdXJjZXNcbiAgICAgICAgICAgIHJldHVybiAnY29weSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zKCkuZHJvcEVmZmVjdDtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSB0aGlzLm1vbml0b3IuZ2V0U291cmNlSWQoKTtcbiAgICAgICAgY29uc3Qgc291cmNlUHJldmlld05vZGVPcHRpb25zID0gdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgYW5jaG9yWDogMC41LFxuICAgICAgICAgICAgYW5jaG9yWTogMC41LFxuICAgICAgICAgICAgY2FwdHVyZURyYWdnaW5nU3RhdGU6IGZhbHNlXG4gICAgICAgIH0sIHNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyB8fCB7fSk7XG4gICAgfVxuICAgIGlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkge1xuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHRoaXMubW9uaXRvci5nZXRJdGVtVHlwZSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoTmF0aXZlVHlwZXMpLnNvbWUoKGtleSk9Pk5hdGl2ZVR5cGVzW2tleV0gPT09IGl0ZW1UeXBlXG4gICAgICAgICk7XG4gICAgfVxuICAgIGJlZ2luRHJhZ05hdGl2ZUl0ZW0odHlwZSwgZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlU291cmNlID0gY3JlYXRlTmF0aXZlRHJhZ1NvdXJjZSh0eXBlLCBkYXRhVHJhbnNmZXIpO1xuICAgICAgICB0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUgPSB0aGlzLnJlZ2lzdHJ5LmFkZFNvdXJjZSh0eXBlLCB0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpO1xuICAgICAgICB0aGlzLmFjdGlvbnMuYmVnaW5EcmFnKFtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc2V0Q3VycmVudERyYWdTb3VyY2VOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSA9IG5vZGU7XG4gICAgICAgIC8vIEEgdGltZW91dCBvZiA+IDAgaXMgbmVjZXNzYXJ5IHRvIHJlc29sdmUgRmlyZWZveCBpc3N1ZSByZWZlcmVuY2VkXG4gICAgICAgIC8vIFNlZTpcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL3B1bGwvOTI4XG4gICAgICAgIC8vICAgKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvODY5XG4gICAgICAgIGNvbnN0IE1PVVNFX01PVkVfVElNRU9VVCA9IDEwMDA7XG4gICAgICAgIC8vIFJlY2VpdmluZyBhIG1vdXNlIGV2ZW50IGluIHRoZSBtaWRkbGUgb2YgYSBkcmFnZ2luZyBvcGVyYXRpb25cbiAgICAgICAgLy8gbWVhbnMgaXQgaGFzIGVuZGVkIGFuZCB0aGUgZHJhZyBzb3VyY2Ugbm9kZSBkaXNhcHBlYXJlZCBmcm9tIERPTSxcbiAgICAgICAgLy8gc28gdGhlIGJyb3dzZXIgZGlkbid0IGRpc3BhdGNoIHRoZSBkcmFnZW5kIGV2ZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHdhaXQgYmVmb3JlIHdlIHN0YXJ0IGxpc3RlbmluZyBmb3IgbW91c2Vtb3ZlIGV2ZW50cy5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgZHJhZyBwcmV2aWV3IG5lZWRzIHRvIGJlIGRyYXduIG9yIGVsc2UgaXQgZmlyZXMgYW4gJ21vdXNlbW92ZScgZXZlbnRcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlOlxuICAgICAgICAvLyAgICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvcHVsbC85MjhcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL2lzc3Vlcy84NjlcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5tb3VzZU1vdmVUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLnJvb3RFbGVtZW50KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCB0cnVlKTtcbiAgICAgICAgfSwgTU9VU0VfTU9WRV9USU1FT1VUKTtcbiAgICB9XG4gICAgY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIChyZWYgPSB0aGlzLndpbmRvdykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY2xlYXJUaW1lb3V0KHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRHJhZ1N0YXJ0KGUsIHNvdXJjZUlkKSB7XG4gICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydFNvdXJjZUlkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzLnVuc2hpZnQoc291cmNlSWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcmFnRW50ZXIoX2UsIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcmFnT3ZlcihfZSwgdGFyZ2V0SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcm9wKF9lLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRJZHMudW5zaGlmdCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGdsb2JhbENvbnRleHQsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZU9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0SWRzID0gW107XG4gICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudERyYWdTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbHRLZXlQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hc3luY0VuZERyYWdGcmFtZUlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnT3ZlclRhcmdldElkcyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENsaWVudE9mZnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaG92ZXJSYWZJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2VOb2Rlcy5nZXQoc291cmNlSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSAmJiBnZXROb2RlQ2xpZW50T2Zmc2V0JDEoc291cmNlKSB8fCBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZERyYWdOYXRpdmVJdGVtID0gKCk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJlbW92ZVNvdXJjZSh0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlSGFuZGxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNOb2RlSW5Eb2N1bWVudCA9IChub2RlKT0+e1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIG5vZGUgZWl0aGVyIGluIHRoZSBtYWluIGRvY3VtZW50IG9yIGluIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG5vZGUgJiYgdGhpcy5kb2N1bWVudCAmJiB0aGlzLmRvY3VtZW50LmJvZHkgJiYgdGhpcy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKG5vZGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmREcmFnSWZTb3VyY2VXYXNSZW1vdmVkRnJvbURPTSA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IHRoaXMuaXNOb2RlSW5Eb2N1bWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNsZWFyQ3VycmVudERyYWdTb3VyY2VOb2RlKCkgJiYgdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEhvdmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZWR1bGVIb3ZlciA9IChkcmFnT3ZlclRhcmdldElkcyk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyUmFmSWQgPT09IG51bGwgJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3ZlcihkcmFnT3ZlclRhcmdldElkcyB8fCBbXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogdGhpcy5sYXN0Q2xpZW50T2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyUmFmSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbmNlbEhvdmVyID0gKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyUmFmSWQgIT09IG51bGwgJiYgdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuaG92ZXJSYWZJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlclJhZklkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnU3RhcnRDYXB0dXJlID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkcmFnU3RhcnRTb3VyY2VJZHMgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRTb3VyY2VJZHMgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50T2Zmc2V0ID0gZ2V0RXZlbnRDbGllbnRPZmZzZXQkMShlKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIGNyYXNoaW5nIGlmIHdlIG1pc3NlZCBhIGRyb3AgZXZlbnQgb3Igb3VyIHByZXZpb3VzIGRyYWcgZGllZFxuICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuZW5kRHJhZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHB1Ymxpc2ggdGhlIHNvdXJjZSBqdXN0IHlldCAoc2VlIHdoeSBiZWxvdylcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5iZWdpbkRyYWcoZHJhZ1N0YXJ0U291cmNlSWRzIHx8IFtdLCB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFNvdXJjZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0U291cmNlQ2xpZW50T2Zmc2V0OiB0aGlzLmdldFNvdXJjZUNsaWVudE9mZnNldCxcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhVHJhbnNmZXIgIH0gPSBlO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlVHlwZSA9IG1hdGNoTmF0aXZlSXRlbVR5cGUoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiB0eXBlb2YgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY3VzdG9tIGRyYWcgaW1hZ2UgaWYgdXNlciBzcGVjaWZpZXMgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNoaWxkIGRyYWcgc291cmNlIHJlZnVzZXMgZHJhZyBidXQgcGFyZW50IGFncmVlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHBhcmVudCdzIG5vZGUgYXMgZHJhZyBpbWFnZS4gTmVpdGhlciB3b3JrcyBpbiBJRSB0aG91Z2guXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUlkID0gdGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSB0aGlzLnNvdXJjZU5vZGVzLmdldChzb3VyY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdQcmV2aWV3ID0gdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuZ2V0KHNvdXJjZUlkKSB8fCBzb3VyY2VOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yWCAsIGFuY2hvclkgLCBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IHRoaXMuZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JZXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0UG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHJhZ1ByZXZpZXdPZmZzZXQgPSBnZXREcmFnUHJldmlld09mZnNldChzb3VyY2VOb2RlLCBkcmFnUHJldmlldywgY2xpZW50T2Zmc2V0LCBhbmNob3JQb2ludCwgb2Zmc2V0UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnUHJldmlldywgZHJhZ1ByZXZpZXdPZmZzZXQueCwgZHJhZ1ByZXZpZXdPZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCB3b24ndCBkcmFnIHdpdGhvdXQgc2V0dGluZyBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2ZlciA9PT0gbnVsbCB8fCBkYXRhVHJhbnNmZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFUcmFuc2Zlci5zZXREYXRhKCdhcHBsaWNhdGlvbi9qc29uJywge30pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBNSU1FIHR5cGVzIGluIHNldERhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgZHJhZyBzb3VyY2Ugbm9kZSBzbyB3ZSBjYW4gY2hlY2sgd2hldGhlclxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHJlbW92ZWQgZnJvbSBET00gYW5kIHRyaWdnZXIgZW5kRHJhZyBtYW51YWxseS5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnREcmFnU291cmNlTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgLy8gTm93IHdlIGFyZSByZWFkeSB0byBwdWJsaXNoIHRoZSBkcmFnIHNvdXJjZS4uIG9yIGFyZSB3ZSBub3Q/XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYXB0dXJlRHJhZ2dpbmdTdGF0ZSAgfSA9IHRoaXMuZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIGlmICghY2FwdHVyZURyYWdnaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXN1YWxseSB3ZSB3YW50IHRvIHB1Ymxpc2ggaXQgaW4gdGhlIG5leHQgdGljayBzbyB0aGF0IGJyb3dzZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYWJsZSB0byBzY3JlZW5zaG90IHRoZSBjdXJyZW50IChub3QgeWV0IGRyYWdnaW5nKSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgYWxzbyBuZWF0bHkgYXZvaWRzIGEgc2l0dWF0aW9uIHdoZXJlIHJlbmRlcigpIHJldHVybnMgbnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgc2FtZSB0aWNrIGZvciB0aGUgc291cmNlIGVsZW1lbnQsIGFuZCBicm93c2VyIGZyZWFrcyBvdXQuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnRoaXMuYWN0aW9ucy5wdWJsaXNoRHJhZ1NvdXJjZSgpXG4gICAgICAgICAgICAgICAgICAgICwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB0aGUgdXNlciBtYXkgd2FudCB0byBvdmVycmlkZSB0aGlzIGJlaGF2aW9yLCBlLmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHdvcmsgYXJvdW5kIElFIG5vdCBzdXBwb3J0aW5nIGN1c3RvbSBkcmFnIHByZXZpZXdzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGEgY3VzdG9tIGRyYWcgbGF5ZXIsIHRoZSBvbmx5IHdheSB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IGRyYWcgcHJldmlldyBmcm9tIGRyYXdpbmcgaW4gSUUgaXMgdG8gc2NyZWVuc2hvdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZHJhZ2dpbmcgc3RhdGUgaW4gd2hpY2ggdGhlIG5vZGUgaXRzZWxmIGhhcyB6ZXJvIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGhlaWdodC4gSW4gdGhpcyBjYXNlLCB0aG91Z2gsIHJldHVybmluZyBudWxsIGZyb20gcmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBhYnJ1cHRseSBlbmQgdGhlIGRyYWdnaW5nLCB3aGljaCBpcyBub3Qgb2J2aW91cy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhc29uIHN1Y2ggYmVoYXZpb3IgaXMgc3RyaWN0bHkgb3B0LWluLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMucHVibGlzaERyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBIG5hdGl2ZSBpdGVtIChzdWNoIGFzIFVSTCkgZHJhZ2dlZCBmcm9tIGluc2lkZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFUcmFuc2ZlciAmJiAhZGF0YVRyYW5zZmVyLnR5cGVzICYmIChlLnRhcmdldCAmJiAhZS50YXJnZXQuaGFzQXR0cmlidXRlIHx8ICFlLnRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpKSkge1xuICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgYSBTYWZhcmkgYnVnOiBkYXRhVHJhbnNmZXIudHlwZXMgaXMgbnVsbCwgYnV0IHRoZXJlIHdhcyBubyBkcmFnZ2FibGUuXG4gICAgICAgICAgICAgICAgLy8gSnVzdCBsZXQgaXQgZHJhZy4gSXQncyBhIG5hdGl2ZSB0eXBlIChVUkwgb3IgdGV4dCkgYW5kIHdpbGwgYmUgcGlja2VkIHVwIGluXG4gICAgICAgICAgICAgICAgLy8gZHJhZ2VudGVyIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBieSB0aGlzIHRpbWUgbm8gZHJhZyBzb3VyY2UgcmVhY3RlZCwgdGVsbCBicm93c2VyIG5vdCB0byBkcmFnLlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpICYmIHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGNhbiBkaXNwYXRjaCB0aGlzIGV2ZW50IGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICAvLyBpZiBkcmFnZW5kIGhhbmRsZXIgZG9lcyBzb21ldGhpbmcgbGlrZSBzaG93aW5nIGFuIGFsZXJ0LlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VlZCBpZiB3ZSBoYXZlIG5vdCBoYW5kbGVkIGl0IGFscmVhZHkuXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlID0gKGUpPT57XG4gICAgICAgICAgICB0aGlzLmRyYWdFbnRlclRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgKHJlZiA9IHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubG9hZERhdGFUcmFuc2ZlcihlLmRhdGFUcmFuc2Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0RW50ZXIgPSB0aGlzLmVudGVyTGVhdmVDb3VudGVyLmVudGVyKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaXNGaXJzdEVudGVyIHx8IHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFUcmFuc2ZlciAgfSA9IGU7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVUeXBlID0gbWF0Y2hOYXRpdmVJdGVtVHlwZShkYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgaWYgKG5hdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBIG5hdGl2ZSBpdGVtIChzdWNoIGFzIGZpbGUgb3IgVVJMKSBkcmFnZ2VkIGZyb20gb3V0c2lkZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSwgZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ0VudGVyVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmF0aXZlIGl0ZW0gdHlwZSB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWx0S2V5UHJlc3NlZCA9IGUuYWx0S2V5O1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBjaGFuZ2VzIHBvc2l0aW9uIGFzIHRoZSByZXN1bHQgb2YgYGRyYWdlbnRlcmAsIGBkcmFnb3ZlcmAgbWlnaHQgc3RpbGxcbiAgICAgICAgICAgIC8vIGdldCBkaXNwYXRjaGVkIGRlc3BpdGUgdGFyZ2V0IGJlaW5nIG5vIGxvbmdlciB0aGVyZS4gVGhlIGVhc3kgc29sdXRpb24gaXMgdG8gY2hlY2tcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgYWN0dWFsbHkgaXMgYSB0YXJnZXQgYmVmb3JlIGZpcmluZyBgaG92ZXJgLlxuICAgICAgICAgICAgaWYgKGRyYWdFbnRlclRhcmdldElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmhvdmVyKGRyYWdFbnRlclRhcmdldElkcywge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbkRyb3AgPSBkcmFnRW50ZXJUYXJnZXRJZHMuc29tZSgodGFyZ2V0SWQpPT50aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjYW5Ecm9wKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgcmVxdWlyZXMgdGhpcyB0byBmaXJlIGRyYWdvdmVyIGV2ZW50c1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHRoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlID0gKGUpPT57XG4gICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAocmVmID0gdGhpcy5jdXJyZW50TmF0aXZlU291cmNlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sb2FkRGF0YVRyYW5zZmVyKGUuZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnT3ZlciA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnT3ZlclRhcmdldElkcyAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmF0aXZlIGl0ZW0gdHlwZSB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBcImRyb3AgYW5kIGJsb3cgYXdheSB0aGUgd2hvbGUgZG9jdW1lbnRcIiBhY3Rpb24uXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFsdEtleVByZXNzZWQgPSBlLmFsdEtleTtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWVudE9mZnNldCA9IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlSG92ZXIoZHJhZ092ZXJUYXJnZXRJZHMpO1xuICAgICAgICAgICAgY29uc3QgY2FuRHJvcCA9IChkcmFnT3ZlclRhcmdldElkcyB8fCBbXSkuc29tZSgodGFyZ2V0SWQpPT50aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjYW5Ecm9wKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyB1c2VyLXNwZWNpZmllZCBkcm9wIGVmZmVjdC5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSB0aGlzLmdldEN1cnJlbnREcm9wRWZmZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGEgbmljZSBjdXJzb3IgYnV0IHN0aWxsIHByZXZlbnQgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIFwiZHJvcCBhbmQgYmxvdyBhd2F5IHRoZSB3aG9sZSBkb2N1bWVudFwiIGFjdGlvbi5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ0xlYXZlQ2FwdHVyZSA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdExlYXZlID0gdGhpcy5lbnRlckxlYXZlQ291bnRlci5sZWF2ZShlLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWlzTGFzdExlYXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnRoaXMuZW5kRHJhZ05hdGl2ZUl0ZW0oKVxuICAgICAgICAgICAgICAgICwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEhvdmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUgPSAoZSk9PntcbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIChyZWYgPSB0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmxvYWREYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaE5hdGl2ZUl0ZW1UeXBlKGUuZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIERyYWdnaW5nIHNvbWUgZWxlbWVudHMsIGxpa2UgPGE+IGFuZCA8aW1nPiBtYXkgc3RpbGwgYmVoYXZlIGxpa2UgYSBuYXRpdmUgZHJhZyBldmVudCxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBjdXJyZW50IGRyYWcgZXZlbnQgbWF0Y2hlcyBhIHVzZXItZGVmaW5lZCB0eXBlLlxuICAgICAgICAgICAgICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiB3ZSdyZSBub3QgZXhwZWN0aW5nIGEgbmF0aXZlIGl0ZW0gdG8gYmUgZHJvcHBlZC5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVudGVyTGVhdmVDb3VudGVyLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJvcCA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBkcm9wVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmhvdmVyKGRyb3BUYXJnZXRJZHMsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICAgICAgICAgIGRyb3BFZmZlY3Q6IHRoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmREcmFnTmF0aXZlSXRlbSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAvLyBPbmx5IElFIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2F5XG4gICAgICAgICAgICAvLyB3ZSB3YW50IGRyYWcgZHJvcCBvcGVyYXRpb24gdG8gc3RhcnRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LmRyYWdEcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5wdXRzIGFuZCB0ZXh0YXJlYXMgc2hvdWxkIGJlIHNlbGVjdGFibGVcbiAgICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHwgdGFyZ2V0LnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIG90aGVyIHRhcmdldHMsIGFzayBJRVxuICAgICAgICAgICAgLy8gdG8gZW5hYmxlIGRyYWcgYW5kIGRyb3BcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRhcmdldC5kcmFnRHJvcCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXcgT3B0aW9uc1JlYWRlciQxKGdsb2JhbENvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuZW50ZXJMZWF2ZUNvdW50ZXIgPSBuZXcgRW50ZXJMZWF2ZUNvdW50ZXIodGhpcy5pc05vZGVJbkRvY3VtZW50KTtcbiAgICB9XG59XG5cbmxldCBlbXB0eUltYWdlO1xuZnVuY3Rpb24gZ2V0RW1wdHlJbWFnZSgpIHtcbiAgICBpZiAoIWVtcHR5SW1hZ2UpIHtcbiAgICAgICAgZW1wdHlJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBlbXB0eUltYWdlLnNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PSc7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eUltYWdlO1xufVxuXG5jb25zdCBIVE1MNUJhY2tlbmQgPSBmdW5jdGlvbiBjcmVhdGVCYWNrZW5kKG1hbmFnZXIsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEhUTUw1QmFja2VuZEltcGwobWFuYWdlciwgY29udGV4dCwgb3B0aW9ucyk7XG59O1xuXG5mdW5jdGlvbiBQaWVjZSh7IGlzUHJlbW92ZWRQaWVjZSA9IGZhbHNlLCBwaWVjZSwgc3F1YXJlLCBzcXVhcmVzLCB9KSB7XHJcbiAgICBjb25zdCB7IGFuaW1hdGlvbkR1cmF0aW9uLCBhcmVQaWVjZXNEcmFnZ2FibGUsIGJvYXJkV2lkdGgsIGJvYXJkT3JpZW50YXRpb24sIGNoZXNzUGllY2VzLCBjdXJyZW50UG9zaXRpb24sIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZSwgZHJvcE9mZkJvYXJkQWN0aW9uLCBpZCwgaXNEcmFnZ2FibGVQaWVjZSwgaXNXYWl0aW5nRm9yQW5pbWF0aW9uLCBvblBpZWNlQ2xpY2ssIG9uUGllY2VEcmFnQmVnaW4sIG9uUGllY2VEcmFnRW5kLCBvblBpZWNlRHJvcE9mZkJvYXJkLCBvblByb21vdGlvbkNoZWNrLCBwb3NpdGlvbkRpZmZlcmVuY2VzLCB9ID0gdXNlQ2hlc3Nib2FyZCgpO1xyXG4gICAgY29uc3QgW3BpZWNlU3R5bGUsIHNldFBpZWNlU3R5bGVdID0gdXNlU3RhdGUoe1xyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgekluZGV4OiA1LFxyXG4gICAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcclxuICAgICAgICBjdXJzb3I6IGFyZVBpZWNlc0RyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZVBpZWNlKHsgcGllY2UsIHNvdXJjZVNxdWFyZTogc3F1YXJlIH0pXHJcbiAgICAgICAgICAgID8gXCItd2Via2l0LWdyYWJcIlxyXG4gICAgICAgICAgICA6IFwiZGVmYXVsdFwiLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBbeyBjYW5EcmFnLCBpc0RyYWdnaW5nIH0sIGRyYWcsIGRyYWdQcmV2aWV3XSA9IHVzZURyYWcoKCkgPT4gKHtcclxuICAgICAgICB0eXBlOiBcInBpZWNlXCIsXHJcbiAgICAgICAgaXRlbTogKCkgPT4ge1xyXG4gICAgICAgICAgICBvblBpZWNlRHJhZ0JlZ2luKHBpZWNlLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBwaWVjZSwgc3F1YXJlLCBpZCB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kOiAoaXRlbSwgbW9uaXRvcikgPT4ge1xyXG4gICAgICAgICAgICBvblBpZWNlRHJhZ0VuZChwaWVjZSwgc3F1YXJlKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRHJvcE91dHNpZGVUaGVCb2FyZCA9ICFtb25pdG9yLmRpZERyb3AoKTtcclxuICAgICAgICAgICAgaWYgKHdhc0Ryb3BPdXRzaWRlVGhlQm9hcmQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcm9wT2ZmQm9hcmRBY3Rpb24gPT09IFwidHJhc2hcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZShzcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb25QaWVjZURyb3BPZmZCb2FyZCA9PT0gbnVsbCB8fCBvblBpZWNlRHJvcE9mZkJvYXJkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblBpZWNlRHJvcE9mZkJvYXJkKHNxdWFyZSwgcGllY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0OiAobW9uaXRvcikgPT4gKHtcclxuICAgICAgICAgICAgY2FuRHJhZzogaXNEcmFnZ2FibGVQaWVjZSh7IHBpZWNlLCBzb3VyY2VTcXVhcmU6IHNxdWFyZSB9KSxcclxuICAgICAgICAgICAgaXNEcmFnZ2luZzogISFtb25pdG9yLmlzRHJhZ2dpbmcoKSxcclxuICAgICAgICB9KSxcclxuICAgIH0pLCBbcGllY2UsIHNxdWFyZSwgY3VycmVudFBvc2l0aW9uLCBpZF0pO1xyXG4gICAgLy8gaGlkZSB0aGUgZGVmYXVsdCBwcmV2aWV3XHJcbiAgICBkcmFnUHJldmlldyhnZXRFbXB0eUltYWdlKCksIHsgY2FwdHVyZURyYWdnaW5nU3RhdGU6IHRydWUgfSk7XHJcbiAgICAvLyBoaWRlIHBpZWNlIG9uIGRyYWdcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0UGllY2VTdHlsZSgob2xkUGllY2VTdHlsZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkUGllY2VTdHlsZSksIHsgb3BhY2l0eTogaXNEcmFnZ2luZyA/IDAgOiAxIH0pKSk7XHJcbiAgICB9LCBbaXNEcmFnZ2luZ10pO1xyXG4gICAgLy8gbmV3IG1vdmUgaGFzIGNvbWUgaW5cclxuICAgIC8vIGlmIHdhaXRpbmcgZm9yIGFuaW1hdGlvbiwgdGhlbiBhbmltYXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHdlIGNhbiBwZXJmb3JtIGFuaW1hdGlvblxyXG4gICAgLy8gd2UgbmVlZCB0byBoZWFkIHRvd2FyZHMgd2hlcmUgd2UgbmVlZCB0byBnbywgd2UgYXJlIHRoZSBzb3VyY2UsIHdlIGFyZSBoZWFkaW5nIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFBpZWNlID0gKF9hID0gcG9zaXRpb25EaWZmZXJlbmNlcy5yZW1vdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fbc3F1YXJlXTtcclxuICAgICAgICAvLyByZXR1cm4gYXMgbnVsbCBhbmQgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICBpZiAoIXBvc2l0aW9uRGlmZmVyZW5jZXMuYWRkZWQgfHwgIXJlbW92ZWRQaWVjZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBpZWNlIG1hdGNoZXMgb3IgaWYgcmVtb3ZlZCBwaWVjZSB3YXMgYSBwYXduIGFuZCBuZXcgc3F1YXJlIGlzIG9uIDFzdCBvciA4dGggcmFuayAocHJvbW90aW9uKVxyXG4gICAgICAgIGNvbnN0IG5ld1NxdWFyZSA9IE9iamVjdC5lbnRyaWVzKHBvc2l0aW9uRGlmZmVyZW5jZXMuYWRkZWQpLmZpbmQoKFtzLCBwXSkgPT4gcCA9PT0gcmVtb3ZlZFBpZWNlIHx8IG9uUHJvbW90aW9uQ2hlY2soc3F1YXJlLCBzLCByZW1vdmVkUGllY2UpKTtcclxuICAgICAgICAvLyB3ZSBjYW4gcGVyZm9ybSBhbmltYXRpb24gaWYgb3VyIHNxdWFyZSB3YXMgaW4gcmVtb3ZlZCwgQU5EIHRoZSBtYXRjaGluZyBwaWVjZSBpcyBpbiBhZGRlZCBBTkQgdGhpcyBpc24ndCBhIHByZW1vdmVkIHBpZWNlXHJcbiAgICAgICAgaWYgKGlzV2FpdGluZ0ZvckFuaW1hdGlvbiAmJlxyXG4gICAgICAgICAgICByZW1vdmVkUGllY2UgJiZcclxuICAgICAgICAgICAgbmV3U3F1YXJlICYmXHJcbiAgICAgICAgICAgICFpc1ByZW1vdmVkUGllY2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlU3EgPSBzcXVhcmU7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNxID0gbmV3U3F1YXJlWzBdO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlU3EgJiYgdGFyZ2V0U3EpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDg7XHJcbiAgICAgICAgICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gLTEgOiAxKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0YXJnZXRTcS5jaGFyQ29kZUF0KDApIC0gc291cmNlU3EuY2hhckNvZGVBdCgwKSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weCwgJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gLTEgOiAxKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChOdW1iZXIoc291cmNlU3FbMV0pIC0gTnVtYmVyKHRhcmdldFNxWzFdKSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weClgLCB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7YW5pbWF0aW9uRHVyYXRpb259bXNgLCB6SW5kZXg6IDYgfSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtwb3NpdGlvbkRpZmZlcmVuY2VzXSk7XHJcbiAgICAvLyB0cmFuc2xhdGUgdG8gdGhlaXIgb3duIHBvc2l0aW9ucyAocmVwYWludCBvbiB1bmRvKVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHNvdXJjZVNxIH0gPSBnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcygpO1xyXG4gICAgICAgIGlmIChzb3VyY2VTcSkge1xyXG4gICAgICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHswfXB4LCAkezB9cHgpYCwgdHJhbnNpdGlvbjogYHRyYW5zZm9ybSAkezB9bXNgIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRQb3NpdGlvbl0pO1xyXG4gICAgLy8gdXBkYXRlIGlzIHBpZWNlIGRyYWdnYWJsZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyBjdXJzb3I6IGFyZVBpZWNlc0RyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZVBpZWNlKHsgcGllY2UsIHNvdXJjZVNxdWFyZTogc3F1YXJlIH0pXHJcbiAgICAgICAgICAgICAgICA/IFwiLXdlYmtpdC1ncmFiXCJcclxuICAgICAgICAgICAgICAgIDogXCJkZWZhdWx0XCIgfSkpKTtcclxuICAgIH0sIFtzcXVhcmUsIGN1cnJlbnRQb3NpdGlvbiwgYXJlUGllY2VzRHJhZ2dhYmxlXSk7XHJcbiAgICBmdW5jdGlvbiBnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcygpIHtcclxuICAgICAgICByZXR1cm4geyBzb3VyY2VTcTogc3F1YXJlc1tzcXVhcmVdIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBhcmVQaWVjZXNEcmFnZ2FibGUgJiYgY2FuRHJhZyA/IGRyYWcgOiBudWxsLCBvbkNsaWNrOiAoKSA9PiBvblBpZWNlQ2xpY2socGllY2UsIHNxdWFyZSksIFwiZGF0YS1waWVjZVwiOiBwaWVjZSwgc3R5bGU6IHBpZWNlU3R5bGUgfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW3BpZWNlXSA9PT0gXCJmdW5jdGlvblwiID8gKGNoZXNzUGllY2VzW3BpZWNlXSh7XHJcbiAgICAgICAgICAgIHNxdWFyZVdpZHRoOiBib2FyZFdpZHRoIC8gOCxcclxuICAgICAgICAgICAgaXNEcmFnZ2luZyxcclxuICAgICAgICAgICAgc3F1YXJlLFxyXG4gICAgICAgIH0pKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiBib2FyZFdpZHRoIC8gOCwgaGVpZ2h0OiBib2FyZFdpZHRoIC8gOCwgc3R5bGU6IHsgZGlzcGxheTogXCJibG9ja1wiIH0gfSwgeyBjaGlsZHJlbjoganN4KFwiZ1wiLCB7IGNoaWxkcmVuOiBjaGVzc1BpZWNlc1twaWVjZV0gfSkgfSkpKSB9KSkpO1xyXG59XG5cbmZ1bmN0aW9uIFNxdWFyZSh7IHNxdWFyZSwgc3F1YXJlQ29sb3IsIHNldFNxdWFyZXMsIHNxdWFyZUhhc1ByZW1vdmUsIGNoaWxkcmVuLCB9KSB7XHJcbiAgICBjb25zdCBzcXVhcmVSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCB7IGF1dG9Qcm9tb3RlVG9RdWVlbiwgYm9hcmRXaWR0aCwgYm9hcmRPcmllbnRhdGlvbiwgY2xlYXJBcnJvd3MsIGN1cnJlbnRQb3NpdGlvbiwgY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBjdXN0b21Cb2FyZFN0eWxlLCBjdXN0b21EYXJrU3F1YXJlU3R5bGUsIGN1c3RvbURyb3BTcXVhcmVTdHlsZSwgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSwgY3VzdG9tUHJlbW92ZURhcmtTcXVhcmVTdHlsZSwgY3VzdG9tUHJlbW92ZUxpZ2h0U3F1YXJlU3R5bGUsIGN1c3RvbVNxdWFyZTogQ3VzdG9tU3F1YXJlLCBjdXN0b21TcXVhcmVTdHlsZXMsIGRyYXdOZXdBcnJvdywgaGFuZGxlU2V0UG9zaXRpb24sIGhhbmRsZVNwYXJlUGllY2VEcm9wLCBpc1dhaXRpbmdGb3JBbmltYXRpb24sIGxhc3RQaWVjZUNvbG91ciwgbGFzdFNxdWFyZURyYWdnZWRPdmVyLCBvbkFycm93RHJhd0VuZCwgb25EcmFnT3ZlclNxdWFyZSwgb25Nb3VzZU91dFNxdWFyZSwgb25Nb3VzZU92ZXJTcXVhcmUsIG9uUGllY2VEcm9wLCBvblByb21vdGlvbkNoZWNrLCBvblJpZ2h0Q2xpY2tEb3duLCBvblJpZ2h0Q2xpY2tVcCwgb25TcXVhcmVDbGljaywgc2V0TGFzdFNxdWFyZURyYWdnZWRPdmVyLCBzZXRQcm9tb3RlRnJvbVNxdWFyZSwgc2V0UHJvbW90ZVRvU3F1YXJlLCBzZXRTaG93UHJvbW90ZURpYWxvZywgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IFt7IGlzT3ZlciB9LCBkcm9wXSA9IHVzZURyb3AoKCkgPT4gKHtcclxuICAgICAgICBhY2NlcHQ6IFwicGllY2VcIixcclxuICAgICAgICBkcm9wOiBoYW5kbGVEcm9wLFxyXG4gICAgICAgIGNvbGxlY3Q6IChtb25pdG9yKSA9PiAoe1xyXG4gICAgICAgICAgICBpc092ZXI6ICEhbW9uaXRvci5pc092ZXIoKSxcclxuICAgICAgICB9KSxcclxuICAgIH0pLCBbXHJcbiAgICAgICAgc3F1YXJlLFxyXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbixcclxuICAgICAgICBvblBpZWNlRHJvcCxcclxuICAgICAgICBpc1dhaXRpbmdGb3JBbmltYXRpb24sXHJcbiAgICAgICAgbGFzdFBpZWNlQ29sb3VyLFxyXG4gICAgXSk7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVEcm9wKGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbS5pc1NwYXJlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNwYXJlUGllY2VEcm9wKGl0ZW0ucGllY2UsIHNxdWFyZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uUHJvbW90aW9uQ2hlY2soaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZSkpIHtcclxuICAgICAgICAgICAgaWYgKGF1dG9Qcm9tb3RlVG9RdWVlbikge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0UG9zaXRpb24oaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZVswXSA9PT0gXCJ3XCIgPyBcIndRXCIgOiBcImJRXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbW90ZUZyb21TcXVhcmUoaXRlbS5zcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbW90ZVRvU3F1YXJlKHNxdWFyZSk7XHJcbiAgICAgICAgICAgICAgICBzZXRTaG93UHJvbW90ZURpYWxvZyh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0UG9zaXRpb24oaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3F1YXJlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBzcXVhcmVSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgc2V0U3F1YXJlcygob2xkU3F1YXJlcykgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkU3F1YXJlcyksIHsgW3NxdWFyZV06IHsgeCwgeSB9IH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2JvYXJkV2lkdGgsIGJvYXJkT3JpZW50YXRpb25dKTtcclxuICAgIGNvbnN0IGRlZmF1bHRTcXVhcmVTdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJvcmRlclJhZGl1cyhzcXVhcmUsIGJvYXJkT3JpZW50YXRpb24sIGN1c3RvbUJvYXJkU3R5bGUpKSwgKHNxdWFyZUNvbG9yID09PSBcImJsYWNrXCJcclxuICAgICAgICA/IGN1c3RvbURhcmtTcXVhcmVTdHlsZVxyXG4gICAgICAgIDogY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSkpLCAoc3F1YXJlSGFzUHJlbW92ZSAmJlxyXG4gICAgICAgIChzcXVhcmVDb2xvciA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgID8gY3VzdG9tUHJlbW92ZURhcmtTcXVhcmVTdHlsZVxyXG4gICAgICAgICAgICA6IGN1c3RvbVByZW1vdmVMaWdodFNxdWFyZVN0eWxlKSkpLCAoaXNPdmVyICYmIGN1c3RvbURyb3BTcXVhcmVTdHlsZSkpO1xyXG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogZHJvcCwgc3R5bGU6IGRlZmF1bHRTcXVhcmVTdHlsZSwgXCJkYXRhLXNxdWFyZS1jb2xvclwiOiBzcXVhcmVDb2xvciwgXCJkYXRhLXNxdWFyZVwiOiBzcXVhcmUsIG9uVG91Y2hNb3ZlOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0b3VjaCBldmVudHMgb24gdGFibGV0IGFuZCBtb2JpbGUgbm90IGNvdmVyZWQgYnkgb25Nb3VzZU92ZXIvb25EcmFnRW50ZXJcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hMb2NhdGlvbiA9IGUudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQodG91Y2hMb2NhdGlvbi5jbGllbnRYLCB0b3VjaExvY2F0aW9uLmNsaWVudFkpO1xyXG4gICAgICAgICAgICBjb25zdCBkcmFnZ2VkT3ZlclNxdWFyZSA9IChfYSA9IHRvdWNoRWxlbWVudCA9PT0gbnVsbCB8fCB0b3VjaEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvdWNoRWxlbWVudC5maW5kKChlbCkgPT4gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcXVhcmVcIikpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcXVhcmVcIik7XHJcbiAgICAgICAgICAgIGlmIChkcmFnZ2VkT3ZlclNxdWFyZSAmJiBkcmFnZ2VkT3ZlclNxdWFyZSAhPT0gbGFzdFNxdWFyZURyYWdnZWRPdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRMYXN0U3F1YXJlRHJhZ2dlZE92ZXIoZHJhZ2dlZE92ZXJTcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgb25EcmFnT3ZlclNxdWFyZShkcmFnZ2VkT3ZlclNxdWFyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvbk1vdXNlT3ZlcjogKGUpID0+IHtcclxuICAgICAgICAgICAgLy8gbm9vcCBpZiBtb3ZpbmcgZnJvbSBjaGlsZCBvZiBzcXVhcmUgaW50byBzcXVhcmUuXHJcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgPT09IDIgJiYgY3VycmVudFJpZ2h0Q2xpY2tEb3duKSB7XHJcbiAgICAgICAgICAgICAgICBkcmF3TmV3QXJyb3coY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgJiZcclxuICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25Nb3VzZU92ZXJTcXVhcmUoc3F1YXJlKTtcclxuICAgICAgICB9LCBvbk1vdXNlT3V0OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBub29wIGlmIG1vdmluZyBmcm9tIHNxdWFyZSBpbnRvIGEgY2hpbGQgb2Ygc3F1YXJlLlxyXG4gICAgICAgICAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ICYmXHJcbiAgICAgICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgb25Nb3VzZU91dFNxdWFyZShzcXVhcmUpO1xyXG4gICAgICAgIH0sIG9uTW91c2VEb3duOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpXHJcbiAgICAgICAgICAgICAgICBvblJpZ2h0Q2xpY2tEb3duKHNxdWFyZSk7XHJcbiAgICAgICAgfSwgb25Nb3VzZVVwOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmlnaHRDbGlja0Rvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgb25BcnJvd0RyYXdFbmQoY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgb25SaWdodENsaWNrVXAoc3F1YXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9uRHJhZ0VudGVyOiAoKSA9PiBvbkRyYWdPdmVyU3F1YXJlKHNxdWFyZSksIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXTtcclxuICAgICAgICAgICAgb25TcXVhcmVDbGljayhzcXVhcmUsIHBpZWNlKTtcclxuICAgICAgICAgICAgY2xlYXJBcnJvd3MoKTtcclxuICAgICAgICB9LCBvbkNvbnRleHRNZW51OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiB0eXBlb2YgQ3VzdG9tU3F1YXJlID09PSBcInN0cmluZ1wiID8gKGpzeChDdXN0b21TcXVhcmVcclxuICAgICAgICAvLyBUeXBlIGlzIHRvbyBjb21wbGV4IHRvIHByb3Blcmx5IGV2YWx1YXRlLCBzbyBpZ25vcmUgdGhpcyBsaW5lLlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAsIE9iamVjdC5hc3NpZ24oeyBcclxuICAgICAgICAgICAgLy8gVHlwZSBpcyB0b28gY29tcGxleCB0byBwcm9wZXJseSBldmFsdWF0ZSwgc28gaWdub3JlIHRoaXMgbGluZS5cclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICByZWY6IHNxdWFyZVJlZiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaXplKGJvYXJkV2lkdGgpKSwgY2VudGVyKSwgKCFzcXVhcmVIYXNQcmVtb3ZlICYmIChjdXN0b21TcXVhcmVTdHlsZXMgPT09IG51bGwgfHwgY3VzdG9tU3F1YXJlU3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21TcXVhcmVTdHlsZXNbc3F1YXJlXSkpKSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpIDogKGpzeChDdXN0b21TcXVhcmUsIE9iamVjdC5hc3NpZ24oeyByZWY6IHNxdWFyZVJlZiwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZUNvbG9yOiBzcXVhcmVDb2xvciwgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaXplKGJvYXJkV2lkdGgpKSwgY2VudGVyKSwgKCFzcXVhcmVIYXNQcmVtb3ZlICYmIChjdXN0b21TcXVhcmVTdHlsZXMgPT09IG51bGwgfHwgY3VzdG9tU3F1YXJlU3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21TcXVhcmVTdHlsZXNbc3F1YXJlXSkpKSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpIH0pKSk7XHJcbn1cclxuY29uc3QgY2VudGVyID0ge1xyXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxufTtcclxuY29uc3Qgc2l6ZSA9ICh3aWR0aCkgPT4gKHtcclxuICAgIHdpZHRoOiB3aWR0aCAvIDgsXHJcbiAgICBoZWlnaHQ6IHdpZHRoIC8gOCxcclxufSk7XHJcbmNvbnN0IGJvcmRlclJhZGl1cyA9IChzcXVhcmUsIGJvYXJkT3JpZW50YXRpb24sIGN1c3RvbUJvYXJkU3R5bGUpID0+IHtcclxuICAgIGlmICghKGN1c3RvbUJvYXJkU3R5bGUgPT09IG51bGwgfHwgY3VzdG9tQm9hcmRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMpKVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIGlmIChzcXVhcmUgPT09IFwiYTFcIikge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCJcclxuICAgICAgICAgICAgPyB7IGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGN1c3RvbUJvYXJkU3R5bGUuYm9yZGVyUmFkaXVzIH1cclxuICAgICAgICAgICAgOiB7IGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHNxdWFyZSA9PT0gXCJhOFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGJvYXJkT3JpZW50YXRpb24gPT09IFwid2hpdGVcIlxyXG4gICAgICAgICAgICA/IHsgYm9yZGVyVG9wTGVmdFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfVxyXG4gICAgICAgICAgICA6IHsgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGN1c3RvbUJvYXJkU3R5bGUuYm9yZGVyUmFkaXVzIH07XHJcbiAgICB9XHJcbiAgICBpZiAoc3F1YXJlID09PSBcImgxXCIpIHtcclxuICAgICAgICByZXR1cm4gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiXHJcbiAgICAgICAgICAgID8geyBib3JkZXJCb3R0b21SaWdodFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfVxyXG4gICAgICAgICAgICA6IHsgYm9yZGVyVG9wTGVmdFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfTtcclxuICAgIH1cclxuICAgIGlmIChzcXVhcmUgPT09IFwiaDhcIikge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCJcclxuICAgICAgICAgICAgPyB7IGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9XHJcbiAgICAgICAgICAgIDogeyBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG59O1xuXG5mdW5jdGlvbiBTcXVhcmVzKCkge1xyXG4gICAgY29uc3QgW3NxdWFyZXMsIHNldFNxdWFyZXNdID0gdXNlU3RhdGUoe30pO1xyXG4gICAgY29uc3QgeyBhcmVQcmVtb3Zlc0FsbG93ZWQsIGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1cnJlbnRQb3NpdGlvbiwgaWQsIHByZW1vdmVzLCBzaG93Qm9hcmROb3RhdGlvbiwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IHByZW1vdmVzSGlzdG9yeSA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIC8vIGlmIHByZW1vdmVzIGFyZW4ndCBhbGxvd2VkLCBkb24ndCB3YXN0ZSB0aW1lIG9uIGNhbGN1bGF0aW9uc1xyXG4gICAgICAgIGlmICghYXJlUHJlbW92ZXNBbGxvd2VkKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgcHJlbW92ZXMuZm9yRWFjaCgocHJlbW92ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIHBpZWNlIH0gPSBwcmVtb3ZlO1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIHByZW1vdmUgaXMgbWFkZSBieSBhbiBhbHJlYWR5IHByZW1vdmVkIHBpZWNlXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWRQcmVtb3ZlZFBpZWNlID0gcmVzdWx0LmZpbmQoKHApID0+IHsgdmFyIF9hOyByZXR1cm4gcC5waWVjZSA9PT0gcGllY2UgJiYgKChfYSA9IHAucHJlbW92ZXNSb3V0ZS5hdCgtMSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXRTcSkgPT09IHNvdXJjZVNxOyB9KTtcclxuICAgICAgICAgICAgLy8gaWYgcHJlbW92ZSBoYXMgYmVlbiBtYWRlIGJ5IGFscmVhZHkgcHJlbW92ZWQgcGllY2UgdGhlbiB3cml0ZSB0aGUgbW92ZSB0byBpdHMgYHByZW1vdmVzUm91dGVgIGZpZWxkIHRvIGJlIGFibGUgZmluZCBpdHMgZmluYWwgZGVzdGluYXRpb24gbGF0ZXJcclxuICAgICAgICAgICAgaWYgKHJlbGF0ZWRQcmVtb3ZlZFBpZWNlKSB7XHJcbiAgICAgICAgICAgICAgICByZWxhdGVkUHJlbW92ZWRQaWVjZS5wcmVtb3Zlc1JvdXRlLnB1c2goeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIGluZGV4IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHByZW1vdmUgaGFzIGJlZW4gbWFkZSBieSBzdGFuZGFyZCBwaWVjZSBjcmVhdGUgbmV3IG9iamVjdCBpbiBgcHJlbW92ZXNIaXN0b3J5YCB3aGVyZSB3ZSB3aWxsIGtlZXAgaXRzIG93biBwcmVtb3Zlc1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwaWVjZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCBpcyB1c2VmdWwgZm9yIHNjZW5hcmlvcyB3aGVyZSB0d28gb3IgbW9yZSBwaWVjZXMgYXJlIHRhcmdldGluZyB0aGUgc2FtZSBzcXVhcmVcclxuICAgICAgICAgICAgICAgICAgICBwcmVtb3Zlc1JvdXRlOiBbeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIGluZGV4IH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgW3ByZW1vdmVzXSk7XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgXCJkYXRhLWJvYXJkaWRcIjogaWQgfSwgeyBjaGlsZHJlbjogWy4uLkFycmF5KDgpXS5tYXAoKF8sIHIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJvYXJkV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFsuLi5BcnJheSg4KV0ubWFwKChfLCBjKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKENPTFVNTlNbNyAtIGNdICsgKHIgKyAxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoQ09MVU1OU1tjXSArICg4IC0gcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZUNvbG9yID0gYyAlIDIgPT09IHIgJSAyID8gXCJ3aGl0ZVwiIDogXCJibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZUhhc1ByZW1vdmUgPSBwcmVtb3Zlcy5maW5kKChwKSA9PiBwLnNvdXJjZVNxID09PSBzcXVhcmUgfHwgcC50YXJnZXRTcSA9PT0gc3F1YXJlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcXVhcmVIYXNQcmVtb3ZlVGFyZ2V0ID0gcHJlbW92ZXNIaXN0b3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgcHJlbW92ZXNSb3V0ZSB9KSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBwcmVtb3Zlc1JvdXRlLmF0KC0xKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldFNxKSA9PT0gc3F1YXJlOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBwcmVtb3ZlZCBwaWVjZSB3aXRoIHRoZSBoaWdoZXIgaW5kZXggd2lsbCBiZSBzaG93biwgYXMgaXQgaXMgdGhlIGxhdGVzdCBvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBiLnByZW1vdmVzUm91dGUuYXQoLTEpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXgpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBhLnByZW1vdmVzUm91dGUuYXQoLTEpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGpzeHMoU3F1YXJlLCBPYmplY3QuYXNzaWduKHsgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZUNvbG9yOiBzcXVhcmVDb2xvciwgc2V0U3F1YXJlczogc2V0U3F1YXJlcywgc3F1YXJlSGFzUHJlbW92ZTogISFzcXVhcmVIYXNQcmVtb3ZlIH0sIHsgY2hpbGRyZW46IFshc3F1YXJlSGFzUHJlbW92ZSAmJiBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSAmJiAoanN4KFBpZWNlLCB7IHBpZWNlOiBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZXM6IHNxdWFyZXMgfSkpLCBzcXVhcmVIYXNQcmVtb3ZlVGFyZ2V0ICYmIChqc3goUGllY2UsIHsgaXNQcmVtb3ZlZFBpZWNlOiB0cnVlLCBwaWVjZTogc3F1YXJlSGFzUHJlbW92ZVRhcmdldC5waWVjZSwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZXM6IHNxdWFyZXMgfSkpLCBzaG93Qm9hcmROb3RhdGlvbiAmJiBqc3goTm90YXRpb24sIHsgcm93OiByLCBjb2w6IGMgfSldIH0pLCBgJHtjfSR7cn1gKSk7XHJcbiAgICAgICAgICAgICAgICB9KSB9KSwgci50b1N0cmluZygpKSk7XHJcbiAgICAgICAgfSkgfSkpKTtcclxufVxuXG5jb25zdCBBcnJvd3MgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IGFycm93cywgbmV3QXJyb3csIGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1c3RvbUFycm93Q29sb3I6IHByaW1hcnlBcnJvd0NvbGxvciwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IGFycm93c0xpc3QgPSBbLi4uYXJyb3dzLCBuZXdBcnJvd10uZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHdpZHRoOiBib2FyZFdpZHRoLCBoZWlnaHQ6IGJvYXJkV2lkdGgsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXHJcbiAgICAgICAgICAgIGxlZnQ6IFwiMFwiLFxyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgekluZGV4OiBcIjEwXCIsXHJcbiAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBhcnJvd3NMaXN0Lm1hcCgoYXJyb3csIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2Fycm93U3RhcnRGaWVsZCwgYXJyb3dFbmRGaWVsZCwgYXJyb3dDb2xvcl0gPSBhcnJvdztcclxuICAgICAgICAgICAgaWYgKGFycm93U3RhcnRGaWVsZCA9PT0gYXJyb3dFbmRGaWVsZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gZ2V0UmVsYXRpdmVDb29yZHMoYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgYXJyb3dTdGFydEZpZWxkKTtcclxuICAgICAgICAgICAgY29uc3QgdG8gPSBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBhcnJvd0VuZEZpZWxkKTtcclxuICAgICAgICAgICAgbGV0IEFSUk9XX0xFTkdUSF9SRURVQ0VSID0gYm9hcmRXaWR0aCAvIDMyO1xyXG4gICAgICAgICAgICBjb25zdCBpc0Fycm93QWN0aXZlID0gaSA9PT0gYXJyb3dzLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGRpZmZlcmVudCBhcnJvd3MgdGFyZ2V0aW5nIHRoZSBzYW1lIHNxdWFyZSBtYWtlIHRoZWlyIGxlbmd0aCBhIGJpdCBzaG9ydGVyXHJcbiAgICAgICAgICAgIGlmIChhcnJvd3Muc29tZSgocmVzdEFycm93KSA9PiByZXN0QXJyb3dbMF0gIT09IGFycm93U3RhcnRGaWVsZCAmJiByZXN0QXJyb3dbMV0gPT09IGFycm93RW5kRmllbGQpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNBcnJvd0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgQVJST1dfTEVOR1RIX1JFRFVDRVIgPSBib2FyZFdpZHRoIC8gMTY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZHggPSB0by54IC0gZnJvbS54O1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IHRvLnkgLSBmcm9tLnk7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBNYXRoLmh5cG90KGR5LCBkeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGZyb20ueCArIChkeCAqIChyIC0gQVJST1dfTEVOR1RIX1JFRFVDRVIpKSAvIHIsXHJcbiAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyAoZHkgKiAociAtIEFSUk9XX0xFTkdUSF9SRURVQ0VSKSkgLyByLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW2pzeChcIm1hcmtlclwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IGBhcnJvd2hlYWQtJHtpfWAsIG1hcmtlcldpZHRoOiBcIjJcIiwgbWFya2VySGVpZ2h0OiBcIjIuNVwiLCByZWZYOiBcIjEuMjVcIiwgcmVmWTogXCIxLjI1XCIsIG9yaWVudDogXCJhdXRvXCIgfSwgeyBjaGlsZHJlbjoganN4KFwicG9seWdvblwiLCB7IHBvaW50czogXCIwLjMgMCwgMiAxLjI1LCAwLjMgMi41XCIsIGZpbGw6IGFycm93Q29sb3IgIT09IG51bGwgJiYgYXJyb3dDb2xvciAhPT0gdm9pZCAwID8gYXJyb3dDb2xvciA6IHByaW1hcnlBcnJvd0NvbGxvciB9KSB9KSksIGpzeChcImxpbmVcIiwgeyB4MTogZnJvbS54LCB5MTogZnJvbS55LCB4MjogZW5kLngsIHkyOiBlbmQueSwgb3BhY2l0eTogaXNBcnJvd0FjdGl2ZSA/IFwiMC41XCIgOiBcIjAuNjVcIiwgc3Ryb2tlOiBhcnJvd0NvbG9yICE9PSBudWxsICYmIGFycm93Q29sb3IgIT09IHZvaWQgMCA/IGFycm93Q29sb3IgOiBwcmltYXJ5QXJyb3dDb2xsb3IsIHN0cm9rZVdpZHRoOiBpc0Fycm93QWN0aXZlID8gKDAuOSAqIGJvYXJkV2lkdGgpIC8gNDAgOiBib2FyZFdpZHRoIC8gNDAsIG1hcmtlckVuZDogYHVybCgjYXJyb3doZWFkLSR7aX0pYCB9KV0gfSwgYCR7YXJyb3dTdGFydEZpZWxkfS0ke2Fycm93RW5kRmllbGR9JHtpc0Fycm93QWN0aXZlID8gXCItYWN0aXZlXCIgOiBcIlwifWApKTtcclxuICAgICAgICB9KSB9KSkpO1xyXG59O1xuXG5mdW5jdGlvbiBQcm9tb3Rpb25PcHRpb24oeyBvcHRpb24gfSkge1xyXG4gICAgY29uc3QgW2lzSG92ZXIsIHNldElzSG92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgeyBib2FyZFdpZHRoLCBjaGVzc1BpZWNlcywgY3VzdG9tRGFya1NxdWFyZVN0eWxlLCBjdXN0b21MaWdodFNxdWFyZVN0eWxlLCBoYW5kbGVTZXRQb3NpdGlvbiwgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCwgcHJvbW90ZUZyb21TcXVhcmUsIHByb21vdGVUb1NxdWFyZSwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9ICgpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKG9wdGlvblsxXSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbURhcmtTcXVhcmVTdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tTGlnaHRTcXVhcmVTdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGNhc2UgXCJOXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbW90aW9uRGlhbG9nVmFyaWFudCA9PT0gXCJkZWZhdWx0XCJcclxuICAgICAgICAgICAgICAgICAgICA/IGN1c3RvbUxpZ2h0U3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICBjYXNlIFwiQlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21vdGlvbkRpYWxvZ1ZhcmlhbnQgPT09IFwiZGVmYXVsdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21MaWdodFNxdWFyZVN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uUHJvbW90aW9uUGllY2VTZWxlY3Qob3B0aW9uLCBwcm9tb3RlRnJvbVNxdWFyZSAhPT0gbnVsbCAmJiBwcm9tb3RlRnJvbVNxdWFyZSAhPT0gdm9pZCAwID8gcHJvbW90ZUZyb21TcXVhcmUgOiB1bmRlZmluZWQsIHByb21vdGVUb1NxdWFyZSAhPT0gbnVsbCAmJiBwcm9tb3RlVG9TcXVhcmUgIT09IHZvaWQgMCA/IHByb21vdGVUb1NxdWFyZSA6IHVuZGVmaW5lZCkpXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXRQb3NpdGlvbihwcm9tb3RlRnJvbVNxdWFyZSwgcHJvbW90ZVRvU3F1YXJlLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sIG9uTW91c2VPdmVyOiAoKSA9PiBzZXRJc0hvdmVyKHRydWUpLCBvbk1vdXNlT3V0OiAoKSA9PiBzZXRJc0hvdmVyKGZhbHNlKSwgXCJkYXRhLXBpZWNlXCI6IG9wdGlvbiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0hvdmVyID8gYmFja2dyb3VuZENvbG9yKCkgOiBgJHtiYWNrZ3JvdW5kQ29sb3IoKX1hYWAsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC4xcyBlYXNlLW91dFwiLFxyXG4gICAgICAgIH0gfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW29wdGlvbl0gPT09IFwiZnVuY3Rpb25cIiA/IChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBcImFsbCAwLjFzIGVhc2Utb3V0XCIsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzSG92ZXIgPyBcInNjYWxlKDEpXCIgOiBcInNjYWxlKDAuODUpXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogY2hlc3NQaWVjZXNbb3B0aW9uXSh7XHJcbiAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aDogYm9hcmRXaWR0aCAvIDgsXHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgfSkgfSkpKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiBib2FyZFdpZHRoIC8gOCwgaGVpZ2h0OiBib2FyZFdpZHRoIC8gOCwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFwiYWxsIDAuMXMgZWFzZS1vdXRcIixcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNIb3ZlciA/IFwic2NhbGUoMSlcIiA6IFwic2NhbGUoMC44NSlcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IGNoZXNzUGllY2VzW29wdGlvbl0gfSkgfSkpKSB9KSkpO1xyXG59XG5cbmZ1bmN0aW9uIFByb21vdGlvbkRpYWxvZygpIHtcclxuICAgIGNvbnN0IHsgYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCwgcHJvbW90ZVRvU3F1YXJlLCB9ID0gdXNlQ2hlc3Nib2FyZCgpO1xyXG4gICAgY29uc3QgcHJvbW90ZVBpZWNlQ29sb3IgPSAocHJvbW90ZVRvU3F1YXJlID09PSBudWxsIHx8IHByb21vdGVUb1NxdWFyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvbW90ZVRvU3F1YXJlWzFdKSA9PT0gXCIxXCIgPyBcImJcIiA6IFwid1wiO1xyXG4gICAgY29uc3QgcHJvbW90aW9uT3B0aW9ucyA9IFtcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1RYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1SYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1OYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1CYCxcclxuICAgIF07XHJcbiAgICBjb25zdCBkaWFsb2dTdHlsZXMgPSB7XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiBcImdyaWRcIixcclxuICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogXCIxZnIgMWZyXCIsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1ib2FyZFdpZHRoIC8gOH1weCwgJHstYm9hcmRXaWR0aCAvIDh9cHgpYCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1ib2FyZFdpZHRoIC8gMTZ9cHgsICR7LWJvYXJkV2lkdGggLyAxNn1weClgLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9kYWw6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoMHB4LCAkeygzICogYm9hcmRXaWR0aCkgLyA4fXB4KWAsXHJcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtib2FyZFdpZHRoIC8gNH1weGAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBjb25zdCBkaWFsb2dDb29yZHMgPSBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBwcm9tb3RlVG9TcXVhcmUgfHwgXCJhOFwiKTtcclxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogYCR7ZGlhbG9nQ29vcmRzID09PSBudWxsIHx8IGRpYWxvZ0Nvb3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlhbG9nQ29vcmRzLnl9cHhgLCBsZWZ0OiBgJHtkaWFsb2dDb29yZHMgPT09IG51bGwgfHwgZGlhbG9nQ29vcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaWFsb2dDb29yZHMueH1weGAsIHpJbmRleDogMTAwMCB9LCBkaWFsb2dTdHlsZXNbcHJvbW90aW9uRGlhbG9nVmFyaWFudF0pLCB0aXRsZTogXCJDaG9vc2UgcHJvbW90aW9uIHBpZWNlXCIgfSwgeyBjaGlsZHJlbjogcHJvbW90aW9uT3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gKGpzeChQcm9tb3Rpb25PcHRpb24sIHsgb3B0aW9uOiBvcHRpb24gfSwgb3B0aW9uKSkpIH0pKSk7XHJcbn1cblxuY29uc3QgZXJyb3JJbWFnZSA9IHtcclxuICAgIHdoaXRlS2luZzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgc2hhcGVSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXHJcbiAgICAgICAgICAgIHRleHRSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXHJcbiAgICAgICAgICAgIGltYWdlUmVuZGVyaW5nOiBcImNyaXNwLWVkZ2VzXCIsXHJcbiAgICAgICAgfSwgdmlld0JveDogXCIwIDAgNDIxMCAxMjk3MFwiLCB4OiBcIjBweFwiLCB5OiBcIjBweFwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIGNsaXBSdWxlOiBcImV2ZW5vZGRcIiwgd2lkdGg6IFwiMjUwXCIsIGhlaWdodDogXCIyNTBcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICB9LCBkOiBcIk0yMTA1IDBjMTY5LDAgMjg2LDE2MCAyNDksMzE1bDIwMCAwYy0xNzIsMjY2IC0yMzEsNDc5IC0yNTYsNzkyIDMxNSwtMjQgNTMwLC04NiA3OTIsLTI1NWwwIDg5N2MtMjY1LC0xNzEgLTQ3OSwtMjMxIC03OTIsLTI1NiAxOCwyMzQgNzUsNDk1IDE4NSw2ODJsMzM5IDBjMjMzLDAgMzY5LDI2OSAyMjUsNDU2bDU0NSAwIC01OTUgMTkxNmMxMzAsOTQgMTU4LDI3NSA1OSw0MDIgNDY1LDAgNDE2LDU2OCA1MSw1NjhsLTMzNCAwIDQ2NSAyODY3IDMzMiAwYzI1MCwwIDM4MSwzMDYgMTk5LDQ4NSAxNjIsNjMgMjczLDIyMCAyNzMsMzk5bDAgNjMzIDE2OCAwIDAgNDc1Yy0xNDAzLDAgLTI4MDcsMCAtNDIxMCwwbDAgLTQ3NSAxNjcgMCAwIC02MzNjMCwtMTc5IDExMiwtMzM2IDI3NCwtMzk5IC0xODEsLTE3OCAtNTIsLTQ4NSAxOTksLTQ4NWwzMzIgMCA0NjUgLTI4NjcgLTMzNSAwYy0zNTMsMCAtNDE4LC01NjggNTEsLTU2OCAtOTgsLTEyNyAtNzAsLTMwOCA1OSwtNDAybC01OTQgLTE5MTZjMTgxLDAgMzYzLDAgNTQ1LDAgLTE0NCwtMTg3IC05LC00NTYgMjI1LC00NTZsMzM5IDBjMTEwLC0xODcgMTY3LC00NDggMTg1LC02ODIgLTMxNSwyNSAtNTMwLDg3IC03OTMsMjU2bDAgLTg5N2MyNjYsMTcxIDQ4MCwyMzEgNzkzLDI1NSAtMjUsLTMxNSAtODcsLTUyOSAtMjU2LC03OTJsMTk5IDBjLTM2LC0xNTUgODEsLTMxNSAyNTAsLTMxNXptLTE5OTQgMTAwMTJsMCAyNTMgMzk4OCAwIDAgLTI1M2MtMTMzMCwwIC0yNjU5LDAgLTM5ODgsMHptNDg0IC0xMDYwYy0xNzQsMCAtMzE2LDE0MiAtMzE2LDMxNmwwIDYzMyAzNjUyIDAgMCAtNjMzYzAsLTE3NCAtMTQyLC0zMTYgLTMxNiwtMzE2IC0xMDA3LDAgLTIwMTMsMCAtMzAyMCwwem00NSAtNDU3Yy0yMzAsMCAtMjI1LDM0NSAwLDM0NWwyOTMwIDBjMjMwLDAgMjI1LC0zNDUgMCwtMzQ1IC05NzcsMCAtMTk1MywwIC0yOTMwLDB6bTIwMjAgLTI5NzhsLTExMTEgMCAtNDY1IDI4NjcgMjA0MSAwIC00NjUgLTI4Njd6bS0xNTU4IC00NTZjLTIyOSwwIC0yMjQsMzQ1IDAsMzQ1IDY2OSwwIDEzMzcsMCAyMDA1LDAgMjMwLDAgMjI1LC0zNDUgMCwtMzQ1IC02NjgsMCAtMTMzNiwwIC0yMDA1LDB6bTE3MzAgLTQ1N2wtMTQ1NCAwYy0yMjksMCAtMjI0LDM0NSAwLDM0NWwxNDU0IDBjMjI5LDAgMjI0LC0zNDUgMCwtMzQ1em0tMjA2NCAtMTg2Mmw1NDQgMTc1MWM1MjksMCAxMDU3LDAgMTU4NiwwbDU0NCAtMTc1MWMtODkyLDAgLTE3ODMsMCAtMjY3NCwwem0xMDg1IC01NjdsNTA0IDBjLTEyNiwtMjQ3IC0xNjMsLTUyNiAtMTc3LC04MDAgMjczLDE1IDU1Myw1MiA4MDAsMTc3bDAgLTUwNGMtMjQ3LDEyNiAtNTI3LDE2MyAtODAwLDE3NyAxNCwtMjczIDUxLC01NTIgMTc3LC03OTkgLTE2OCwwIC0zMzYsMCAtNTA0LDAgMTI1LDI0NyAxNjIsNTI2IDE3Nyw3OTkgLTI3NCwtMTQgLTU1MywtNTEgLTgwMCwtMTc3bDAgNTA0YzI0NywtMTI1IDUyNywtMTYyIDgwMCwtMTc3IC0xNSwyNzQgLTUyLDU1MyAtMTc3LDgwMHptOTY5IDExMWwtMTQzNCAwYy0yMzAsMCAtMjI1LDM0NSAwLDM0NWwxNDM0IDBjMjMwLDAgMjI1LC0zNDUgMCwtMzQ1em0tNzE3IC0yMTc1Yy0xMDUsMCAtMTc1LDEwOSAtMTMzLDIwNGwyNjYgMGM0MiwtOTYgLTMwLC0yMDUgLTEzMywtMjA0elwiIH0pIH0pIH0pKSksXHJcbn07XG5cbmZ1bmN0aW9uIEVycm9yQm91bmRhcnkoeyBjaGlsZHJlbiB9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBqc3goV2hpdGVLaW5nLCB7IHNob3dFcnJvcjogdHJ1ZSB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBXaGl0ZUtpbmcoeyBzaG93RXJyb3IgPSBmYWxzZSB9KSB7XHJcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcclxuICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDI1MCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDI1MCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlKDkwZGVnKVwiLFxyXG4gICAgICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBlcnJvckltYWdlLndoaXRlS2luZyB9KSksIHNob3dFcnJvciAmJiBqc3goXCJoMVwiLCB7IGNoaWxkcmVuOiBcIlNvbWV0aGluZyB3ZW50IHdyb25nXCIgfSldIH0pKSk7XHJcbn1cblxuZnVuY3Rpb24gQm9hcmQoKSB7XHJcbiAgICBjb25zdCBib2FyZFJlZiA9IHVzZVJlZihudWxsKTtcclxuICAgIGNvbnN0IHsgYm9hcmRXaWR0aCwgY2xlYXJDdXJyZW50UmlnaHRDbGlja0Rvd24sIG9uUHJvbW90aW9uUGllY2VTZWxlY3QsIHNldFNob3dQcm9tb3RlRGlhbG9nLCBzaG93UHJvbW90ZURpYWxvZywgY3VzdG9tQm9hcmRTdHlsZSwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChib2FyZFJlZi5jdXJyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAhYm9hcmRSZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckN1cnJlbnRSaWdodENsaWNrRG93bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIGJvYXJkV2lkdGggPyAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogeyBwZXJzcGVjdGl2ZTogXCIxMDAwcHhcIiB9IH0sIHsgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogYm9hcmRSZWYsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0sIGJvYXJkU3R5bGVzKGJvYXJkV2lkdGgpKSwgY3VzdG9tQm9hcmRTdHlsZSkgfSwgeyBjaGlsZHJlbjogW2pzeChTcXVhcmVzLCB7fSksIGpzeChBcnJvd3MsIHt9KSwgc2hvd1Byb21vdGVEaWFsb2cgJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBvbkNsaWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2coZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUHJvbW90aW9uUGllY2VTZWxlY3QgPT09IG51bGwgfHwgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiBcIjEwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDIyLDIxLDE4LC43KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib2FyZFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYm9hcmRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChQcm9tb3Rpb25EaWFsb2csIHt9KV0gfSkpXSB9KSkgfSkpKSA6IChqc3goV2hpdGVLaW5nLCB7fSkpO1xyXG59XHJcbmNvbnN0IGJvYXJkU3R5bGVzID0gKHdpZHRoKSA9PiAoe1xyXG4gICAgY3Vyc29yOiBcImRlZmF1bHRcIixcclxuICAgIGhlaWdodDogd2lkdGgsXHJcbiAgICB3aWR0aCxcclxufSk7XG5cbnZhciBMaXN0ZW5lclR5cGU7XG4oZnVuY3Rpb24oTGlzdGVuZXJUeXBlKSB7XG4gICAgTGlzdGVuZXJUeXBlW1wibW91c2VcIl0gPSBcIm1vdXNlXCI7XG4gICAgTGlzdGVuZXJUeXBlW1widG91Y2hcIl0gPSBcInRvdWNoXCI7XG4gICAgTGlzdGVuZXJUeXBlW1wia2V5Ym9hcmRcIl0gPSBcImtleWJvYXJkXCI7XG59KShMaXN0ZW5lclR5cGUgfHwgKExpc3RlbmVyVHlwZSA9IHt9KSk7XG5cbmNsYXNzIE9wdGlvbnNSZWFkZXIge1xuICAgIGdldCBkZWxheSgpIHtcbiAgICAgICAgdmFyIF9kZWxheTtcbiAgICAgICAgcmV0dXJuIChfZGVsYXkgPSB0aGlzLmFyZ3MuZGVsYXkpICE9PSBudWxsICYmIF9kZWxheSAhPT0gdm9pZCAwID8gX2RlbGF5IDogMDtcbiAgICB9XG4gICAgZ2V0IHNjcm9sbEFuZ2xlUmFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLnNjcm9sbEFuZ2xlUmFuZ2VzO1xuICAgIH1cbiAgICBnZXQgZ2V0RHJvcFRhcmdldEVsZW1lbnRzQXRQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5nZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50O1xuICAgIH1cbiAgICBnZXQgaWdub3JlQ29udGV4dE1lbnUoKSB7XG4gICAgICAgIHZhciBfaWdub3JlQ29udGV4dE1lbnU7XG4gICAgICAgIHJldHVybiAoX2lnbm9yZUNvbnRleHRNZW51ID0gdGhpcy5hcmdzLmlnbm9yZUNvbnRleHRNZW51KSAhPT0gbnVsbCAmJiBfaWdub3JlQ29udGV4dE1lbnUgIT09IHZvaWQgMCA/IF9pZ25vcmVDb250ZXh0TWVudSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0KCkge1xuICAgICAgICB2YXIgX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldDtcbiAgICAgICAgcmV0dXJuIChfZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0ID0gdGhpcy5hcmdzLmVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCkgIT09IG51bGwgJiYgX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCAhPT0gdm9pZCAwID8gX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlS2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlS2V5Ym9hcmRFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZUtleWJvYXJkRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZUtleWJvYXJkRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlS2V5Ym9hcmRFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVLZXlib2FyZEV2ZW50cyA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlTW91c2VFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlTW91c2VFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZU1vdXNlRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZU1vdXNlRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlTW91c2VFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVNb3VzZUV2ZW50cyA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlVG91Y2hFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlVG91Y2hFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZVRvdWNoRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZVRvdWNoRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlVG91Y2hFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVUb3VjaEV2ZW50cyA6IHRydWU7XG4gICAgfVxuICAgIGdldCB0b3VjaFNsb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3MudG91Y2hTbG9wIHx8IDA7XG4gICAgfVxuICAgIGdldCBkZWxheVRvdWNoU3RhcnQoKSB7XG4gICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICByZXR1cm4gKHJlZjMgPSAocmVmMiA9IChyZWYgPSB0aGlzLmFyZ3MpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRlbGF5VG91Y2hTdGFydCkgIT09IG51bGwgJiYgcmVmMiAhPT0gdm9pZCAwID8gcmVmMiA6IChyZWYxID0gdGhpcy5hcmdzKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLmRlbGF5KSAhPT0gbnVsbCAmJiByZWYzICE9PSB2b2lkIDAgPyByZWYzIDogMDtcbiAgICB9XG4gICAgZ2V0IGRlbGF5TW91c2VTdGFydCgpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmNDtcbiAgICAgICAgdmFyIHJlZjUsIHJlZjY7XG4gICAgICAgIHJldHVybiAocmVmNiA9IChyZWY1ID0gKHJlZiA9IHRoaXMuYXJncykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuZGVsYXlNb3VzZVN0YXJ0KSAhPT0gbnVsbCAmJiByZWY1ICE9PSB2b2lkIDAgPyByZWY1IDogKHJlZjQgPSB0aGlzLmFyZ3MpID09PSBudWxsIHx8IHJlZjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjQuZGVsYXkpICE9PSBudWxsICYmIHJlZjYgIT09IHZvaWQgMCA/IHJlZjYgOiAwO1xuICAgIH1cbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0ICYmIHRoaXMuY29udGV4dC53aW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQud2luZG93O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBkb2N1bWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmNvbnRleHQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2luZG93LmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5hcmdzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5yb290RWxlbWVudCkgfHwgdGhpcy5kb2N1bWVudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXJncywgY29udGV4dCl7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoeDIgLSB4MSksIDIpICsgTWF0aC5wb3coTWF0aC5hYnMoeTIgLSB5MSksIDIpKTtcbn1cbmZ1bmN0aW9uIGluQW5nbGVSYW5nZXMoeDEsIHkxLCB4MiwgeTIsIGFuZ2xlUmFuZ2VzKSB7XG4gICAgaWYgKCFhbmdsZVJhbmdlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEkgKyAxODA7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFuZ2xlUmFuZ2VzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgY29uc3QgYXIgPSBhbmdsZVJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGFyICYmIChhci5zdGFydCA9PSBudWxsIHx8IGFuZ2xlID49IGFyLnN0YXJ0KSAmJiAoYXIuZW5kID09IG51bGwgfHwgYW5nbGUgPD0gYXIuZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBVc2VkIGZvciBNb3VzZUV2ZW50LmJ1dHRvbnMgKG5vdGUgdGhlIHMgb24gdGhlIGVuZCkuXG5jb25zdCBNb3VzZUJ1dHRvbnMgPSB7XG4gICAgTGVmdDogMSxcbiAgICBSaWdodDogMixcbiAgICBDZW50ZXI6IDRcbn07XG4vLyBVc2VkIGZvciBlLmJ1dHRvbiAobm90ZSB0aGUgbGFjayBvZiBhbiBzIG9uIHRoZSBlbmQpLlxuY29uc3QgTW91c2VCdXR0b24gPSB7XG4gICAgTGVmdDogMCxcbiAgICBDZW50ZXI6IDEsXG4gICAgUmlnaHQ6IDJcbn07XG4vKipcbiAqIE9ubHkgdG91Y2ggZXZlbnRzIGFuZCBtb3VzZSBldmVudHMgd2hlcmUgdGhlIGxlZnQgYnV0dG9uIGlzIHByZXNzZWQgc2hvdWxkIGluaXRpYXRlIGEgZHJhZy5cbiAqIEBwYXJhbSB7TW91c2VFdmVudCB8IFRvdWNoRXZlbnR9IGUgVGhlIGV2ZW50XG4gKi8gZnVuY3Rpb24gZXZlbnRTaG91bGRTdGFydERyYWcoZSkge1xuICAgIC8vIEZvciB0b3VjaCBldmVudHMsIGJ1dHRvbiB3aWxsIGJlIHVuZGVmaW5lZC4gSWYgZS5idXR0b24gaXMgZGVmaW5lZCxcbiAgICAvLyB0aGVuIGl0IHNob3VsZCBiZSBNb3VzZUJ1dHRvbi5MZWZ0LlxuICAgIHJldHVybiBlLmJ1dHRvbiA9PT0gdW5kZWZpbmVkIHx8IGUuYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5MZWZ0O1xufVxuLyoqXG4gKiBPbmx5IHRvdWNoIGV2ZW50cyBhbmQgbW91c2UgZXZlbnRzIHdoZXJlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBubyBsb25nZXIgaGVsZCBzaG91bGQgZW5kIGEgZHJhZy5cbiAqIEl0J3MgcG9zc2libGUgdGhlIHVzZXIgbW91c2UgZG93bnMgd2l0aCB0aGUgbGVmdCBtb3VzZSBidXR0b24sIHRoZW4gbW91c2UgZG93biBhbmQgdXBzIHdpdGggdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbi5cbiAqIFdlIGRvbid0IHdhbnQgcmVsZWFzaW5nIHRoZSByaWdodCBtb3VzZSBidXR0b24gdG8gZW5kIHRoZSBkcmFnLlxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZSBUaGUgZXZlbnRcbiAqLyBmdW5jdGlvbiBldmVudFNob3VsZEVuZERyYWcoZSkge1xuICAgIC8vIFRvdWNoIGV2ZW50cyB3aWxsIGhhdmUgYnV0dG9ucyBiZSB1bmRlZmluZWQsIHdoaWxlIG1vdXNlIGV2ZW50cyB3aWxsIGhhdmUgZS5idXR0b25zJ3MgbGVmdCBidXR0b25cbiAgICAvLyBiaXQgZmllbGQgdW5zZXQgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGhhcyBiZWVuIHJlbGVhc2VkXG4gICAgcmV0dXJuIGUuYnV0dG9ucyA9PT0gdW5kZWZpbmVkIHx8IChlLmJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnMuTGVmdCkgPT09IDA7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZSkge1xuICAgIHJldHVybiAhIWUudGFyZ2V0VG91Y2hlcztcbn1cblxuY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbmZ1bmN0aW9uIGdldE5vZGVDbGllbnRPZmZzZXQobm9kZSkge1xuICAgIGNvbnN0IGVsID0gbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHsgdG9wICwgbGVmdCAgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IHRvcFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRFdmVudENsaWVudFRvdWNoT2Zmc2V0KGUsIGxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUudGFyZ2V0VG91Y2hlc1swXSk7XG4gICAgfSBlbHNlIGlmIChsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMF0udGFyZ2V0ID09PSBsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjay50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFdmVudENsaWVudE9mZnNldChlLnRvdWNoZXNbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUsIGxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrKSB7XG4gICAgaWYgKGlzVG91Y2hFdmVudChlKSkge1xuICAgICAgICByZXR1cm4gZ2V0RXZlbnRDbGllbnRUb3VjaE9mZnNldChlLCBsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3Qgc3VwcG9ydHNQYXNzaXZlID0gKCgpPT57XG4gICAgLy8gc2ltdWxhciB0byBqUXVlcnkncyB0ZXN0XG4gICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCAoKT0+e1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufSkoKTtcblxuY29uc3QgZXZlbnROYW1lcyA9IHtcbiAgICBbTGlzdGVuZXJUeXBlLm1vdXNlXToge1xuICAgICAgICBzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgICAgICBlbmQ6ICdtb3VzZXVwJyxcbiAgICAgICAgY29udGV4dG1lbnU6ICdjb250ZXh0bWVudSdcbiAgICB9LFxuICAgIFtMaXN0ZW5lclR5cGUudG91Y2hdOiB7XG4gICAgICAgIHN0YXJ0OiAndG91Y2hzdGFydCcsXG4gICAgICAgIG1vdmU6ICd0b3VjaG1vdmUnLFxuICAgICAgICBlbmQ6ICd0b3VjaGVuZCdcbiAgICB9LFxuICAgIFtMaXN0ZW5lclR5cGUua2V5Ym9hcmRdOiB7XG4gICAgICAgIGtleWRvd246ICdrZXlkb3duJ1xuICAgIH1cbn07XG5jbGFzcyBUb3VjaEJhY2tlbmRJbXBsIHtcbiAgICAvKipcblx0ICogR2VuZXJhdGUgcHJvZmlsaW5nIHN0YXRpc3RpY3MgZm9yIHRoZSBIVE1MNUJhY2tlbmQuXG5cdCAqLyBwcm9maWxlKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlTm9kZXM6IHRoaXMuc291cmNlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZVByZXZpZXdOb2RlczogdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZVByZXZpZXdOb2RlT3B0aW9uczogdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGVzOiB0aGlzLnRhcmdldE5vZGVzLnNpemUsXG4gICAgICAgICAgICBkcmFnT3ZlclRhcmdldElkczogKChyZWYgPSB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sZW5ndGgpIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcHVibGljIGZvciB0ZXN0XG4gICAgZ2V0IGRvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRvY3VtZW50O1xuICAgIH1cbiAgICBzZXR1cCgpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KCFUb3VjaEJhY2tlbmRJbXBsLmlzU2V0VXAsICdDYW5ub3QgaGF2ZSB0d28gVG91Y2ggYmFja2VuZHMgYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICAgICAgVG91Y2hCYWNrZW5kSW1wbC5pc1NldFVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHJvb3QsICdzdGFydCcsIHRoaXMuZ2V0VG9wTW92ZVN0YXJ0SGFuZGxlcigpKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHJvb3QsICdzdGFydCcsIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW92ZScsIHRoaXMuaGFuZGxlVG9wTW92ZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW92ZScsIHRoaXMuaGFuZGxlVG9wTW92ZUNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ2VuZCcsIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZU1vdXNlRXZlbnRzICYmICF0aGlzLm9wdGlvbnMuaWdub3JlQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVG91Y2hCYWNrZW5kSW1wbC5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihyb290LCAnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ3N0YXJ0JywgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdmUnLCB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdtb3ZlJywgdGhpcy5oYW5kbGVUb3BNb3ZlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdlbmQnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVNb3VzZUV2ZW50cyAmJiAhdGhpcy5vcHRpb25zLmlnbm9yZUNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ2NvbnRleHRtZW51JywgdGhpcy5oYW5kbGVUb3BNb3ZlRW5kQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVLZXlib2FyZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdrZXlkb3duJywgdGhpcy5oYW5kbGVDYW5jZWxPbkVzY2FwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIoc3ViamVjdCwgZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgICAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0gOiBjYXB0dXJlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGV2ZW50TmFtZXNbbGlzdGVuZXJUeXBlXVtldmVudF07XG4gICAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHN1YmplY3QsIGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogY2FwdHVyZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXJUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBldnQgPSBldmVudE5hbWVzW2xpc3RlbmVyVHlwZV1bZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdERyYWdTb3VyY2Uoc291cmNlSWQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlTW92ZVN0YXJ0ID0gdGhpcy5oYW5kbGVNb3ZlU3RhcnQuYmluZCh0aGlzLCBzb3VyY2VJZCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMuc2V0KHNvdXJjZUlkLCBub2RlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2Rlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbm5lY3REcmFnUHJldmlldyhzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5zZXQoc291cmNlSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25uZWN0RHJvcFRhcmdldCh0YXJnZXRJZCwgbm9kZSkge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5vcHRpb25zLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnQgfHwgIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgLyogbm9vcCAqLyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZU1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5kb2N1bWVudCB8fCAhcm9vdCB8fCAhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb29yZHM7XG4gICAgICAgICAgICAvKipcblx0XHRcdCAqIEdyYWIgdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgY3VycmVudCBtb3VzZS90b3VjaCBwb3NpdGlvblxuXHRcdFx0ICovIHN3aXRjaChlLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgZXZlbnROYW1lcy5tb3VzZS5tb3ZlOlxuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBldmVudE5hbWVzLnRvdWNoLm1vdmU6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6ICgocmVmID0gZS50b3VjaGVzWzBdKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jbGllbnRYKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogKChyZWYxID0gZS50b3VjaGVzWzBdKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLmNsaWVudFkpIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcblx0XHRcdCAqIFVzZSB0aGUgY29vcmRpbmF0ZXMgdG8gZ3JhYiB0aGUgZWxlbWVudCB0aGUgZHJhZyBlbmRlZCBvbi5cblx0XHRcdCAqIElmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIGFzIHRoZSB0YXJnZXQgbm9kZSAob3IgYW55IG9mIGl0J3MgY2hpbGRyZW4pIHRoZW4gd2UgaGF2ZSBoaXQgYSBkcm9wIHRhcmdldCBhbmQgY2FuIGhhbmRsZSB0aGUgbW92ZS5cblx0XHRcdCAqLyBjb25zdCBkcm9wcGVkT24gPSBjb29yZHMgIT0gbnVsbCA/IHRoaXMuZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjb29yZHMueCwgY29vcmRzLnkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRNYXRjaCA9IGRyb3BwZWRPbiAmJiBub2RlLmNvbnRhaW5zKGRyb3BwZWRPbik7XG4gICAgICAgICAgICBpZiAoZHJvcHBlZE9uID09PSBub2RlIHx8IGNoaWxkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNb3ZlKGUsIHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG5cdFx0ICogQXR0YWNoaW5nIHRoZSBldmVudCBsaXN0ZW5lciB0byB0aGUgYm9keSBzbyB0aGF0IHRvdWNobW92ZSB3aWxsIHdvcmsgd2hpbGUgZHJhZ2dpbmcgb3ZlciBtdWx0aXBsZSB0YXJnZXQgZWxlbWVudHMuXG5cdFx0ICovIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmRvY3VtZW50LmJvZHksICdtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0Tm9kZXMuc2V0KHRhcmdldElkLCBub2RlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0Tm9kZXMuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb2N1bWVudC5ib2R5LCAnbW92ZScsIGhhbmRsZU1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRUb3BNb3ZlU3RhcnRIYW5kbGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWxheVRvdWNoU3RhcnQgJiYgIXRoaXMub3B0aW9ucy5kZWxheU1vdXNlU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnREZWxheTtcbiAgICB9XG4gICAgaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIobm9kZSkge1xuICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKT0+e1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgIW5vZGUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdXJyZWN0U291cmNlTm9kZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyLm9ic2VydmUobm9kZS5wYXJlbnRFbGVtZW50LCB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VycmVjdFNvdXJjZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50ICYmIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXJlYWN0aWQnKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyYWdnZWRTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgY29udGV4dCwgb3B0aW9ucyl7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuc291cmNlTm9kZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50ICYmIGdldE5vZGVDbGllbnRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0Q2FwdHVyZSA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZFN0YXJ0RHJhZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZVN0YXJ0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgLy8gSnVzdCBiZWNhdXNlIHdlIHJlY2VpdmVkIGFuIGV2ZW50IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiB3ZSBuZWVkIHRvIGNvbGxlY3QgZHJhZyBzb3VyY2VzLlxuICAgICAgICAgICAgLy8gV2Ugb25seSBjb2xsZWN0IHN0YXJ0IGNvbGxlY3RpbmcgZHJhZyBzb3VyY2VzIG9uIHRvdWNoIGFuZCBsZWZ0IG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubW92ZVN0YXJ0U291cmNlSWRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzLnVuc2hpZnQoc291cmNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZFN0YXJ0RHJhZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHByZW1hdHVyZWx5IHByZXZlbnREZWZhdWx0KCkgaGVyZSBzaW5jZSBpdCBtaWdodDpcbiAgICAgICAgICAgIC8vIDEuIE1lc3MgdXAgc2Nyb2xsaW5nXG4gICAgICAgICAgICAvLyAyLiBNZXNzIHVwIGxvbmcgdGFwICh3aGljaCBicmluZ3MgdXAgY29udGV4dCBtZW51KVxuICAgICAgICAgICAgLy8gMy4gSWYgdGhlcmUncyBhbiBhbmNob3IgbGluayBhcyBhIGNoaWxkLCB0YXAgd29uJ3QgYmUgdHJpZ2dlcmVkIG9uIGxpbmtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudE9mZnNldCA9IGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUpO1xuICAgICAgICAgICAgaWYgKGNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayA9IGUudGFyZ2V0VG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQgPSBjbGllbnRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdGb3JEZWxheSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydERlbGF5ID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoIWV2ZW50U2hvdWxkU3RhcnREcmFnKGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBlLnR5cGUgPT09IGV2ZW50TmFtZXMudG91Y2guc3RhcnQgPyB0aGlzLm9wdGlvbnMuZGVsYXlUb3VjaFN0YXJ0IDogdGhpcy5vcHRpb25zLmRlbGF5TW91c2VTdGFydDtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQuYmluZCh0aGlzLCBlKSwgZGVsYXkpO1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yRGVsYXkgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlID0gKF9ldnQsIHRhcmdldElkKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmUgPSAoZTEpPT57XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnQgfHwgdGhpcy53YWl0aW5nRm9yRGVsYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1vdmVTdGFydFNvdXJjZUlkcyAsIGRyYWdPdmVyVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCA9IHRoaXMub3B0aW9ucy5lbmFibGVIb3Zlck91dHNpZGVUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRPZmZzZXQgPSBnZXRFdmVudENsaWVudE9mZnNldChlMSwgdGhpcy5sYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoIWNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0b3VjaCBtb3ZlIHN0YXJ0ZWQgYXMgYSBzY3JvbGwsIG9yIGlzIGlzIGJldHdlZW4gdGhlIHNjcm9sbCBhbmdsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Njcm9sbGluZyB8fCAhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSAmJiBpbkFuZ2xlUmFuZ2VzKHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0LnggfHwgMCwgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQueSB8fCAwLCBjbGllbnRPZmZzZXQueCwgY2xpZW50T2Zmc2V0LnksIHRoaXMub3B0aW9ucy5zY3JvbGxBbmdsZVJhbmdlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIGFuZCB3ZSd2ZSBtb3ZlZCBhIGxpdHRsZSwgdGhhdCBjb3VudHMgYXMgYSBkcmFnIHN0YXJ0XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQuaGFzT3duUHJvcGVydHkoJ3gnKSAmJiBtb3ZlU3RhcnRTb3VyY2VJZHMgJiYgZGlzdGFuY2UodGhpcy5fbW91c2VDbGllbnRPZmZzZXQueCB8fCAwLCB0aGlzLl9tb3VzZUNsaWVudE9mZnNldC55IHx8IDAsIGNsaWVudE9mZnNldC54LCBjbGllbnRPZmZzZXQueSkgPiAodGhpcy5vcHRpb25zLnRvdWNoU2xvcCA/IHRoaXMub3B0aW9ucy50b3VjaFNsb3AgOiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5iZWdpbkRyYWcobW92ZVN0YXJ0U291cmNlSWRzLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogdGhpcy5fbW91c2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGdldFNvdXJjZUNsaWVudE9mZnNldDogdGhpcy5nZXRTb3VyY2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hTb3VyY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gdGhpcy5zb3VyY2VOb2Rlcy5nZXQodGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCkpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcihzb3VyY2VOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wdWJsaXNoRHJhZ1NvdXJjZSgpO1xuICAgICAgICAgICAgaWYgKGUxLmNhbmNlbGFibGUpIGUxLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5vZGUgZWxlbWVudHMgb2YgdGhlIGhvdmVyZWQgRHJvcFRhcmdldHNcbiAgICAgICAgICAgIGNvbnN0IGRyYWdPdmVyVGFyZ2V0Tm9kZXMgPSAoZHJhZ092ZXJUYXJnZXRJZHMgfHwgW10pLm1hcCgoa2V5KT0+dGhpcy50YXJnZXROb2Rlcy5nZXQoa2V5KVxuICAgICAgICAgICAgKS5maWx0ZXIoKGUpPT4hIWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGEgb3JkZXJlZCBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRvdWNoZWQgYnlcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQXRQb2ludCA9IHRoaXMub3B0aW9ucy5nZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50ID8gdGhpcy5vcHRpb25zLmdldERyb3BUYXJnZXRFbGVtZW50c0F0UG9pbnQoY2xpZW50T2Zmc2V0LngsIGNsaWVudE9mZnNldC55LCBkcmFnT3ZlclRhcmdldE5vZGVzKSA6IHRoaXMuZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoY2xpZW50T2Zmc2V0LngsIGNsaWVudE9mZnNldC55KTtcbiAgICAgICAgICAgIC8vIEV4dGVuZCBsaXN0IHdpdGggcGFyZW50cyB0aGF0IGFyZSBub3QgcmVjZWl2aW5nIGVsZW1lbnRzRnJvbVBvaW50IGV2ZW50cyAoc2l6ZSAwIGVsZW1lbnRzIGFuZCBzdmcgZ3JvdXBzKVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQgPSBbXTtcbiAgICAgICAgICAgIGZvcihjb25zdCBub2RlSWQgaW4gZWxlbWVudHNBdFBvaW50KXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50c0F0UG9pbnQuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudHNBdFBvaW50W25vZGVJZF07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnROb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQuaW5kZXhPZihjdXJyZW50Tm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0F0UG9pbnRFeHRlbmRlZC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9yZGVyZWREcmFnT3ZlclRhcmdldElkcyA9IGVsZW1lbnRzQXRQb2ludEV4dGVuZGVkLy8gRmlsdGVyIG9mZiBub2RlcyB0aGF0IGFyZW50IGEgaG92ZXJlZCBEcm9wVGFyZ2V0cyBub2Rlc1xuICAgICAgICAgICAgLmZpbHRlcigobm9kZSk9PmRyYWdPdmVyVGFyZ2V0Tm9kZXMuaW5kZXhPZihub2RlKSA+IC0xXG4gICAgICAgICAgICApLy8gTWFwIGJhY2sgdGhlIG5vZGVzIGVsZW1lbnRzIHRvIHRhcmdldElkc1xuICAgICAgICAgICAgLm1hcCgobm9kZSk9PnRoaXMuX2dldERyb3BUYXJnZXRJZChub2RlKVxuICAgICAgICAgICAgKS8vIEZpbHRlciBvZmYgcG9zc2libGUgbnVsbCByb3dzXG4gICAgICAgICAgICAuZmlsdGVyKChub2RlKT0+ISFub2RlXG4gICAgICAgICAgICApLmZpbHRlcigoaWQsIGluZGV4LCBpZHMpPT5pZHMuaW5kZXhPZihpZCkgPT09IGluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gSW52b2tlIGhvdmVyIGZvciBkcm9wIHRhcmdldHMgd2hlbiBzb3VyY2Ugbm9kZSBpcyBzdGlsbCBvdmVyIGFuZCBwb2ludGVyIGlzIG91dHNpZGVcbiAgICAgICAgICAgIGlmIChlbmFibGVIb3Zlck91dHNpZGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IoY29uc3QgdGFyZ2V0SWQgaW4gdGhpcy50YXJnZXROb2Rlcyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLnRhcmdldE5vZGVzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlICYmIHRhcmdldE5vZGUgJiYgdGFyZ2V0Tm9kZS5jb250YWlucyhzb3VyY2VOb2RlKSAmJiBvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMudW5zaGlmdCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgYmVjYXVzZSBkbmQtY29yZSByZXZlcnNlIGl0IGJlZm9yZSBjYWxsaW5nIHRoZSBEcm9wVGFyZ2V0IGRyb3AgbWV0aG9kc1xuICAgICAgICAgICAgb3JkZXJlZERyYWdPdmVyVGFyZ2V0SWRzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3ZlcihvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuXHQgKlxuXHQgKiB2aXNpYmxlIGZvciB0ZXN0aW5nXG5cdCAqLyB0aGlzLl9nZXREcm9wVGFyZ2V0SWQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLnRhcmdldE5vZGVzLmtleXMoKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0ga2V5cy5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZShuZXh0LmRvbmUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJZCA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0Tm9kZXMuZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGtleXMubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUgPSAoZSk9PntcbiAgICAgICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZEVuZERyYWcoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkgfHwgdGhpcy5tb25pdG9yLmRpZERyb3AoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5kcm9wKCk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuZW5kRHJhZygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnICYmIHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zUmVhZGVyKG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50YXJnZXROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzID0gW107XG4gICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJUeXBlcy5wdXNoKExpc3RlbmVyVHlwZS5tb3VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLnB1c2goTGlzdGVuZXJUeXBlLnRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMucHVzaChMaXN0ZW5lclR5cGUua2V5Ym9hcmQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBUb3VjaEJhY2tlbmQgPSBmdW5jdGlvbiBjcmVhdGVCYWNrZW5kKG1hbmFnZXIsIGNvbnRleHQgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBUb3VjaEJhY2tlbmRJbXBsKG1hbmFnZXIsIGNvbnRleHQsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgQ2hlc3Nib2FyZERuRENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHsgaXNDdXN0b21EbmRQcm92aWRlclNldDogZmFsc2UgfSk7XHJcbmNvbnN0IEVtcHR5UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcclxufTtcclxuY29uc3QgQ2hlc3Nib2FyZERuRFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGJhY2tlbmQsIGNvbnRleHQsIG9wdGlvbnMsIGRlYnVnTW9kZSwgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChqc3goQ2hlc3Nib2FyZERuRENvbnRleHQuUHJvdmlkZXIsIE9iamVjdC5hc3NpZ24oeyB2YWx1ZTogeyBpc0N1c3RvbURuZFByb3ZpZGVyU2V0OiB0cnVlIH0gfSwgeyBjaGlsZHJlbjoganN4KERuZFByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgYmFja2VuZDogYmFja2VuZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgPyBUb3VjaEJhY2tlbmQgOiBIVE1MNUJhY2tlbmQpLCBjb250ZXh0OiBjb250ZXh0LCBvcHRpb25zOiBvcHRpb25zLCBkZWJ1Z01vZGU6IGRlYnVnTW9kZSAhPT0gbnVsbCAmJiBkZWJ1Z01vZGUgIT09IHZvaWQgMCA/IGRlYnVnTW9kZSA6IGZhbHNlIH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSB9KSkpO1xyXG59O1xyXG5jb25zdCBDaGVzc2JvYXJkRG5EUm9vdCA9ICh7IGN1c3RvbURuZEJhY2tlbmQsIGN1c3RvbURuZEJhY2tlbmRPcHRpb25zLCBjaGlsZHJlbiwgfSkgPT4ge1xyXG4gICAgY29uc3QgW2NsaWVudFdpbmRvdywgc2V0Q2xpZW50V2luZG93XSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbYmFja2VuZFNldCwgc2V0QmFja2VuZFNldF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNNb2JpbGUsIHNldElzTW9iaWxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHsgaXNDdXN0b21EbmRQcm92aWRlclNldCB9ID0gdXNlQ29udGV4dChDaGVzc2JvYXJkRG5EQ29udGV4dCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldElzTW9iaWxlKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KTtcclxuICAgICAgICBzZXRCYWNrZW5kU2V0KHRydWUpO1xyXG4gICAgICAgIHNldENsaWVudFdpbmRvdyh3aW5kb3cpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgLy8gaW4gY2FzZSB3ZSBhbHJlYWR5IHdyYXBwZWQgYDxDaGVzc2JvYXJkLz5gICB3aXRoIGA8RG5EUHJvdmlkZXIvPmAgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICBjb25zdCBEbkRXcmFwcGVyID0gaXNDdXN0b21EbmRQcm92aWRlclNldCA/IEVtcHR5UHJvdmlkZXIgOiBEbmRQcm92aWRlcjtcclxuICAgIGlmICghYmFja2VuZFNldCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsaWVudFdpbmRvdyA/IChqc3goRG5EV3JhcHBlciwgT2JqZWN0LmFzc2lnbih7IGJhY2tlbmQ6IGN1c3RvbURuZEJhY2tlbmQgfHwgKGlzTW9iaWxlID8gVG91Y2hCYWNrZW5kIDogSFRNTDVCYWNrZW5kKSwgY29udGV4dDogY2xpZW50V2luZG93LCBvcHRpb25zOiBjdXN0b21EbmRCYWNrZW5kID8gY3VzdG9tRG5kQmFja2VuZE9wdGlvbnMgOiB1bmRlZmluZWQgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpKSA6IChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcclxufTtcblxuZnVuY3Rpb24gQ3VzdG9tRHJhZ0xheWVyKHsgYm9hcmRDb250YWluZXIgfSkge1xyXG4gICAgY29uc3QgeyBib2FyZFdpZHRoLCBjaGVzc1BpZWNlcywgaWQsIHNuYXBUb0N1cnNvciwgYWxsb3dEcmFnT3V0c2lkZUJvYXJkIH0gPSB1c2VDaGVzc2JvYXJkKCk7XHJcbiAgICBjb25zdCBjb2xsZWN0ZWRQcm9wcyA9IHVzZURyYWdMYXllcigobW9uaXRvcikgPT4gKHtcclxuICAgICAgICBpdGVtOiBtb25pdG9yLmdldEl0ZW0oKSxcclxuICAgICAgICBjbGllbnRPZmZzZXQ6IG1vbml0b3IuZ2V0Q2xpZW50T2Zmc2V0KCksXHJcbiAgICAgICAgc291cmNlQ2xpZW50T2Zmc2V0OiBtb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpLFxyXG4gICAgICAgIGlzRHJhZ2dpbmc6IG1vbml0b3IuaXNEcmFnZ2luZygpLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgeyBpc0RyYWdnaW5nLCBpdGVtLCBjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCwgfSA9IGNvbGxlY3RlZFByb3BzO1xyXG4gICAgY29uc3QgZ2V0SXRlbVN0eWxlID0gdXNlQ2FsbGJhY2soKGNsaWVudE9mZnNldCwgc291cmNlQ2xpZW50T2Zmc2V0KSA9PiB7XHJcbiAgICAgICAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIXNvdXJjZUNsaWVudE9mZnNldClcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcGxheTogXCJub25lXCIgfTtcclxuICAgICAgICBsZXQgeyB4LCB5IH0gPSBzbmFwVG9DdXJzb3IgPyBjbGllbnRPZmZzZXQgOiBzb3VyY2VDbGllbnRPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgaGFsZlNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDggLyAyO1xyXG4gICAgICAgIGlmIChzbmFwVG9DdXJzb3IpIHtcclxuICAgICAgICAgICAgeCAtPSBoYWxmU3F1YXJlV2lkdGg7XHJcbiAgICAgICAgICAgIHkgLT0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFsbG93RHJhZ091dHNpZGVCb2FyZCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gYm9hcmRDb250YWluZXI7XHJcbiAgICAgICAgICAgIC8vIGhhbGYgc3F1YXJlIHNvIHRoZSBwaWVjZSByZWFjaGVzIHRoZSBib2FyZFxyXG4gICAgICAgICAgICBjb25zdCBtYXhMZWZ0ID0gbGVmdCAtIGhhbGZTcXVhcmVXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgbWF4VG9wID0gdG9wIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IGxlZnQgKyBib2FyZFdpZHRoIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhCb3R0b20gPSB0b3AgKyBib2FyZFdpZHRoIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5tYXgobWF4TGVmdCwgTWF0aC5taW4oeCwgbWF4UmlnaHQpKTtcclxuICAgICAgICAgICAgeSA9IE1hdGgubWF4KG1heFRvcCwgTWF0aC5taW4oeSwgbWF4Qm90dG9tKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICB0b3VjaEFjdGlvbjogXCJub25lXCIsXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtib2FyZFdpZHRoLCBhbGxvd0RyYWdPdXRzaWRlQm9hcmQsIHNuYXBUb0N1cnNvciwgYm9hcmRDb250YWluZXJdKTtcclxuICAgIHJldHVybiBpc0RyYWdnaW5nICYmIGl0ZW0uaWQgPT09IGlkID8gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcclxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXHJcbiAgICAgICAgICAgIHpJbmRleDogMTAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICB9IH0sIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IGdldEl0ZW1TdHlsZShjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkgfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW2l0ZW0ucGllY2VdID09PSBcImZ1bmN0aW9uXCIgPyAoY2hlc3NQaWVjZXNbaXRlbS5waWVjZV0oe1xyXG4gICAgICAgICAgICAgICAgc3F1YXJlV2lkdGg6IGJvYXJkV2lkdGggLyA4LFxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcclxuICAgICAgICAgICAgfSkpIDogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgdmlld0JveDogXCIxIDEgNDMgNDNcIiwgd2lkdGg6IGJvYXJkV2lkdGggLyA4LCBoZWlnaHQ6IGJvYXJkV2lkdGggLyA4IH0sIHsgY2hpbGRyZW46IGpzeChcImdcIiwgeyBjaGlsZHJlbjogY2hlc3NQaWVjZXNbaXRlbS5waWVjZV0gfSkgfSkpKSB9KSkgfSkpKSA6IG51bGw7XHJcbn1cblxuY29uc3QgU3BhcmVQaWVjZSA9ICh7IHBpZWNlLCB3aWR0aCwgY3VzdG9tUGllY2VKU1gsIGRuZElkLCB9KSA9PiB7XHJcbiAgICBjb25zdCByZW5kZXJQaWVjZSA9IGN1c3RvbVBpZWNlSlNYICE9PSBudWxsICYmIGN1c3RvbVBpZWNlSlNYICE9PSB2b2lkIDAgPyBjdXN0b21QaWVjZUpTWCA6IGRlZmF1bHRQaWVjZXNbcGllY2VdO1xyXG4gICAgY29uc3QgW3sgY2FuRHJhZywgaXNEcmFnZ2luZyB9LCBkcmFnLCBkcmFnUHJldmlld10gPSB1c2VEcmFnKCgpID0+ICh7XHJcbiAgICAgICAgdHlwZTogXCJwaWVjZVwiLFxyXG4gICAgICAgIGl0ZW06ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGllY2UsIGlzU3BhcmU6IHRydWUsIGlkOiBkbmRJZCB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdDogKG1vbml0b3IpID0+ICh7XHJcbiAgICAgICAgICAgIGNhbkRyYWc6IHRydWUsXHJcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6ICEhbW9uaXRvci5pc0RyYWdnaW5nKCksXHJcbiAgICAgICAgfSksXHJcbiAgICB9KSwgW3BpZWNlLCBkbmRJZF0pO1xyXG4gICAgLy8gaGlkZSB0aGUgZGVmYXVsdCBwcmV2aWV3XHJcbiAgICBkcmFnUHJldmlldyhnZXRFbXB0eUltYWdlKCksIHsgY2FwdHVyZURyYWdnaW5nU3RhdGU6IHRydWUgfSk7XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBjYW5EcmFnID8gZHJhZyA6IG51bGwsIFwiZGF0YS1waWVjZVwiOiBwaWVjZSwgc3R5bGU6IHsgY3Vyc29yOiBcIm1vdmVcIiB9IH0sIHsgY2hpbGRyZW46IHR5cGVvZiByZW5kZXJQaWVjZSA9PT0gXCJmdW5jdGlvblwiID8gKHJlbmRlclBpZWNlKHtcclxuICAgICAgICAgICAgc3F1YXJlV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBpc0RyYWdnaW5nLFxyXG4gICAgICAgIH0pKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiB3aWR0aCB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IHJlbmRlclBpZWNlIH0pIH0pKSkgfSkpKTtcclxufTtcblxuY29uc3QgQ2hlc3Nib2FyZCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcclxuICAgIGNvbnN0IHsgY3VzdG9tRG5kQmFja2VuZCwgY3VzdG9tRG5kQmFja2VuZE9wdGlvbnMsIG9uQm9hcmRXaWR0aENoYW5nZSB9ID0gcHJvcHMsIG90aGVyUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImN1c3RvbURuZEJhY2tlbmRcIiwgXCJjdXN0b21EbmRCYWNrZW5kT3B0aW9uc1wiLCBcIm9uQm9hcmRXaWR0aENoYW5nZVwiXSk7XHJcbiAgICBjb25zdCBbYm9hcmRXaWR0aCwgc2V0Qm9hcmRXaWR0aF0gPSB1c2VTdGF0ZShwcm9wcy5ib2FyZFdpZHRoKTtcclxuICAgIGNvbnN0IGJvYXJkUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgYm9hcmRDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBbYm9hcmRDb250YWluZXJQb3MsIHNldEJvYXJkQ29udGFpbmVyUG9zXSA9IHVzZVN0YXRlKHtcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbWV0cmljcyA9IHVzZU1lbW8oKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBib2FyZFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0sIFtib2FyZFJlZi5jdXJyZW50XSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGJvYXJkV2lkdGggJiYgKG9uQm9hcmRXaWR0aENoYW5nZSA9PT0gbnVsbCB8fCBvbkJvYXJkV2lkdGhDaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQm9hcmRXaWR0aENoYW5nZShib2FyZFdpZHRoKSk7XHJcbiAgICB9LCBbYm9hcmRXaWR0aF0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRCb2FyZENvbnRhaW5lclBvcyh7XHJcbiAgICAgICAgICAgIGxlZnQ6IChtZXRyaWNzID09PSBudWxsIHx8IG1ldHJpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldHJpY3MubGVmdCkgPyBtZXRyaWNzID09PSBudWxsIHx8IG1ldHJpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldHJpY3MubGVmdCA6IDAsXHJcbiAgICAgICAgICAgIHRvcDogKG1ldHJpY3MgPT09IG51bGwgfHwgbWV0cmljcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0cmljcy50b3ApID8gbWV0cmljcyA9PT0gbnVsbCB8fCBtZXRyaWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRyaWNzLnRvcCA6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbbWV0cmljc10pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHByb3BzLmJvYXJkV2lkdGggPT09IHVuZGVmaW5lZCAmJiAoKF9hID0gYm9hcmRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9mZnNldFdpZHRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBzZXRCb2FyZFdpZHRoKChfYSA9IGJvYXJkUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vZmZzZXRXaWR0aCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGJvYXJkUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtib2FyZFJlZi5jdXJyZW50XSk7XHJcbiAgICByZXR1cm4gKGpzeChFcnJvckJvdW5kYXJ5LCB7IGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyByZWY6IGJvYXJkQ29udGFpbmVyUmVmLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyByZWY6IGJvYXJkUmVmLCBzdHlsZTogeyB3aWR0aDogXCIxMDAlXCIgfSB9KSwganN4KENoZXNzYm9hcmREbkRSb290LCBPYmplY3QuYXNzaWduKHsgY3VzdG9tRG5kQmFja2VuZDogY3VzdG9tRG5kQmFja2VuZCwgY3VzdG9tRG5kQmFja2VuZE9wdGlvbnM6IGN1c3RvbURuZEJhY2tlbmRPcHRpb25zIH0sIHsgY2hpbGRyZW46IGJvYXJkV2lkdGggJiYgKGpzeHMoQ2hlc3Nib2FyZFByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgYm9hcmRXaWR0aDogYm9hcmRXaWR0aCB9LCBvdGhlclByb3BzLCB7IHJlZjogcmVmIH0sIHsgY2hpbGRyZW46IFtqc3goQ3VzdG9tRHJhZ0xheWVyLCB7IGJvYXJkQ29udGFpbmVyOiBib2FyZENvbnRhaW5lclBvcyB9KSwganN4KEJvYXJkLCB7fSldIH0pKSkgfSkpXSB9KSkgfSkpO1xyXG59KTtcblxuZXhwb3J0IHsgQ2hlc3Nib2FyZCwgQ2hlc3Nib2FyZERuRFByb3ZpZGVyLCBTcGFyZVBpZWNlIH07XG4iXSwibmFtZXMiOlsianN4IiwianN4cyIsIkZyYWdtZW50IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjcmVhdGVDb250ZXh0IiwiZm9yd2FyZFJlZiIsInVzZVJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VDb250ZXh0IiwibWVtbyIsInVzZUxheW91dEVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiRnJhZ21lbnQkMSIsIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiQ09MVU1OUyIsInNwbGl0IiwiU1RBUlRfUE9TSVRJT05fT0JKRUNUIiwiYTgiLCJiOCIsImM4IiwiZDgiLCJlOCIsImY4IiwiZzgiLCJoOCIsImE3IiwiYjciLCJjNyIsImQ3IiwiZTciLCJmNyIsImc3IiwiaDciLCJhMiIsImIyIiwiYzIiLCJkMiIsImUyIiwiZjIiLCJnMiIsImgyIiwiYTEiLCJiMSIsImMxIiwiZDEiLCJlMSIsImYxIiwiZzEiLCJoMSIsIldISVRFX0NPTFVNTl9WQUxVRVMiLCJhIiwiYiIsImMiLCJkIiwiZiIsImciLCJoIiwiQkxBQ0tfQ09MVU1OX1ZBTFVFUyIsIldISVRFX1JPV1MiLCJCTEFDS19ST1dTIiwiZGVmYXVsdFBpZWNlcyIsIndQIiwiYXNzaWduIiwieG1sbnMiLCJ2ZXJzaW9uIiwid2lkdGgiLCJoZWlnaHQiLCJjaGlsZHJlbiIsInN0eWxlIiwib3BhY2l0eSIsImZpbGwiLCJmaWxsT3BhY2l0eSIsImZpbGxSdWxlIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlT3BhY2l0eSIsIndSIiwid04iLCJ0cmFuc2Zvcm0iLCJ3QiIsIndRIiwiY3giLCJjeSIsInIiLCJ3SyIsImJQIiwiYlIiLCJiTiIsImJCIiwiYlEiLCJiSyIsImlkIiwiZ2V0UmVsYXRpdmVDb29yZHMiLCJib2FyZE9yaWVudGF0aW9uIiwiYm9hcmRXaWR0aCIsInNxdWFyZSIsInNxdWFyZVdpZHRoIiwiY29sdW1ucyIsInJvd3MiLCJ4IiwieSIsInBhcnNlSW50IiwiaXNEaWZmZXJlbnRGcm9tU3RhcnQiLCJuZXdQb3NpdGlvbiIsImlzRGlmZmVyZW50Iiwia2V5cyIsImZvckVhY2giLCJnZXRQb3NpdGlvbkRpZmZlcmVuY2VzIiwiY3VycmVudFBvc2l0aW9uIiwiZGlmZmVyZW5jZSIsInJlbW92ZWQiLCJhZGRlZCIsImNvbnZlcnRQb3NpdGlvblRvT2JqZWN0IiwicG9zaXRpb24iLCJmZW5Ub09iaiIsImZlbiIsImlzVmFsaWRGZW4iLCJyZXBsYWNlIiwiY3VycmVudFJvdyIsInJvdyIsImNvbElkeCIsImoiLCJzZWFyY2giLCJudW1FbXB0eVNxdWFyZXMiLCJmZW5Ub1BpZWNlQ29kZSIsImV4cGFuZEZlbkVtcHR5U3F1YXJlcyIsImNodW5rcyIsInBpZWNlIiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsInVzZUFycm93cyIsImN1c3RvbUFycm93cyIsImFyZUFycm93c0FsbG93ZWQiLCJvbkFycm93c0NoYW5nZSIsImN1c3RvbUFycm93Q29sb3IiLCJjdXN0b21BcnJvd3NTZXQiLCJzZXRDdXN0b21BcnJvd3MiLCJhcnJvd3MiLCJzZXRBcnJvd3MiLCJuZXdBcnJvdyIsInNldE5ld0Fycm93IiwiQXJyYXkiLCJpc0FycmF5IiwiY2xlYXJBcnJvd3MiLCJmaWx0ZXIiLCJhcnJvdyIsInVuZGVmaW5lZCIsImRyYXdOZXdBcnJvdyIsImZyb21TcXVhcmUiLCJ0b1NxdWFyZSIsImFsbEJvYXJkQXJyb3dzIiwib25BcnJvd0RyYXdFbmQiLCJhcnJvd3NDb3B5IiwiaXNOZXdBcnJvd1VuaXF1ZSIsImV2ZXJ5IiwiYXJyb3dGcm9tIiwiYXJyb3dUbyIsIkNoZXNzYm9hcmRDb250ZXh0IiwidXNlQ2hlc3Nib2FyZCIsIkNoZXNzYm9hcmRQcm92aWRlciIsImFsbG93RHJhZ091dHNpZGVCb2FyZCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYXJlUGllY2VzRHJhZ2dhYmxlIiwiYXJlUHJlbW92ZXNBbGxvd2VkIiwiYXV0b1Byb21vdGVUb1F1ZWVuIiwiY2xlYXJQcmVtb3Zlc09uUmlnaHRDbGljayIsImN1c3RvbUJvYXJkU3R5bGUiLCJjdXN0b21Ob3RhdGlvblN0eWxlIiwiY3VzdG9tRGFya1NxdWFyZVN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiY3VzdG9tRHJvcFNxdWFyZVN0eWxlIiwiYm94U2hhZG93IiwiY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSIsImN1c3RvbVBpZWNlcyIsImN1c3RvbVByZW1vdmVEYXJrU3F1YXJlU3R5bGUiLCJjdXN0b21QcmVtb3ZlTGlnaHRTcXVhcmVTdHlsZSIsImN1c3RvbVNxdWFyZSIsImN1c3RvbVNxdWFyZVN0eWxlcyIsImRyb3BPZmZCb2FyZEFjdGlvbiIsImlzRHJhZ2dhYmxlUGllY2UiLCJnZXRQb3NpdGlvbk9iamVjdCIsIm9uRHJhZ092ZXJTcXVhcmUiLCJvbk1vdXNlT3V0U3F1YXJlIiwib25Nb3VzZU92ZXJTcXVhcmUiLCJvblBpZWNlQ2xpY2siLCJvblBpZWNlRHJhZ0JlZ2luIiwib25QaWVjZURyYWdFbmQiLCJvblBpZWNlRHJvcCIsIm9uUGllY2VEcm9wT2ZmQm9hcmQiLCJvblByb21vdGlvbkNoZWNrIiwic291cmNlU3F1YXJlIiwidGFyZ2V0U3F1YXJlIiwiTWF0aCIsImFicyIsImNoYXJDb2RlQXQiLCJvblByb21vdGlvblBpZWNlU2VsZWN0Iiwib25TcGFyZVBpZWNlRHJvcCIsIm9uU3F1YXJlQ2xpY2siLCJvblNxdWFyZVJpZ2h0Q2xpY2siLCJwcm9tb3Rpb25EaWFsb2dWYXJpYW50IiwicHJvbW90aW9uVG9TcXVhcmUiLCJzaG93Qm9hcmROb3RhdGlvbiIsInNob3dQcm9tb3Rpb25EaWFsb2ciLCJzbmFwVG9DdXJzb3IiLCJyZWYiLCJzZXRDdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbkRpZmZlcmVuY2VzIiwic2V0UG9zaXRpb25EaWZmZXJlbmNlcyIsImxhc3RQaWVjZUNvbG91ciIsInNldExhc3RQaWVjZUNvbG91ciIsInNob3dQcm9tb3RlRGlhbG9nIiwic2V0U2hvd1Byb21vdGVEaWFsb2ciLCJwcm9tb3RlRnJvbVNxdWFyZSIsInNldFByb21vdGVGcm9tU3F1YXJlIiwicHJvbW90ZVRvU3F1YXJlIiwic2V0UHJvbW90ZVRvU3F1YXJlIiwicHJlbW92ZXMiLCJzZXRQcmVtb3ZlcyIsInByZW1vdmVzUmVmIiwiY3VycmVudFJpZ2h0Q2xpY2tEb3duIiwic2V0Q3VycmVudFJpZ2h0Q2xpY2tEb3duIiwiY2hlc3NQaWVjZXMiLCJzZXRDaGVzc1BpZWNlcyIsIndhc01hbnVhbERyb3AiLCJzZXRXYXNNYW51YWxEcm9wIiwicHJldmlvdXNUaW1lb3V0Iiwic2V0UHJldmlvdXNUaW1lb3V0IiwiaXNXYWl0aW5nRm9yQW5pbWF0aW9uIiwic2V0SXNXYWl0aW5nRm9yQW5pbWF0aW9uIiwibGFzdFNxdWFyZURyYWdnZWRPdmVyIiwic2V0TGFzdFNxdWFyZURyYWdnZWRPdmVyIiwiY2xlYXJQcmVtb3ZlcyIsImNsZWFyTGFzdFBpZWNlQ29sb3VyIiwiX2EiLCJfYiIsIl9jIiwiY2xlYXJQcm9tb3Rpb24iLCJkaWZmZXJlbmNlcyIsIm5ld1BpZWNlQ29sb3VyIiwiZW50cmllcyIsImF0dGVtcHRQcmVtb3ZlIiwiY2xlYXJUaW1lb3V0IiwibmV3VGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVTZXRQb3NpdGlvbiIsInNvdXJjZVNxIiwidGFyZ2V0U3EiLCJ3YXNNYW51YWxEcm9wT3ZlcnJpZGUiLCJjdXJyZW50Iiwib2xkUHJlbW92ZXMiLCJwdXNoIiwibmV3T25Ecm9wUG9zaXRpb24iLCJpc1ZhbGlkTW92ZSIsImRlbGV0ZVBpZWNlRnJvbVNxdWFyZSIsInBvc2l0aW9uQ29weSIsInByZW1vdmUiLCJzaGlmdCIsImhhbmRsZVNwYXJlUGllY2VEcm9wIiwiaXNWYWxpZERyb3AiLCJvblJpZ2h0Q2xpY2tEb3duIiwib25SaWdodENsaWNrVXAiLCJjbGVhckN1cnJlbnRSaWdodENsaWNrRG93biIsIkNoZXNzYm9hcmRQcm92aWRlckNvbnRleHRWYWx1ZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJOb3RhdGlvbiIsImNvbCIsIndoaXRlQ29sb3IiLCJibGFja0NvbG9yIiwiaXNSb3ciLCJpc0NvbHVtbiIsImlzQm90dG9tTGVmdFNxdWFyZSIsImdldFJvdyIsImdldENvbHVtbiIsInJlbmRlckJvdHRvbUxlZnQiLCJ6SW5kZXgiLCJjb2xvciIsIm51bWVyaWNTdHlsZSIsImFscGhhU3R5bGUiLCJyZW5kZXJMZXR0ZXJzIiwidXNlclNlbGVjdCIsInJlbmRlck51bWJlcnMiLCJhbGlnblNlbGYiLCJwYWRkaW5nTGVmdCIsImZvbnRTaXplIiwicGFkZGluZ1JpZ2h0IiwiRG5kQ29udGV4dCIsImRyYWdEcm9wTWFuYWdlciIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJjb2RlIiwiJCRvYnNlcnZhYmxlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsInJhbmRvbVN0cmluZyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiam9pbiIsIkFjdGlvblR5cGVzIiwiSU5JVCIsIlJFUExBQ0UiLCJQUk9CRV9VTktOT1dOX0FDVElPTiIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwibWluaUtpbmRPZiIsInZhbCIsInR5cGUiLCJpc0RhdGUiLCJpc0Vycm9yIiwiY29uc3RydWN0b3JOYW1lIiwiY3Rvck5hbWUiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkVycm9yIiwibWVzc2FnZSIsInN0YWNrVHJhY2VMaW1pdCIsIkRhdGUiLCJ0b0RhdGVTdHJpbmciLCJnZXREYXRlIiwic2V0RGF0ZSIsImtpbmRPZiIsInR5cGVPZlZhbCIsInByb2Nlc3MiLCJjcmVhdGVTdG9yZSIsInJlZHVjZXIiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwiX3JlZjIiLCJhcmd1bWVudHMiLCJjdXJyZW50UmVkdWNlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnRMaXN0ZW5lcnMiLCJuZXh0TGlzdGVuZXJzIiwiaXNEaXNwYXRjaGluZyIsImVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMiLCJnZXRTdGF0ZSIsInN1YnNjcmliZSIsImxpc3RlbmVyIiwiaXNTdWJzY3JpYmVkIiwidW5zdWJzY3JpYmUiLCJpbmRleCIsInNwbGljZSIsImRpc3BhdGNoIiwiYWN0aW9uIiwibGlzdGVuZXJzIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsIl9yZWYiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwibmV4dCIsIndhcm5pbmciLCJjb25zb2xlIiwiZXJyb3IiLCJpc0NydXNoZWQiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJmb3JtYXQiLCJhcmdzIiwiaXNQcm9kdWN0aW9uIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsImdldCIsInBhdGgiLCJkZWZhdWx0VmFsdWUiLCJyZWR1Y2UiLCJ3aXRob3V0JDEiLCJpdGVtcyIsIml0ZW0iLCJpc09iamVjdCIsImlucHV0IiwieG9yIiwiaXRlbXNBIiwiaXRlbXNCIiwibWFwIiwiTWFwIiwiaW5zZXJ0SXRlbSIsInNldCIsImhhcyIsInJlc3VsdCIsImNvdW50Iiwia2V5IiwiaW50ZXJzZWN0aW9uIiwiSU5JVF9DT09SRFMiLCJCRUdJTl9EUkFHIiwiUFVCTElTSF9EUkFHX1NPVVJDRSIsIkhPVkVSIiwiRFJPUCIsIkVORF9EUkFHIiwic2V0Q2xpZW50T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwic291cmNlQ2xpZW50T2Zmc2V0IiwicGF5bG9hZCIsIlJlc2V0Q29vcmRpbmF0ZXNBY3Rpb24iLCJjcmVhdGVCZWdpbkRyYWciLCJtYW5hZ2VyIiwiYmVnaW5EcmFnIiwic291cmNlSWRzIiwib3B0aW9ucyIsInB1Ymxpc2hTb3VyY2UiLCJnZXRTb3VyY2VDbGllbnRPZmZzZXQiLCJtb25pdG9yIiwiZ2V0TW9uaXRvciIsInJlZ2lzdHJ5IiwiZ2V0UmVnaXN0cnkiLCJ2ZXJpZnlJbnZhcmlhbnRzJDEiLCJzb3VyY2VJZCIsImdldERyYWdnYWJsZVNvdXJjZSIsInZlcmlmeUdldFNvdXJjZUNsaWVudE9mZnNldElzRnVuY3Rpb24iLCJzb3VyY2UiLCJnZXRTb3VyY2UiLCJ2ZXJpZnlJdGVtSXNPYmplY3QiLCJwaW5Tb3VyY2UiLCJpdGVtVHlwZSIsImdldFNvdXJjZVR5cGUiLCJpc1NvdXJjZVB1YmxpYyIsImlzRHJhZ2dpbmciLCJjYW5EcmFnU291cmNlIiwiX2RlZmluZVByb3BlcnR5JDQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9vYmplY3RTcHJlYWQkNCIsInRhcmdldCIsIm93bktleXMiLCJjb25jYXQiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJjcmVhdGVEcm9wIiwiZHJvcCIsInZlcmlmeUludmFyaWFudHMiLCJ0YXJnZXRJZHMiLCJnZXREcm9wcGFibGVUYXJnZXRzIiwidGFyZ2V0SWQiLCJkcm9wUmVzdWx0IiwiZGV0ZXJtaW5lRHJvcFJlc3VsdCIsImRpZERyb3AiLCJnZXRUYXJnZXQiLCJ2ZXJpZnlEcm9wUmVzdWx0VHlwZSIsImdldERyb3BSZXN1bHQiLCJnZXRUYXJnZXRJZHMiLCJjYW5Ecm9wT25UYXJnZXQiLCJyZXZlcnNlIiwiY3JlYXRlRW5kRHJhZyIsImVuZERyYWciLCJ2ZXJpZnlJc0RyYWdnaW5nIiwiZ2V0U291cmNlSWQiLCJ1bnBpblNvdXJjZSIsIm1hdGNoZXNUeXBlIiwidGFyZ2V0VHlwZSIsImRyYWdnZWRJdGVtVHlwZSIsInNvbWUiLCJjcmVhdGVIb3ZlciIsImhvdmVyIiwidGFyZ2V0SWRzQXJnIiwidmVyaWZ5VGFyZ2V0SWRzSXNBcnJheSIsImdldEl0ZW1UeXBlIiwicmVtb3ZlTm9uTWF0Y2hpbmdUYXJnZXRJZHMiLCJjaGVja0ludmFyaWFudHMiLCJob3ZlckFsbFRhcmdldHMiLCJsYXN0SW5kZXhPZiIsImdldFRhcmdldFR5cGUiLCJjcmVhdGVQdWJsaXNoRHJhZ1NvdXJjZSIsInB1Ymxpc2hEcmFnU291cmNlIiwiY3JlYXRlRHJhZ0Ryb3BBY3Rpb25zIiwiRHJhZ0Ryb3BNYW5hZ2VySW1wbCIsInJlY2VpdmVCYWNrZW5kIiwiYmFja2VuZCIsImdldEJhY2tlbmQiLCJnZXRBY3Rpb25zIiwic3RvcmUiLCJiaW5kQWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3IiLCJhcHBseSIsImFjdGlvbnMiLCJib3VuZEFjdGlvbnMiLCJpc1NldFVwIiwiaGFuZGxlUmVmQ291bnRDaGFuZ2UiLCJzaG91bGRTZXRVcCIsInJlZkNvdW50Iiwic2V0dXAiLCJ0ZWFyZG93biIsImFkZCIsInN1YnRyYWN0Iiwic3RhdGUiLCJpbml0aWFsQ2xpZW50T2Zmc2V0IiwiaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCIsImdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCIsIk5PTkUiLCJBTEwiLCJfX0lTX05PTkVfXyIsIl9fSVNfQUxMX18iLCJhcmVEaXJ0eSIsImRpcnR5SWRzIiwiaGFuZGxlcklkcyIsImNvbW1vbklkcyIsIkRyYWdEcm9wTW9uaXRvckltcGwiLCJzdWJzY3JpYmVUb1N0YXRlQ2hhbmdlIiwicHJldlN0YXRlSWQiLCJzdGF0ZUlkIiwiaGFuZGxlQ2hhbmdlIiwiY3VycmVudFN0YXRlSWQiLCJjYW5Ta2lwTGlzdGVuZXIiLCJkaXJ0eUhhbmRsZXJJZHMiLCJzdWJzY3JpYmVUb09mZnNldENoYW5nZSIsInByZXZpb3VzU3RhdGUiLCJkcmFnT2Zmc2V0IiwibmV4dFN0YXRlIiwiY2FuRHJhZyIsImNhbkRyb3AiLCJCb29sZWFuIiwiaXNEcmFnZ2luZ1NvdXJjZSIsInNvdXJjZVR5cGUiLCJpc092ZXJUYXJnZXQiLCJzaGFsbG93IiwiZHJhZ09wZXJhdGlvbiIsImdldEl0ZW0iLCJnZXRJbml0aWFsQ2xpZW50T2Zmc2V0IiwiZ2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCIsImdldENsaWVudE9mZnNldCIsInNjb3BlIiwiZ2xvYmFsIiwic2VsZiIsIkJyb3dzZXJNdXRhdGlvbk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIiLCJjYWxsYmFjayIsInJlcXVlc3RDYWxsIiwidGltZW91dEhhbmRsZSIsImhhbmRsZVRpbWVyIiwiaW50ZXJ2YWxIYW5kbGUiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlciIsInRvZ2dsZSIsIm5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJkYXRhIiwibWFrZVJlcXVlc3RDYWxsIiwiQXNhcFF1ZXVlIiwiZW5xdWV1ZVRhc2siLCJ0YXNrIiwicXVldWUiLCJxIiwicmVxdWVzdEZsdXNoIiwiZmx1c2hpbmciLCJwZW5kaW5nRXJyb3JzIiwiY2FwYWNpdHkiLCJmbHVzaCIsImN1cnJlbnRJbmRleCIsInNjYW4iLCJuZXdMZW5ndGgiLCJyZWdpc3RlclBlbmRpbmdFcnJvciIsImVyciIsInJlcXVlc3RFcnJvclRocm93IiwiUmF3VGFzayIsIm9uRXJyb3IiLCJyZWxlYXNlIiwiVGFza0ZhY3RvcnkiLCJjcmVhdGUiLCJ0YXNrcyIsImZyZWVUYXNrcyIsInQxIiwicG9wIiwiYXNhcFF1ZXVlIiwidGFza0ZhY3RvcnkiLCJhc2FwIiwiQUREX1NPVVJDRSIsIkFERF9UQVJHRVQiLCJSRU1PVkVfU09VUkNFIiwiUkVNT1ZFX1RBUkdFVCIsImFkZFNvdXJjZSIsImFkZFRhcmdldCIsInJlbW92ZVNvdXJjZSIsInJlbW92ZVRhcmdldCIsInZhbGlkYXRlU291cmNlQ29udHJhY3QiLCJ2YWxpZGF0ZVRhcmdldENvbnRyYWN0IiwidmFsaWRhdGVUeXBlIiwiYWxsb3dBcnJheSIsIkhhbmRsZXJSb2xlIiwibmV4dFVuaXF1ZUlkIiwiZ2V0TmV4dFVuaXF1ZUlkIiwiZ2V0TmV4dEhhbmRsZXJJZCIsInJvbGUiLCJTT1VSQ0UiLCJUQVJHRVQiLCJwYXJzZVJvbGVGcm9tSGFuZGxlcklkIiwiaGFuZGxlcklkIiwibWFwQ29udGFpbnNWYWx1ZSIsInNlYXJjaFZhbHVlIiwiaXNEb25lIiwiZG9uZSIsIkhhbmRsZXJSZWdpc3RyeUltcGwiLCJhZGRIYW5kbGVyIiwiY29udGFpbnNIYW5kbGVyIiwiaGFuZGxlciIsImRyYWdTb3VyY2VzIiwiZHJvcFRhcmdldHMiLCJpbmNsdWRlUGlubmVkIiwiaXNTb3VyY2VJZCIsImlzUGlubmVkIiwicGlubmVkU291cmNlSWQiLCJwaW5uZWRTb3VyY2UiLCJpc1RhcmdldElkIiwidHlwZXMiLCJkZWxldGUiLCJzdHJpY3RFcXVhbGl0eSIsImFyZUNvb3Jkc0VxdWFsIiwib2Zmc2V0QSIsIm9mZnNldEIiLCJhcmVBcnJheXNFcXVhbCIsImlzRXF1YWwiLCJyZWR1Y2UkNSIsIl9zdGF0ZSIsInByZXZUYXJnZXRJZHMiLCJkaWRDaGFuZ2UiLCJwcmV2SW5uZXJtb3N0VGFyZ2V0SWQiLCJpbm5lcm1vc3RUYXJnZXRJZCIsIl9kZWZpbmVQcm9wZXJ0eSQzIiwiX29iamVjdFNwcmVhZCQzIiwiaW5pdGlhbFN0YXRlJDEiLCJyZWR1Y2UkNCIsIl9kZWZpbmVQcm9wZXJ0eSQyIiwiX29iamVjdFNwcmVhZCQyIiwiaW5pdGlhbFN0YXRlIiwicmVkdWNlJDMiLCJyZWR1Y2UkMiIsInJlZHVjZSQxIiwiX2RlZmluZVByb3BlcnR5JDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJjcmVhdGVEcmFnRHJvcE1hbmFnZXIiLCJiYWNrZW5kRmFjdG9yeSIsImdsb2JhbENvbnRleHQiLCJiYWNrZW5kT3B0aW9ucyIsImRlYnVnTW9kZSIsIm1ha2VTdG9yZUluc3RhbmNlIiwicmVkdXhEZXZUb29scyIsIndpbmRvdyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJpbnN0YW5jZUlkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJzb3VyY2VLZXlzIiwiSU5TVEFOQ0VfU1lNIiwiZm9yIiwiRG5kUHJvdmlkZXIiLCJfcGFyYW0iLCJwcm9wcyIsImlzR2xvYmFsSW5zdGFuY2UiLCJnZXREbmRDb250ZXh0VmFsdWUiLCJjb250ZXh0IiwiZ2V0R2xvYmFsQ29udGV4dCIsImNyZWF0ZVNpbmdsZXRvbkRuZENvbnRleHQiLCJjdHgiLCJmYXN0RGVlcEVxdWFsIiwiZXF1YWwiLCJSZWdFeHAiLCJmbGFncyIsInZhbHVlT2YiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlQ29sbGVjdG9yIiwiY29sbGVjdCIsIm9uVXBkYXRlIiwiY29sbGVjdGVkIiwic2V0Q29sbGVjdGVkIiwidXBkYXRlQ29sbGVjdGVkIiwibmV4dFZhbHVlIiwidXNlTW9uaXRvck91dHB1dCIsIm9uQ29sbGVjdCIsInN1YnNjcmliZVRvTW9uaXRvclN0YXRlQ2hhbmdlIiwiZ2V0SGFuZGxlcklkIiwidXNlQ29sbGVjdGVkUHJvcHMiLCJjb2xsZWN0b3IiLCJjb25uZWN0b3IiLCJyZWNvbm5lY3QiLCJ1c2VPcHRpb25hbEZhY3RvcnkiLCJhcmciLCJkZXBzIiwibWVtb0RlcHMiLCJ1c2VDb25uZWN0RHJhZ1NvdXJjZSIsImhvb2tzIiwiZHJhZ1NvdXJjZSIsInVzZUNvbm5lY3REcmFnUHJldmlldyIsImRyYWdQcmV2aWV3IiwiaXNDYWxsaW5nQ2FuRHJhZyIsImlzQ2FsbGluZ0lzRHJhZ2dpbmciLCJEcmFnU291cmNlTW9uaXRvckltcGwiLCJyZWNlaXZlSGFuZGxlcklkIiwiaW50ZXJuYWxNb25pdG9yIiwiaXNDYWxsaW5nQ2FuRHJvcCIsIkRyb3BUYXJnZXRNb25pdG9ySW1wbCIsImlzT3ZlciIsInJlZ2lzdGVyVGFyZ2V0IiwicmVnaXN0ZXJTb3VyY2UiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImNvbXBhcmUiLCJjb21wYXJlQ29udGV4dCIsImNvbXBhcmVSZXN1bHQiLCJrZXlzQSIsImtleXNCIiwiYkhhc093blByb3BlcnR5IiwiYmluZCIsImlkeCIsInZhbHVlQSIsInZhbHVlQiIsImlzUmVmIiwidGhyb3dJZkNvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQiLCJlbGVtZW50IiwiZGlzcGxheU5hbWUiLCJ3cmFwSG9va1RvUmVjb2duaXplRWxlbWVudCIsImhvb2siLCJlbGVtZW50T3JOb2RlIiwiY2xvbmVXaXRoUmVmIiwid3JhcENvbm5lY3Rvckhvb2tzIiwid3JhcHBlZEhvb2tzIiwiZW5kc1dpdGgiLCJ3cmFwcGVkSG9vayIsInNldFJlZiIsIm5ld1JlZiIsInByZXZpb3VzUmVmIiwiU291cmNlQ29ubmVjdG9yIiwibmV3SGFuZGxlcklkIiwiY29ubmVjdFRhcmdldCIsImRyYWdTb3VyY2VPcHRpb25zIiwiZHJhZ1NvdXJjZU9wdGlvbnNJbnRlcm5hbCIsImRyYWdQcmV2aWV3T3B0aW9ucyIsImRyYWdQcmV2aWV3T3B0aW9uc0ludGVybmFsIiwicmVjb25uZWN0RHJhZ1NvdXJjZSIsInJlY29ubmVjdERyYWdQcmV2aWV3IiwiZGlkSGFuZGxlcklkQ2hhbmdlIiwiZGlkQ29ubmVjdGVkRHJhZ1NvdXJjZUNoYW5nZSIsImRpZERyYWdTb3VyY2VPcHRpb25zQ2hhbmdlIiwiZGlzY29ubmVjdERyYWdTb3VyY2UiLCJsYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZSIsImxhc3RDb25uZWN0ZWRIYW5kbGVySWQiLCJsYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZU9wdGlvbnMiLCJkcmFnU291cmNlVW5zdWJzY3JpYmUiLCJjb25uZWN0RHJhZ1NvdXJjZSIsImZvcmNlRGlkQ2hhbmdlIiwiZGlkQ29ubmVjdGVkRHJhZ1ByZXZpZXdDaGFuZ2UiLCJkaWREcmFnUHJldmlld09wdGlvbnNDaGFuZ2UiLCJkaXNjb25uZWN0RHJhZ1ByZXZpZXciLCJsYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXciLCJsYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXdPcHRpb25zIiwiZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSIsImNvbm5lY3REcmFnUHJldmlldyIsImRyYWdQcmV2aWV3Tm9kZSIsImRyYWdQcmV2aWV3UmVmIiwiZHJhZ1NvdXJjZU5vZGUiLCJkcmFnU291cmNlUmVmIiwiY2xlYXJEcmFnU291cmNlIiwiY2xlYXJEcmFnUHJldmlldyIsIlRhcmdldENvbm5lY3RvciIsImRyb3BUYXJnZXQiLCJkaWREcm9wVGFyZ2V0Q2hhbmdlIiwiZGlkT3B0aW9uc0NoYW5nZSIsImRpc2Nvbm5lY3REcm9wVGFyZ2V0IiwibGFzdENvbm5lY3RlZERyb3BUYXJnZXQiLCJsYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMiLCJkcm9wVGFyZ2V0T3B0aW9ucyIsInVuc3Vic2NyaWJlRHJvcFRhcmdldCIsImNvbm5lY3REcm9wVGFyZ2V0IiwiZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbCIsImRyb3BUYXJnZXROb2RlIiwiZHJvcFRhcmdldFJlZiIsImNsZWFyRHJvcFRhcmdldCIsInVzZURyYWdEcm9wTWFuYWdlciIsInVzZURyYWdTb3VyY2VDb25uZWN0b3IiLCJ1c2VEcmFnU291cmNlTW9uaXRvciIsIkRyYWdTb3VyY2VJbXBsIiwic3BlYyIsImdsb2JhbE1vbml0b3IiLCJlbmQiLCJ1c2VEcmFnU291cmNlIiwidXNlRHJhZ1R5cGUiLCJ1c2VSZWdpc3RlcmVkRHJhZ1NvdXJjZSIsInJlZ2lzdGVyRHJhZ1NvdXJjZSIsInVucmVnaXN0ZXIiLCJ1c2VEcmFnIiwic3BlY0FyZyIsImJlZ2luIiwicHJldmlld09wdGlvbnMiLCJ1c2VEcmFnTGF5ZXIiLCJ1c2VDb25uZWN0RHJvcFRhcmdldCIsInVzZURyb3BUYXJnZXRDb25uZWN0b3IiLCJ1c2VEcm9wVGFyZ2V0TW9uaXRvciIsInVzZUFjY2VwdCIsImFjY2VwdCIsIkRyb3BUYXJnZXRJbXBsIiwidXNlRHJvcFRhcmdldCIsInVzZVJlZ2lzdGVyZWREcm9wVGFyZ2V0IiwicmVnaXN0ZXJEcm9wVGFyZ2V0IiwidXNlRHJvcCIsIm1lbW9pemUiLCJmbiIsIm1lbW9pemVkIiwid2l0aG91dCIsInVuaW9uIiwiU2V0IiwiRW50ZXJMZWF2ZUNvdW50ZXIiLCJlbnRlciIsImVudGVyaW5nTm9kZSIsInByZXZpb3VzTGVuZ3RoIiwiZW50ZXJlZCIsImlzTm9kZUVudGVyZWQiLCJpc05vZGVJbkRvY3VtZW50IiwiY29udGFpbnMiLCJsZWF2ZSIsImxlYXZpbmdOb2RlIiwicmVzZXQiLCJOYXRpdmVEcmFnU291cmNlIiwiaW5pdGlhbGl6ZUV4cG9zZWRQcm9wZXJ0aWVzIiwiY29uZmlnIiwiZXhwb3NlUHJvcGVydGllcyIsInByb3BlcnR5Iiwid2FybiIsImxvYWREYXRhVHJhbnNmZXIiLCJkYXRhVHJhbnNmZXIiLCJuZXdQcm9wZXJ0aWVzIiwicHJvcGVydHlGbiIsIm1hdGNoZXNUeXBlcyIsImRlZmluZVByb3BlcnRpZXMiLCJoYW5kbGUiLCJGSUxFIiwiVVJMIiwiVEVYVCIsIkhUTUwiLCJOYXRpdmVUeXBlcyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImdldERhdGFGcm9tRGF0YVRyYW5zZmVyIiwidHlwZXNUb1RyeSIsInJlc3VsdFNvRmFyIiwidHlwZVRvVHJ5IiwiZ2V0RGF0YSIsIm5hdGl2ZVR5cGVzQ29uZmlnIiwiZmlsZXMiLCJodG1sIiwidXJscyIsInRleHQiLCJjcmVhdGVOYXRpdmVEcmFnU291cmNlIiwibWF0Y2hOYXRpdmVJdGVtVHlwZSIsImRhdGFUcmFuc2ZlclR5cGVzIiwibmF0aXZlSXRlbVR5cGUiLCJ0eXBlQ29uZmlnIiwiaXNGaXJlZm94IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzU2FmYXJpIiwic2FmYXJpIiwiTW9ub3RvbmljSW50ZXJwb2xhbnQiLCJpbnRlcnBvbGF0ZSIsInhzIiwieXMiLCJjMXMiLCJjMnMiLCJjM3MiLCJsb3ciLCJoaWdoIiwibWlkIiwiZmxvb3IiLCJ4SGVyZSIsIm1heCIsImRpZmYiLCJkaWZmU3EiLCJpbmRleGVzIiwic29ydCIsImR4cyIsIm1zIiwiZHgiLCJkeSIsImkxIiwiaTIiLCJtMiIsIm1OZXh0IiwiZHhOZXh0IiwiY29tbW9uIiwibSIsImkzIiwiaW52RHgiLCJFTEVNRU5UX05PREUkMSIsImdldE5vZGVDbGllbnRPZmZzZXQkMSIsImVsIiwibm9kZVR5cGUiLCJwYXJlbnRFbGVtZW50IiwidG9wIiwibGVmdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldEV2ZW50Q2xpZW50T2Zmc2V0JDEiLCJjbGllbnRYIiwiY2xpZW50WSIsImlzSW1hZ2VOb2RlIiwibm9kZU5hbWUiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXREcmFnUHJldmlld1NpemUiLCJpc0ltYWdlIiwic291cmNlV2lkdGgiLCJzb3VyY2VIZWlnaHQiLCJkcmFnUHJldmlld1dpZHRoIiwiZHJhZ1ByZXZpZXdIZWlnaHQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiZ2V0RHJhZ1ByZXZpZXdPZmZzZXQiLCJzb3VyY2VOb2RlIiwiYW5jaG9yUG9pbnQiLCJvZmZzZXRQb2ludCIsImRyYWdQcmV2aWV3Tm9kZU9mZnNldEZyb21DbGllbnQiLCJvZmZzZXRGcm9tRHJhZ1ByZXZpZXciLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImFuY2hvclgiLCJhbmNob3JZIiwiY2FsY3VsYXRlWU9mZnNldCIsImludGVycG9sYW50WSIsImNhbGN1bGF0ZVhPZmZzZXQiLCJpbnRlcnBvbGFudFgiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImlzTWFudWFsT2Zmc2V0WCIsImlzTWFudWFsT2Zmc2V0WSIsIk9wdGlvbnNSZWFkZXIkMSIsIk9wdGlvbnNSZWFkZXIiLCJyb290RWxlbWVudCIsIm9wdGlvbnNBcmdzIiwib3duZXJEb2N1bWVudCIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9vYmplY3RTcHJlYWQiLCJIVE1MNUJhY2tlbmRJbXBsIiwicHJvZmlsZSIsInJlZjEiLCJzb3VyY2VQcmV2aWV3Tm9kZXMiLCJzaXplIiwic291cmNlUHJldmlld05vZGVPcHRpb25zIiwic291cmNlTm9kZU9wdGlvbnMiLCJzb3VyY2VOb2RlcyIsImRyYWdTdGFydFNvdXJjZUlkcyIsImRyb3BUYXJnZXRJZHMiLCJkcmFnRW50ZXJUYXJnZXRJZHMiLCJkcmFnT3ZlclRhcmdldElkcyIsInJvb3QiLCJfX2lzUmVhY3REbmRCYWNrZW5kU2V0VXAiLCJhZGRFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwiY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUiLCJhc3luY0VuZERyYWdGcmFtZUlkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVEcmFnU3RhcnQiLCJoYW5kbGVTZWxlY3RTdGFydCIsInNldEF0dHJpYnV0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlRHJhZ0VudGVyIiwiaGFuZGxlRHJhZ092ZXIiLCJoYW5kbGVEcm9wIiwiaGFuZGxlVG9wRHJhZ1N0YXJ0IiwiaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSIsImhhbmRsZVRvcERyYWdFbmRDYXB0dXJlIiwiaGFuZGxlVG9wRHJhZ0VudGVyIiwiaGFuZGxlVG9wRHJhZ0VudGVyQ2FwdHVyZSIsImhhbmRsZVRvcERyYWdMZWF2ZUNhcHR1cmUiLCJoYW5kbGVUb3BEcmFnT3ZlciIsImhhbmRsZVRvcERyYWdPdmVyQ2FwdHVyZSIsImhhbmRsZVRvcERyb3AiLCJoYW5kbGVUb3BEcm9wQ2FwdHVyZSIsImdldEN1cnJlbnRTb3VyY2VOb2RlT3B0aW9ucyIsImRyb3BFZmZlY3QiLCJhbHRLZXlQcmVzc2VkIiwiZ2V0Q3VycmVudERyb3BFZmZlY3QiLCJpc0RyYWdnaW5nTmF0aXZlSXRlbSIsImdldEN1cnJlbnRTb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMiLCJjYXB0dXJlRHJhZ2dpbmdTdGF0ZSIsImJlZ2luRHJhZ05hdGl2ZUl0ZW0iLCJjdXJyZW50TmF0aXZlU291cmNlIiwiY3VycmVudE5hdGl2ZUhhbmRsZSIsInNldEN1cnJlbnREcmFnU291cmNlTm9kZSIsImN1cnJlbnREcmFnU291cmNlTm9kZSIsIk1PVVNFX01PVkVfVElNRU9VVCIsIm1vdXNlTW92ZVRpbWVvdXRUaW1lciIsImVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NIiwiZGVmYXVsdFByZXZlbnRlZCIsInVuc2hpZnQiLCJfZSIsImxhc3RDbGllbnRPZmZzZXQiLCJob3ZlclJhZklkIiwiZW5kRHJhZ05hdGl2ZUl0ZW0iLCJib2R5IiwiY2FuY2VsSG92ZXIiLCJzY2hlZHVsZUhvdmVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmF0aXZlVHlwZSIsInNldERyYWdJbWFnZSIsImRyYWdQcmV2aWV3T2Zmc2V0Iiwic2V0RGF0YSIsImhhc0F0dHJpYnV0ZSIsInByZXZlbnREZWZhdWx0IiwiaXNGaXJzdEVudGVyIiwiZW50ZXJMZWF2ZUNvdW50ZXIiLCJhbHRLZXkiLCJpc0xhc3RMZWF2ZSIsImRyYWdEcm9wIiwidGFnTmFtZSIsImlzQ29udGVudEVkaXRhYmxlIiwiZW1wdHlJbWFnZSIsImdldEVtcHR5SW1hZ2UiLCJJbWFnZSIsInNyYyIsIkhUTUw1QmFja2VuZCIsImNyZWF0ZUJhY2tlbmQiLCJQaWVjZSIsImlzUHJlbW92ZWRQaWVjZSIsInNxdWFyZXMiLCJwaWVjZVN0eWxlIiwic2V0UGllY2VTdHlsZSIsInRvdWNoQWN0aW9uIiwiY3Vyc29yIiwiZHJhZyIsIndhc0Ryb3BPdXRzaWRlVGhlQm9hcmQiLCJvbGRQaWVjZVN0eWxlIiwicmVtb3ZlZFBpZWNlIiwibmV3U3F1YXJlIiwiZmluZCIsIk51bWJlciIsInRyYW5zaXRpb24iLCJnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcyIsIm9uQ2xpY2siLCJ2aWV3Qm94IiwiZGlzcGxheSIsIlNxdWFyZSIsInNxdWFyZUNvbG9yIiwic2V0U3F1YXJlcyIsInNxdWFyZUhhc1ByZW1vdmUiLCJzcXVhcmVSZWYiLCJDdXN0b21TcXVhcmUiLCJpc1NwYXJlIiwib2xkU3F1YXJlcyIsImRlZmF1bHRTcXVhcmVTdHlsZSIsImJvcmRlclJhZGl1cyIsIm9uVG91Y2hNb3ZlIiwidG91Y2hMb2NhdGlvbiIsInRvdWNoZXMiLCJ0b3VjaEVsZW1lbnQiLCJlbGVtZW50c0Zyb21Qb2ludCIsImRyYWdnZWRPdmVyU3F1YXJlIiwiZ2V0QXR0cmlidXRlIiwib25Nb3VzZU92ZXIiLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJvbk1vdXNlT3V0Iiwib25Nb3VzZURvd24iLCJidXR0b24iLCJvbk1vdXNlVXAiLCJvbkRyYWdFbnRlciIsIm9uQ29udGV4dE1lbnUiLCJjZW50ZXIiLCJqdXN0aWZ5Q29udGVudCIsImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsIlNxdWFyZXMiLCJwcmVtb3Zlc0hpc3RvcnkiLCJyZWxhdGVkUHJlbW92ZWRQaWVjZSIsInByZW1vdmVzUm91dGUiLCJhdCIsIl8iLCJmbGV4V3JhcCIsInNxdWFyZUhhc1ByZW1vdmVUYXJnZXQiLCJBcnJvd3MiLCJwcmltYXJ5QXJyb3dDb2xsb3IiLCJhcnJvd3NMaXN0IiwicG9pbnRlckV2ZW50cyIsImFycm93U3RhcnRGaWVsZCIsImFycm93RW5kRmllbGQiLCJhcnJvd0NvbG9yIiwiZnJvbSIsInRvIiwiQVJST1dfTEVOR1RIX1JFRFVDRVIiLCJpc0Fycm93QWN0aXZlIiwicmVzdEFycm93IiwiaHlwb3QiLCJtYXJrZXJXaWR0aCIsIm1hcmtlckhlaWdodCIsInJlZlgiLCJyZWZZIiwib3JpZW50IiwicG9pbnRzIiwieDEiLCJ5MSIsIngyIiwieTIiLCJtYXJrZXJFbmQiLCJQcm9tb3Rpb25PcHRpb24iLCJvcHRpb24iLCJpc0hvdmVyIiwic2V0SXNIb3ZlciIsIlByb21vdGlvbkRpYWxvZyIsInByb21vdGVQaWVjZUNvbG9yIiwicHJvbW90aW9uT3B0aW9ucyIsImRpYWxvZ1N0eWxlcyIsImRlZmF1bHQiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwidmVydGljYWwiLCJtb2RhbCIsImFsaWduSXRlbXMiLCJkaWFsb2dDb29yZHMiLCJ0aXRsZSIsImVycm9ySW1hZ2UiLCJ3aGl0ZUtpbmciLCJzaGFwZVJlbmRlcmluZyIsInRleHRSZW5kZXJpbmciLCJpbWFnZVJlbmRlcmluZyIsImNsaXBSdWxlIiwiRXJyb3JCb3VuZGFyeSIsImxvZyIsIldoaXRlS2luZyIsInNob3dFcnJvciIsImZsZXhEaXJlY3Rpb24iLCJCb2FyZCIsImJvYXJkUmVmIiwiaGFuZGxlQ2xpY2tPdXRzaWRlIiwiZXZlbnQiLCJwZXJzcGVjdGl2ZSIsImJvYXJkU3R5bGVzIiwiTGlzdGVuZXJUeXBlIiwiZGVsYXkiLCJfZGVsYXkiLCJzY3JvbGxBbmdsZVJhbmdlcyIsImdldERyb3BUYXJnZXRFbGVtZW50c0F0UG9pbnQiLCJpZ25vcmVDb250ZXh0TWVudSIsIl9pZ25vcmVDb250ZXh0TWVudSIsImVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCIsIl9lbmFibGVIb3Zlck91dHNpZGVUYXJnZXQiLCJlbmFibGVLZXlib2FyZEV2ZW50cyIsIl9lbmFibGVLZXlib2FyZEV2ZW50cyIsImVuYWJsZU1vdXNlRXZlbnRzIiwiX2VuYWJsZU1vdXNlRXZlbnRzIiwiZW5hYmxlVG91Y2hFdmVudHMiLCJfZW5hYmxlVG91Y2hFdmVudHMiLCJ0b3VjaFNsb3AiLCJkZWxheVRvdWNoU3RhcnQiLCJyZWYyIiwicmVmMyIsImRlbGF5TW91c2VTdGFydCIsInJlZjQiLCJyZWY1IiwicmVmNiIsImRpc3RhbmNlIiwic3FydCIsInBvdyIsImluQW5nbGVSYW5nZXMiLCJhbmdsZVJhbmdlcyIsImFuZ2xlIiwiYXRhbjIiLCJQSSIsImFyIiwic3RhcnQiLCJNb3VzZUJ1dHRvbnMiLCJMZWZ0IiwiUmlnaHQiLCJDZW50ZXIiLCJNb3VzZUJ1dHRvbiIsImV2ZW50U2hvdWxkU3RhcnREcmFnIiwiZXZlbnRTaG91bGRFbmREcmFnIiwiaXNUb3VjaEV2ZW50IiwidGFyZ2V0VG91Y2hlcyIsIkVMRU1FTlRfTk9ERSIsImdldE5vZGVDbGllbnRPZmZzZXQiLCJnZXRFdmVudENsaWVudFRvdWNoT2Zmc2V0IiwibGFzdFRhcmdldFRvdWNoRmFsbGJhY2siLCJnZXRFdmVudENsaWVudE9mZnNldCIsInN1cHBvcnRzUGFzc2l2ZSIsInN1cHBvcnRlZCIsImV2ZW50TmFtZXMiLCJtb3VzZSIsIm1vdmUiLCJjb250ZXh0bWVudSIsInRvdWNoIiwia2V5Ym9hcmQiLCJrZXlkb3duIiwiVG91Y2hCYWNrZW5kSW1wbCIsInRhcmdldE5vZGVzIiwiZ2V0VG9wTW92ZVN0YXJ0SGFuZGxlciIsImhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUiLCJoYW5kbGVUb3BNb3ZlIiwiaGFuZGxlVG9wTW92ZUNhcHR1cmUiLCJoYW5kbGVUb3BNb3ZlRW5kQ2FwdHVyZSIsImhhbmRsZUNhbmNlbE9uRXNjYXBlIiwiX21vdXNlQ2xpZW50T2Zmc2V0IiwiaGFuZGxlVG9wTW92ZVN0YXJ0IiwidW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciIsInN1YmplY3QiLCJjYXB0dXJlIiwicGFzc2l2ZSIsImxpc3RlbmVyVHlwZXMiLCJsaXN0ZW5lclR5cGUiLCJldnQiLCJoYW5kbGVNb3ZlU3RhcnQiLCJoYW5kbGVNb3ZlIiwiY29vcmRzIiwiZHJvcHBlZE9uIiwiZWxlbWVudEZyb21Qb2ludCIsImNoaWxkTWF0Y2giLCJoYW5kbGVUb3BNb3ZlU3RhcnREZWxheSIsImluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyIiwiZHJhZ2dlZFNvdXJjZU5vZGUiLCJkcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciIsInJlc3VycmVjdFNvdXJjZU5vZGUiLCJjaGlsZExpc3QiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsImRpc2Nvbm5lY3QiLCJtb3ZlU3RhcnRTb3VyY2VJZHMiLCJ3YWl0aW5nRm9yRGVsYXkiLCJ0aW1lb3V0IiwiX2V2dCIsIl9pc1Njcm9sbGluZyIsImNhbmNlbGFibGUiLCJkcmFnT3ZlclRhcmdldE5vZGVzIiwiZWxlbWVudHNBdFBvaW50IiwiZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQiLCJub2RlSWQiLCJjdXJyZW50Tm9kZSIsIm9yZGVyZWREcmFnT3ZlclRhcmdldElkcyIsIl9nZXREcm9wVGFyZ2V0SWQiLCJpZHMiLCJ0YXJnZXROb2RlIiwiVG91Y2hCYWNrZW5kIiwiQ2hlc3Nib2FyZERuRENvbnRleHQiLCJpc0N1c3RvbURuZFByb3ZpZGVyU2V0IiwiRW1wdHlQcm92aWRlciIsIkNoZXNzYm9hcmREbkRQcm92aWRlciIsIkNoZXNzYm9hcmREbkRSb290IiwiY3VzdG9tRG5kQmFja2VuZCIsImN1c3RvbURuZEJhY2tlbmRPcHRpb25zIiwiY2xpZW50V2luZG93Iiwic2V0Q2xpZW50V2luZG93IiwiYmFja2VuZFNldCIsInNldEJhY2tlbmRTZXQiLCJpc01vYmlsZSIsInNldElzTW9iaWxlIiwiRG5EV3JhcHBlciIsIkN1c3RvbURyYWdMYXllciIsImJvYXJkQ29udGFpbmVyIiwiY29sbGVjdGVkUHJvcHMiLCJnZXRJdGVtU3R5bGUiLCJoYWxmU3F1YXJlV2lkdGgiLCJtYXhMZWZ0IiwibWF4VG9wIiwibWF4UmlnaHQiLCJtYXhCb3R0b20iLCJtaW4iLCJXZWJraXRUcmFuc2Zvcm0iLCJTcGFyZVBpZWNlIiwiY3VzdG9tUGllY2VKU1giLCJkbmRJZCIsInJlbmRlclBpZWNlIiwiQ2hlc3Nib2FyZCIsIm9uQm9hcmRXaWR0aENoYW5nZSIsIm90aGVyUHJvcHMiLCJzZXRCb2FyZFdpZHRoIiwiYm9hcmRDb250YWluZXJSZWYiLCJib2FyZENvbnRhaW5lclBvcyIsInNldEJvYXJkQ29udGFpbmVyUG9zIiwibWV0cmljcyIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-chessboard/dist/index.esm.js\n");

/***/ })

};
;