"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chess.js";
exports.ids = ["vendor-chunks/chess.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: () => (/* binding */ BISHOP),\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   DEFAULT_POSITION: () => (/* binding */ DEFAULT_POSITION),\n/* harmony export */   KING: () => (/* binding */ KING),\n/* harmony export */   KNIGHT: () => (/* binding */ KNIGHT),\n/* harmony export */   Move: () => (/* binding */ Move),\n/* harmony export */   PAWN: () => (/* binding */ PAWN),\n/* harmony export */   QUEEN: () => (/* binding */ QUEEN),\n/* harmony export */   ROOK: () => (/* binding */ ROOK),\n/* harmony export */   SQUARES: () => (/* binding */ SQUARES),\n/* harmony export */   WHITE: () => (/* binding */ WHITE),\n/* harmony export */   validateFen: () => (/* binding */ validateFen)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ const WHITE = \"w\";\nconst BLACK = \"b\";\nconst PAWN = \"p\";\nconst KNIGHT = \"n\";\nconst BISHOP = \"b\";\nconst ROOK = \"r\";\nconst QUEEN = \"q\";\nconst KING = \"k\";\nconst DEFAULT_POSITION = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\nclass Move {\n    constructor(chess, internal){\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */ this.san = chess[\"_moveToSan\"](internal, chess[\"_moves\"]({\n            legal: true\n        }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess[\"_makeMove\"](internal);\n        this.after = chess.fen();\n        chess[\"_undoMove\"]();\n        // Build the text representation of the move flags\n        this.flags = \"\";\n        for(const flag in BITS){\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS[\"CAPTURE\"]) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS[\"PROMOTION\"]) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS[\"EP_CAPTURE\"]) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS[\"KSIDE_CASTLE\"]) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS[\"QSIDE_CASTLE\"]) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS[\"BIG_PAWN\"]) > -1;\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: \"n\",\n    CAPTURE: \"c\",\n    BIG_PAWN: \"b\",\n    EP_CAPTURE: \"e\",\n    PROMOTION: \"p\",\n    KSIDE_CASTLE: \"k\",\n    QSIDE_CASTLE: \"q\"\n};\n// prettier-ignore\nconst SQUARES = [\n    \"a8\",\n    \"b8\",\n    \"c8\",\n    \"d8\",\n    \"e8\",\n    \"f8\",\n    \"g8\",\n    \"h8\",\n    \"a7\",\n    \"b7\",\n    \"c7\",\n    \"d7\",\n    \"e7\",\n    \"f7\",\n    \"g7\",\n    \"h7\",\n    \"a6\",\n    \"b6\",\n    \"c6\",\n    \"d6\",\n    \"e6\",\n    \"f6\",\n    \"g6\",\n    \"h6\",\n    \"a5\",\n    \"b5\",\n    \"c5\",\n    \"d5\",\n    \"e5\",\n    \"f5\",\n    \"g5\",\n    \"h5\",\n    \"a4\",\n    \"b4\",\n    \"c4\",\n    \"d4\",\n    \"e4\",\n    \"f4\",\n    \"g4\",\n    \"h4\",\n    \"a3\",\n    \"b3\",\n    \"c3\",\n    \"d3\",\n    \"e3\",\n    \"f3\",\n    \"g3\",\n    \"h3\",\n    \"a2\",\n    \"b2\",\n    \"c2\",\n    \"d2\",\n    \"e2\",\n    \"f2\",\n    \"g2\",\n    \"h2\",\n    \"a1\",\n    \"b1\",\n    \"c1\",\n    \"d1\",\n    \"e1\",\n    \"f1\",\n    \"g1\",\n    \"h1\"\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */ // prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0,\n    b8: 1,\n    c8: 2,\n    d8: 3,\n    e8: 4,\n    f8: 5,\n    g8: 6,\n    h8: 7,\n    a7: 16,\n    b7: 17,\n    c7: 18,\n    d7: 19,\n    e7: 20,\n    f7: 21,\n    g7: 22,\n    h7: 23,\n    a6: 32,\n    b6: 33,\n    c6: 34,\n    d6: 35,\n    e6: 36,\n    f6: 37,\n    g6: 38,\n    h6: 39,\n    a5: 48,\n    b5: 49,\n    c5: 50,\n    d5: 51,\n    e5: 52,\n    f5: 53,\n    g5: 54,\n    h5: 55,\n    a4: 64,\n    b4: 65,\n    c4: 66,\n    d4: 67,\n    e4: 68,\n    f4: 69,\n    g4: 70,\n    h4: 71,\n    a3: 80,\n    b3: 81,\n    c3: 82,\n    d3: 83,\n    e3: 84,\n    f3: 85,\n    g3: 86,\n    h3: 87,\n    a2: 96,\n    b2: 97,\n    c2: 98,\n    d2: 99,\n    e2: 100,\n    f2: 101,\n    g2: 102,\n    h2: 103,\n    a1: 112,\n    b1: 113,\n    c1: 114,\n    d1: 115,\n    e1: 116,\n    f1: 117,\n    g1: 118,\n    h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [\n        16,\n        32,\n        17,\n        15\n    ],\n    w: [\n        -16,\n        -32,\n        -17,\n        -15\n    ]\n};\nconst PIECE_OFFSETS = {\n    n: [\n        -18,\n        -33,\n        -31,\n        -14,\n        18,\n        33,\n        31,\n        14\n    ],\n    b: [\n        -17,\n        -15,\n        17,\n        15\n    ],\n    r: [\n        -16,\n        1,\n        16,\n        -1\n    ],\n    q: [\n        -17,\n        -16,\n        -15,\n        1,\n        17,\n        16,\n        15,\n        -1\n    ],\n    k: [\n        -17,\n        -16,\n        -15,\n        1,\n        17,\n        16,\n        15,\n        -1\n    ]\n};\n// prettier-ignore\nconst ATTACKS = [\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    24,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    2,\n    24,\n    2,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    53,\n    56,\n    53,\n    2,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    56,\n    0,\n    56,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    53,\n    56,\n    53,\n    2,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    2,\n    24,\n    2,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    24,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20\n];\n// prettier-ignore\nconst RAYS = [\n    17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    16,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    16,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    16,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    -16,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    -16,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -17\n];\nconst PIECE_MASKS = {\n    p: 0x1,\n    n: 0x2,\n    b: 0x4,\n    r: 0x8,\n    q: 0x10,\n    k: 0x20\n};\nconst SYMBOLS = \"pnbrqkPNBRQK\";\nconst PROMOTIONS = [\n    KNIGHT,\n    BISHOP,\n    ROOK,\n    QUEEN\n];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */ const RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE\n};\nconst ROOKS = {\n    w: [\n        {\n            square: Ox88.a1,\n            flag: BITS.QSIDE_CASTLE\n        },\n        {\n            square: Ox88.h1,\n            flag: BITS.KSIDE_CASTLE\n        }\n    ],\n    b: [\n        {\n            square: Ox88.a8,\n            flag: BITS.QSIDE_CASTLE\n        },\n        {\n            square: Ox88.h8,\n            flag: BITS.KSIDE_CASTLE\n        }\n    ]\n};\nconst SECOND_RANK = {\n    b: RANK_7,\n    w: RANK_2\n};\nconst TERMINATION_MARKERS = [\n    \"1-0\",\n    \"0-1\",\n    \"1/2-1/2\",\n    \"*\"\n];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return \"0123456789\".indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return \"abcdefgh\".substring(f, f + 1) + \"87654321\".substring(r, r + 1);\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: must contain six space-delimited fields\"\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: move number must be a positive integer\"\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: half move counter number must be a non-negative integer\"\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: en-passant square is invalid\"\n        };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: castling availability is invalid\"\n        };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: side-to-move is invalid\"\n        };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split(\"/\");\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n        };\n    }\n    // 8th criterion: every row is valid?\n    for(let i = 0; i < rows.length; i++){\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for(let k = 0; k < rows[i].length; k++){\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: \"Invalid FEN: piece data is invalid (consecutive number)\"\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            } else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: \"Invalid FEN: piece data is invalid (invalid piece)\"\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: \"Invalid FEN: piece data is invalid (too many squares in rank)\"\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if (tokens[3][1] == \"3\" && tokens[1] == \"w\" || tokens[3][1] == \"6\" && tokens[1] == \"b\") {\n        return {\n            ok: false,\n            error: \"Invalid FEN: illegal en-passant square\"\n        };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        {\n            color: \"white\",\n            regex: /K/g\n        },\n        {\n            color: \"black\",\n            regex: /k/g\n        }\n    ];\n    for (const { color, regex } of kings){\n        if (!regex.test(tokens[0])) {\n            return {\n                ok: false,\n                error: `Invalid FEN: missing ${color} king`\n            };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return {\n                ok: false,\n                error: `Invalid FEN: too many ${color} kings`\n            };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char)=>char.toUpperCase() === \"P\")) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: some pawns are on the edge rows\"\n        };\n    }\n    return {\n        ok: true\n    };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for(let i = 0, len = moves.length; i < len; i++){\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */ if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */ return algebraic(from);\n        } else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */ return algebraic(from).charAt(1);\n        } else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return \"\";\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for(let i = 0; i < PROMOTIONS.length; i++){\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION\n            });\n        }\n    } else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= \"a\" && pieceType <= \"h\") {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === \"o\") {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, \"\").replace(/[+#]?[?!]*$/, \"\");\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */ return fen.split(\" \").slice(0, 4).join(\" \");\n}\nclass Chess {\n    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}){\n        this._board = new Array(128);\n        this._turn = WHITE;\n        this._header = {};\n        this._kings = {\n            w: EMPTY,\n            b: EMPTY\n        };\n        this._epSquare = -1;\n        this._halfMoves = 0;\n        this._moveNumber = 0;\n        this._history = [];\n        this._comments = {};\n        this._castling = {\n            w: 0,\n            b: 0\n        };\n        // tracks number of times a position has been seen for repetition checking\n        this._positionCount = {};\n        this.load(fen, {\n            skipValidation\n        });\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = {\n            w: EMPTY,\n            b: EMPTY\n        };\n        this._turn = WHITE;\n        this._castling = {\n            w: 0,\n            b: 0\n        };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */ delete this._header[\"SetUp\"];\n        delete this._header[\"FEN\"];\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = [\n                \"-\",\n                \"-\",\n                \"0\",\n                \"1\"\n            ];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(\" \");\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({\n            preserveHeaders\n        });\n        for(let i = 0; i < position.length; i++){\n            const piece = position.charAt(i);\n            if (piece === \"/\") {\n                square += 8;\n            } else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            } else {\n                const color = piece < \"a\" ? WHITE : BLACK;\n                this._put({\n                    type: piece.toLowerCase(),\n                    color\n                }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf(\"K\") > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf(\"Q\") > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf(\"k\") > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf(\"q\") > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === \"-\" ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = \"\";\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            } else {\n                empty++;\n            }\n            if (i + 1 & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += \"/\";\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = \"\";\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += \"K\";\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += \"Q\";\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += \"k\";\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += \"q\";\n        }\n        // do we have an empty castling flag?\n        castling = castling || \"-\";\n        let epSquare = \"-\";\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */ if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [\n                bigPawnSquare + 1,\n                bigPawnSquare - 1\n            ];\n            for (const square of squares){\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color && this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber\n        ].join(\" \");\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */ _updateSetup(fen) {\n        if (this._history.length > 0) return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header[\"SetUp\"] = \"1\";\n            this._header[\"FEN\"] = fen;\n        } else {\n            delete this._header[\"SetUp\"];\n            delete this._header[\"FEN\"];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    put({ type, color }, square) {\n        if (this._put({\n            type,\n            color\n        }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = {\n            type: type,\n            color: color\n        };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING && this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING && this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace || this._board[Ox88.a1]?.type !== ROOK || this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace || this._board[Ox88.h1]?.type !== ROOK || this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace || this._board[Ox88.a8]?.type !== ROOK || this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace || this._board[Ox88.h8]?.type !== ROOK || this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [\n            currentSquare + 1,\n            currentSquare - 1\n        ];\n        if (this._board[startSquare] !== null || this._board[this._epSquare] !== null || this._board[currentSquare]?.color !== swapColor(this._turn) || this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square)=>!(square & 0x88) && this._board[square]?.color === this._turn && this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0 && piece.color === WHITE || difference <= 0 && piece.color === BLACK) {\n                        if (!verbose) {\n                            return true;\n                        } else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === \"n\" || piece.type === \"k\") {\n                    if (!verbose) {\n                        return true;\n                    } else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while(j !== square){\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    } else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        } else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        } else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */ const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        } else if (// k vs. kn .... or .... k vs. kb\n        numPieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        } else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for(let i = 0; i < len; i++){\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return this.isDrawByFiftyMoves() || this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined } = {}) {\n        const moves = this._moves({\n            square,\n            piece\n        });\n        if (verbose) {\n            return moves.map((move)=>new Move(this, move));\n        } else {\n            return moves.map((move)=>this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            } else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for(let from = firstSquare; from <= lastSquare; from++){\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type) continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for(let j = 2; j < 4; j++){\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88) continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    } else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            } else {\n                if (forPiece && forPiece !== type) continue;\n                for(let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++){\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while(true){\n                        to += offset;\n                        if (to & 0x88) break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        } else {\n                            // own color, stop loop\n                            if (this._board[to].color === us) break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */ if (type === KNIGHT || type === KING) break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */ if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */ if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for(let i = 0, len = moves.length; i < len; i++){\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */ let moveObj = null;\n        if (typeof move === \"string\") {\n            moveObj = this._moveFromSan(move, strict);\n        } else if (typeof move === \"object\") {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for(let i = 0, len = moves.length; i < len; i++){\n                if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!(\"promotion\" in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === \"string\") {\n                throw new Error(`Invalid move: ${move}`);\n            } else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */ const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: {\n                b: this._kings.b,\n                w: this._kings.w\n            },\n            turn: this._turn,\n            castling: {\n                b: this._castling.b,\n                w: this._castling.w\n            },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            } else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = {\n                type: move.promotion,\n                color: us\n            };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            } else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for(let i = 0, len = ROOKS[us].length; i < len; i++){\n                if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for(let i = 0, len = ROOKS[them].length; i < len; i++){\n                if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            } else {\n                this._epSquare = move.to + 16;\n            }\n        } else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        } else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                } else {\n                    index = move.to + 16;\n                }\n                this._board[index] = {\n                    type: PAWN,\n                    color: them\n                };\n            } else {\n                // regular capture\n                this._board[move.to] = {\n                    type: move.captured,\n                    color: them\n                };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            } else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = \"\\n\", maxWidth = 0 } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */ const result = [];\n        let headerExists = false;\n        /* add the PGN header information */ for(const i in this._header){\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */ result.push(\"[\" + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString)=>{\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== \"undefined\") {\n                const delimiter = moveString.length > 0 ? \" \" : \"\";\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while(this._history.length > 0){\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = \"\";\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(\"\"));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while(reversedHistory.length > 0){\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === \"b\") {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            } else if (move.color === \"w\") {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + \".\";\n            }\n            moveString = moveString + \" \" + this._moveToSan(move, this._moves({\n                legal: true\n            }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== \"undefined\") {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */ if (maxWidth === 0) {\n            return result.join(\"\") + moves.join(\" \");\n        }\n        // TODO (jah): huh?\n        const strip = function() {\n            if (result.length > 0 && result[result.length - 1] === \" \") {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function(width, move) {\n            for (const token of move.split(\" \")){\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while(strip()){\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(\" \");\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for(let i = 0; i < moves.length; i++){\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes(\"{\")) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === \" \") {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            } else if (i !== 0) {\n                result.push(\" \");\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join(\"\");\n    }\n    /*\n     * @deprecated Use `setHeader` and `getHeaders` instead.\n     */ header(...args) {\n        for(let i = 0; i < args.length; i += 2){\n            if (typeof args[i] === \"string\" && typeof args[i + 1] === \"string\") {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    setHeader(key, value) {\n        this._header[key] = value;\n        return this._header;\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n            return true;\n        }\n        return false;\n    }\n    getHeaders() {\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = \"\\r?\\n\" } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, \"\\\\\");\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = \"\";\n            let value = \"\";\n            for(let i = 0; i < headers.length; i++){\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, \"$1\");\n                value = headers[i].replace(regex, \"$2\");\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */ const headerRegex = new RegExp(\"^(\\\\[((?:\" + mask(newlineChar) + \")|.)*\\\\])\" + \"((?:\\\\s*\" + mask(newlineChar) + \"){2}|(?:\\\\s*\" + mask(newlineChar) + \")*$)\");\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : \"\" : \"\";\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = \"\";\n        for(const key in headers){\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === \"fen\") {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */ if (!strict) {\n            if (fen) {\n                this.load(fen, {\n                    preserveHeaders: true\n                });\n            }\n        } else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */ if (headers[\"SetUp\"] === \"1\") {\n                if (!(\"FEN\" in headers)) {\n                    throw new Error(\"Invalid PGN: FEN tag must be supplied with SetUp tag\");\n                }\n                // don't clear the headers when loading\n                this.load(headers[\"FEN\"], {\n                    preserveHeaders: true\n                });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */ function toHex(s) {\n            return Array.from(s).map(function(c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */ return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, \"\").toLowerCase();\n            }).join(\"\");\n        }\n        function fromHex(s) {\n            return s.length == 0 ? \"\" : decodeURIComponent(\"%\" + (s.match(/.{1,2}/g) || []).join(\"%\"));\n        }\n        const encodeComment = function(s) {\n            s = s.replace(new RegExp(mask(newlineChar), \"g\"), \" \");\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function(s) {\n            if (s.startsWith(\"{\") && s.endsWith(\"}\")) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn.replace(headerString, \"\").replace(// encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, \"g\"), function(_match, bracket, semicolon) {\n            return bracket !== undefined ? encodeComment(bracket) : \" \" + encodeComment(`{${semicolon.slice(1)}}`);\n        }).replace(new RegExp(mask(newlineChar), \"g\"), \" \");\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while(ravRegex.test(ms)){\n            ms = ms.replace(ravRegex, \"\");\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, \"\");\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, \"\");\n        /* delete numeric annotation glyphs */ ms = ms.replace(/\\$\\d+/g, \"\");\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move)=>move !== \"\");\n        let result = \"\";\n        for(let halfMove = 0; halfMove < moves.length; halfMove++){\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                } else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            } else {\n                // reset the end of game marker if making a valid move\n                result = \"\";\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */ if (result && Object.keys(this._header).length && !this._header[\"Result\"]) {\n            this.header(\"Result\", result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */ _moveToSan(move, moves) {\n        let output = \"\";\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = \"O-O\";\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = \"O-O-O\";\n        } else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += \"x\";\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += \"=\" + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += \"#\";\n            } else {\n                output += \"+\";\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({\n            legal: true,\n            piece: pieceType\n        });\n        // strict parser\n        for(let i = 0, len = moves.length; i < len; i++){\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */ let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        } else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */ matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType\n        });\n        if (!to) {\n            return null;\n        }\n        for(let i = 0, len = moves.length; i < len; i++){\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace(\"x\", \"\")) {\n                    return moves[i];\n                }\n            // hand-compare move properties with the results from our permissive regex\n            } else if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            } else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */ const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = \"   +------------------------+\\n\";\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            // display the rank\n            if (file(i) === 0) {\n                s += \" \" + \"87654321\"[rank(i)] + \" |\";\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += \" \" + symbol + \" \";\n            } else {\n                s += \" . \";\n            }\n            if (i + 1 & 0x88) {\n                s += \"|\\n\";\n                i += 8;\n            }\n        }\n        s += \"   +------------------------+\\n\";\n        s += \"     a  b  c  d  e  f  g  h\";\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({\n            legal: false\n        });\n        let nodes = 0;\n        const color = this._turn;\n        for(let i = 0, len = moves.length; i < len; i++){\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                } else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            if (this._board[i] == null) {\n                row.push(null);\n            } else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color\n                });\n            }\n            if (i + 1 & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? \"light\" : \"dark\";\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while(this._history.length > 0){\n            reversedHistory.push(this._undoMove());\n        }\n        while(true){\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            } else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */ _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        } else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen)=>{\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while(this._history.length > 0){\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while(true){\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace(\"{\", \"[\").replace(\"}\", \"]\");\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */ deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen)=>{\n            return {\n                fen: fen,\n                comment: this._comments[fen]\n            };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */ deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen)=>{\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return {\n                fen: fen,\n                comment: comment\n            };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [\n            KING,\n            QUEEN\n        ]){\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                } else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]);\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n} //# sourceMappingURL=chess.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeUJDLEdBQ00sTUFBTUEsUUFBUSxJQUFJO0FBQ2xCLE1BQU1DLFFBQVEsSUFBSTtBQUNsQixNQUFNQyxPQUFPLElBQUk7QUFDakIsTUFBTUMsU0FBUyxJQUFJO0FBQ25CLE1BQU1DLFNBQVMsSUFBSTtBQUNuQixNQUFNQyxPQUFPLElBQUk7QUFDakIsTUFBTUMsUUFBUSxJQUFJO0FBQ2xCLE1BQU1DLE9BQU8sSUFBSTtBQUNqQixNQUFNQyxtQkFBbUIsMkRBQTJEO0FBQ3BGLE1BQU1DO0lBa0JUQyxZQUFZQyxLQUFLLEVBQUVDLFFBQVEsQ0FBRTtRQUN6QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHUDtRQUMvRCxNQUFNUSxnQkFBZ0JDLFVBQVVOO1FBQ2hDLE1BQU1PLGNBQWNELFVBQVVMO1FBQzlCLElBQUksQ0FBQ0gsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsSUFBSSxHQUFHSztRQUNaLElBQUksQ0FBQ0osRUFBRSxHQUFHTTtRQUNWOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLEdBQUcsR0FBR1osS0FBSyxDQUFDLGFBQWEsQ0FBQ0MsVUFBVUQsS0FBSyxDQUFDLFNBQVMsQ0FBQztZQUFFYSxPQUFPO1FBQUs7UUFDdkUsSUFBSSxDQUFDQyxHQUFHLEdBQUdMLGdCQUFnQkU7UUFDM0IsSUFBSSxDQUFDSSxNQUFNLEdBQUdmLE1BQU1nQixHQUFHO1FBQ3ZCLHVDQUF1QztRQUN2Q2hCLEtBQUssQ0FBQyxZQUFZLENBQUNDO1FBQ25CLElBQUksQ0FBQ2dCLEtBQUssR0FBR2pCLE1BQU1nQixHQUFH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STtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQzVEQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFDNURDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUM1REMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUtDLElBQUk7SUFBS0MsSUFBSTtJQUFLQyxJQUFJO0lBQy9EQyxJQUFJO0lBQUtDLElBQUk7SUFBS0MsSUFBSTtJQUFLQyxJQUFJO0lBQUtDLElBQUk7SUFBS0MsSUFBSTtJQUFLQyxJQUFJO0lBQUtDLElBQUk7QUFDdkU7QUFDQSxNQUFNQyxlQUFlO0lBQ2pCQyxHQUFHO1FBQUM7UUFBSTtRQUFJO1FBQUk7S0FBRztJQUNuQkMsR0FBRztRQUFDLENBQUM7UUFBSSxDQUFDO1FBQUksQ0FBQztRQUFJLENBQUM7S0FBRztBQUMzQjtBQUNBLE1BQU1DLGdCQUFnQjtJQUNsQkMsR0FBRztRQUFDLENBQUM7UUFBSSxDQUFDO1FBQUksQ0FBQztRQUFJLENBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFHO0lBQ3ZDSCxHQUFHO1FBQUMsQ0FBQztRQUFJLENBQUM7UUFBSTtRQUFJO0tBQUc7SUFDckJJLEdBQUc7UUFBQyxDQUFDO1FBQUk7UUFBRztRQUFJLENBQUM7S0FBRTtJQUNuQkMsR0FBRztRQUFDLENBQUM7UUFBSSxDQUFDO1FBQUksQ0FBQztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUksQ0FBQztLQUFFO0lBQ3JDQyxHQUFHO1FBQUMsQ0FBQztRQUFJLENBQUM7UUFBSSxDQUFDO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSSxDQUFDO0tBQUU7QUFDekM7QUFDQSxrQkFBa0I7QUFDbEIsTUFBTUMsVUFBVTtJQUNaO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQ2hEO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQzNEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQ2hEO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUMvQztBQUNELGtCQUFrQjtBQUNsQixNQUFNQyxPQUFPO0lBQ1Q7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFDaEQ7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFDaEQ7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFDaEQ7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFDaEQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDaEQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDaEQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDaEQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBRyxDQUFDO0lBQUcsQ0FBQztJQUFHLENBQUM7SUFBRyxDQUFDO0lBQUcsQ0FBQztJQUFHLENBQUM7SUFBRztJQUNwRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRyxDQUFDO0lBQUksQ0FBQztJQUFJLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNuRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUcsQ0FBQztJQUFJO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNuRDtJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRyxDQUFDO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNuRDtJQUFHO0lBQUc7SUFBRyxDQUFDO0lBQUk7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUNuRDtJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUNuRDtJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRyxDQUFDO0lBQUk7SUFBRztJQUNuRCxDQUFDO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7Q0FDbEQ7QUFDRCxNQUFNQyxjQUFjO0lBQUVDLEdBQUc7SUFBS1AsR0FBRztJQUFLSCxHQUFHO0lBQUtJLEdBQUc7SUFBS0Ms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LEtBQUs7Z0JBQ3pDO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ2hKLHFCQUFxQjtRQUMxQixNQUFNK0QsU0FBUyxJQUFJLENBQUNrRixpQkFBaUIsQ0FBQ3BXO1FBQ3RDLE9BQVEsQ0FBQ2tXLE1BQU0sQ0FBQ3hXLEtBQUssS0FBSzBLLGFBQWE4TCxNQUFNLENBQUN4VyxLQUFLLEtBQUt3UixNQUFNLENBQUN4UixLQUFLLEtBQy9Ed1csQ0FBQUEsTUFBTSxDQUFDelcsTUFBTSxLQUFLMkssYUFBYThMLE1BQU0sQ0FBQ3pXLE1BQU0sS0FBS3lSLE1BQU0sQ0FBQ3pSLE1BQU07SUFDdkU7SUFDQTJXLGtCQUFrQnBXLEtBQUssRUFBRTtRQUNyQixPQUFPO1lBQ0gsQ0FBQ04sS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDZ00sU0FBUyxDQUFDMUwsTUFBTSxHQUFHc0gsS0FBSyxDQUFDNUgsS0FBSyxNQUFNO1lBQ2xELENBQUNELE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQ2lNLFNBQVMsQ0FBQzFMLE1BQU0sR0FBR3NILEtBQUssQ0FBQzdILE1BQU0sTUFBTTtRQUN4RDtJQUNKO0lBQ0ErSSxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUMrQyxXQUFXO0lBQzNCO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGVzc21lbnRvci8uL25vZGVfbW9kdWxlcy9jaGVzcy5qcy9kaXN0L2VzbS9jaGVzcy5qcz8zMmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyNSwgSmVmZiBIbHl3YSAoamhseXdhQGdtYWlsLmNvbSlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5leHBvcnQgY29uc3QgV0hJVEUgPSAndyc7XG5leHBvcnQgY29uc3QgQkxBQ0sgPSAnYic7XG5leHBvcnQgY29uc3QgUEFXTiA9ICdwJztcbmV4cG9ydCBjb25zdCBLTklHSFQgPSAnbic7XG5leHBvcnQgY29uc3QgQklTSE9QID0gJ2InO1xuZXhwb3J0IGNvbnN0IFJPT0sgPSAncic7XG5leHBvcnQgY29uc3QgUVVFRU4gPSAncSc7XG5leHBvcnQgY29uc3QgS0lORyA9ICdrJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPU0lUSU9OID0gJ3JuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIC0gMCAxJztcbmV4cG9ydCBjbGFzcyBNb3ZlIHtcbiAgICBjb2xvcjtcbiAgICBmcm9tO1xuICAgIHRvO1xuICAgIHBpZWNlO1xuICAgIGNhcHR1cmVkO1xuICAgIHByb21vdGlvbjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZpZWxkIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDIuMC4wLlxuICAgICAqIFBsZWFzZSB1c2UgbW92ZSBkZXNjcmlwdG9yIGZ1bmN0aW9ucyBpbnN0ZWFkOiBgaXNDYXB0dXJlYCwgYGlzUHJvbW90aW9uYCxcbiAgICAgKiBgaXNFblBhc3NhbnRgLCBgaXNLaW5nc2lkZUNhc3RsZWAsIGBpc1F1ZWVuc2lkZUNhc3RsZWAsIGBpc0Nhc3RsZWAsIGFuZFxuICAgICAqIGBpc0JpZ1Bhd25gXG4gICAgICovXG4gICAgZmxhZ3M7XG4gICAgc2FuO1xuICAgIGxhbjtcbiAgICBiZWZvcmU7XG4gICAgYWZ0ZXI7XG4gICAgY29uc3RydWN0b3IoY2hlc3MsIGludGVybmFsKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHBpZWNlLCBmcm9tLCB0bywgZmxhZ3MsIGNhcHR1cmVkLCBwcm9tb3Rpb24gfSA9IGludGVybmFsO1xuICAgICAgICBjb25zdCBmcm9tQWxnZWJyYWljID0gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICBjb25zdCB0b0FsZ2VicmFpYyA9IGFsZ2VicmFpYyh0byk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5waWVjZSA9IHBpZWNlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tQWxnZWJyYWljO1xuICAgICAgICB0aGlzLnRvID0gdG9BbGdlYnJhaWM7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEhBQ0s6IFRoZSBjaGVzc1snX21ldGhvZCddKCkgY2FsbHMgYmVsb3cgaW52b2tlIHByaXZhdGUgbWV0aG9kcyBpbiB0aGVcbiAgICAgICAgICogQ2hlc3MgY2xhc3MgdG8gZ2VuZXJhdGUgU0FOIGFuZCBGRU4uIEl0J3MgYSBiaXQgb2YgYSBoYWNrLCBidXQgbWFrZXMgdGhlXG4gICAgICAgICAqIGNvZGUgY2xlYW5lciBlbHNld2hlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNhbiA9IGNoZXNzWydfbW92ZVRvU2FuJ10oaW50ZXJuYWwsIGNoZXNzWydfbW92ZXMnXSh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5sYW4gPSBmcm9tQWxnZWJyYWljICsgdG9BbGdlYnJhaWM7XG4gICAgICAgIHRoaXMuYmVmb3JlID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBGRU4gZm9yIHRoZSAnYWZ0ZXInIGtleVxuICAgICAgICBjaGVzc1snX21ha2VNb3ZlJ10oaW50ZXJuYWwpO1xuICAgICAgICB0aGlzLmFmdGVyID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIGNoZXNzWydfdW5kb01vdmUnXSgpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbW92ZSBmbGFnc1xuICAgICAgICB0aGlzLmZsYWdzID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBCSVRTKSB7XG4gICAgICAgICAgICBpZiAoQklUU1tmbGFnXSAmIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncyArPSBGTEFHU1tmbGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZWQgPSBjYXB0dXJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbW90aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGlvbiA9IHByb21vdGlvbjtcbiAgICAgICAgICAgIHRoaXMubGFuICs9IHByb21vdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NhcHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0NBUFRVUkUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNQcm9tb3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1BST01PVElPTiddKSA+IC0xO1xuICAgIH1cbiAgICBpc0VuUGFzc2FudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snRVBfQ0FQVFVSRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0tpbmdzaWRlQ2FzdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydLU0lERV9DQVNUTEUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNRdWVlbnNpZGVDYXN0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1FTSURFX0NBU1RMRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0JpZ1Bhd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0JJR19QQVdOJ10pID4gLTE7XG4gICAgfVxufVxuY29uc3QgRU1QVFkgPSAtMTtcbmNvbnN0IEZMQUdTID0ge1xuICAgIE5PUk1BTDogJ24nLFxuICAgIENBUFRVUkU6ICdjJyxcbiAgICBCSUdfUEFXTjogJ2InLFxuICAgIEVQX0NBUFRVUkU6ICdlJyxcbiAgICBQUk9NT1RJT046ICdwJyxcbiAgICBLU0lERV9DQVNUTEU6ICdrJyxcbiAgICBRU0lERV9DQVNUTEU6ICdxJyxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBTUVVBUkVTID0gW1xuICAgICdhOCcsICdiOCcsICdjOCcsICdkOCcsICdlOCcsICdmOCcsICdnOCcsICdoOCcsXG4gICAgJ2E3JywgJ2I3JywgJ2M3JywgJ2Q3JywgJ2U3JywgJ2Y3JywgJ2c3JywgJ2g3JyxcbiAgICAnYTYnLCAnYjYnLCAnYzYnLCAnZDYnLCAnZTYnLCAnZjYnLCAnZzYnLCAnaDYnLFxuICAgICdhNScsICdiNScsICdjNScsICdkNScsICdlNScsICdmNScsICdnNScsICdoNScsXG4gICAgJ2E0JywgJ2I0JywgJ2M0JywgJ2Q0JywgJ2U0JywgJ2Y0JywgJ2c0JywgJ2g0JyxcbiAgICAnYTMnLCAnYjMnLCAnYzMnLCAnZDMnLCAnZTMnLCAnZjMnLCAnZzMnLCAnaDMnLFxuICAgICdhMicsICdiMicsICdjMicsICdkMicsICdlMicsICdmMicsICdnMicsICdoMicsXG4gICAgJ2ExJywgJ2IxJywgJ2MxJywgJ2QxJywgJ2UxJywgJ2YxJywgJ2cxJywgJ2gxJ1xuXTtcbmNvbnN0IEJJVFMgPSB7XG4gICAgTk9STUFMOiAxLFxuICAgIENBUFRVUkU6IDIsXG4gICAgQklHX1BBV046IDQsXG4gICAgRVBfQ0FQVFVSRTogOCxcbiAgICBQUk9NT1RJT046IDE2LFxuICAgIEtTSURFX0NBU1RMRTogMzIsXG4gICAgUVNJREVfQ0FTVExFOiA2NCxcbn07XG4vKlxuICogTk9URVMgQUJPVVQgMHg4OCBNT1ZFIEdFTkVSQVRJT04gQUxHT1JJVEhNXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGx5d2EvY2hlc3MuanMvaXNzdWVzLzIzMFxuICpcbiAqIEEgbG90IG9mIHBlb3BsZSBhcmUgY29uZnVzZWQgd2hlbiB0aGV5IGZpcnN0IHNlZSB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAqIG9mIGNoZXNzLmpzLiBJdCB1c2VzIHRoZSAweDg4IE1vdmUgR2VuZXJhdGlvbiBBbGdvcml0aG0gd2hpY2ggaW50ZXJuYWxseVxuICogc3RvcmVzIHRoZSBib2FyZCBhcyBhbiA4eDE2IGFycmF5LiBUaGlzIGlzIHB1cmVseSBmb3IgZWZmaWNpZW5jeSBidXQgaGFzIGFcbiAqIGNvdXBsZSBvZiBpbnRlcmVzdGluZyBiZW5lZml0czpcbiAqXG4gKiAxLiAweDg4IG9mZmVycyBhIHZlcnkgaW5leHBlbnNpdmUgXCJvZmYgdGhlIGJvYXJkXCIgY2hlY2suIEJpdHdpc2UgQU5EICgmKSBhbnlcbiAqICAgIHNxdWFyZSB3aXRoIDB4ODgsIGlmIHRoZSByZXN1bHQgaXMgbm9uLXplcm8gdGhlbiB0aGUgc3F1YXJlIGlzIG9mZiB0aGVcbiAqICAgIGJvYXJkLiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSBrbmlnaHQgc3F1YXJlIEE4ICgwIGluIDB4ODggbm90YXRpb24pLFxuICogICAgdGhlcmUgYXJlIDggcG9zc2libGUgZGlyZWN0aW9ucyBpbiB3aGljaCB0aGUga25pZ2h0IGNhbiBtb3ZlLiBUaGVzZVxuICogICAgZGlyZWN0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhlIDh4MTYgYm9hcmQgYW5kIGFyZSBzdG9yZWQgaW4gdGhlXG4gKiAgICBQSUVDRV9PRkZTRVRTIG1hcC4gT25lIHBvc3NpYmxlIG1vdmUgaXMgQTggLSAxOCAodXAgb25lIHNxdWFyZSwgYW5kIHR3b1xuICogICAgc3F1YXJlcyB0byB0aGUgbGVmdCAtIHdoaWNoIGlzIG9mZiB0aGUgYm9hcmQpLiAwIC0gMTggPSAtMTggJiAweDg4ID0gMHg4OFxuICogICAgKGJlY2F1c2Ugb2YgdHdvLWNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gb2YgLTE4KS4gVGhlIG5vbi16ZXJvIHJlc3VsdFxuICogICAgbWVhbnMgdGhlIHNxdWFyZSBpcyBvZmYgdGhlIGJvYXJkIGFuZCB0aGUgbW92ZSBpcyBpbGxlZ2FsLiBUYWtlIHRoZVxuICogICAgb3Bwb3NpdGUgbW92ZSAoZnJvbSBBOCB0byBDNyksIDAgKyAxOCA9IDE4ICYgMHg4OCA9IDAuIEEgcmVzdWx0IG9mIHplcm9cbiAqICAgIG1lYW5zIHRoZSBzcXVhcmUgaXMgb24gdGhlIGJvYXJkLlxuICpcbiAqIDIuIFRoZSByZWxhdGl2ZSBkaXN0YW5jZSAob3IgZGlmZmVyZW5jZSkgYmV0d2VlbiB0d28gc3F1YXJlcyBvbiBhIDh4MTYgYm9hcmRcbiAqICAgIGlzIHVuaXF1ZSBhbmQgY2FuIGJlIHVzZWQgdG8gaW5leHBlbnNpdmVseSBkZXRlcm1pbmUgaWYgYSBwaWVjZSBvbiBhXG4gKiAgICBzcXVhcmUgY2FuIGF0dGFjayBhbnkgb3RoZXIgYXJiaXRyYXJ5IHNxdWFyZS4gRm9yIGV4YW1wbGUsIGxldCdzIHNlZSBpZiBhXG4gKiAgICBwYXduIG9uIEU3IGNhbiBhdHRhY2sgRTIuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gRTcgKDIwKSAtIEUyICgxMDApIGlzXG4gKiAgICAtODAuIFdlIGFkZCAxMTkgdG8gbWFrZSB0aGUgQVRUQUNLUyBhcnJheSBpbmRleCBub24tbmVnYXRpdmUgKGJlY2F1c2UgdGhlXG4gKiAgICB3b3JzdCBjYXNlIGRpZmZlcmVuY2UgaXMgQTggLSBIMSA9IC0xMTkpLiBUaGUgQVRUQUNLUyBhcnJheSBjb250YWlucyBhXG4gKiAgICBiaXRtYXNrIG9mIHBpZWNlcyB0aGF0IGNhbiBhdHRhY2sgZnJvbSB0aGF0IGRpc3RhbmNlIGFuZCBkaXJlY3Rpb24uXG4gKiAgICBBVFRBQ0tTWy04MCArIDExOT0zOV0gZ2l2ZXMgdXMgMjQgb3IgMGIxMTAwMCBpbiBiaW5hcnkuIExvb2sgYXQgdGhlXG4gKiAgICBQSUVDRV9NQVNLUyBtYXAgdG8gZGV0ZXJtaW5lIHRoZSBtYXNrIGZvciBhIGdpdmVuIHBpZWNlIHR5cGUuIEluIG91ciBwYXduXG4gKiAgICBleGFtcGxlLCB3ZSB3b3VsZCBjaGVjayB0byBzZWUgaWYgMjQgJiAweDEgaXMgbm9uLXplcm8sIHdoaWNoIGl0IGlzXG4gKiAgICBub3QuIFNvLCBuYXR1cmFsbHksIGEgcGF3biBvbiBFNyBjYW4ndCBhdHRhY2sgYSBwaWVjZSBvbiBFMi4gSG93ZXZlciwgYVxuICogICAgcm9vayBjYW4gc2luY2UgMjQgJiAweDggaXMgbm9uLXplcm8uIFRoZSBvbmx5IHRoaW5nIGxlZnQgdG8gY2hlY2sgaXMgdGhhdFxuICogICAgdGhlcmUgYXJlIG5vIGJsb2NraW5nIHBpZWNlcyBiZXR3ZWVuIEU3IGFuZCBFMi4gVGhhdCdzIHdoZXJlIHRoZSBSQVlTXG4gKiAgICBhcnJheSBjb21lcyBpbi4gSXQgcHJvdmlkZXMgYW4gb2Zmc2V0IChpbiB0aGlzIGNhc2UgMTYpIHRvIGFkZCB0byBFNyAoMjApXG4gKiAgICB0byBjaGVjayBmb3IgYmxvY2tpbmcgcGllY2VzLiBFNyAoMjApICsgMTYgPSBFNiAoMzYpICsgMTYgPSBFNSAoNTIpIGV0Yy5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IE94ODggPSB7XG4gICAgYTg6IDAsIGI4OiAxLCBjODogMiwgZDg6IDMsIGU4OiA0LCBmODogNSwgZzg6IDYsIGg4OiA3LFxuICAgIGE3OiAxNiwgYjc6IDE3LCBjNzogMTgsIGQ3OiAxOSwgZTc6IDIwLCBmNzogMjEsIGc3OiAyMiwgaDc6IDIzLFxuICAgIGE2OiAzMiwgYjY6IDMzLCBjNjogMzQsIGQ2OiAzNSwgZTY6IDM2LCBmNjogMzcsIGc2OiAzOCwgaDY6IDM5LFxuICAgIGE1OiA0OCwgYjU6IDQ5LCBjNTogNTAsIGQ1OiA1MSwgZTU6IDUyLCBmNTogNTMsIGc1OiA1NCwgaDU6IDU1LFxuICAgIGE0OiA2NCwgYjQ6IDY1LCBjNDogNjYsIGQ0OiA2NywgZTQ6IDY4LCBmNDogNjksIGc0OiA3MCwgaDQ6IDcxLFxuICAgIGEzOiA4MCwgYjM6IDgxLCBjMzogODIsIGQzOiA4MywgZTM6IDg0LCBmMzogODUsIGczOiA4NiwgaDM6IDg3LFxuICAgIGEyOiA5NiwgYjI6IDk3LCBjMjogOTgsIGQyOiA5OSwgZTI6IDEwMCwgZjI6IDEwMSwgZzI6IDEwMiwgaDI6IDEwMyxcbiAgICBhMTogMTEyLCBiMTogMTEzLCBjMTogMTE0LCBkMTogMTE1LCBlMTogMTE2LCBmMTogMTE3LCBnMTogMTE4LCBoMTogMTE5XG59O1xuY29uc3QgUEFXTl9PRkZTRVRTID0ge1xuICAgIGI6IFsxNiwgMzIsIDE3LCAxNV0sXG4gICAgdzogWy0xNiwgLTMyLCAtMTcsIC0xNV0sXG59O1xuY29uc3QgUElFQ0VfT0ZGU0VUUyA9IHtcbiAgICBuOiBbLTE4LCAtMzMsIC0zMSwgLTE0LCAxOCwgMzMsIDMxLCAxNF0sXG4gICAgYjogWy0xNywgLTE1LCAxNywgMTVdLFxuICAgIHI6IFstMTYsIDEsIDE2LCAtMV0sXG4gICAgcTogWy0xNywgLTE2LCAtMTUsIDEsIDE3LCAxNiwgMTUsIC0xXSxcbiAgICBrOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQVRUQUNLUyA9IFtcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLFxuICAgIDAsIDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsXG4gICAgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAyNCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMjAsIDIsIDI0LCAyLCAyMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDU2LCAwLCA1NiwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDI0LCAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXG4gICAgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCxcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwXG5dO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBSQVlTID0gW1xuICAgIDE3LCAwLCAwLCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsXG4gICAgMCwgMTcsIDAsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAwLCAxNSwgMCwgMCxcbiAgICAwLCAwLCAxNywgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDE1LCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDE3LCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMTUsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMTcsIDAsIDAsIDE2LCAwLCAwLCAxNSwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAxNywgMCwgMTYsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDE3LCAxNiwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgLTE1LCAtMTYsIC0xNywgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAtMTUsIDAsIC0xNiwgMCwgLTE3LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIC0xNSwgMCwgMCwgLTE2LCAwLCAwLCAtMTcsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgLTE1LCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIC0xNywgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAtMTUsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgLTE3LCAwLCAwLCAwLFxuICAgIDAsIC0xNSwgMCwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAwLCAtMTcsIDAsIDAsXG4gICAgLTE1LCAwLCAwLCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIDAsIDAsIC0xN1xuXTtcbmNvbnN0IFBJRUNFX01BU0tTID0geyBwOiAweDEsIG46IDB4MiwgYjogMHg0LCByOiAweDgsIHE6IDB4MTAsIGs6IDB4MjAgfTtcbmNvbnN0IFNZTUJPTFMgPSAncG5icnFrUE5CUlFLJztcbmNvbnN0IFBST01PVElPTlMgPSBbS05JR0hULCBCSVNIT1AsIFJPT0ssIFFVRUVOXTtcbmNvbnN0IFJBTktfMSA9IDc7XG5jb25zdCBSQU5LXzIgPSA2O1xuLypcbiAqIGNvbnN0IFJBTktfMyA9IDVcbiAqIGNvbnN0IFJBTktfNCA9IDRcbiAqIGNvbnN0IFJBTktfNSA9IDNcbiAqIGNvbnN0IFJBTktfNiA9IDJcbiAqL1xuY29uc3QgUkFOS183ID0gMTtcbmNvbnN0IFJBTktfOCA9IDA7XG5jb25zdCBTSURFUyA9IHtcbiAgICBbS0lOR106IEJJVFMuS1NJREVfQ0FTVExFLFxuICAgIFtRVUVFTl06IEJJVFMuUVNJREVfQ0FTVExFLFxufTtcbmNvbnN0IFJPT0tTID0ge1xuICAgIHc6IFtcbiAgICAgICAgeyBzcXVhcmU6IE94ODguYTEsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmgxLCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG4gICAgYjogW1xuICAgICAgICB7IHNxdWFyZTogT3g4OC5hOCwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcbiAgICAgICAgeyBzcXVhcmU6IE94ODguaDgsIGZsYWc6IEJJVFMuS1NJREVfQ0FTVExFIH0sXG4gICAgXSxcbn07XG5jb25zdCBTRUNPTkRfUkFOSyA9IHsgYjogUkFOS183LCB3OiBSQU5LXzIgfTtcbmNvbnN0IFRFUk1JTkFUSU9OX01BUktFUlMgPSBbJzEtMCcsICcwLTEnLCAnMS8yLTEvMicsICcqJ107XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCByYW5rIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gcmFuayhzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlID4+IDQ7XG59XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCBmaWxlIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gZmlsZShzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlICYgMHhmO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjKSB7XG4gICAgcmV0dXJuICcwMTIzNDU2Nzg5Jy5pbmRleE9mKGMpICE9PSAtMTtcbn1cbi8vIENvbnZlcnRzIGEgMHg4OCBzcXVhcmUgdG8gYWxnZWJyYWljIG5vdGF0aW9uLlxuZnVuY3Rpb24gYWxnZWJyYWljKHNxdWFyZSkge1xuICAgIGNvbnN0IGYgPSBmaWxlKHNxdWFyZSk7XG4gICAgY29uc3QgciA9IHJhbmsoc3F1YXJlKTtcbiAgICByZXR1cm4gKCdhYmNkZWZnaCcuc3Vic3RyaW5nKGYsIGYgKyAxKSArXG4gICAgICAgICc4NzY1NDMyMScuc3Vic3RyaW5nKHIsIHIgKyAxKSk7XG59XG5mdW5jdGlvbiBzd2FwQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IgPT09IFdISVRFID8gQkxBQ0sgOiBXSElURTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZlbihmZW4pIHtcbiAgICAvLyAxc3QgY3JpdGVyaW9uOiA2IHNwYWNlLXNlcGVyYXRlZCBmaWVsZHM/XG4gICAgY29uc3QgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG11c3QgY29udGFpbiBzaXggc3BhY2UtZGVsaW1pdGVkIGZpZWxkcycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDJuZCBjcml0ZXJpb246IG1vdmUgbnVtYmVyIGZpZWxkIGlzIGEgaW50ZWdlciB2YWx1ZSA+IDA/XG4gICAgY29uc3QgbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgIGlmIChpc05hTihtb3ZlTnVtYmVyKSB8fCBtb3ZlTnVtYmVyIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG1vdmUgbnVtYmVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gM3JkIGNyaXRlcmlvbjogaGFsZiBtb3ZlIGNvdW50ZXIgaXMgYW4gaW50ZWdlciA+PSAwP1xuICAgIGNvbnN0IGhhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgIGlmIChpc05hTihoYWxmTW92ZXMpIHx8IGhhbGZNb3ZlcyA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IGhhbGYgbW92ZSBjb3VudGVyIG51bWJlciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyA0dGggY3JpdGVyaW9uOiA0dGggZmllbGQgaXMgYSB2YWxpZCBlLnAuLXN0cmluZz9cbiAgICBpZiAoIS9eKC18W2FiY2RlZmdoXVszNl0pJC8udGVzdCh0b2tlbnNbM10pKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogZW4tcGFzc2FudCBzcXVhcmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNXRoIGNyaXRlcmlvbjogM3RoIGZpZWxkIGlzIGEgdmFsaWQgY2FzdGxlLXN0cmluZz9cbiAgICBpZiAoL1tea0txUS1dLy50ZXN0KHRva2Vuc1syXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBjYXN0bGluZyBhdmFpbGFiaWxpdHkgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNnRoIGNyaXRlcmlvbjogMm5kIGZpZWxkIGlzIFwid1wiICh3aGl0ZSkgb3IgXCJiXCIgKGJsYWNrKT9cbiAgICBpZiAoIS9eKHd8YikkLy50ZXN0KHRva2Vuc1sxXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBzaWRlLXRvLW1vdmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gN3RoIGNyaXRlcmlvbjogMXN0IGZpZWxkIGNvbnRhaW5zIDggcm93cz9cbiAgICBjb25zdCByb3dzID0gdG9rZW5zWzBdLnNwbGl0KCcvJyk7XG4gICAgaWYgKHJvd3MubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBkb2VzIG5vdCBjb250YWluIDggJy8nLWRlbGltaXRlZCByb3dzXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDh0aCBjcml0ZXJpb246IGV2ZXJ5IHJvdyBpcyB2YWxpZD9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJpZ2h0IHN1bSBvZiBmaWVsZHMgQU5EIG5vdCB0d28gbnVtYmVycyBpbiBzdWNjZXNzaW9uXG4gICAgICAgIGxldCBzdW1GaWVsZHMgPSAwO1xuICAgICAgICBsZXQgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChyb3dzW2ldW2tdKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1dhc051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBpcyBpbnZhbGlkIChjb25zZWN1dGl2ZSBudW1iZXIpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IHBhcnNlSW50KHJvd3NbaV1ba10sIDEwKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9eW3BybmJxa1BSTkJRS10kLy50ZXN0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGludmFsaWQgcGllY2UpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IDE7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtRmllbGRzICE9PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKHRvbyBtYW55IHNxdWFyZXMgaW4gcmFuayknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA5dGggY3JpdGVyaW9uOiBpcyBlbi1wYXNzYW50IHNxdWFyZSBsZWdhbD9cbiAgICBpZiAoKHRva2Vuc1szXVsxXSA9PSAnMycgJiYgdG9rZW5zWzFdID09ICd3JykgfHxcbiAgICAgICAgKHRva2Vuc1szXVsxXSA9PSAnNicgJiYgdG9rZW5zWzFdID09ICdiJykpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBpbGxlZ2FsIGVuLXBhc3NhbnQgc3F1YXJlJyB9O1xuICAgIH1cbiAgICAvLyAxMHRoIGNyaXRlcmlvbjogZG9lcyBjaGVzcyBwb3NpdGlvbiBjb250YWluIGV4YWN0IHR3byBraW5ncz9cbiAgICBjb25zdCBraW5ncyA9IFtcbiAgICAgICAgeyBjb2xvcjogJ3doaXRlJywgcmVnZXg6IC9LL2cgfSxcbiAgICAgICAgeyBjb2xvcjogJ2JsYWNrJywgcmVnZXg6IC9rL2cgfSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgeyBjb2xvciwgcmVnZXggfSBvZiBraW5ncykge1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodG9rZW5zWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEludmFsaWQgRkVOOiBtaXNzaW5nICR7Y29sb3J9IGtpbmdgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0b2tlbnNbMF0ubWF0Y2gocmVnZXgpIHx8IFtdKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBGRU46IHRvbyBtYW55ICR7Y29sb3J9IGtpbmdzYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDExdGggY3JpdGVyaW9uOiBhcmUgYW55IHBhd25zIG9uIHRoZSBmaXJzdCBvciBlaWdodGggcm93cz9cbiAgICBpZiAoQXJyYXkuZnJvbShyb3dzWzBdICsgcm93c1s3XSkuc29tZSgoY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpID09PSAnUCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBzb21lIHBhd25zIGFyZSBvbiB0aGUgZWRnZSByb3dzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcbn1cbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhbWJpZ3VvdXMgbW92ZXNcbmZ1bmN0aW9uIGdldERpc2FtYmlndWF0b3IobW92ZSwgbW92ZXMpIHtcbiAgICBjb25zdCBmcm9tID0gbW92ZS5mcm9tO1xuICAgIGNvbnN0IHRvID0gbW92ZS50bztcbiAgICBjb25zdCBwaWVjZSA9IG1vdmUucGllY2U7XG4gICAgbGV0IGFtYmlndWl0aWVzID0gMDtcbiAgICBsZXQgc2FtZVJhbmsgPSAwO1xuICAgIGxldCBzYW1lRmlsZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFtYmlnRnJvbSA9IG1vdmVzW2ldLmZyb207XG4gICAgICAgIGNvbnN0IGFtYmlnVG8gPSBtb3Zlc1tpXS50bztcbiAgICAgICAgY29uc3QgYW1iaWdQaWVjZSA9IG1vdmVzW2ldLnBpZWNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBpZiBhIG1vdmUgb2YgdGhlIHNhbWUgcGllY2UgdHlwZSBlbmRzIG9uIHRoZSBzYW1lIHRvIHNxdWFyZSwgd2UnbGwgbmVlZFxuICAgICAgICAgKiB0byBhZGQgYSBkaXNhbWJpZ3VhdG9yIHRvIHRoZSBhbGdlYnJhaWMgbm90YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwaWVjZSA9PT0gYW1iaWdQaWVjZSAmJiBmcm9tICE9PSBhbWJpZ0Zyb20gJiYgdG8gPT09IGFtYmlnVG8pIHtcbiAgICAgICAgICAgIGFtYmlndWl0aWVzKys7XG4gICAgICAgICAgICBpZiAocmFuayhmcm9tKSA9PT0gcmFuayhhbWJpZ0Zyb20pKSB7XG4gICAgICAgICAgICAgICAgc2FtZVJhbmsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlKGZyb20pID09PSBmaWxlKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lRmlsZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbWJpZ3VpdGllcyA+IDApIHtcbiAgICAgICAgaWYgKHNhbWVSYW5rID4gMCAmJiBzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGVyZSBleGlzdHMgYSBzaW1pbGFyIG1vdmluZyBwaWVjZSBvbiB0aGUgc2FtZSByYW5rIGFuZCBmaWxlIGFzXG4gICAgICAgICAgICAgKiB0aGUgbW92ZSBpbiBxdWVzdGlvbiwgdXNlIHRoZSBzcXVhcmUgYXMgdGhlIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGUgbW92aW5nIHBpZWNlIHJlc3RzIG9uIHRoZSBzYW1lIGZpbGUsIHVzZSB0aGUgcmFuayBzeW1ib2wgYXMgdGhlXG4gICAgICAgICAgICAgKiBkaXNhbWJpZ3VhdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pLmNoYXJBdCgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBhZGRNb3ZlKG1vdmVzLCBjb2xvciwgZnJvbSwgdG8sIHBpZWNlLCBjYXB0dXJlZCA9IHVuZGVmaW5lZCwgZmxhZ3MgPSBCSVRTLk5PUk1BTCkge1xuICAgIGNvbnN0IHIgPSByYW5rKHRvKTtcbiAgICBpZiAocGllY2UgPT09IFBBV04gJiYgKHIgPT09IFJBTktfMSB8fCByID09PSBSQU5LXzgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPTU9USU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvbW90aW9uID0gUFJPTU9USU9OU1tpXTtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgcGllY2UsXG4gICAgICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgcHJvbW90aW9uLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncyB8IEJJVFMuUFJPTU9USU9OLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgIGNhcHR1cmVkLFxuICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZmVyUGllY2VUeXBlKHNhbikge1xuICAgIGxldCBwaWVjZVR5cGUgPSBzYW4uY2hhckF0KDApO1xuICAgIGlmIChwaWVjZVR5cGUgPj0gJ2EnICYmIHBpZWNlVHlwZSA8PSAnaCcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNhbi5tYXRjaCgvW2EtaF1cXGQuKlthLWhdXFxkLyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVdOO1xuICAgIH1cbiAgICBwaWVjZVR5cGUgPSBwaWVjZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocGllY2VUeXBlID09PSAnbycpIHtcbiAgICAgICAgcmV0dXJuIEtJTkc7XG4gICAgfVxuICAgIHJldHVybiBwaWVjZVR5cGU7XG59XG4vLyBwYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcbmZ1bmN0aW9uIHN0cmlwcGVkU2FuKG1vdmUpIHtcbiAgICByZXR1cm4gbW92ZS5yZXBsYWNlKC89LywgJycpLnJlcGxhY2UoL1srI10/Wz8hXSokLywgJycpO1xufVxuZnVuY3Rpb24gdHJpbUZlbihmZW4pIHtcbiAgICAvKlxuICAgICAqIHJlbW92ZSBsYXN0IHR3byBmaWVsZHMgaW4gRkVOIHN0cmluZyBhcyB0aGV5J3JlIG5vdCBuZWVkZWQgd2hlbiBjaGVja2luZ1xuICAgICAqIGZvciByZXBldGl0aW9uXG4gICAgICovXG4gICAgcmV0dXJuIGZlbi5zcGxpdCgnICcpLnNsaWNlKDAsIDQpLmpvaW4oJyAnKTtcbn1cbmV4cG9ydCBjbGFzcyBDaGVzcyB7XG4gICAgX2JvYXJkID0gbmV3IEFycmF5KDEyOCk7XG4gICAgX3R1cm4gPSBXSElURTtcbiAgICBfaGVhZGVyID0ge307XG4gICAgX2tpbmdzID0geyB3OiBFTVBUWSwgYjogRU1QVFkgfTtcbiAgICBfZXBTcXVhcmUgPSAtMTtcbiAgICBfaGFsZk1vdmVzID0gMDtcbiAgICBfbW92ZU51bWJlciA9IDA7XG4gICAgX2hpc3RvcnkgPSBbXTtcbiAgICBfY29tbWVudHMgPSB7fTtcbiAgICBfY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAvLyB0cmFja3MgbnVtYmVyIG9mIHRpbWVzIGEgcG9zaXRpb24gaGFzIGJlZW4gc2VlbiBmb3IgcmVwZXRpdGlvbiBjaGVja2luZ1xuICAgIF9wb3NpdGlvbkNvdW50ID0ge307XG4gICAgY29uc3RydWN0b3IoZmVuID0gREVGQVVMVF9QT1NJVElPTiwgeyBza2lwVmFsaWRhdGlvbiA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHNraXBWYWxpZGF0aW9uIH0pO1xuICAgIH1cbiAgICBjbGVhcih7IHByZXNlcnZlSGVhZGVycyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgICAgICB0aGlzLl9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgICAgIHRoaXMuX3R1cm4gPSBXSElURTtcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IDE7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5faGVhZGVyID0gcHJlc2VydmVIZWFkZXJzID8gdGhpcy5faGVhZGVyIDoge307XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQgPSB7fTtcbiAgICAgICAgLypcbiAgICAgICAgICogRGVsZXRlIHRoZSBTZXRVcCBhbmQgRkVOIGhlYWRlcnMgKGlmIHByZXNlcnZlZCksIHRoZSBib2FyZCBpcyBlbXB0eSBhbmRcbiAgICAgICAgICogdGhlc2UgaGVhZGVycyBkb24ndCBtYWtlIHNlbnNlIGluIHRoaXMgc3RhdGUuIFRoZXknbGwgZ2V0IGFkZGVkIGxhdGVyXG4gICAgICAgICAqIHZpYSAubG9hZCgpIG9yIC5wdXQoKVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnU2V0VXAnXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnRkVOJ107XG4gICAgfVxuICAgIGxvYWQoZmVuLCB7IHNraXBWYWxpZGF0aW9uID0gZmFsc2UsIHByZXNlcnZlSGVhZGVycyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBsZXQgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIC8vIGFwcGVuZCBjb21tb25seSBvbWl0dGVkIGZlbiB0b2tlbnNcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPj0gMiAmJiB0b2tlbnMubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudHMgPSBbJy0nLCAnLScsICcwJywgJzEnXTtcbiAgICAgICAgICAgIGZlbiA9IHRva2Vucy5jb25jYXQoYWRqdXN0bWVudHMuc2xpY2UoLSg2IC0gdG9rZW5zLmxlbmd0aCkpKS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2ssIGVycm9yIH0gPSB2YWxpZGF0ZUZlbihmZW4pO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0b2tlbnNbMF07XG4gICAgICAgIGxldCBzcXVhcmUgPSAwO1xuICAgICAgICB0aGlzLmNsZWFyKHsgcHJlc2VydmVIZWFkZXJzIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHBvc2l0aW9uLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChwaWVjZSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RpZ2l0KHBpZWNlKSkge1xuICAgICAgICAgICAgICAgIHNxdWFyZSArPSBwYXJzZUludChwaWVjZSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwaWVjZSA8ICdhJyA/IFdISVRFIDogQkxBQ0s7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHV0KHsgdHlwZTogcGllY2UudG9Mb3dlckNhc2UoKSwgY29sb3IgfSwgYWxnZWJyYWljKHNxdWFyZSkpO1xuICAgICAgICAgICAgICAgIHNxdWFyZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R1cm4gPSB0b2tlbnNbMV07XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignSycpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgfD0gQklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdRJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyB8PSBCSVRTLlFTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ2snKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iIHw9IEJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZigncScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgfD0gQklUUy5RU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSB0b2tlbnNbM10gPT09ICctJyA/IEVNUFRZIDogT3g4OFt0b2tlbnNbM11dO1xuICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSBwYXJzZUludCh0b2tlbnNbNF0sIDEwKTtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgICAgICB0aGlzLl91cGRhdGVTZXR1cChmZW4pO1xuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KGZlbik7XG4gICAgfVxuICAgIGZlbigpIHtcbiAgICAgICAgbGV0IGVtcHR5ID0gMDtcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9IGVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3IsIHR5cGU6IHBpZWNlIH0gPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgICAgICBmZW4gKz0gY29sb3IgPT09IFdISVRFID8gcGllY2UudG9VcHBlckNhc2UoKSA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbXB0eSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBPeDg4LmgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhc3RsaW5nID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ0snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ1EnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ2snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ3EnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIHdlIGhhdmUgYW4gZW1wdHkgY2FzdGxpbmcgZmxhZz9cbiAgICAgICAgY2FzdGxpbmcgPSBjYXN0bGluZyB8fCAnLSc7XG4gICAgICAgIGxldCBlcFNxdWFyZSA9ICctJztcbiAgICAgICAgLypcbiAgICAgICAgICogb25seSBwcmludCB0aGUgZXAgc3F1YXJlIGlmIGVuIHBhc3NhbnQgaXMgYSB2YWxpZCBtb3ZlIChwYXduIGlzIHByZXNlbnRcbiAgICAgICAgICogYW5kIGVwIGNhcHR1cmUgaXMgbm90IHBpbm5lZClcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSAhPT0gRU1QVFkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ1Bhd25TcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IDE2IDogLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbYmlnUGF3blNxdWFyZSArIDEsIGJpZ1Bhd25TcXVhcmUgLSAxXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc3F1YXJlIG9mZiB0aGUgYm9hcmQ/XG4gICAgICAgICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIHBhd24gdGhhdCBjYW4gY2FwdHVyZSB0aGUgZXBTcXVhcmU/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSBjb2xvciAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXduIG1ha2VzIGFuIGVwIGNhcHR1cmUsIGRvZXMgaXQgbGVhdmUgaXQncyBraW5nIGluIGNoZWNrP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZWNlOiBQQVdOLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZWQ6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogQklUUy5FUF9DQVBUVVJFLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMZWdhbCA9ICF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGVwIGlzIGxlZ2FsLCBicmVhayBhbmQgc2V0IHRoZSBlcCBzcXVhcmUgaW4gdGhlIEZFTiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwU3F1YXJlID0gYWxnZWJyYWljKHRoaXMuX2VwU3F1YXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmZW4sXG4gICAgICAgICAgICB0aGlzLl90dXJuLFxuICAgICAgICAgICAgY2FzdGxpbmcsXG4gICAgICAgICAgICBlcFNxdWFyZSxcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyxcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIsXG4gICAgICAgIF0uam9pbignICcpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIGJvYXJkIHNldHVwIGlzIGNoYW5nZWQgd2l0aCBwdXQoKSBvciByZW1vdmUoKS5cbiAgICAgKiBtb2RpZmllcyB0aGUgU2V0VXAgYW5kIEZFTiBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXIgb2JqZWN0LiBJZiB0aGUgRkVOXG4gICAgICogaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkIHRoZSBzZXR1cFxuICAgICAqIGlzIG9ubHkgdXBkYXRlZCBpZiBoaXN0b3J5Lmxlbmd0aCBpcyB6ZXJvLCBpZSBtb3ZlcyBoYXZlbid0IGJlZW4gbWFkZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlU2V0dXAoZmVuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmZW4gIT09IERFRkFVTFRfUE9TSVRJT04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9ICcxJztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBmZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyWydTZXRVcCddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnRkVOJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubG9hZChERUZBVUxUX1BPU0lUSU9OKTtcbiAgICB9XG4gICAgZ2V0KHNxdWFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXTtcbiAgICB9XG4gICAgcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXR1cCh0aGlzLmZlbigpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3B1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgcGllY2VcbiAgICAgICAgaWYgKFNZTUJPTFMuaW5kZXhPZih0eXBlLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciB2YWxpZCBzcXVhcmVcbiAgICAgICAgaWYgKCEoc3F1YXJlIGluIE94ODgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3EgPSBPeDg4W3NxdWFyZV07XG4gICAgICAgIC8vIGRvbid0IGxldCB0aGUgdXNlciBwbGFjZSBtb3JlIHRoYW4gb25lIGtpbmdcbiAgICAgICAgaWYgKHR5cGUgPT0gS0lORyAmJlxuICAgICAgICAgICAgISh0aGlzLl9raW5nc1tjb2xvcl0gPT0gRU1QVFkgfHwgdGhpcy5fa2luZ3NbY29sb3JdID09IHNxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQaWVjZU9uU3F1YXJlID0gdGhpcy5fYm9hcmRbc3FdO1xuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIGtpbmdzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHBpZWNlIGZyb20gYXJncywgc2V0IHRoZSBgX2tpbmdzYCByZXNwZWN0aXZlIGVudHJ5IHRvIGBFTVBUWWBcbiAgICAgICAgaWYgKGN1cnJlbnRQaWVjZU9uU3F1YXJlICYmIGN1cnJlbnRQaWVjZU9uU3F1YXJlLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2N1cnJlbnRQaWVjZU9uU3F1YXJlLmNvbG9yXSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JvYXJkW3NxXSA9IHsgdHlwZTogdHlwZSwgY29sb3I6IGNvbG9yIH07XG4gICAgICAgIGlmICh0eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1tjb2xvcl0gPSBzcTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlKHNxdWFyZSkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuZ2V0KHNxdWFyZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtPeDg4W3NxdWFyZV1dO1xuICAgICAgICBpZiAocGllY2UgJiYgcGllY2UudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbcGllY2UuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICByZXR1cm4gcGllY2U7XG4gICAgfVxuICAgIF91cGRhdGVDYXN0bGluZ1JpZ2h0cygpIHtcbiAgICAgICAgY29uc3Qgd2hpdGVLaW5nSW5QbGFjZSA9IHRoaXMuX2JvYXJkW094ODguZTFdPy50eXBlID09PSBLSU5HICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmUxXT8uY29sb3IgPT09IFdISVRFO1xuICAgICAgICBjb25zdCBibGFja0tpbmdJblBsYWNlID0gdGhpcy5fYm9hcmRbT3g4OC5lOF0/LnR5cGUgPT09IEtJTkcgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguZThdPy5jb2xvciA9PT0gQkxBQ0s7XG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hMV0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYTFdPy5jb2xvciAhPT0gV0hJVEUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDFdPy5jb2xvciAhPT0gV0hJVEUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgJj0gfkJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmxhY2tLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hOF0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYThdPy5jb2xvciAhPT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmxhY2tLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oOF0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDhdPy5jb2xvciAhPT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVFblBhc3NhbnRTcXVhcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSA9PT0gRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gLTE2IDogMTYpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gV0hJVEUgPyAxNiA6IC0xNik7XG4gICAgICAgIGNvbnN0IGF0dGFja2VycyA9IFtjdXJyZW50U3F1YXJlICsgMSwgY3VycmVudFNxdWFyZSAtIDFdO1xuICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3RhcnRTcXVhcmVdICE9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFt0aGlzLl9lcFNxdWFyZV0gIT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW2N1cnJlbnRTcXVhcmVdPy5jb2xvciAhPT0gc3dhcENvbG9yKHRoaXMuX3R1cm4pIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8udHlwZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5DYXB0dXJlID0gKHNxdWFyZSkgPT4gIShzcXVhcmUgJiAweDg4KSAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IHRoaXMuX3R1cm4gJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LnR5cGUgPT09IFBBV047XG4gICAgICAgIGlmICghYXR0YWNrZXJzLnNvbWUoY2FuQ2FwdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGFja2VkKGNvbG9yLCBzcXVhcmUsIHZlcmJvc2UpIHtcbiAgICAgICAgY29uc3QgYXR0YWNrZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGkgKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGVtcHR5IHNxdWFyZSBvciB3cm9uZyBjb2xvclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09PSB1bmRlZmluZWQgfHwgdGhpcy5fYm9hcmRbaV0uY29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IGkgLSBzcXVhcmU7XG4gICAgICAgICAgICAvLyBza2lwIC0gdG8vZnJvbSBzcXVhcmUgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkaWZmZXJlbmNlICsgMTE5O1xuICAgICAgICAgICAgaWYgKEFUVEFDS1NbaW5kZXhdICYgUElFQ0VfTUFTS1NbcGllY2UudHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZlcmVuY2UgPiAwICYmIHBpZWNlLmNvbG9yID09PSBXSElURSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmZXJlbmNlIDw9IDAgJiYgcGllY2UuY29sb3IgPT09IEJMQUNLKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGllY2UgaXMgYSBrbmlnaHQgb3IgYSBraW5nXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICduJyB8fCBwaWVjZS50eXBlID09PSAnaycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBSQVlTW2luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiAhPT0gc3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtqXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGogKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFja2VycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2tlcnMoc3F1YXJlLCBhdHRhY2tlZEJ5KSB7XG4gICAgICAgIGlmICghYXR0YWNrZWRCeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKHRoaXMuX3R1cm4sIE94ODhbc3F1YXJlXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQoYXR0YWNrZWRCeSwgT3g4OFtzcXVhcmVdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNLaW5nQXR0YWNrZWQoY29sb3IpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gdGhpcy5fa2luZ3NbY29sb3JdO1xuICAgICAgICByZXR1cm4gc3F1YXJlID09PSAtMSA/IGZhbHNlIDogdGhpcy5fYXR0YWNrZWQoc3dhcENvbG9yKGNvbG9yKSwgc3F1YXJlKTtcbiAgICB9XG4gICAgaXNBdHRhY2tlZChzcXVhcmUsIGF0dGFja2VkQnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSk7XG4gICAgfVxuICAgIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0tpbmdBdHRhY2tlZCh0aGlzLl90dXJuKTtcbiAgICB9XG4gICAgaW5DaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpO1xuICAgIH1cbiAgICBpc0NoZWNrbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1N0YWxlbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ2hlY2soKSAmJiB0aGlzLl9tb3ZlcygpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogay5iLiB2cyBrLmIuIChvZiBvcHBvc2l0ZSBjb2xvcnMpIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFiNi84L0IxazUvSzcgYiAtIC0gMCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIGsuYi4gdnMgay5uLiB3aXRoIG1hdGUgaW4gMTpcbiAgICAgICAgICogOC84LzgvOC8xbjYvOC9CNy9LMWs1IGIgLSAtIDIgMVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGllY2VzID0ge1xuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcTogMCxcbiAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICBwOiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiaXNob3BzID0gW107XG4gICAgICAgIGxldCBudW1QaWVjZXMgPSAwO1xuICAgICAgICBsZXQgc3F1YXJlQ29sb3IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIHNxdWFyZUNvbG9yID0gKHNxdWFyZUNvbG9yICsgMSkgJSAyO1xuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgICAgICAgIHBpZWNlc1twaWVjZS50eXBlXSA9IHBpZWNlLnR5cGUgaW4gcGllY2VzID8gcGllY2VzW3BpZWNlLnR5cGVdICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IEJJU0hPUCkge1xuICAgICAgICAgICAgICAgICAgICBiaXNob3BzLnB1c2goc3F1YXJlQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1QaWVjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBrIHZzLiBrXG4gICAgICAgIGlmIChudW1QaWVjZXMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBrIHZzLiBrbiAuLi4uIG9yIC4uLi4gayB2cy4ga2JcbiAgICAgICAgbnVtUGllY2VzID09PSAzICYmXG4gICAgICAgICAgICAocGllY2VzW0JJU0hPUF0gPT09IDEgfHwgcGllY2VzW0tOSUdIVF0gPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1QaWVjZXMgPT09IHBpZWNlc1tCSVNIT1BdICsgMikge1xuICAgICAgICAgICAgLy8ga2IgdnMuIGtiIHdoZXJlIGFueSBudW1iZXIgb2YgYmlzaG9wcyBhcmUgYWxsIG9uIHRoZSBzYW1lIGNvbG9yXG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJpc2hvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaXNob3BzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UG9zaXRpb25Db3VudCh0aGlzLmZlbigpKSA+PSAzO1xuICAgIH1cbiAgICBpc0RyYXdCeUZpZnR5TW92ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWxmTW92ZXMgPj0gMTAwOyAvLyA1MCBtb3ZlcyBwZXIgc2lkZSA9IDEwMCBoYWxmIG1vdmVzXG4gICAgfVxuICAgIGlzRHJhdygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzRHJhd0J5RmlmdHlNb3ZlcygpIHx8XG4gICAgICAgICAgICB0aGlzLmlzU3RhbGVtYXRlKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzVGhyZWVmb2xkUmVwZXRpdGlvbigpKTtcbiAgICB9XG4gICAgaXNHYW1lT3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVja21hdGUoKSB8fCB0aGlzLmlzU3RhbGVtYXRlKCkgfHwgdGhpcy5pc0RyYXcoKTtcbiAgICB9XG4gICAgbW92ZXMoeyB2ZXJib3NlID0gZmFsc2UsIHNxdWFyZSA9IHVuZGVmaW5lZCwgcGllY2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgc3F1YXJlLCBwaWVjZSB9KTtcbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Zlcy5tYXAoKG1vdmUpID0+IG5ldyBNb3ZlKHRoaXMsIG1vdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Zlcy5tYXAoKG1vdmUpID0+IHRoaXMuX21vdmVUb1Nhbihtb3ZlLCBtb3ZlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9tb3Zlcyh7IGxlZ2FsID0gdHJ1ZSwgcGllY2UgPSB1bmRlZmluZWQsIHNxdWFyZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZvclNxdWFyZSA9IHNxdWFyZSA/IHNxdWFyZS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmb3JQaWVjZSA9IHBpZWNlPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtb3ZlcyA9IFtdO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICBsZXQgZmlyc3RTcXVhcmUgPSBPeDg4LmE4O1xuICAgICAgICBsZXQgbGFzdFNxdWFyZSA9IE94ODguaDE7XG4gICAgICAgIGxldCBzaW5nbGVTcXVhcmUgPSBmYWxzZTtcbiAgICAgICAgLy8gYXJlIHdlIGdlbmVyYXRpbmcgbW92ZXMgZm9yIGEgc2luZ2xlIHNxdWFyZT9cbiAgICAgICAgaWYgKGZvclNxdWFyZSkge1xuICAgICAgICAgICAgLy8gaWxsZWdhbCBzcXVhcmUsIHJldHVybiBlbXB0eSBtb3Zlc1xuICAgICAgICAgICAgaWYgKCEoZm9yU3F1YXJlIGluIE94ODgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3RTcXVhcmUgPSBsYXN0U3F1YXJlID0gT3g4OFtmb3JTcXVhcmVdO1xuICAgICAgICAgICAgICAgIHNpbmdsZVNxdWFyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IGZpcnN0U3F1YXJlOyBmcm9tIDw9IGxhc3RTcXVhcmU7IGZyb20rKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChmcm9tICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGZyb20gKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtcHR5IHNxdWFyZSBvciBvcHBvbmVudCwgc2tpcFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtmcm9tXSB8fCB0aGlzLl9ib2FyZFtmcm9tXS5jb2xvciA9PT0gdGhlbSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0aGlzLl9ib2FyZFtmcm9tXTtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3F1YXJlLCBub24tY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04pO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUgc3F1YXJlXG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChTRUNPTkRfUkFOS1t1c10gPT09IHJhbmsoZnJvbSkgJiYgIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCB1bmRlZmluZWQsIEJJVFMuQklHX1BBV04pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhd24gY2FwdHVyZXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10/LmNvbG9yID09PSB0aGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSB0aGlzLl9lcFNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCBQQVdOLCBCSVRTLkVQX0NBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuID0gUElFQ0VfT0ZGU0VUU1t0eXBlXS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBQSUVDRV9PRkZTRVRTW3R5cGVdW2pdO1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFt0b10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duIGNvbG9yLCBzdG9wIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbdG9dLmNvbG9yID09PSB1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCB0eXBlLCB0aGlzLl9ib2FyZFt0b10udHlwZSwgQklUUy5DQVBUVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJyZWFrLCBpZiBrbmlnaHQgb3Iga2luZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEtOSUdIVCB8fCB0eXBlID09PSBLSU5HKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIGNoZWNrIGZvciBjYXN0bGluZyBpZiB3ZSdyZTpcbiAgICAgICAgICogICBhKSBnZW5lcmF0aW5nIGFsbCBtb3Zlcywgb3JcbiAgICAgICAgICogICBiKSBkb2luZyBzaW5nbGUgc3F1YXJlIG1vdmUgZ2VuZXJhdGlvbiBvbiB0aGUga2luZydzIHNxdWFyZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZvclBpZWNlID09PSB1bmRlZmluZWQgfHwgZm9yUGllY2UgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIGlmICghc2luZ2xlU3F1YXJlIHx8IGxhc3RTcXVhcmUgPT09IHRoaXMuX2tpbmdzW3VzXSkge1xuICAgICAgICAgICAgICAgIC8vIGtpbmctc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gKyAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSArIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCB0aGlzLl9raW5nc1t1c10pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdGcm9tICsgMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ1RvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIHRoaXMuX2tpbmdzW3VzXSwgY2FzdGxpbmdUbywgS0lORywgdW5kZWZpbmVkLCBCSVRTLktTSURFX0NBU1RMRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcXVlZW4tc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gLSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIHRoaXMuX2tpbmdzW3VzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gLSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nVG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgdGhpcy5fa2luZ3NbdXNdLCBjYXN0bGluZ1RvLCBLSU5HLCB1bmRlZmluZWQsIEJJVFMuUVNJREVfQ0FTVExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiByZXR1cm4gYWxsIHBzZXVkby1sZWdhbCBtb3ZlcyAodGhpcyBpbmNsdWRlcyBtb3ZlcyB0aGF0IGFsbG93IHRoZSBraW5nXG4gICAgICAgICAqIHRvIGJlIGNhcHR1cmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFsZWdhbCB8fCB0aGlzLl9raW5nc1t1c10gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbGxlZ2FsIG1vdmVzXG4gICAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3Zlc1tpXSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzS2luZ0F0dGFja2VkKHVzKSkge1xuICAgICAgICAgICAgICAgIGxlZ2FsTW92ZXMucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWdhbE1vdmVzO1xuICAgIH1cbiAgICBtb3ZlKG1vdmUsIHsgc3RyaWN0ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBtb3ZlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aCBpbiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKCdOeGI3JykgICAgICAgPC0gYXJndW1lbnQgaXMgYSBjYXNlLXNlbnNpdGl2ZSBTQU4gc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKHsgZnJvbTogJ2g3JywgPC0gYXJndW1lbnQgaXMgYSBtb3ZlIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgIHRvIDonaDgnLFxuICAgICAgICAgKiAgICAgICAgIHByb21vdGlvbjogJ3EnIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHN0cmljdCBhcmd1bWVudCBtYXkgYmUgc3VwcGxpZWQgdG8gdGVsbCBjaGVzcy5qcyB0b1xuICAgICAgICAgKiBzdHJpY3RseSBmb2xsb3cgdGhlIFNBTiBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG1vdmVPYmogPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG1vdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtb3ZlT2JqID0gdGhpcy5fbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW92ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHByZXR0eSBtb3ZlIG9iamVjdCB0byBhbiB1Z2x5IG1vdmUgb2JqZWN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBhbGdlYnJhaWMobW92ZXNbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW92ZS50byA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICAoISgncHJvbW90aW9uJyBpbiBtb3Zlc1tpXSkgfHwgbW92ZS5wcm9tb3Rpb24gPT09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9iaiA9IG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFpbGVkIHRvIGZpbmQgbW92ZVxuICAgICAgICBpZiAoIW1vdmVPYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZTogJHttb3ZlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7SlNPTi5zdHJpbmdpZnkobW92ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogbmVlZCB0byBtYWtlIGEgY29weSBvZiBtb3ZlIGJlY2F1c2Ugd2UgY2FuJ3QgZ2VuZXJhdGUgU0FOIGFmdGVyIHRoZSBtb3ZlXG4gICAgICAgICAqIGlzIG1hZGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZXR0eU1vdmUgPSBuZXcgTW92ZSh0aGlzLCBtb3ZlT2JqKTtcbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZU9iaik7XG4gICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQocHJldHR5TW92ZS5hZnRlcik7XG4gICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgIH1cbiAgICBfcHVzaChtb3ZlKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBtb3ZlLFxuICAgICAgICAgICAga2luZ3M6IHsgYjogdGhpcy5fa2luZ3MuYiwgdzogdGhpcy5fa2luZ3MudyB9LFxuICAgICAgICAgICAgdHVybjogdGhpcy5fdHVybixcbiAgICAgICAgICAgIGNhc3RsaW5nOiB7IGI6IHRoaXMuX2Nhc3RsaW5nLmIsIHc6IHRoaXMuX2Nhc3RsaW5nLncgfSxcbiAgICAgICAgICAgIGVwU3F1YXJlOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgIGhhbGZNb3ZlczogdGhpcy5faGFsZk1vdmVzLFxuICAgICAgICAgICAgbW92ZU51bWJlcjogdGhpcy5fbW92ZU51bWJlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9tYWtlTW92ZShtb3ZlKSB7XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIHRoaXMuX3B1c2gobW92ZSk7XG4gICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG9dID0gdGhpcy5fYm9hcmRbbW92ZS5mcm9tXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUuZnJvbV07XG4gICAgICAgIC8vIGlmIGVwIGNhcHR1cmUsIHJlbW92ZSB0aGUgY2FwdHVyZWQgcGF3blxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R1cm4gPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUudG8gLSAxNl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbbW92ZS50byArIDE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBwYXduIHByb21vdGlvbiwgcmVwbGFjZSB3aXRoIG5ldyBwaWVjZVxuICAgICAgICBpZiAobW92ZS5wcm9tb3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG9dID0geyB0eXBlOiBtb3ZlLnByb21vdGlvbiwgY29sb3I6IHVzIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgbW92ZWQgdGhlIGtpbmdcbiAgICAgICAgaWYgKHRoaXMuX2JvYXJkW21vdmUudG9dLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW3VzXSA9IG1vdmUudG87XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYXN0bGVkLCBtb3ZlIHRoZSByb29rIG5leHQgdG8gdGhlIGtpbmdcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW2Nhc3RsaW5nVG9dID0gdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nXG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t1c10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIG1vdmUgYSByb29rXG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBST09LU1t1c10ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBST09LU1t1c11baV0uc3F1YXJlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSAmIFJPT0tTW3VzXVtpXS5mbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSBePSBST09LU1t1c11baV0uZmxhZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIGNhcHR1cmUgYSByb29rXG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t0aGVtXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3RoZW1dLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmUudG8gPT09IFJPT0tTW3RoZW1dW2ldLnNxdWFyZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t0aGVtXSAmIFJPT0tTW3RoZW1dW2ldLmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdGhlbV0gXj0gUk9PS1NbdGhlbV1baV0uZmxhZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGJpZyBwYXduIG1vdmUsIHVwZGF0ZSB0aGUgZW4gcGFzc2FudCBzcXVhcmVcbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkJJR19QQVdOKSB7XG4gICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIDUwIG1vdmUgY291bnRlciBpZiBhIHBhd24gaXMgbW92ZWQgb3IgYSBwaWVjZSBpcyBjYXB0dXJlZFxuICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHVybiA9IHRoZW07XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmUpO1xuICAgICAgICAgICAgdGhpcy5fZGVjUG9zaXRpb25Db3VudChwcmV0dHlNb3ZlLmFmdGVyKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdW5kb01vdmUoKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX2hpc3RvcnkucG9wKCk7XG4gICAgICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZSA9IG9sZC5tb3ZlO1xuICAgICAgICB0aGlzLl9raW5ncyA9IG9sZC5raW5ncztcbiAgICAgICAgdGhpcy5fdHVybiA9IG9sZC50dXJuO1xuICAgICAgICB0aGlzLl9jYXN0bGluZyA9IG9sZC5jYXN0bGluZztcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBvbGQuZXBTcXVhcmU7XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IG9sZC5oYWxmTW92ZXM7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSBvbGQubW92ZU51bWJlcjtcbiAgICAgICAgY29uc3QgdXMgPSB0aGlzLl90dXJuO1xuICAgICAgICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS5mcm9tXSA9IHRoaXMuX2JvYXJkW21vdmUudG9dO1xuICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLmZyb21dLnR5cGUgPSBtb3ZlLnBpZWNlOyAvLyB0byB1bmRvIGFueSBwcm9tb3Rpb25zXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFttb3ZlLnRvXTtcbiAgICAgICAgaWYgKG1vdmUuY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICAgICAgICAgICAgLy8gZW4gcGFzc2FudCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbaW5kZXhdID0geyB0eXBlOiBQQVdOLCBjb2xvcjogdGhlbSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVndWxhciBjYXB0dXJlXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50b10gPSB7IHR5cGU6IG1vdmUuY2FwdHVyZWQsIGNvbG9yOiB0aGVtIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5LU0lERV9DQVNUTEUgfCBCSVRTLlFTSURFX0NBU1RMRSkpIHtcbiAgICAgICAgICAgIGxldCBjYXN0bGluZ1RvLCBjYXN0bGluZ0Zyb207XG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmU7XG4gICAgfVxuICAgIHBnbih7IG5ld2xpbmUgPSAnXFxuJywgbWF4V2lkdGggPSAwLCB9ID0ge30pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogdXNpbmcgdGhlIHNwZWNpZmljYXRpb24gZnJvbSBodHRwOi8vd3d3LmNoZXNzY2x1Yi5jb20vaGVscC9QR04tc3BlY1xuICAgICAgICAgKiBleGFtcGxlIGZvciBodG1sIHVzYWdlOiAucGduKHsgbWF4X3dpZHRoOiA3MiwgbmV3bGluZV9jaGFyOiBcIjxiciAvPlwiIH0pXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGhlYWRlckV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAvKiBhZGQgdGhlIFBHTiBoZWFkZXIgaW5mb3JtYXRpb24gKi9cbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRPRE86IG9yZGVyIG9mIGVudW1lcmF0ZWQgcHJvcGVydGllcyBpbiBoZWFkZXIgb2JqZWN0IGlzIG5vdFxuICAgICAgICAgICAgICogZ3VhcmFudGVlZCwgc2VlIEVDTUEtMjYyIHNwZWMgKHNlY3Rpb24gMTIuNi40KVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXN1bHQucHVzaCgnWycgKyBpICsgJyBcIicgKyB0aGlzLl9oZWFkZXJbaV0gKyAnXCJdJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgaGVhZGVyRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyRXhpc3RzICYmIHRoaXMuX2hpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRDb21tZW50ID0gKG1vdmVTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXIgPSBtb3ZlU3RyaW5nLmxlbmd0aCA+IDAgPyAnICcgOiAnJztcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gYCR7bW92ZVN0cmluZ30ke2RlbGltaXRlcn17JHtjb21tZW50fX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vdmVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBvcCBhbGwgb2YgaGlzdG9yeSBvbnRvIHJldmVyc2VkX2hpc3RvcnlcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGxldCBtb3ZlU3RyaW5nID0gJyc7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBvZiBhIGNvbW1lbnRlZCBzdGFydGluZyBwb3NpdGlvbiB3aXRoIG5vIG1vdmVzXG4gICAgICAgIGlmIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQoJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB0aGUgbGlzdCBvZiBtb3Zlcy4gIGEgbW92ZV9zdHJpbmcgbG9va3MgbGlrZTogXCIzLiBlMyBlNlwiXG4gICAgICAgIHdoaWxlIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbW92ZVN0cmluZyA9IGFwcGVuZENvbW1lbnQobW92ZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgLy8gbWFrZSBUeXBlU2NyaXB0IHN0b3AgY29tcGxhaW5pbmcgYWJvdXQgbW92ZSBiZWluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvc2l0aW9uIHN0YXJ0ZWQgd2l0aCBibGFjayB0byBtb3ZlLCBzdGFydCBQR04gd2l0aCAjLiAuLi5cbiAgICAgICAgICAgIGlmICghdGhpcy5faGlzdG9yeS5sZW5ndGggJiYgbW92ZS5jb2xvciA9PT0gJ2InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYCR7dGhpcy5fbW92ZU51bWJlcn0uIC4uLmA7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBjb21tZW50IHByZWNlZGluZyB0aGUgZmlyc3QgbW92ZT9cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gbW92ZVN0cmluZyA/IGAke21vdmVTdHJpbmd9ICR7cHJlZml4fWAgOiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmNvbG9yID09PSAndycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgZ2VuZXJhdGVkIG1vdmVfc3RyaW5nIGlmIHdlIGhhdmUgb25lXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVzLnB1c2gobW92ZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSB0aGlzLl9tb3ZlTnVtYmVyICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZVN0cmluZyA9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyArICcgJyArIHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFyZSB0aGVyZSBhbnkgb3RoZXIgbGVmdG92ZXIgbW92ZXM/XG4gICAgICAgIGlmIChtb3ZlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChhcHBlbmRDb21tZW50KG1vdmVTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpcyB0aGVyZSBhIHJlc3VsdD9cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9oZWFkZXIuUmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbW92ZXMucHVzaCh0aGlzLl9oZWFkZXIuUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBoaXN0b3J5IHNob3VsZCBiZSBiYWNrIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBzdGFydGVkIGdlbmVyYXRpbmcgUEdOLFxuICAgICAgICAgKiBzbyBqb2luIHRvZ2V0aGVyIG1vdmVzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobWF4V2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJykgKyBtb3Zlcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyAoamFoKTogaHVoP1xuICAgICAgICBjb25zdCBzdHJpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5COiB0aGlzIGRvZXMgbm90IHByZXNlcnZlIGNvbW1lbnQgd2hpdGVzcGFjZS5cbiAgICAgICAgY29uc3Qgd3JhcENvbW1lbnQgPSBmdW5jdGlvbiAod2lkdGgsIG1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbW92ZS5zcGxpdCgnICcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoICsgdG9rZW4ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0cmlwKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIHdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaXAoKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdyYXAgdGhlIFBHTiBvdXRwdXQgYXQgbWF4X3dpZHRoXG4gICAgICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZXNbaV0uaW5jbHVkZXMoJ3snKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSB3cmFwQ29tbWVudChjdXJyZW50V2lkdGgsIG1vdmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbW92ZSB3aWxsIHB1c2ggcGFzdCBtYXhfd2lkdGhcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggKyBtb3Zlc1tpXS5sZW5ndGggPiBtYXhXaWR0aCAmJiBpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHRoZSBsaW5lIHdpdGggd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICBjdXJyZW50V2lkdGggKz0gbW92ZXNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBzZXRIZWFkZXJgIGFuZCBgZ2V0SGVhZGVyc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBoZWFkZXIoLi4uYXJncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3NbaSArIDFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclthcmdzW2ldXSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcltrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9XG4gICAgbG9hZFBnbihwZ24sIHsgc3RyaWN0ID0gZmFsc2UsIG5ld2xpbmVDaGFyID0gJ1xccj9cXG4nLCB9ID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gbWFzayhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlUGduSGVhZGVyKGhlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyT2JqID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gaGVhZGVyLnNwbGl0KG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhcikpKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSAnJztcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvXlxccypcXFtcXHMqKFtBLVphLXpdKylcXHMqXCIoLiopXCJcXHMqXFxdXFxzKiQvO1xuICAgICAgICAgICAgICAgIGtleSA9IGhlYWRlcnNbaV0ucmVwbGFjZShyZWdleCwgJyQxJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2ldLnJlcGxhY2UocmVnZXgsICckMicpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyT2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyT2JqO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cmlwIHdoaXRlc3BhY2UgZnJvbSBoZWFkL3RhaWwgb2YgUEdOIGJsb2NrXG4gICAgICAgIHBnbiA9IHBnbi50cmltKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlZ0V4cCB0byBzcGxpdCBoZWFkZXIuIFRha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGhlYWRlciBhbmQgbW92ZXRleHRcbiAgICAgICAgICogd2lsbCBhbHdheXMgaGF2ZSBhIGJsYW5rIGxpbmUgYmV0d2VlbiB0aGVtIChpZSwgdHdvIG5ld2xpbmVfY2hhcidzKS4gSGFuZGxlc1xuICAgICAgICAgKiBjYXNlIHdoZXJlIG1vdmV0ZXh0IGlzIGVtcHR5IGJ5IG1hdGNoaW5nIG5ld2xpbmVDaGFyIHVudGlsIGVuZCBvZiBzdHJpbmcgaXNcbiAgICAgICAgICogbWF0Y2hlZCAtIGVmZmVjdGl2ZWx5IHRyaW1taW5nIGZyb20gdGhlIGVuZCBleHRyYSBuZXdsaW5lQ2hhci5cbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBkZWZhdWx0IG5ld2xpbmVfY2hhciwgd2lsbCBlcXVhbDpcbiAgICAgICAgICogL14oXFxbKCg/Olxccj9cXG4pfC4pKlxcXSkoKD86XFxzKlxccj9cXG4pezJ9fCg/OlxccypcXHI/XFxuKSokKS9cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhlYWRlclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXihcXFxcWygoPzonICtcbiAgICAgICAgICAgIG1hc2sobmV3bGluZUNoYXIpICtcbiAgICAgICAgICAgICcpfC4pKlxcXFxdKScgK1xuICAgICAgICAgICAgJygoPzpcXFxccyonICtcbiAgICAgICAgICAgIG1hc2sobmV3bGluZUNoYXIpICtcbiAgICAgICAgICAgICcpezJ9fCg/OlxcXFxzKicgK1xuICAgICAgICAgICAgbWFzayhuZXdsaW5lQ2hhcikgK1xuICAgICAgICAgICAgJykqJCknKTtcbiAgICAgICAgLy8gSWYgbm8gaGVhZGVyIGdpdmVuLCBiZWdpbiB3aXRoIG1vdmVzLlxuICAgICAgICBjb25zdCBoZWFkZXJSZWdleFJlc3VsdHMgPSBoZWFkZXJSZWdleC5leGVjKHBnbik7XG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGhlYWRlclJlZ2V4UmVzdWx0c1xuICAgICAgICAgICAgPyBoZWFkZXJSZWdleFJlc3VsdHMubGVuZ3RoID49IDJcbiAgICAgICAgICAgICAgICA/IGhlYWRlclJlZ2V4UmVzdWx0c1sxXVxuICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIC8vIFB1dCB0aGUgYm9hcmQgaW4gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgLy8gcGFyc2UgUEdOIGhlYWRlclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VQZ25IZWFkZXIoaGVhZGVyU3RyaW5nKTtcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgdXNlciBpcyBpbmNsdWRpbmcgZmVuIChwb3NzaWJseSB3aXRoIHdyb25nIHRhZyBjYXNlKVxuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnZmVuJykge1xuICAgICAgICAgICAgICAgIGZlbiA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiB0aGUgcGVybWlzc2l2ZSBwYXJzZXIgc2hvdWxkIGF0dGVtcHQgdG8gbG9hZCBhIGZlbiB0YWcsIGV2ZW4gaWYgaXQncyB0aGVcbiAgICAgICAgICogd3JvbmcgY2FzZSBhbmQgZG9lc24ndCBpbmNsdWRlIGEgY29ycmVzcG9uZGluZyBbU2V0VXAgXCIxXCJdIHRhZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHByZXNlcnZlSGVhZGVyczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBzdHJpY3QgcGFyc2VyIC0gbG9hZCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaW5kaWNhdGVkIGJ5IFtTZXR1cCAnMSddXG4gICAgICAgICAgICAgKiBhbmQgW0ZFTiBwb3NpdGlvbl1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1NldFVwJ10gPT09ICcxJykge1xuICAgICAgICAgICAgICAgIGlmICghKCdGRU4nIGluIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQR046IEZFTiB0YWcgbXVzdCBiZSBzdXBwbGllZCB3aXRoIFNldFVwIHRhZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjbGVhciB0aGUgaGVhZGVycyB3aGVuIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoaGVhZGVyc1snRkVOJ10sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIE5COiB0aGUgcmVnZXhlcyBiZWxvdyB0aGF0IGRlbGV0ZSBtb3ZlIG51bWJlcnMsIHJlY3Vyc2l2ZSBhbm5vdGF0aW9ucyxcbiAgICAgICAgICogYW5kIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgbWF5IGFsc28gbWF0Y2ggdGV4dCBpbiBjb21tZW50cy4gVG9cbiAgICAgICAgICogcHJldmVudCB0aGlzLCB3ZSB0cmFuc2Zvcm0gY29tbWVudHMgYnkgaGV4LWVuY29kaW5nIHRoZW0gaW4gcGxhY2UgYW5kXG4gICAgICAgICAqIGRlY29kaW5nIHRoZW0gYWdhaW4gYWZ0ZXIgdGhlIG90aGVyIHRva2VucyBoYXZlIGJlZW4gZGVsZXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hpbGUgdGhlIHNwZWMgc3RhdGVzIHRoYXQgUEdOIGZpbGVzIHNob3VsZCBiZSBBU0NJSSBlbmNvZGVkLCB3ZSB1c2VcbiAgICAgICAgICoge2VuLGRlfWNvZGVVUklDb21wb25lbnQgaGVyZSB0byBzdXBwb3J0IGFyYml0cmFyeSBVVEY4IGFzIGEgY29udmVuaWVuY2VcbiAgICAgICAgICogZm9yIG1vZGVybiB1c2Vyc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdG9IZXgocykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBlbmNvZGVVUkkgZG9lc24ndCB0cmFuc2Zvcm0gbW9zdCBBU0NJSSBjaGFyYWN0ZXJzLCBzbyB3ZSBoYW5kbGVcbiAgICAgICAgICAgICAgICAgKiB0aGVzZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIDwgMTI4XG4gICAgICAgICAgICAgICAgICAgID8gYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChjKS5yZXBsYWNlKC8lL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnJvbUhleChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5sZW5ndGggPT0gMFxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IGRlY29kZVVSSUNvbXBvbmVudCgnJScgKyAocy5tYXRjaCgvLnsxLDJ9L2cpIHx8IFtdKS5qb2luKCclJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kZUNvbW1lbnQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShuZXcgUmVnRXhwKG1hc2sobmV3bGluZUNoYXIpLCAnZycpLCAnICcpO1xuICAgICAgICAgICAgcmV0dXJuIGB7JHt0b0hleChzLnNsaWNlKDEsIHMubGVuZ3RoIC0gMSkpfX1gO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVDb21tZW50ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLnN0YXJ0c1dpdGgoJ3snKSAmJiBzLmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUhleChzLnNsaWNlKDEsIHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgaGVhZGVyIHRvIGdldCB0aGUgbW92ZXNcbiAgICAgICAgbGV0IG1zID0gcGduXG4gICAgICAgICAgICAucmVwbGFjZShoZWFkZXJTdHJpbmcsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgIC8vIGVuY29kZSBjb21tZW50cyBzbyB0aGV5IGRvbid0IGdldCBkZWxldGVkIGJlbG93XG4gICAgICAgIG5ldyBSZWdFeHAoYCh7W159XSp9KSs/fDsoW14ke21hc2sobmV3bGluZUNoYXIpfV0qKWAsICdnJyksIGZ1bmN0aW9uIChfbWF0Y2gsIGJyYWNrZXQsIHNlbWljb2xvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJyYWNrZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZW5jb2RlQ29tbWVudChicmFja2V0KVxuICAgICAgICAgICAgICAgIDogJyAnICsgZW5jb2RlQ29tbWVudChgeyR7c2VtaWNvbG9uLnNsaWNlKDEpfX1gKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhciksICdnJyksICcgJyk7XG4gICAgICAgIC8vIGRlbGV0ZSByZWN1cnNpdmUgYW5ub3RhdGlvbiB2YXJpYXRpb25zXG4gICAgICAgIGNvbnN0IHJhdlJlZ2V4ID0gLyhcXChbXigpXStcXCkpKz8vZztcbiAgICAgICAgd2hpbGUgKHJhdlJlZ2V4LnRlc3QobXMpKSB7XG4gICAgICAgICAgICBtcyA9IG1zLnJlcGxhY2UocmF2UmVnZXgsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxldGUgbW92ZSBudW1iZXJzXG4gICAgICAgIG1zID0gbXMucmVwbGFjZSgvXFxkK1xcLihcXC5cXC4pPy9nLCAnJyk7XG4gICAgICAgIC8vIGRlbGV0ZSAuLi4gaW5kaWNhdGluZyBibGFjayB0byBtb3ZlXG4gICAgICAgIG1zID0gbXMucmVwbGFjZSgvXFwuXFwuXFwuL2csICcnKTtcbiAgICAgICAgLyogZGVsZXRlIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgKi9cbiAgICAgICAgbXMgPSBtcy5yZXBsYWNlKC9cXCRcXGQrL2csICcnKTtcbiAgICAgICAgLy8gdHJpbSBhbmQgZ2V0IGFycmF5IG9mIG1vdmVzXG4gICAgICAgIGxldCBtb3ZlcyA9IG1zLnRyaW0oKS5zcGxpdChuZXcgUmVnRXhwKC9cXHMrLykpO1xuICAgICAgICAvLyBkZWxldGUgZW1wdHkgZW50cmllc1xuICAgICAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcigobW92ZSkgPT4gbW92ZSAhPT0gJycpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGhhbGZNb3ZlID0gMDsgaGFsZk1vdmUgPCBtb3Zlcy5sZW5ndGg7IGhhbGZNb3ZlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBkZWNvZGVDb21tZW50KG1vdmVzW2hhbGZNb3ZlXSk7XG4gICAgICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX21vdmVGcm9tU2FuKG1vdmVzW2hhbGZNb3ZlXSwgc3RyaWN0KTtcbiAgICAgICAgICAgIC8vIGludmFsaWQgbW92ZVxuICAgICAgICAgICAgaWYgKG1vdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdhcyB0aGUgbW92ZSBhbiBlbmQgb2YgZ2FtZSBtYXJrZXJcbiAgICAgICAgICAgICAgICBpZiAoVEVSTUlOQVRJT05fTUFSS0VSUy5pbmRleE9mKG1vdmVzW2hhbGZNb3ZlXSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb3Zlc1toYWxmTW92ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZSBpbiBQR046ICR7bW92ZXNbaGFsZk1vdmVdfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBlbmQgb2YgZ2FtZSBtYXJrZXIgaWYgbWFraW5nIGEgdmFsaWQgbW92ZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQodGhpcy5mZW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogUGVyIHNlY3Rpb24gOC4yLjYgb2YgdGhlIFBHTiBzcGVjLCB0aGUgUmVzdWx0IHRhZyBwYWlyIG11c3QgbWF0Y2ggbWF0Y2hcbiAgICAgICAgICogdGhlIHRlcm1pbmF0aW9uIG1hcmtlci4gT25seSBkbyB0aGlzIHdoZW4gaGVhZGVycyBhcmUgcHJlc2VudCwgYnV0IHRoZVxuICAgICAgICAgKiByZXN1bHQgdGFnIGlzIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXN1bHQgJiYgT2JqZWN0LmtleXModGhpcy5faGVhZGVyKS5sZW5ndGggJiYgIXRoaXMuX2hlYWRlclsnUmVzdWx0J10pIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKCdSZXN1bHQnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogQ29udmVydCBhIG1vdmUgZnJvbSAweDg4IGNvb3JkaW5hdGVzIHRvIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvblxuICAgICAqIChTQU4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0cmljdCBVc2UgdGhlIHN0cmljdCBTQU4gcGFyc2VyLiBJdCB3aWxsIHRocm93IGVycm9yc1xuICAgICAqIG9uIG92ZXJseSBkaXNhbWJpZ3VhdGVkIG1vdmVzIChzZWUgYmVsb3cpOlxuICAgICAqXG4gICAgICogcjFicWtibnIvcHBwMnBwcC8ybjUvMUIxcFAzLzRQMy84L1BQUFAyUFAvUk5CUUsxTlIgYiBLUWtxIC0gMiA0XG4gICAgICogNC4gLi4uIE5nZTcgaXMgb3Zlcmx5IGRpc2FtYmlndWF0ZWQgYmVjYXVzZSB0aGUga25pZ2h0IG9uIGM2IGlzIHBpbm5lZFxuICAgICAqIDQuIC4uLiBOZTcgaXMgdGVjaG5pY2FsbHkgdGhlIHZhbGlkIFNBTlxuICAgICAqL1xuICAgIF9tb3ZlVG9TYW4obW92ZSwgbW92ZXMpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9ICcnO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSAnTy1PJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8tTyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbW92ZS5waWVjZS50b1VwcGVyQ2FzZSgpICsgZGlzYW1iaWd1YXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAneCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pO1xuICAgICAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGVja21hdGUoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnIyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJysnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcbiAgICBfbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gc3RyaXAgb2ZmIGFueSBtb3ZlIGRlY29yYXRpb25zOiBlLmcgTmYzKz8hIGJlY29tZXMgTmYzXG4gICAgICAgIGNvbnN0IGNsZWFuTW92ZSA9IHN0cmlwcGVkU2FuKG1vdmUpO1xuICAgICAgICBsZXQgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcbiAgICAgICAgbGV0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBsZWdhbDogdHJ1ZSwgcGllY2U6IHBpZWNlVHlwZSB9KTtcbiAgICAgICAgLy8gc3RyaWN0IHBhcnNlclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09IHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc3RyaWN0IHBhcnNlciBmYWlsZWRcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBpZWNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHByb21vdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGRlZmF1bHQgcGVybWlzc2l2ZSAobm9uLXN0cmljdCkgcGFyc2VyIGFsbG93cyB0aGUgdXNlciB0byBwYXJzZVxuICAgICAgICAgKiBub24tc3RhbmRhcmQgY2hlc3Mgbm90YXRpb25zLiBUaGlzIHBhcnNlciBpcyBvbmx5IHJ1biBhZnRlciB0aGUgc3RyaWN0XG4gICAgICAgICAqIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvbiAoU0FOKSBwYXJzZXIgaGFzIGZhaWxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBydW5uaW5nIHRoZSBwZXJtaXNzaXZlIHBhcnNlciwgd2UnbGwgcnVuIGEgcmVnZXggdG8gZ3JhYiB0aGUgcGllY2UsIHRoZVxuICAgICAgICAgKiB0by9mcm9tIHNxdWFyZSwgYW5kIGFuIG9wdGlvbmFsIHByb21vdGlvbiBwaWVjZS4gVGhpcyByZWdleCB3aWxsXG4gICAgICAgICAqIHBhcnNlIGNvbW1vbiBub24tc3RhbmRhcmQgbm90YXRpb24gbGlrZTogUGUyLWU0LCBSYzFjNCwgUWYzeGY3LFxuICAgICAgICAgKiBmN2Y4cSwgYjFjM1xuICAgICAgICAgKlxuICAgICAgICAgKiBOT1RFOiBTb21lIHBvc2l0aW9ucyBhbmQgbW92ZXMgbWF5IGJlIGFtYmlndW91cyB3aGVuIHVzaW5nIHRoZSBwZXJtaXNzaXZlXG4gICAgICAgICAqIHBhcnNlci4gRm9yIGV4YW1wbGUsIGluIHRoaXMgcG9zaXRpb246IDZrMS84LzgvQjcvOC84LzgvQk40SzEgdyAtIC0gMCAxLFxuICAgICAgICAgKiB0aGUgbW92ZSBiMWMzIG1heSBiZSBpbnRlcnByZXRlZCBhcyBOYzMgb3IgQjFjMyAoYSBkaXNhbWJpZ3VhdGVkIGJpc2hvcFxuICAgICAgICAgKiBtb3ZlKS4gSW4gdGhlc2UgY2FzZXMsIHRoZSBwZXJtaXNzaXZlIHBhcnNlciB3aWxsIGRlZmF1bHQgdG8gdGhlIG1vc3RcbiAgICAgICAgICogYmFzaWMgaW50ZXJwcmV0YXRpb24gKHdoaWNoIGlzIGIxYzMgcGFyc2luZyB0byBOYzMpLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG92ZXJseURpc2FtYmlndWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaCgvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF1bMS04XSl4Py0/KFthLWhdWzEtOF0pKFtxcmJuUVJCTl0pPy8pO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgcGllY2UgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgZnJvbSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB0byA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBvdmVybHlEaXNhbWJpZ3VhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgW2EtaF0/WzEtOF0/IHBvcnRpb24gb2YgdGhlIHJlZ2V4IGJlbG93IGhhbmRsZXMgbW92ZXMgdGhhdCBtYXkgYmVcbiAgICAgICAgICAgICAqIG92ZXJseSBkaXNhbWJpZ3VhdGVkIChlLmcuIE5nZTcgaXMgdW5uZWNlc3NhcnkgYW5kIG5vbi1zdGFuZGFyZCB3aGVuXG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBvbmUgbGVnYWwga25pZ2h0IG1vdmUgdG8gZTcpLiBJbiB0aGlzIGNhc2UsIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgICAgICogJ2Zyb20nIHZhcmlhYmxlIHdpbGwgYmUgYSByYW5rIG9yIGZpbGUsIG5vdCBhIHNxdWFyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaCgvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF0/WzEtOF0/KXg/LT8oW2EtaF1bMS04XSkoW3FyYm5RUkJOXSk/Lyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHBpZWNlID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICBmcm9tID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgICAgICB0byA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgcHJvbW90aW9uID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybHlEaXNhbWJpZ3VhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcbiAgICAgICAgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7XG4gICAgICAgICAgICBsZWdhbDogdHJ1ZSxcbiAgICAgICAgICAgIHBpZWNlOiBwaWVjZSA/IHBpZWNlIDogcGllY2VUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0bykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZyb20pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmcm9tIHNxdWFyZSwgaXQgY291bGQgYmUganVzdCAneCcgbWlzc2luZyBmcm9tIGEgY2FwdHVyZVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09XG4gICAgICAgICAgICAgICAgICAgIHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKS5yZXBsYWNlKCd4JywgJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGFuZC1jb21wYXJlIG1vdmUgcHJvcGVydGllcyB3aXRoIHRoZSByZXN1bHRzIGZyb20gb3VyIHBlcm1pc3NpdmUgcmVnZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCghcGllY2UgfHwgcGllY2UudG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5waWVjZSkgJiZcbiAgICAgICAgICAgICAgICBPeDg4W2Zyb21dID09IG1vdmVzW2ldLmZyb20gJiZcbiAgICAgICAgICAgICAgICBPeDg4W3RvXSA9PSBtb3Zlc1tpXS50byAmJlxuICAgICAgICAgICAgICAgICghcHJvbW90aW9uIHx8IHByb21vdGlvbi50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybHlEaXNhbWJpZ3VhdGVkKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBTUEVDSUFMIENBU0U6IHdlIHBhcnNlZCBhIG1vdmUgc3RyaW5nIHRoYXQgbWF5IGhhdmUgYW4gdW5uZWVkZWRcbiAgICAgICAgICAgICAgICAgKiByYW5rL2ZpbGUgZGlzYW1iaWd1YXRvciAoZS5nLiBOZ2U3KS4gIFRoZSAnZnJvbScgdmFyaWFibGUgd2lsbFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZSA9IGFsZ2VicmFpYyhtb3Zlc1tpXS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoKCFwaWVjZSB8fCBwaWVjZS50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnBpZWNlKSAmJlxuICAgICAgICAgICAgICAgICAgICBPeDg4W3RvXSA9PSBtb3Zlc1tpXS50byAmJlxuICAgICAgICAgICAgICAgICAgICAoZnJvbSA9PSBzcXVhcmVbMF0gfHwgZnJvbSA9PSBzcXVhcmVbMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICghcHJvbW90aW9uIHx8IHByb21vdGlvbi50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXNjaWkoKSB7XG4gICAgICAgIGxldCBzID0gJyAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXFxuJztcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkaXNwbGF5IHRoZSByYW5rXG4gICAgICAgICAgICBpZiAoZmlsZShpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnICsgJzg3NjU0MzIxJ1tyYW5rKGkpXSArICcgfCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9ib2FyZFtpXS5jb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBjb2xvciA9PT0gV0hJVEUgPyBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzICs9ICcgJyArIHN5bWJvbCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAuICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBzICs9ICd8XFxuJztcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xuICAgICAgICBzICs9ICcgICAgIGEgIGIgIGMgIGQgIGUgIGYgIGcgIGgnO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcGVyZnQoZGVwdGgpIHtcbiAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiBmYWxzZSB9KTtcbiAgICAgICAgbGV0IG5vZGVzID0gMDtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl90dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNLaW5nQXR0YWNrZWQoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIC0gMSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMgKz0gdGhpcy5wZXJmdChkZXB0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdHVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm47XG4gICAgfVxuICAgIGJvYXJkKCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZTogYWxnZWJyYWljKGkpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9ib2FyZFtpXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5fYm9hcmRbaV0uY29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBzcXVhcmVDb2xvcihzcXVhcmUpIHtcbiAgICAgICAgaWYgKHNxdWFyZSBpbiBPeDg4KSB7XG4gICAgICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgICAgIHJldHVybiAocmFuayhzcSkgKyBmaWxlKHNxKSkgJSAyID09PSAwID8gJ2xpZ2h0JyA6ICdkYXJrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGlzdG9yeSh7IHZlcmJvc2UgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIGNvbnN0IG1vdmVIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIG1vdmVIaXN0b3J5LnB1c2gobmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaCh0aGlzLl9tb3ZlVG9TYW4obW92ZSwgdGhpcy5fbW92ZXMoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVIaXN0b3J5O1xuICAgIH1cbiAgICAvKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHBvc2l0aW9uIG9jY3VycmVuY2UgY291bnRzIGZvciB0aGUgcHVycG9zZSBvZiByZXBldGl0aW9uXG4gICAgICogY2hlY2tpbmcuIEFsbCB0aHJlZSBtZXRob2RzIChgX2luY2AsIGBfZGVjYCwgYW5kIGBfZ2V0YCkgdHJpbSB0aGVcbiAgICAgKiBpcnJlbGV2ZW50IGluZm9ybWF0aW9uIGZyb20gdGhlIGZlbiwgaW5pdGlhbGlzaW5nIG5ldyBwb3NpdGlvbnMsIGFuZFxuICAgICAqIHJlbW92aW5nIG9sZCBwb3NpdGlvbnMgZnJvbSB0aGUgcmVjb3JkIGlmIHRoZWlyIGNvdW50cyBhcmUgcmVkdWNlZCB0byAwLlxuICAgICAqL1xuICAgIF9nZXRQb3NpdGlvbkNvdW50KGZlbikge1xuICAgICAgICBjb25zdCB0cmltbWVkRmVuID0gdHJpbUZlbihmZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSB8fCAwO1xuICAgIH1cbiAgICBfaW5jUG9zaXRpb25Db3VudChmZW4pIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZEZlbiA9IHRyaW1GZW4oZmVuKTtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ291bnRbdHJpbW1lZEZlbl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSArPSAxO1xuICAgIH1cbiAgICBfZGVjUG9zaXRpb25Db3VudChmZW4pIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZEZlbiA9IHRyaW1GZW4oZmVuKTtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ291bnRbdHJpbW1lZEZlbl0gPT09IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wb3NpdGlvbkNvdW50W3RyaW1tZWRGZW5dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcnVuZUNvbW1lbnRzKCkge1xuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbW1lbnRzID0ge307XG4gICAgICAgIGNvbnN0IGNvcHlDb21tZW50ID0gKGZlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGZlbiBpbiB0aGlzLl9jb21tZW50cykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21tZW50c1tmZW5dID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29weUNvbW1lbnQodGhpcy5mZW4oKSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgIGNvcHlDb21tZW50KHRoaXMuZmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0gY3VycmVudENvbW1lbnRzO1xuICAgIH1cbiAgICBnZXRDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgfVxuICAgIHNldENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXSA9IGNvbW1lbnQucmVwbGFjZSgneycsICdbJykucmVwbGFjZSgnfScsICddJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFJlbmFtZWQgdG8gYHJlbW92ZUNvbW1lbnRgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbW1lbnQoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbWVudCgpIHtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICBnZXRDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogdGhpcy5fY29tbWVudHNbZmVuXSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudHNgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21tZW50cygpO1xuICAgIH1cbiAgICByZW1vdmVDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgcmV0dXJuIHsgZmVuOiBmZW4sIGNvbW1lbnQ6IGNvbW1lbnQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENhc3RsaW5nUmlnaHRzKGNvbG9yLCByaWdodHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzaWRlIG9mIFtLSU5HLCBRVUVFTl0pIHtcbiAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdIHw9IFNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdICY9IH5TSURFU1tzaWRlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDYXN0bGluZ1JpZ2h0cyhjb2xvcik7XG4gICAgICAgIHJldHVybiAoKHJpZ2h0c1tLSU5HXSA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0c1tLSU5HXSA9PT0gcmVzdWx0W0tJTkddKSAmJlxuICAgICAgICAgICAgKHJpZ2h0c1tRVUVFTl0gPT09IHVuZGVmaW5lZCB8fCByaWdodHNbUVVFRU5dID09PSByZXN1bHRbUVVFRU5dKSk7XG4gICAgfVxuICAgIGdldENhc3RsaW5nUmlnaHRzKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbS0lOR106ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tLSU5HXSkgIT09IDAsXG4gICAgICAgICAgICBbUVVFRU5dOiAodGhpcy5fY2FzdGxpbmdbY29sb3JdICYgU0lERVNbUVVFRU5dKSAhPT0gMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW92ZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVOdW1iZXI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlc3MuanMubWFwIl0sIm5hbWVzIjpbIldISVRFIiwiQkxBQ0siLCJQQVdOIiwiS05JR0hUIiwiQklTSE9QIiwiUk9PSyIsIlFVRUVOIiwiS0lORyIsIkRFRkFVTFRfUE9TSVRJT04iLCJNb3ZlIiwiY29uc3RydWN0b3IiLCJjaGVzcyIsImludGVybmFsIiwiY29sb3IiLCJwaWVjZSIsImZyb20iLCJ0byIsImZsYWdzIiwiY2FwdHVyZWQiLCJwcm9tb3Rpb24iLCJmcm9tQWxnZWJyYWljIiwiYWxnZWJyYWljIiwidG9BbGdlYnJhaWMiLCJzYW4iLCJsZWdhbCIsImxhbiIsImJlZm9yZSIsImZlbiIsImFmdGVyIiwiZmxhZyIsIkJJVFMiLCJGTEFHUyIsImlzQ2FwdHVyZSIsImluZGV4T2YiLCJpc1Byb21vdGlvbiIsImlzRW5QYXNzYW50IiwiaXNLaW5nc2lkZUNhc3RsZSIsImlzUXVlZW5zaWRlQ2FzdGxlIiwiaXNCaWdQYXduIiwiRU1QVFkiLCJOT1JNQUwiLCJDQVBUVVJFIiwiQklHX1BBV04iLCJFUF9DQVBUVVJFIiwiUFJPTU9USU9OIiwiS1NJREVfQ0FTVExFIiwiUVNJREVfQ0FTVExFIiwiU1FVQVJFUyIsIk94ODgiLCJhOCIsImI4IiwiYzgiLCJkOCIsImU4IiwiZjgiLCJnOCIsImg4IiwiYTciLCJiNyIsImM3IiwiZDciLCJlNyIsImY3IiwiZzciLCJoNyIsImE2IiwiYjYiLCJjNiIsImQ2IiwiZTYiLCJmNiIsImc2IiwiaDYiLCJhNSIsImI1IiwiYzUiLCJkNSIsImU1IiwiZjUiLCJnNSIsImg1IiwiYTQiLCJiNCIsImM0IiwiZDQiLCJlNCIsImY0IiwiZzQiLCJoNCIsImEzIiwiYjMiLCJjMyIsImQzIiwiZTMiLCJmMyIsImczIiwiaDMiLCJhMiIsImIyIiwiYzIiLCJkMiIsImUyIiwiZjIiLCJnMiIsImgyIiwiYTEiLCJiMSIsImMxIiwiZDEiLCJlMSIsImYxIiwiZzEiLCJoMSIsIlBBV05fT0ZGU0VUUyIsImIiLCJ3IiwiUElFQ0VfT0ZGU0VUUyIsIm4iLCJyIiwicSIsImsiLCJBVFRBQ0tTIiwiUkFZUyIsIlBJRUNFX01BU0tTIiwicCIsIlNZTUJPTFMiLCJQUk9NT1RJT05TIiwiUkFOS18xIiwiUkFOS18yIiwiUkFOS183IiwiUkFOS184IiwiU0lERVMiLCJST09LUyIsInNxdWFyZSIsIlNFQ09ORF9SQU5LIiwiVEVSTUlOQVRJT05fTUFSS0VSUyIsInJhbmsiLCJmaWxlIiwiaXNEaWdpdCIsImMiLCJmIiwic3Vic3RyaW5nIiwic3dhcENvbG9yIiwidmFsaWRhdGVGZW4iLCJ0b2tlbnMiLCJzcGxpdCIsImxlbmd0aCIsIm9rIiwiZXJyb3IiLCJtb3ZlTnVtYmVyIiwicGFyc2VJbnQiLCJpc05hTiIsImhhbGZNb3ZlcyIsInRlc3QiLCJyb3dzIiwiaSIsInN1bUZpZWxkcyIsInByZXZpb3VzV2FzTnVtYmVyIiwia2luZ3MiLCJyZWdleCIsIm1hdGNoIiwiQXJyYXkiLCJzb21lIiwiY2hhciIsInRvVXBwZXJDYXNlIiwiZ2V0RGlzYW1iaWd1YXRvciIsIm1vdmUiLCJtb3ZlcyIsImFtYmlndWl0aWVzIiwic2FtZVJhbmsiLCJzYW1lRmlsZSIsImxlbiIsImFtYmlnRnJvbSIsImFtYmlnVG8iLCJhbWJpZ1BpZWNlIiwiY2hhckF0IiwiYWRkTW92ZSIsInVuZGVmaW5lZCIsInB1c2giLCJpbmZlclBpZWNlVHlwZSIsInBpZWNlVHlwZSIsIm1hdGNoZXMiLCJ0b0xvd2VyQ2FzZSIsInN0cmlwcGVkU2FuIiwicmVwbGFjZSIsInRyaW1GZW4iLCJzbGljZSIsImpvaW4iLCJDaGVzcyIsInNraXBWYWxpZGF0aW9uIiwiX2JvYXJkIiwiX3R1cm4iLCJfaGVhZGVyIiwiX2tpbmdzIiwiX2VwU3F1YXJlIiwiX2hhbGZNb3ZlcyIsIl9tb3ZlTnVtYmVyIiwiX2hpc3RvcnkiLCJfY29tbWVudHMiLCJfY2FzdGxpbmciLCJfcG9zaXRpb25Db3VudCIsImxvYWQiLCJjbGVhciIsInByZXNlcnZlSGVhZGVycyIsImFkanVzdG1lbnRzIiwiY29uY2F0IiwiRXJyb3IiLCJwb3NpdGlvbiIsIl9wdXQiLCJ0eXBlIiwiX3VwZGF0ZVNldHVwIiwiX2luY1Bvc2l0aW9uQ291bnQiLCJlbXB0eSIsImNhc3RsaW5nIiwiZXBTcXVhcmUiLCJiaWdQYXduU3F1YXJlIiwic3F1YXJlcyIsIl9tYWtlTW92ZSIsImlzTGVnYWwiLCJfaXNLaW5nQXR0YWNrZWQiLCJfdW5kb01vdmUiLCJyZXNldCIsImdldCIsInB1dCIsIl91cGRhdGVDYXN0bGluZ1JpZ2h0cyIsIl91cGRhdGVFblBhc3NhbnRTcXVhcmUiLCJzcSIsImN1cnJlbnRQaWVjZU9uU3F1YXJlIiwicmVtb3ZlIiwid2hpdGVLaW5nSW5QbGFjZSIsImJsYWNrS2luZ0luUGxhY2UiLCJzdGFydFNxdWFyZSIsImN1cnJlbnRTcXVhcmUiLCJhdHRhY2tlcnMiLCJjYW5DYXB0dXJlIiwiX2F0dGFja2VkIiwidmVyYm9zZSIsImRpZmZlcmVuY2UiLCJpbmRleCIsIm9mZnNldCIsImoiLCJibG9ja2VkIiwiYXR0YWNrZWRCeSIsImlzQXR0YWNrZWQiLCJpc0NoZWNrIiwiaW5DaGVjayIsImlzQ2hlY2ttYXRlIiwiX21vdmVzIiwiaXNTdGFsZW1hdGUiLCJpc0luc3VmZmljaWVudE1hdGVyaWFsIiwicGllY2VzIiwiYmlzaG9wcyIsIm51bVBpZWNlcyIsInNxdWFyZUNvbG9yIiwic3VtIiwiaXNUaHJlZWZvbGRSZXBldGl0aW9uIiwiX2dldFBvc2l0aW9uQ291bnQiLCJpc0RyYXdCeUZpZnR5TW92ZXMiLCJpc0RyYXciLCJpc0dhbWVPdmVyIiwibWFwIiwiX21vdmVUb1NhbiIsImZvclNxdWFyZSIsImZvclBpZWNlIiwidXMiLCJ0aGVtIiwiZmlyc3RTcXVhcmUiLCJsYXN0U3F1YXJlIiwic2luZ2xlU3F1YXJlIiwiY2FzdGxpbmdGcm9tIiwiY2FzdGxpbmdUbyIsImxlZ2FsTW92ZXMiLCJzdHJpY3QiLCJtb3ZlT2JqIiwiX21vdmVGcm9tU2FuIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXR0eU1vdmUiLCJfcHVzaCIsInR1cm4iLCJ1bmRvIiwiX2RlY1Bvc2l0aW9uQ291bnQiLCJvbGQiLCJwb3AiLCJwZ24iLCJuZXdsaW5lIiwibWF4V2lkdGgiLCJyZXN1bHQiLCJoZWFkZXJFeGlzdHMiLCJhcHBlbmRDb21tZW50IiwibW92ZVN0cmluZyIsImNvbW1lbnQiLCJkZWxpbWl0ZXIiLCJyZXZlcnNlZEhpc3RvcnkiLCJwcmVmaXgiLCJSZXN1bHQiLCJzdHJpcCIsIndyYXBDb21tZW50Iiwid2lkdGgiLCJ0b2tlbiIsImN1cnJlbnRXaWR0aCIsImluY2x1ZGVzIiwiaGVhZGVyIiwiYXJncyIsInNldEhlYWRlciIsImtleSIsInZhbHVlIiwicmVtb3ZlSGVhZGVyIiwiZ2V0SGVhZGVycyIsImxvYWRQZ24iLCJuZXdsaW5lQ2hhciIsIm1hc2siLCJzdHIiLCJwYXJzZVBnbkhlYWRlciIsImhlYWRlck9iaiIsImhlYWRlcnMiLCJSZWdFeHAiLCJ0cmltIiwiaGVhZGVyUmVnZXgiLCJoZWFkZXJSZWdleFJlc3VsdHMiLCJleGVjIiwiaGVhZGVyU3RyaW5nIiwidG9IZXgiLCJzIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZnJvbUhleCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZUNvbW1lbnQiLCJkZWNvZGVDb21tZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwibXMiLCJfbWF0Y2giLCJicmFja2V0Iiwic2VtaWNvbG9uIiwicmF2UmVnZXgiLCJmaWx0ZXIiLCJoYWxmTW92ZSIsIk9iamVjdCIsImtleXMiLCJvdXRwdXQiLCJkaXNhbWJpZ3VhdG9yIiwiY2xlYW5Nb3ZlIiwib3Zlcmx5RGlzYW1iaWd1YXRlZCIsImFzY2lpIiwic3ltYm9sIiwicGVyZnQiLCJkZXB0aCIsIm5vZGVzIiwiYm9hcmQiLCJyb3ciLCJoaXN0b3J5IiwibW92ZUhpc3RvcnkiLCJ0cmltbWVkRmVuIiwiX3BydW5lQ29tbWVudHMiLCJjdXJyZW50Q29tbWVudHMiLCJjb3B5Q29tbWVudCIsImdldENvbW1lbnQiLCJzZXRDb21tZW50IiwiZGVsZXRlQ29tbWVudCIsInJlbW92ZUNvbW1lbnQiLCJnZXRDb21tZW50cyIsImRlbGV0ZUNvbW1lbnRzIiwicmVtb3ZlQ29tbWVudHMiLCJzZXRDYXN0bGluZ1JpZ2h0cyIsInJpZ2h0cyIsInNpZGUiLCJnZXRDYXN0bGluZ1JpZ2h0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chess.js/dist/esm/chess.js\n");

/***/ })

};
;