/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/analysis/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Camirn%5COneDrive%5Cchessmentor%5Csrc%5Capp%5Canalysis%5Cpage.tsx&server=false!":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Camirn%5COneDrive%5Cchessmentor%5Csrc%5Capp%5Canalysis%5Cpage.tsx&server=false! ***!
  \***********************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/analysis/page.tsx */ \"(app-pages-browser)/./src/app/analysis/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNhbWlybiU1Q09uZURyaXZlJTVDY2hlc3NtZW50b3IlNUNzcmMlNUNhcHAlNUNhbmFseXNpcyU1Q3BhZ2UudHN4JnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz83YjFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcYW1pcm5cXFxcT25lRHJpdmVcXFxcY2hlc3NtZW50b3JcXFxcc3JjXFxcXGFwcFxcXFxhbmFseXNpc1xcXFxwYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Camirn%5COneDrive%5Cchessmentor%5Csrc%5Capp%5Canalysis%5Cpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: function() { return /* binding */ BISHOP; },\n/* harmony export */   BLACK: function() { return /* binding */ BLACK; },\n/* harmony export */   Chess: function() { return /* binding */ Chess; },\n/* harmony export */   DEFAULT_POSITION: function() { return /* binding */ DEFAULT_POSITION; },\n/* harmony export */   KING: function() { return /* binding */ KING; },\n/* harmony export */   KNIGHT: function() { return /* binding */ KNIGHT; },\n/* harmony export */   Move: function() { return /* binding */ Move; },\n/* harmony export */   PAWN: function() { return /* binding */ PAWN; },\n/* harmony export */   QUEEN: function() { return /* binding */ QUEEN; },\n/* harmony export */   ROOK: function() { return /* binding */ ROOK; },\n/* harmony export */   SQUARES: function() { return /* binding */ SQUARES; },\n/* harmony export */   WHITE: function() { return /* binding */ WHITE; },\n/* harmony export */   validateFen: function() { return /* binding */ validateFen; }\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */ const WHITE = \"w\";\nconst BLACK = \"b\";\nconst PAWN = \"p\";\nconst KNIGHT = \"n\";\nconst BISHOP = \"b\";\nconst ROOK = \"r\";\nconst QUEEN = \"q\";\nconst KING = \"k\";\nconst DEFAULT_POSITION = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\nclass Move {\n    isCapture() {\n        return this.flags.indexOf(FLAGS[\"CAPTURE\"]) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS[\"PROMOTION\"]) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS[\"EP_CAPTURE\"]) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS[\"KSIDE_CASTLE\"]) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS[\"QSIDE_CASTLE\"]) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS[\"BIG_PAWN\"]) > -1;\n    }\n    constructor(chess, internal){\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */ this.san = chess[\"_moveToSan\"](internal, chess[\"_moves\"]({\n            legal: true\n        }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess[\"_makeMove\"](internal);\n        this.after = chess.fen();\n        chess[\"_undoMove\"]();\n        // Build the text representation of the move flags\n        this.flags = \"\";\n        for(const flag in BITS){\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: \"n\",\n    CAPTURE: \"c\",\n    BIG_PAWN: \"b\",\n    EP_CAPTURE: \"e\",\n    PROMOTION: \"p\",\n    KSIDE_CASTLE: \"k\",\n    QSIDE_CASTLE: \"q\"\n};\n// prettier-ignore\nconst SQUARES = [\n    \"a8\",\n    \"b8\",\n    \"c8\",\n    \"d8\",\n    \"e8\",\n    \"f8\",\n    \"g8\",\n    \"h8\",\n    \"a7\",\n    \"b7\",\n    \"c7\",\n    \"d7\",\n    \"e7\",\n    \"f7\",\n    \"g7\",\n    \"h7\",\n    \"a6\",\n    \"b6\",\n    \"c6\",\n    \"d6\",\n    \"e6\",\n    \"f6\",\n    \"g6\",\n    \"h6\",\n    \"a5\",\n    \"b5\",\n    \"c5\",\n    \"d5\",\n    \"e5\",\n    \"f5\",\n    \"g5\",\n    \"h5\",\n    \"a4\",\n    \"b4\",\n    \"c4\",\n    \"d4\",\n    \"e4\",\n    \"f4\",\n    \"g4\",\n    \"h4\",\n    \"a3\",\n    \"b3\",\n    \"c3\",\n    \"d3\",\n    \"e3\",\n    \"f3\",\n    \"g3\",\n    \"h3\",\n    \"a2\",\n    \"b2\",\n    \"c2\",\n    \"d2\",\n    \"e2\",\n    \"f2\",\n    \"g2\",\n    \"h2\",\n    \"a1\",\n    \"b1\",\n    \"c1\",\n    \"d1\",\n    \"e1\",\n    \"f1\",\n    \"g1\",\n    \"h1\"\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */ // prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0,\n    b8: 1,\n    c8: 2,\n    d8: 3,\n    e8: 4,\n    f8: 5,\n    g8: 6,\n    h8: 7,\n    a7: 16,\n    b7: 17,\n    c7: 18,\n    d7: 19,\n    e7: 20,\n    f7: 21,\n    g7: 22,\n    h7: 23,\n    a6: 32,\n    b6: 33,\n    c6: 34,\n    d6: 35,\n    e6: 36,\n    f6: 37,\n    g6: 38,\n    h6: 39,\n    a5: 48,\n    b5: 49,\n    c5: 50,\n    d5: 51,\n    e5: 52,\n    f5: 53,\n    g5: 54,\n    h5: 55,\n    a4: 64,\n    b4: 65,\n    c4: 66,\n    d4: 67,\n    e4: 68,\n    f4: 69,\n    g4: 70,\n    h4: 71,\n    a3: 80,\n    b3: 81,\n    c3: 82,\n    d3: 83,\n    e3: 84,\n    f3: 85,\n    g3: 86,\n    h3: 87,\n    a2: 96,\n    b2: 97,\n    c2: 98,\n    d2: 99,\n    e2: 100,\n    f2: 101,\n    g2: 102,\n    h2: 103,\n    a1: 112,\n    b1: 113,\n    c1: 114,\n    d1: 115,\n    e1: 116,\n    f1: 117,\n    g1: 118,\n    h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [\n        16,\n        32,\n        17,\n        15\n    ],\n    w: [\n        -16,\n        -32,\n        -17,\n        -15\n    ]\n};\nconst PIECE_OFFSETS = {\n    n: [\n        -18,\n        -33,\n        -31,\n        -14,\n        18,\n        33,\n        31,\n        14\n    ],\n    b: [\n        -17,\n        -15,\n        17,\n        15\n    ],\n    r: [\n        -16,\n        1,\n        16,\n        -1\n    ],\n    q: [\n        -17,\n        -16,\n        -15,\n        1,\n        17,\n        16,\n        15,\n        -1\n    ],\n    k: [\n        -17,\n        -16,\n        -15,\n        1,\n        17,\n        16,\n        15,\n        -1\n    ]\n};\n// prettier-ignore\nconst ATTACKS = [\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    24,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    2,\n    24,\n    2,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    53,\n    56,\n    53,\n    2,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    56,\n    0,\n    56,\n    24,\n    24,\n    24,\n    24,\n    24,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    53,\n    56,\n    53,\n    2,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    2,\n    24,\n    2,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    24,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20,\n    0,\n    0,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    24,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    20\n];\n// prettier-ignore\nconst RAYS = [\n    17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    0,\n    16,\n    0,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    0,\n    16,\n    0,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    0,\n    16,\n    0,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    17,\n    16,\n    15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    -16,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    -16,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -17,\n    0,\n    0,\n    -15,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -16,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -17\n];\nconst PIECE_MASKS = {\n    p: 0x1,\n    n: 0x2,\n    b: 0x4,\n    r: 0x8,\n    q: 0x10,\n    k: 0x20\n};\nconst SYMBOLS = \"pnbrqkPNBRQK\";\nconst PROMOTIONS = [\n    KNIGHT,\n    BISHOP,\n    ROOK,\n    QUEEN\n];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */ const RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE\n};\nconst ROOKS = {\n    w: [\n        {\n            square: Ox88.a1,\n            flag: BITS.QSIDE_CASTLE\n        },\n        {\n            square: Ox88.h1,\n            flag: BITS.KSIDE_CASTLE\n        }\n    ],\n    b: [\n        {\n            square: Ox88.a8,\n            flag: BITS.QSIDE_CASTLE\n        },\n        {\n            square: Ox88.h8,\n            flag: BITS.KSIDE_CASTLE\n        }\n    ]\n};\nconst SECOND_RANK = {\n    b: RANK_7,\n    w: RANK_2\n};\nconst TERMINATION_MARKERS = [\n    \"1-0\",\n    \"0-1\",\n    \"1/2-1/2\",\n    \"*\"\n];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return \"0123456789\".indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return \"abcdefgh\".substring(f, f + 1) + \"87654321\".substring(r, r + 1);\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: must contain six space-delimited fields\"\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: move number must be a positive integer\"\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: half move counter number must be a non-negative integer\"\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: en-passant square is invalid\"\n        };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: castling availability is invalid\"\n        };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: side-to-move is invalid\"\n        };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split(\"/\");\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n        };\n    }\n    // 8th criterion: every row is valid?\n    for(let i = 0; i < rows.length; i++){\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for(let k = 0; k < rows[i].length; k++){\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: \"Invalid FEN: piece data is invalid (consecutive number)\"\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            } else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: \"Invalid FEN: piece data is invalid (invalid piece)\"\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: \"Invalid FEN: piece data is invalid (too many squares in rank)\"\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if (tokens[3][1] == \"3\" && tokens[1] == \"w\" || tokens[3][1] == \"6\" && tokens[1] == \"b\") {\n        return {\n            ok: false,\n            error: \"Invalid FEN: illegal en-passant square\"\n        };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        {\n            color: \"white\",\n            regex: /K/g\n        },\n        {\n            color: \"black\",\n            regex: /k/g\n        }\n    ];\n    for (const { color, regex } of kings){\n        if (!regex.test(tokens[0])) {\n            return {\n                ok: false,\n                error: \"Invalid FEN: missing \".concat(color, \" king\")\n            };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return {\n                ok: false,\n                error: \"Invalid FEN: too many \".concat(color, \" kings\")\n            };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char)=>char.toUpperCase() === \"P\")) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: some pawns are on the edge rows\"\n        };\n    }\n    return {\n        ok: true\n    };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for(let i = 0, len = moves.length; i < len; i++){\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */ if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */ return algebraic(from);\n        } else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */ return algebraic(from).charAt(1);\n        } else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return \"\";\n}\nfunction addMove(moves, color, from, to, piece) {\n    let captured = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : undefined, flags = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : BITS.NORMAL;\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for(let i = 0; i < PROMOTIONS.length; i++){\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION\n            });\n        }\n    } else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= \"a\" && pieceType <= \"h\") {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === \"o\") {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, \"\").replace(/[+#]?[?!]*$/, \"\");\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */ return fen.split(\" \").slice(0, 4).join(\" \");\n}\nclass Chess {\n    clear() {\n        let { preserveHeaders = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this._board = new Array(128);\n        this._kings = {\n            w: EMPTY,\n            b: EMPTY\n        };\n        this._turn = WHITE;\n        this._castling = {\n            w: 0,\n            b: 0\n        };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */ delete this._header[\"SetUp\"];\n        delete this._header[\"FEN\"];\n    }\n    load(fen) {\n        let { skipValidation = false, preserveHeaders = false } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = [\n                \"-\",\n                \"-\",\n                \"0\",\n                \"1\"\n            ];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(\" \");\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({\n            preserveHeaders\n        });\n        for(let i = 0; i < position.length; i++){\n            const piece = position.charAt(i);\n            if (piece === \"/\") {\n                square += 8;\n            } else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            } else {\n                const color = piece < \"a\" ? WHITE : BLACK;\n                this._put({\n                    type: piece.toLowerCase(),\n                    color\n                }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf(\"K\") > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf(\"Q\") > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf(\"k\") > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf(\"q\") > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === \"-\" ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = \"\";\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            } else {\n                empty++;\n            }\n            if (i + 1 & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += \"/\";\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = \"\";\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += \"K\";\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += \"Q\";\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += \"k\";\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += \"q\";\n        }\n        // do we have an empty castling flag?\n        castling = castling || \"-\";\n        let epSquare = \"-\";\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */ if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [\n                bigPawnSquare + 1,\n                bigPawnSquare - 1\n            ];\n            for (const square of squares){\n                var _this__board_square, _this__board_square1;\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (((_this__board_square = this._board[square]) === null || _this__board_square === void 0 ? void 0 : _this__board_square.color) === color && ((_this__board_square1 = this._board[square]) === null || _this__board_square1 === void 0 ? void 0 : _this__board_square1.type) === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber\n        ].join(\" \");\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */ _updateSetup(fen) {\n        if (this._history.length > 0) return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header[\"SetUp\"] = \"1\";\n            this._header[\"FEN\"] = fen;\n        } else {\n            delete this._header[\"SetUp\"];\n            delete this._header[\"FEN\"];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    put(param, square) {\n        let { type, color } = param;\n        if (this._put({\n            type,\n            color\n        }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put(param, square) {\n        let { type, color } = param;\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = {\n            type: type,\n            color: color\n        };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        var _this__board_Ox88_e1, _this__board_Ox88_e11, _this__board_Ox88_e8, _this__board_Ox88_e81, _this__board_Ox88_a1, _this__board_Ox88_a11, _this__board_Ox88_h1, _this__board_Ox88_h11, _this__board_Ox88_a8, _this__board_Ox88_a81, _this__board_Ox88_h8, _this__board_Ox88_h81;\n        const whiteKingInPlace = ((_this__board_Ox88_e1 = this._board[Ox88.e1]) === null || _this__board_Ox88_e1 === void 0 ? void 0 : _this__board_Ox88_e1.type) === KING && ((_this__board_Ox88_e11 = this._board[Ox88.e1]) === null || _this__board_Ox88_e11 === void 0 ? void 0 : _this__board_Ox88_e11.color) === WHITE;\n        const blackKingInPlace = ((_this__board_Ox88_e8 = this._board[Ox88.e8]) === null || _this__board_Ox88_e8 === void 0 ? void 0 : _this__board_Ox88_e8.type) === KING && ((_this__board_Ox88_e81 = this._board[Ox88.e8]) === null || _this__board_Ox88_e81 === void 0 ? void 0 : _this__board_Ox88_e81.color) === BLACK;\n        if (!whiteKingInPlace || ((_this__board_Ox88_a1 = this._board[Ox88.a1]) === null || _this__board_Ox88_a1 === void 0 ? void 0 : _this__board_Ox88_a1.type) !== ROOK || ((_this__board_Ox88_a11 = this._board[Ox88.a1]) === null || _this__board_Ox88_a11 === void 0 ? void 0 : _this__board_Ox88_a11.color) !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace || ((_this__board_Ox88_h1 = this._board[Ox88.h1]) === null || _this__board_Ox88_h1 === void 0 ? void 0 : _this__board_Ox88_h1.type) !== ROOK || ((_this__board_Ox88_h11 = this._board[Ox88.h1]) === null || _this__board_Ox88_h11 === void 0 ? void 0 : _this__board_Ox88_h11.color) !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace || ((_this__board_Ox88_a8 = this._board[Ox88.a8]) === null || _this__board_Ox88_a8 === void 0 ? void 0 : _this__board_Ox88_a8.type) !== ROOK || ((_this__board_Ox88_a81 = this._board[Ox88.a8]) === null || _this__board_Ox88_a81 === void 0 ? void 0 : _this__board_Ox88_a81.color) !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace || ((_this__board_Ox88_h8 = this._board[Ox88.h8]) === null || _this__board_Ox88_h8 === void 0 ? void 0 : _this__board_Ox88_h8.type) !== ROOK || ((_this__board_Ox88_h81 = this._board[Ox88.h8]) === null || _this__board_Ox88_h81 === void 0 ? void 0 : _this__board_Ox88_h81.color) !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        var _this__board_currentSquare, _this__board_currentSquare1;\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [\n            currentSquare + 1,\n            currentSquare - 1\n        ];\n        if (this._board[startSquare] !== null || this._board[this._epSquare] !== null || ((_this__board_currentSquare = this._board[currentSquare]) === null || _this__board_currentSquare === void 0 ? void 0 : _this__board_currentSquare.color) !== swapColor(this._turn) || ((_this__board_currentSquare1 = this._board[currentSquare]) === null || _this__board_currentSquare1 === void 0 ? void 0 : _this__board_currentSquare1.type) !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square)=>{\n            var _this__board_square, _this__board_square1;\n            return !(square & 0x88) && ((_this__board_square = this._board[square]) === null || _this__board_square === void 0 ? void 0 : _this__board_square.color) === this._turn && ((_this__board_square1 = this._board[square]) === null || _this__board_square1 === void 0 ? void 0 : _this__board_square1.type) === PAWN;\n        };\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0 && piece.color === WHITE || difference <= 0 && piece.color === BLACK) {\n                        if (!verbose) {\n                            return true;\n                        } else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === \"n\" || piece.type === \"k\") {\n                    if (!verbose) {\n                        return true;\n                    } else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while(j !== square){\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    } else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        } else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        } else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */ const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        } else if (// k vs. kn .... or .... k vs. kb\n        numPieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        } else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for(let i = 0; i < len; i++){\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return this.isDrawByFiftyMoves() || this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves() {\n        let { verbose = false, square = undefined, piece = undefined } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const moves = this._moves({\n            square,\n            piece\n        });\n        if (verbose) {\n            return moves.map((move)=>new Move(this, move));\n        } else {\n            return moves.map((move)=>this._moveToSan(move, moves));\n        }\n    }\n    _moves() {\n        let { legal = true, piece = undefined, square = undefined } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            } else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for(let from = firstSquare; from <= lastSquare; from++){\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type) continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for(let j = 2; j < 4; j++){\n                    var _this__board_to;\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88) continue;\n                    if (((_this__board_to = this._board[to]) === null || _this__board_to === void 0 ? void 0 : _this__board_to.color) === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    } else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            } else {\n                if (forPiece && forPiece !== type) continue;\n                for(let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++){\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while(true){\n                        to += offset;\n                        if (to & 0x88) break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        } else {\n                            // own color, stop loop\n                            if (this._board[to].color === us) break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */ if (type === KNIGHT || type === KING) break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */ if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */ if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for(let i = 0, len = moves.length; i < len; i++){\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move) {\n        let { strict = false } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */ let moveObj = null;\n        if (typeof move === \"string\") {\n            moveObj = this._moveFromSan(move, strict);\n        } else if (typeof move === \"object\") {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for(let i = 0, len = moves.length; i < len; i++){\n                if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!(\"promotion\" in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === \"string\") {\n                throw new Error(\"Invalid move: \".concat(move));\n            } else {\n                throw new Error(\"Invalid move: \".concat(JSON.stringify(move)));\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */ const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: {\n                b: this._kings.b,\n                w: this._kings.w\n            },\n            turn: this._turn,\n            castling: {\n                b: this._castling.b,\n                w: this._castling.w\n            },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            } else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = {\n                type: move.promotion,\n                color: us\n            };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            } else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for(let i = 0, len = ROOKS[us].length; i < len; i++){\n                if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for(let i = 0, len = ROOKS[them].length; i < len; i++){\n                if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            } else {\n                this._epSquare = move.to + 16;\n            }\n        } else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        } else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                } else {\n                    index = move.to + 16;\n                }\n                this._board[index] = {\n                    type: PAWN,\n                    color: them\n                };\n            } else {\n                // regular capture\n                this._board[move.to] = {\n                    type: move.captured,\n                    color: them\n                };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            } else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn() {\n        let { newline = \"\\n\", maxWidth = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */ const result = [];\n        let headerExists = false;\n        /* add the PGN header information */ for(const i in this._header){\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */ result.push(\"[\" + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString)=>{\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== \"undefined\") {\n                const delimiter = moveString.length > 0 ? \" \" : \"\";\n                moveString = \"\".concat(moveString).concat(delimiter, \"{\").concat(comment, \"}\");\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while(this._history.length > 0){\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = \"\";\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(\"\"));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while(reversedHistory.length > 0){\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === \"b\") {\n                const prefix = \"\".concat(this._moveNumber, \". ...\");\n                // is there a comment preceding the first move?\n                moveString = moveString ? \"\".concat(moveString, \" \").concat(prefix) : prefix;\n            } else if (move.color === \"w\") {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + \".\";\n            }\n            moveString = moveString + \" \" + this._moveToSan(move, this._moves({\n                legal: true\n            }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== \"undefined\") {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */ if (maxWidth === 0) {\n            return result.join(\"\") + moves.join(\" \");\n        }\n        // TODO (jah): huh?\n        const strip = function() {\n            if (result.length > 0 && result[result.length - 1] === \" \") {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function(width, move) {\n            for (const token of move.split(\" \")){\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while(strip()){\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(\" \");\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for(let i = 0; i < moves.length; i++){\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes(\"{\")) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === \" \") {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            } else if (i !== 0) {\n                result.push(\" \");\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join(\"\");\n    }\n    /*\n     * @deprecated Use `setHeader` and `getHeaders` instead.\n     */ header() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        for(let i = 0; i < args.length; i += 2){\n            if (typeof args[i] === \"string\" && typeof args[i + 1] === \"string\") {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    setHeader(key, value) {\n        this._header[key] = value;\n        return this._header;\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n            return true;\n        }\n        return false;\n    }\n    getHeaders() {\n        return this._header;\n    }\n    loadPgn(pgn) {\n        let { strict = false, newlineChar = \"\\r?\\n\" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        function mask(str) {\n            return str.replace(/\\\\/g, \"\\\\\");\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = \"\";\n            let value = \"\";\n            for(let i = 0; i < headers.length; i++){\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, \"$1\");\n                value = headers[i].replace(regex, \"$2\");\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */ const headerRegex = new RegExp(\"^(\\\\[((?:\" + mask(newlineChar) + \")|.)*\\\\])\" + \"((?:\\\\s*\" + mask(newlineChar) + \"){2}|(?:\\\\s*\" + mask(newlineChar) + \")*$)\");\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : \"\" : \"\";\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = \"\";\n        for(const key in headers){\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === \"fen\") {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */ if (!strict) {\n            if (fen) {\n                this.load(fen, {\n                    preserveHeaders: true\n                });\n            }\n        } else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */ if (headers[\"SetUp\"] === \"1\") {\n                if (!(\"FEN\" in headers)) {\n                    throw new Error(\"Invalid PGN: FEN tag must be supplied with SetUp tag\");\n                }\n                // don't clear the headers when loading\n                this.load(headers[\"FEN\"], {\n                    preserveHeaders: true\n                });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */ function toHex(s) {\n            return Array.from(s).map(function(c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */ return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, \"\").toLowerCase();\n            }).join(\"\");\n        }\n        function fromHex(s) {\n            return s.length == 0 ? \"\" : decodeURIComponent(\"%\" + (s.match(/.{1,2}/g) || []).join(\"%\"));\n        }\n        const encodeComment = function(s) {\n            s = s.replace(new RegExp(mask(newlineChar), \"g\"), \" \");\n            return \"{\".concat(toHex(s.slice(1, s.length - 1)), \"}\");\n        };\n        const decodeComment = function(s) {\n            if (s.startsWith(\"{\") && s.endsWith(\"}\")) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn.replace(headerString, \"\").replace(// encode comments so they don't get deleted below\n        new RegExp(\"({[^}]*})+?|;([^\".concat(mask(newlineChar), \"]*)\"), \"g\"), function(_match, bracket, semicolon) {\n            return bracket !== undefined ? encodeComment(bracket) : \" \" + encodeComment(\"{\".concat(semicolon.slice(1), \"}\"));\n        }).replace(new RegExp(mask(newlineChar), \"g\"), \" \");\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while(ravRegex.test(ms)){\n            ms = ms.replace(ravRegex, \"\");\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, \"\");\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, \"\");\n        /* delete numeric annotation glyphs */ ms = ms.replace(/\\$\\d+/g, \"\");\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move)=>move !== \"\");\n        let result = \"\";\n        for(let halfMove = 0; halfMove < moves.length; halfMove++){\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                } else {\n                    throw new Error(\"Invalid move in PGN: \".concat(moves[halfMove]));\n                }\n            } else {\n                // reset the end of game marker if making a valid move\n                result = \"\";\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */ if (result && Object.keys(this._header).length && !this._header[\"Result\"]) {\n            this.header(\"Result\", result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */ _moveToSan(move, moves) {\n        let output = \"\";\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = \"O-O\";\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = \"O-O-O\";\n        } else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += \"x\";\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += \"=\" + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += \"#\";\n            } else {\n                output += \"+\";\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move) {\n        let strict = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({\n            legal: true,\n            piece: pieceType\n        });\n        // strict parser\n        for(let i = 0, len = moves.length; i < len; i++){\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */ let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        } else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */ matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType\n        });\n        if (!to) {\n            return null;\n        }\n        for(let i = 0, len = moves.length; i < len; i++){\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace(\"x\", \"\")) {\n                    return moves[i];\n                }\n            // hand-compare move properties with the results from our permissive regex\n            } else if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            } else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */ const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = \"   +------------------------+\\n\";\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            // display the rank\n            if (file(i) === 0) {\n                s += \" \" + \"87654321\"[rank(i)] + \" |\";\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += \" \" + symbol + \" \";\n            } else {\n                s += \" . \";\n            }\n            if (i + 1 & 0x88) {\n                s += \"|\\n\";\n                i += 8;\n            }\n        }\n        s += \"   +------------------------+\\n\";\n        s += \"     a  b  c  d  e  f  g  h\";\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({\n            legal: false\n        });\n        let nodes = 0;\n        const color = this._turn;\n        for(let i = 0, len = moves.length; i < len; i++){\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                } else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for(let i = Ox88.a8; i <= Ox88.h1; i++){\n            if (this._board[i] == null) {\n                row.push(null);\n            } else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color\n                });\n            }\n            if (i + 1 & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? \"light\" : \"dark\";\n        }\n        return null;\n    }\n    history() {\n        let { verbose = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const reversedHistory = [];\n        const moveHistory = [];\n        while(this._history.length > 0){\n            reversedHistory.push(this._undoMove());\n        }\n        while(true){\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            } else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */ _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        } else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen)=>{\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while(this._history.length > 0){\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while(true){\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace(\"{\", \"[\").replace(\"}\", \"]\");\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */ deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen)=>{\n            return {\n                fen: fen,\n                comment: this._comments[fen]\n            };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */ deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen)=>{\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return {\n                fen: fen,\n                comment: comment\n            };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [\n            KING,\n            QUEEN\n        ]){\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                } else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]);\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}){\n        this._board = new Array(128);\n        this._turn = WHITE;\n        this._header = {};\n        this._kings = {\n            w: EMPTY,\n            b: EMPTY\n        };\n        this._epSquare = -1;\n        this._halfMoves = 0;\n        this._moveNumber = 0;\n        this._history = [];\n        this._comments = {};\n        this._castling = {\n            w: 0,\n            b: 0\n        };\n        // tracks number of times a position has been seen for repetition checking\n        this._positionCount = {};\n        this.load(fen, {\n            skipValidation\n        });\n    }\n} //# sourceMappingURL=chess.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGVzcy5qcy9kaXN0L2VzbS9jaGVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDTSxNQUFNQSxRQUFRLElBQUk7QUFDbEIsTUFBTUMsUUFBUSxJQUFJO0FBQ2xCLE1BQU1DLE9BQU8sSUFBSTtBQUNqQixNQUFNQyxTQUFTLElBQUk7QUFDbkIsTUFBTUMsU0FBUyxJQUFJO0FBQ25CLE1BQU1DLE9BQU8sSUFBSTtBQUNqQixNQUFNQyxRQUFRLElBQUk7QUFDbEIsTUFBTUMsT0FBTyxJQUFJO0FBQ2pCLE1BQU1DLG1CQUFtQiwyREFBMkQ7QUFDcEYsTUFBTUM7SUFxRFRDLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxPQUFPLENBQUNDLEtBQUssQ0FBQyxVQUFVLElBQUksQ0FBQztJQUNuRDtJQUNBQyxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUNILEtBQUssQ0FBQ0MsT0FBTyxDQUFDQyxLQUFLLENBQUMsWUFBWSxJQUFJLENBQUM7SUFDckQ7SUFDQUUsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDSixLQUFLLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLGFBQWEsSUFBSSxDQUFDO0lBQ3REO0lBQ0FHLG1CQUFtQjtRQUNmLE9BQU8sSUFBSSxDQUFDTCxLQUFLLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLGVBQWUsSUFBSSxDQUFDO0lBQ3hEO0lBQ0FJLG9CQUFvQjtRQUNoQixPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDQyxPQUFPLENBQUNDLEtBQUssQ0FBQyxlQUFlLElBQUksQ0FBQztJQUN4RDtJQUNBSyxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUNQLEtBQUssQ0FBQ0MsT0FBTyxDQUFDQyxLQUFLLENBQUMsV0FBVyxJQUFJLENBQUM7SUFDcEQ7SUFwREFNLFlBQVlDLEtBQUssRUFBRUMsUUFBUSxDQUFFO1FBQ3pCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFZCxLQUFLLEVBQUVlLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUdOO1FBQy9ELE1BQU1PLGdCQUFnQkMsVUFBVUw7UUFDaEMsTUFBTU0sY0FBY0QsVUFBVUo7UUFDOUIsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxJQUFJLEdBQUdJO1FBQ1osSUFBSSxDQUFDSCxFQUFFLEdBQUdLO1FBQ1Y7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHWCxLQUFLLENBQUMsYUFBYSxDQUFDQyxVQUFVRCxLQUFLLENBQUMsU0FBUyxDQUFDO1lBQUVZLE9BQU87UUFBSztRQUN2RSxJQUFJLENBQUNDLEdBQUcsR0FBR0wsZ0JBQWdCRTtRQUMzQixJQUFJLENBQUNJLE1BQU0sR0FBR2QsTUFBTWUsR0FBRztRQUN2Qix1Q0FBdUM7UUFDdkNmLEtBQUssQ0FBQyxZQUFZLENBQUNDO1FBQ25CLElBQUksQ0FBQ2UsS0FBSyxHQUFHaEIsTUFBTWUsR0FBRztRQUN0QmYsS0FBSyxDQUFDLFlBQVk7UUFDbEIsa0RBQWtEO1FBQ2xELElBQUksQ0FBQ1QsS0FBSyxHQUFHO1FBQ2IsSUFBSyxNQUFNMEIsUUFBUUMsS0FBTTtZQUNyQixJQUFJQSxJQUFJLENBQUNELEtBQUssR0FBRzFCLE9BQU87Z0JBQ3BCLElBQUksQ0FBQ0EsS0FBSyxJQUFJRSxLQUFLLENBQUN3QixLQUFLO1lBQzdCO1FBQ0o7UUFDQSxJQUFJWCxVQUFVO1lBQ1YsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ3BCO1FBQ0EsSUFBSUMsV0FBVztZQUNYLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtZQUNqQixJQUFJLENBQUNNLEdBQUcsSUFBSU47UUFDaEI7SUFDSjtBQW1CSjtBQUNBLE1BQU1ZLFFBQVEsQ0FBQztBQUNmLE1BQU0xQixRQUFRO0lBQ1YyQixRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLFdBQVc7SUFDWEMsY0FBYztJQUNkQyxjQUFjO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ1gsTUFBTUMsVUFBVTtJQUNuQjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQzFDO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxQztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQzFDO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDMUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUMxQztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQzFDO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FDN0MsQ0FBQztBQUNGLE1BQU1ULE9BQU87SUFDVEUsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLGNBQWM7SUFDZEMsY0FBYztBQUNsQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUNDLEdBQ0Qsa0JBQWtCO0FBQ2xCLDJCQUEyQjtBQUMzQixNQUFNRSxPQUFPO0lBQ1RDLElBQUk7SUFBR0MsSUFBSTtJQUFHQyxJQUFJO0lBQUdDLElBQUk7SUFBR0MsSUFBSTtJQUFHQyxJQUFJO0lBQUdDLElBQUk7SUFBR0MsSUFBSTtJQUNyREMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQzVEQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFDNURDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUM1REMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQzVEQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFDNURDLElBQUk7SUFBSUMsSUFBSTtJQUFJQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsSUFBSTtJQUFLQyxJQUFJO0lBQUtDLElBQUk7SUFBS0MsSUFBSTtJQUMvREMsSUFBSTtJQUFLQyxJQUFJO0lBQUtDLElBQUk7SUFBS0MsSUFBSTtJQUFLQyxJQUFJO0lBQUtDLElBQUk7SUFBS0MsSUFBSTtJQUFLQyxJQUFJO0FBQ3ZFO0FBQ0EsTUFBTUMsZUFBZTtJQUNqQkMsR0FBRztRQUFDO1FBQUk7UUFBSTtRQUFJO0tBQUc7SUFDbkJDLEdBQUc7UUFBQyxDQUFDO1FBQUksQ0FBQztRQUFJLENBQUM7UUFBSSxDQUFDO0tBQUc7QUFDM0I7QUFDQSxNQUFNQyxnQkFBZ0I7SUFDbEJDLEdBQUc7UUFBQyxDQUFDO1FBQUksQ0FBQztRQUFJLENBQUM7UUFBSSxDQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7S0FBRztJQUN2Q0gsR0FBRztRQUFDLENBQUM7UUFBSSxDQUFDO1FBQUk7UUFBSTtLQUFHO0lBQ3JCSSxHQUFHO1FBQUMsQ0FBQztRQUFJO1FBQUc7UUFBSSxDQUFDO0tBQUU7SUFDbkJDLEdBQUc7UUFBQyxDQUFDO1FBQUksQ0FBQztRQUFJLENBQUM7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFJLENBQUM7S0FBRTtJQUNyQ0MsR0FBRztRQUFDLENBQUM7UUFBSSxDQUFDO1FBQUksQ0FBQztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUksQ0FBQztLQUFFO0FBQ3pDO0FBQ0Esa0JBQWtCO0FBQ2xCLE1BQU1DLFVBQVU7SUFDWjtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUNoRDtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUMzRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUNoRDtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUNoRDtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FDL0M7QUFDRCxrQkFBa0I7QUFDbEIsTUFBTUMsT0FBTztJQUNUO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQ2hEO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQ2hEO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRyxDQUFDO0lBQUcsQ0FBQztJQUFHLENBQUM7SUFBRyxDQUFDO0lBQUcsQ0FBQztJQUFHLENBQUM7SUFBRyxDQUFDO0lBQUc7SUFDcEQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJLENBQUM7SUFBSSxDQUFDO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDbkQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHLENBQUM7SUFBSTtJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDbkQ7SUFBRztJQUFHO0lBQUc7SUFBRyxDQUFDO0lBQUk7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDbkQ7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRyxDQUFDO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFDbkQ7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFDbkQ7SUFBRyxDQUFDO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUcsQ0FBQztJQUFJO0lBQUc7SUFDbkQsQ0FBQztJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLENBQUM7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRyxDQUFDO0NBQ2xEO0FBQ0QsTUFBTUMsY0FBYztJQUFFQyxHQUFHO0lBQUtQLEdBQUc7SUFBS0gsR0FBRztJQUFLSSxHQUFHO0lB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Q0MsSUFBSSxDQUFDdkssS0FBSztZQUFFd0s7UUFBZTtJQUNwQztBQTg4Q0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NoZXNzLmpzL2Rpc3QvZXNtL2NoZXNzLmpzPzMyYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDI1LCBKZWZmIEhseXdhIChqaGx5d2FAZ21haWwuY29tKVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmV4cG9ydCBjb25zdCBXSElURSA9ICd3JztcbmV4cG9ydCBjb25zdCBCTEFDSyA9ICdiJztcbmV4cG9ydCBjb25zdCBQQVdOID0gJ3AnO1xuZXhwb3J0IGNvbnN0IEtOSUdIVCA9ICduJztcbmV4cG9ydCBjb25zdCBCSVNIT1AgPSAnYic7XG5leHBvcnQgY29uc3QgUk9PSyA9ICdyJztcbmV4cG9ydCBjb25zdCBRVUVFTiA9ICdxJztcbmV4cG9ydCBjb25zdCBLSU5HID0gJ2snO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUE9TSVRJT04gPSAncm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDEnO1xuZXhwb3J0IGNsYXNzIE1vdmUge1xuICAgIGNvbG9yO1xuICAgIGZyb207XG4gICAgdG87XG4gICAgcGllY2U7XG4gICAgY2FwdHVyZWQ7XG4gICAgcHJvbW90aW9uO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmllbGQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMi4wLjAuXG4gICAgICogUGxlYXNlIHVzZSBtb3ZlIGRlc2NyaXB0b3IgZnVuY3Rpb25zIGluc3RlYWQ6IGBpc0NhcHR1cmVgLCBgaXNQcm9tb3Rpb25gLFxuICAgICAqIGBpc0VuUGFzc2FudGAsIGBpc0tpbmdzaWRlQ2FzdGxlYCwgYGlzUXVlZW5zaWRlQ2FzdGxlYCwgYGlzQ2FzdGxlYCwgYW5kXG4gICAgICogYGlzQmlnUGF3bmBcbiAgICAgKi9cbiAgICBmbGFncztcbiAgICBzYW47XG4gICAgbGFuO1xuICAgIGJlZm9yZTtcbiAgICBhZnRlcjtcbiAgICBjb25zdHJ1Y3RvcihjaGVzcywgaW50ZXJuYWwpIHtcbiAgICAgICAgY29uc3QgeyBjb2xvciwgcGllY2UsIGZyb20sIHRvLCBmbGFncywgY2FwdHVyZWQsIHByb21vdGlvbiB9ID0gaW50ZXJuYWw7XG4gICAgICAgIGNvbnN0IGZyb21BbGdlYnJhaWMgPSBhbGdlYnJhaWMoZnJvbSk7XG4gICAgICAgIGNvbnN0IHRvQWxnZWJyYWljID0gYWxnZWJyYWljKHRvKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLnBpZWNlID0gcGllY2U7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb21BbGdlYnJhaWM7XG4gICAgICAgIHRoaXMudG8gPSB0b0FsZ2VicmFpYztcbiAgICAgICAgLypcbiAgICAgICAgICogSEFDSzogVGhlIGNoZXNzWydfbWV0aG9kJ10oKSBjYWxscyBiZWxvdyBpbnZva2UgcHJpdmF0ZSBtZXRob2RzIGluIHRoZVxuICAgICAgICAgKiBDaGVzcyBjbGFzcyB0byBnZW5lcmF0ZSBTQU4gYW5kIEZFTi4gSXQncyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBtYWtlcyB0aGVcbiAgICAgICAgICogY29kZSBjbGVhbmVyIGVsc2V3aGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2FuID0gY2hlc3NbJ19tb3ZlVG9TYW4nXShpbnRlcm5hbCwgY2hlc3NbJ19tb3ZlcyddKHsgbGVnYWw6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLmxhbiA9IGZyb21BbGdlYnJhaWMgKyB0b0FsZ2VicmFpYztcbiAgICAgICAgdGhpcy5iZWZvcmUgPSBjaGVzcy5mZW4oKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIEZFTiBmb3IgdGhlICdhZnRlcicga2V5XG4gICAgICAgIGNoZXNzWydfbWFrZU1vdmUnXShpbnRlcm5hbCk7XG4gICAgICAgIHRoaXMuYWZ0ZXIgPSBjaGVzcy5mZW4oKTtcbiAgICAgICAgY2hlc3NbJ191bmRvTW92ZSddKCk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb3ZlIGZsYWdzXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBmbGFnIGluIEJJVFMpIHtcbiAgICAgICAgICAgIGlmIChCSVRTW2ZsYWddICYgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzICs9IEZMQUdTW2ZsYWddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYXB0dXJlZCkge1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlZCA9IGNhcHR1cmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tb3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHJvbW90aW9uID0gcHJvbW90aW9uO1xuICAgICAgICAgICAgdGhpcy5sYW4gKz0gcHJvbW90aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ2FwdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snQ0FQVFVSRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc1Byb21vdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snUFJPTU9USU9OJ10pID4gLTE7XG4gICAgfVxuICAgIGlzRW5QYXNzYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydFUF9DQVBUVVJFJ10pID4gLTE7XG4gICAgfVxuICAgIGlzS2luZ3NpZGVDYXN0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0tTSURFX0NBU1RMRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc1F1ZWVuc2lkZUNhc3RsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snUVNJREVfQ0FTVExFJ10pID4gLTE7XG4gICAgfVxuICAgIGlzQmlnUGF3bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snQklHX1BBV04nXSkgPiAtMTtcbiAgICB9XG59XG5jb25zdCBFTVBUWSA9IC0xO1xuY29uc3QgRkxBR1MgPSB7XG4gICAgTk9STUFMOiAnbicsXG4gICAgQ0FQVFVSRTogJ2MnLFxuICAgIEJJR19QQVdOOiAnYicsXG4gICAgRVBfQ0FQVFVSRTogJ2UnLFxuICAgIFBST01PVElPTjogJ3AnLFxuICAgIEtTSURFX0NBU1RMRTogJ2snLFxuICAgIFFTSURFX0NBU1RMRTogJ3EnLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IFNRVUFSRVMgPSBbXG4gICAgJ2E4JywgJ2I4JywgJ2M4JywgJ2Q4JywgJ2U4JywgJ2Y4JywgJ2c4JywgJ2g4JyxcbiAgICAnYTcnLCAnYjcnLCAnYzcnLCAnZDcnLCAnZTcnLCAnZjcnLCAnZzcnLCAnaDcnLFxuICAgICdhNicsICdiNicsICdjNicsICdkNicsICdlNicsICdmNicsICdnNicsICdoNicsXG4gICAgJ2E1JywgJ2I1JywgJ2M1JywgJ2Q1JywgJ2U1JywgJ2Y1JywgJ2c1JywgJ2g1JyxcbiAgICAnYTQnLCAnYjQnLCAnYzQnLCAnZDQnLCAnZTQnLCAnZjQnLCAnZzQnLCAnaDQnLFxuICAgICdhMycsICdiMycsICdjMycsICdkMycsICdlMycsICdmMycsICdnMycsICdoMycsXG4gICAgJ2EyJywgJ2IyJywgJ2MyJywgJ2QyJywgJ2UyJywgJ2YyJywgJ2cyJywgJ2gyJyxcbiAgICAnYTEnLCAnYjEnLCAnYzEnLCAnZDEnLCAnZTEnLCAnZjEnLCAnZzEnLCAnaDEnXG5dO1xuY29uc3QgQklUUyA9IHtcbiAgICBOT1JNQUw6IDEsXG4gICAgQ0FQVFVSRTogMixcbiAgICBCSUdfUEFXTjogNCxcbiAgICBFUF9DQVBUVVJFOiA4LFxuICAgIFBST01PVElPTjogMTYsXG4gICAgS1NJREVfQ0FTVExFOiAzMixcbiAgICBRU0lERV9DQVNUTEU6IDY0LFxufTtcbi8qXG4gKiBOT1RFUyBBQk9VVCAweDg4IE1PVkUgR0VORVJBVElPTiBBTEdPUklUSE1cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pobHl3YS9jaGVzcy5qcy9pc3N1ZXMvMjMwXG4gKlxuICogQSBsb3Qgb2YgcGVvcGxlIGFyZSBjb25mdXNlZCB3aGVuIHRoZXkgZmlyc3Qgc2VlIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICogb2YgY2hlc3MuanMuIEl0IHVzZXMgdGhlIDB4ODggTW92ZSBHZW5lcmF0aW9uIEFsZ29yaXRobSB3aGljaCBpbnRlcm5hbGx5XG4gKiBzdG9yZXMgdGhlIGJvYXJkIGFzIGFuIDh4MTYgYXJyYXkuIFRoaXMgaXMgcHVyZWx5IGZvciBlZmZpY2llbmN5IGJ1dCBoYXMgYVxuICogY291cGxlIG9mIGludGVyZXN0aW5nIGJlbmVmaXRzOlxuICpcbiAqIDEuIDB4ODggb2ZmZXJzIGEgdmVyeSBpbmV4cGVuc2l2ZSBcIm9mZiB0aGUgYm9hcmRcIiBjaGVjay4gQml0d2lzZSBBTkQgKCYpIGFueVxuICogICAgc3F1YXJlIHdpdGggMHg4OCwgaWYgdGhlIHJlc3VsdCBpcyBub24temVybyB0aGVuIHRoZSBzcXVhcmUgaXMgb2ZmIHRoZVxuICogICAgYm9hcmQuIEZvciBleGFtcGxlLCBhc3N1bWluZyBhIGtuaWdodCBzcXVhcmUgQTggKDAgaW4gMHg4OCBub3RhdGlvbiksXG4gKiAgICB0aGVyZSBhcmUgOCBwb3NzaWJsZSBkaXJlY3Rpb25zIGluIHdoaWNoIHRoZSBrbmlnaHQgY2FuIG1vdmUuIFRoZXNlXG4gKiAgICBkaXJlY3Rpb25zIGFyZSByZWxhdGl2ZSB0byB0aGUgOHgxNiBib2FyZCBhbmQgYXJlIHN0b3JlZCBpbiB0aGVcbiAqICAgIFBJRUNFX09GRlNFVFMgbWFwLiBPbmUgcG9zc2libGUgbW92ZSBpcyBBOCAtIDE4ICh1cCBvbmUgc3F1YXJlLCBhbmQgdHdvXG4gKiAgICBzcXVhcmVzIHRvIHRoZSBsZWZ0IC0gd2hpY2ggaXMgb2ZmIHRoZSBib2FyZCkuIDAgLSAxOCA9IC0xOCAmIDB4ODggPSAweDg4XG4gKiAgICAoYmVjYXVzZSBvZiB0d28tY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBvZiAtMTgpLiBUaGUgbm9uLXplcm8gcmVzdWx0XG4gKiAgICBtZWFucyB0aGUgc3F1YXJlIGlzIG9mZiB0aGUgYm9hcmQgYW5kIHRoZSBtb3ZlIGlzIGlsbGVnYWwuIFRha2UgdGhlXG4gKiAgICBvcHBvc2l0ZSBtb3ZlIChmcm9tIEE4IHRvIEM3KSwgMCArIDE4ID0gMTggJiAweDg4ID0gMC4gQSByZXN1bHQgb2YgemVyb1xuICogICAgbWVhbnMgdGhlIHNxdWFyZSBpcyBvbiB0aGUgYm9hcmQuXG4gKlxuICogMi4gVGhlIHJlbGF0aXZlIGRpc3RhbmNlIChvciBkaWZmZXJlbmNlKSBiZXR3ZWVuIHR3byBzcXVhcmVzIG9uIGEgOHgxNiBib2FyZFxuICogICAgaXMgdW5pcXVlIGFuZCBjYW4gYmUgdXNlZCB0byBpbmV4cGVuc2l2ZWx5IGRldGVybWluZSBpZiBhIHBpZWNlIG9uIGFcbiAqICAgIHNxdWFyZSBjYW4gYXR0YWNrIGFueSBvdGhlciBhcmJpdHJhcnkgc3F1YXJlLiBGb3IgZXhhbXBsZSwgbGV0J3Mgc2VlIGlmIGFcbiAqICAgIHBhd24gb24gRTcgY2FuIGF0dGFjayBFMi4gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBFNyAoMjApIC0gRTIgKDEwMCkgaXNcbiAqICAgIC04MC4gV2UgYWRkIDExOSB0byBtYWtlIHRoZSBBVFRBQ0tTIGFycmF5IGluZGV4IG5vbi1uZWdhdGl2ZSAoYmVjYXVzZSB0aGVcbiAqICAgIHdvcnN0IGNhc2UgZGlmZmVyZW5jZSBpcyBBOCAtIEgxID0gLTExOSkuIFRoZSBBVFRBQ0tTIGFycmF5IGNvbnRhaW5zIGFcbiAqICAgIGJpdG1hc2sgb2YgcGllY2VzIHRoYXQgY2FuIGF0dGFjayBmcm9tIHRoYXQgZGlzdGFuY2UgYW5kIGRpcmVjdGlvbi5cbiAqICAgIEFUVEFDS1NbLTgwICsgMTE5PTM5XSBnaXZlcyB1cyAyNCBvciAwYjExMDAwIGluIGJpbmFyeS4gTG9vayBhdCB0aGVcbiAqICAgIFBJRUNFX01BU0tTIG1hcCB0byBkZXRlcm1pbmUgdGhlIG1hc2sgZm9yIGEgZ2l2ZW4gcGllY2UgdHlwZS4gSW4gb3VyIHBhd25cbiAqICAgIGV4YW1wbGUsIHdlIHdvdWxkIGNoZWNrIHRvIHNlZSBpZiAyNCAmIDB4MSBpcyBub24temVybywgd2hpY2ggaXQgaXNcbiAqICAgIG5vdC4gU28sIG5hdHVyYWxseSwgYSBwYXduIG9uIEU3IGNhbid0IGF0dGFjayBhIHBpZWNlIG9uIEUyLiBIb3dldmVyLCBhXG4gKiAgICByb29rIGNhbiBzaW5jZSAyNCAmIDB4OCBpcyBub24temVyby4gVGhlIG9ubHkgdGhpbmcgbGVmdCB0byBjaGVjayBpcyB0aGF0XG4gKiAgICB0aGVyZSBhcmUgbm8gYmxvY2tpbmcgcGllY2VzIGJldHdlZW4gRTcgYW5kIEUyLiBUaGF0J3Mgd2hlcmUgdGhlIFJBWVNcbiAqICAgIGFycmF5IGNvbWVzIGluLiBJdCBwcm92aWRlcyBhbiBvZmZzZXQgKGluIHRoaXMgY2FzZSAxNikgdG8gYWRkIHRvIEU3ICgyMClcbiAqICAgIHRvIGNoZWNrIGZvciBibG9ja2luZyBwaWVjZXMuIEU3ICgyMCkgKyAxNiA9IEU2ICgzNikgKyAxNiA9IEU1ICg1MikgZXRjLlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuY29uc3QgT3g4OCA9IHtcbiAgICBhODogMCwgYjg6IDEsIGM4OiAyLCBkODogMywgZTg6IDQsIGY4OiA1LCBnODogNiwgaDg6IDcsXG4gICAgYTc6IDE2LCBiNzogMTcsIGM3OiAxOCwgZDc6IDE5LCBlNzogMjAsIGY3OiAyMSwgZzc6IDIyLCBoNzogMjMsXG4gICAgYTY6IDMyLCBiNjogMzMsIGM2OiAzNCwgZDY6IDM1LCBlNjogMzYsIGY2OiAzNywgZzY6IDM4LCBoNjogMzksXG4gICAgYTU6IDQ4LCBiNTogNDksIGM1OiA1MCwgZDU6IDUxLCBlNTogNTIsIGY1OiA1MywgZzU6IDU0LCBoNTogNTUsXG4gICAgYTQ6IDY0LCBiNDogNjUsIGM0OiA2NiwgZDQ6IDY3LCBlNDogNjgsIGY0OiA2OSwgZzQ6IDcwLCBoNDogNzEsXG4gICAgYTM6IDgwLCBiMzogODEsIGMzOiA4MiwgZDM6IDgzLCBlMzogODQsIGYzOiA4NSwgZzM6IDg2LCBoMzogODcsXG4gICAgYTI6IDk2LCBiMjogOTcsIGMyOiA5OCwgZDI6IDk5LCBlMjogMTAwLCBmMjogMTAxLCBnMjogMTAyLCBoMjogMTAzLFxuICAgIGExOiAxMTIsIGIxOiAxMTMsIGMxOiAxMTQsIGQxOiAxMTUsIGUxOiAxMTYsIGYxOiAxMTcsIGcxOiAxMTgsIGgxOiAxMTlcbn07XG5jb25zdCBQQVdOX09GRlNFVFMgPSB7XG4gICAgYjogWzE2LCAzMiwgMTcsIDE1XSxcbiAgICB3OiBbLTE2LCAtMzIsIC0xNywgLTE1XSxcbn07XG5jb25zdCBQSUVDRV9PRkZTRVRTID0ge1xuICAgIG46IFstMTgsIC0zMywgLTMxLCAtMTQsIDE4LCAzMywgMzEsIDE0XSxcbiAgICBiOiBbLTE3LCAtMTUsIDE3LCAxNV0sXG4gICAgcjogWy0xNiwgMSwgMTYsIC0xXSxcbiAgICBxOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxuICAgIGs6IFstMTcsIC0xNiwgLTE1LCAxLCAxNywgMTYsIDE1LCAtMV0sXG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBBVFRBQ0tTID0gW1xuICAgIDIwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsXG4gICAgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCxcbiAgICAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDI0LCAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyMCwgMiwgMjQsIDIsIDIwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIsIDUzLCA1NiwgNTMsIDIsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgNTYsIDAsIDU2LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIsIDUzLCA1NiwgNTMsIDIsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMjAsIDIsIDI0LCAyLCAyMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMjQsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMCxcbiAgICAwLCAyMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLFxuICAgIDIwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMCwgMjBcbl07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFJBWVMgPSBbXG4gICAgMTcsIDAsIDAsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAwLCAwLCAxNSwgMCxcbiAgICAwLCAxNywgMCwgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDAsIDE1LCAwLCAwLFxuICAgIDAsIDAsIDE3LCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMTUsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMTcsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAxNSwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAxNywgMCwgMCwgMTYsIDAsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDE3LCAwLCAxNiwgMCwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMTcsIDE2LCAxNSwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAtMTUsIC0xNiwgLTE3LCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIC0xNSwgMCwgLTE2LCAwLCAtMTcsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgLTE1LCAwLCAwLCAtMTYsIDAsIDAsIC0xNywgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAtMTUsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgLTE3LCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIC0xNSwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAtMTcsIDAsIDAsIDAsXG4gICAgMCwgLTE1LCAwLCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIDAsIC0xNywgMCwgMCxcbiAgICAtMTUsIDAsIDAsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgMCwgMCwgLTE3XG5dO1xuY29uc3QgUElFQ0VfTUFTS1MgPSB7IHA6IDB4MSwgbjogMHgyLCBiOiAweDQsIHI6IDB4OCwgcTogMHgxMCwgazogMHgyMCB9O1xuY29uc3QgU1lNQk9MUyA9ICdwbmJycWtQTkJSUUsnO1xuY29uc3QgUFJPTU9USU9OUyA9IFtLTklHSFQsIEJJU0hPUCwgUk9PSywgUVVFRU5dO1xuY29uc3QgUkFOS18xID0gNztcbmNvbnN0IFJBTktfMiA9IDY7XG4vKlxuICogY29uc3QgUkFOS18zID0gNVxuICogY29uc3QgUkFOS180ID0gNFxuICogY29uc3QgUkFOS181ID0gM1xuICogY29uc3QgUkFOS182ID0gMlxuICovXG5jb25zdCBSQU5LXzcgPSAxO1xuY29uc3QgUkFOS184ID0gMDtcbmNvbnN0IFNJREVTID0ge1xuICAgIFtLSU5HXTogQklUUy5LU0lERV9DQVNUTEUsXG4gICAgW1FVRUVOXTogQklUUy5RU0lERV9DQVNUTEUsXG59O1xuY29uc3QgUk9PS1MgPSB7XG4gICAgdzogW1xuICAgICAgICB7IHNxdWFyZTogT3g4OC5hMSwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcbiAgICAgICAgeyBzcXVhcmU6IE94ODguaDEsIGZsYWc6IEJJVFMuS1NJREVfQ0FTVExFIH0sXG4gICAgXSxcbiAgICBiOiBbXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmE4LCBmbGFnOiBCSVRTLlFTSURFX0NBU1RMRSB9LFxuICAgICAgICB7IHNxdWFyZTogT3g4OC5oOCwgZmxhZzogQklUUy5LU0lERV9DQVNUTEUgfSxcbiAgICBdLFxufTtcbmNvbnN0IFNFQ09ORF9SQU5LID0geyBiOiBSQU5LXzcsIHc6IFJBTktfMiB9O1xuY29uc3QgVEVSTUlOQVRJT05fTUFSS0VSUyA9IFsnMS0wJywgJzAtMScsICcxLzItMS8yJywgJyonXTtcbi8vIEV4dHJhY3RzIHRoZSB6ZXJvLWJhc2VkIHJhbmsgb2YgYW4gMHg4OCBzcXVhcmUuXG5mdW5jdGlvbiByYW5rKHNxdWFyZSkge1xuICAgIHJldHVybiBzcXVhcmUgPj4gNDtcbn1cbi8vIEV4dHJhY3RzIHRoZSB6ZXJvLWJhc2VkIGZpbGUgb2YgYW4gMHg4OCBzcXVhcmUuXG5mdW5jdGlvbiBmaWxlKHNxdWFyZSkge1xuICAgIHJldHVybiBzcXVhcmUgJiAweGY7XG59XG5mdW5jdGlvbiBpc0RpZ2l0KGMpIHtcbiAgICByZXR1cm4gJzAxMjM0NTY3ODknLmluZGV4T2YoYykgIT09IC0xO1xufVxuLy8gQ29udmVydHMgYSAweDg4IHNxdWFyZSB0byBhbGdlYnJhaWMgbm90YXRpb24uXG5mdW5jdGlvbiBhbGdlYnJhaWMoc3F1YXJlKSB7XG4gICAgY29uc3QgZiA9IGZpbGUoc3F1YXJlKTtcbiAgICBjb25zdCByID0gcmFuayhzcXVhcmUpO1xuICAgIHJldHVybiAoJ2FiY2RlZmdoJy5zdWJzdHJpbmcoZiwgZiArIDEpICtcbiAgICAgICAgJzg3NjU0MzIxJy5zdWJzdHJpbmcociwgciArIDEpKTtcbn1cbmZ1bmN0aW9uIHN3YXBDb2xvcihjb2xvcikge1xuICAgIHJldHVybiBjb2xvciA9PT0gV0hJVEUgPyBCTEFDSyA6IFdISVRFO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmVuKGZlbikge1xuICAgIC8vIDFzdCBjcml0ZXJpb246IDYgc3BhY2Utc2VwZXJhdGVkIGZpZWxkcz9cbiAgICBjb25zdCB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCAhPT0gNikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogbXVzdCBjb250YWluIHNpeCBzcGFjZS1kZWxpbWl0ZWQgZmllbGRzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gMm5kIGNyaXRlcmlvbjogbW92ZSBudW1iZXIgZmllbGQgaXMgYSBpbnRlZ2VyIHZhbHVlID4gMD9cbiAgICBjb25zdCBtb3ZlTnVtYmVyID0gcGFyc2VJbnQodG9rZW5zWzVdLCAxMCk7XG4gICAgaWYgKGlzTmFOKG1vdmVOdW1iZXIpIHx8IG1vdmVOdW1iZXIgPD0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogbW92ZSBudW1iZXIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAzcmQgY3JpdGVyaW9uOiBoYWxmIG1vdmUgY291bnRlciBpcyBhbiBpbnRlZ2VyID49IDA/XG4gICAgY29uc3QgaGFsZk1vdmVzID0gcGFyc2VJbnQodG9rZW5zWzRdLCAxMCk7XG4gICAgaWYgKGlzTmFOKGhhbGZNb3ZlcykgfHwgaGFsZk1vdmVzIDwgMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogaGFsZiBtb3ZlIGNvdW50ZXIgbnVtYmVyIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDR0aCBjcml0ZXJpb246IDR0aCBmaWVsZCBpcyBhIHZhbGlkIGUucC4tc3RyaW5nP1xuICAgIGlmICghL14oLXxbYWJjZGVmZ2hdWzM2XSkkLy50ZXN0KHRva2Vuc1szXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBlbi1wYXNzYW50IHNxdWFyZSBpcyBpbnZhbGlkJyB9O1xuICAgIH1cbiAgICAvLyA1dGggY3JpdGVyaW9uOiAzdGggZmllbGQgaXMgYSB2YWxpZCBjYXN0bGUtc3RyaW5nP1xuICAgIGlmICgvW15rS3FRLV0vLnRlc3QodG9rZW5zWzJdKSkge1xuICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBGRU46IGNhc3RsaW5nIGF2YWlsYWJpbGl0eSBpcyBpbnZhbGlkJyB9O1xuICAgIH1cbiAgICAvLyA2dGggY3JpdGVyaW9uOiAybmQgZmllbGQgaXMgXCJ3XCIgKHdoaXRlKSBvciBcImJcIiAoYmxhY2spP1xuICAgIGlmICghL14od3xiKSQvLnRlc3QodG9rZW5zWzFdKSkge1xuICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBGRU46IHNpZGUtdG8tbW92ZSBpcyBpbnZhbGlkJyB9O1xuICAgIH1cbiAgICAvLyA3dGggY3JpdGVyaW9uOiAxc3QgZmllbGQgY29udGFpbnMgOCByb3dzP1xuICAgIGNvbnN0IHJvd3MgPSB0b2tlbnNbMF0uc3BsaXQoJy8nKTtcbiAgICBpZiAocm93cy5sZW5ndGggIT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGRvZXMgbm90IGNvbnRhaW4gOCAnLyctZGVsaW1pdGVkIHJvd3NcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gOHRoIGNyaXRlcmlvbjogZXZlcnkgcm93IGlzIHZhbGlkP1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBjaGVjayBmb3IgcmlnaHQgc3VtIG9mIGZpZWxkcyBBTkQgbm90IHR3byBudW1iZXJzIGluIHN1Y2Nlc3Npb25cbiAgICAgICAgbGV0IHN1bUZpZWxkcyA9IDA7XG4gICAgICAgIGxldCBwcmV2aW91c1dhc051bWJlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvd3NbaV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzV2FzTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGNvbnNlY3V0aXZlIG51bWJlciknLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW1GaWVsZHMgKz0gcGFyc2VJbnQocm93c1tpXVtrXSwgMTApO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzV2FzTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghL15bcHJuYnFrUFJOQlFLXSQvLnRlc3Qocm93c1tpXVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgaXMgaW52YWxpZCAoaW52YWxpZCBwaWVjZSknLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdW1GaWVsZHMgKz0gMTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdW1GaWVsZHMgIT09IDgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgaXMgaW52YWxpZCAodG9vIG1hbnkgc3F1YXJlcyBpbiByYW5rKScsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDl0aCBjcml0ZXJpb246IGlzIGVuLXBhc3NhbnQgc3F1YXJlIGxlZ2FsP1xuICAgIGlmICgodG9rZW5zWzNdWzFdID09ICczJyAmJiB0b2tlbnNbMV0gPT0gJ3cnKSB8fFxuICAgICAgICAodG9rZW5zWzNdWzFdID09ICc2JyAmJiB0b2tlbnNbMV0gPT0gJ2InKSkge1xuICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBGRU46IGlsbGVnYWwgZW4tcGFzc2FudCBzcXVhcmUnIH07XG4gICAgfVxuICAgIC8vIDEwdGggY3JpdGVyaW9uOiBkb2VzIGNoZXNzIHBvc2l0aW9uIGNvbnRhaW4gZXhhY3QgdHdvIGtpbmdzP1xuICAgIGNvbnN0IGtpbmdzID0gW1xuICAgICAgICB7IGNvbG9yOiAnd2hpdGUnLCByZWdleDogL0svZyB9LFxuICAgICAgICB7IGNvbG9yOiAnYmxhY2snLCByZWdleDogL2svZyB9LFxuICAgIF07XG4gICAgZm9yIChjb25zdCB7IGNvbG9yLCByZWdleCB9IG9mIGtpbmdzKSB7XG4gICAgICAgIGlmICghcmVnZXgudGVzdCh0b2tlbnNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBGRU46IG1pc3NpbmcgJHtjb2xvcn0ga2luZ2AgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRva2Vuc1swXS5tYXRjaChyZWdleCkgfHwgW10pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGBJbnZhbGlkIEZFTjogdG9vIG1hbnkgJHtjb2xvcn0ga2luZ3NgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMTF0aCBjcml0ZXJpb246IGFyZSBhbnkgcGF3bnMgb24gdGhlIGZpcnN0IG9yIGVpZ2h0aCByb3dzP1xuICAgIGlmIChBcnJheS5mcm9tKHJvd3NbMF0gKyByb3dzWzddKS5zb21lKChjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkgPT09ICdQJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHNvbWUgcGF3bnMgYXJlIG9uIHRoZSBlZGdlIHJvd3MnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBvazogdHJ1ZSB9O1xufVxuLy8gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFtYmlndW91cyBtb3Zlc1xuZnVuY3Rpb24gZ2V0RGlzYW1iaWd1YXRvcihtb3ZlLCBtb3Zlcykge1xuICAgIGNvbnN0IGZyb20gPSBtb3ZlLmZyb207XG4gICAgY29uc3QgdG8gPSBtb3ZlLnRvO1xuICAgIGNvbnN0IHBpZWNlID0gbW92ZS5waWVjZTtcbiAgICBsZXQgYW1iaWd1aXRpZXMgPSAwO1xuICAgIGxldCBzYW1lUmFuayA9IDA7XG4gICAgbGV0IHNhbWVGaWxlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYW1iaWdGcm9tID0gbW92ZXNbaV0uZnJvbTtcbiAgICAgICAgY29uc3QgYW1iaWdUbyA9IG1vdmVzW2ldLnRvO1xuICAgICAgICBjb25zdCBhbWJpZ1BpZWNlID0gbW92ZXNbaV0ucGllY2U7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGlmIGEgbW92ZSBvZiB0aGUgc2FtZSBwaWVjZSB0eXBlIGVuZHMgb24gdGhlIHNhbWUgdG8gc3F1YXJlLCB3ZSdsbCBuZWVkXG4gICAgICAgICAqIHRvIGFkZCBhIGRpc2FtYmlndWF0b3IgdG8gdGhlIGFsZ2VicmFpYyBub3RhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHBpZWNlID09PSBhbWJpZ1BpZWNlICYmIGZyb20gIT09IGFtYmlnRnJvbSAmJiB0byA9PT0gYW1iaWdUbykge1xuICAgICAgICAgICAgYW1iaWd1aXRpZXMrKztcbiAgICAgICAgICAgIGlmIChyYW5rKGZyb20pID09PSByYW5rKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lUmFuaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGUoZnJvbSkgPT09IGZpbGUoYW1iaWdGcm9tKSkge1xuICAgICAgICAgICAgICAgIHNhbWVGaWxlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFtYmlndWl0aWVzID4gMCkge1xuICAgICAgICBpZiAoc2FtZVJhbmsgPiAwICYmIHNhbWVGaWxlID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGlmIHRoZXJlIGV4aXN0cyBhIHNpbWlsYXIgbW92aW5nIHBpZWNlIG9uIHRoZSBzYW1lIHJhbmsgYW5kIGZpbGUgYXNcbiAgICAgICAgICAgICAqIHRoZSBtb3ZlIGluIHF1ZXN0aW9uLCB1c2UgdGhlIHNxdWFyZSBhcyB0aGUgZGlzYW1iaWd1YXRvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNhbWVGaWxlID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGlmIHRoZSBtb3ZpbmcgcGllY2UgcmVzdHMgb24gdGhlIHNhbWUgZmlsZSwgdXNlIHRoZSByYW5rIHN5bWJvbCBhcyB0aGVcbiAgICAgICAgICAgICAqIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKS5jaGFyQXQoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlIHVzZSB0aGUgZmlsZSBzeW1ib2xcbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGFkZE1vdmUobW92ZXMsIGNvbG9yLCBmcm9tLCB0bywgcGllY2UsIGNhcHR1cmVkID0gdW5kZWZpbmVkLCBmbGFncyA9IEJJVFMuTk9STUFMKSB7XG4gICAgY29uc3QgciA9IHJhbmsodG8pO1xuICAgIGlmIChwaWVjZSA9PT0gUEFXTiAmJiAociA9PT0gUkFOS18xIHx8IHIgPT09IFJBTktfOCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQUk9NT1RJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tb3Rpb24gPSBQUk9NT1RJT05TW2ldO1xuICAgICAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgICAgICBjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb24sXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzIHwgQklUUy5QUk9NT1RJT04sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHBpZWNlLFxuICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICBmbGFncyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5mZXJQaWVjZVR5cGUoc2FuKSB7XG4gICAgbGV0IHBpZWNlVHlwZSA9IHNhbi5jaGFyQXQoMCk7XG4gICAgaWYgKHBpZWNlVHlwZSA+PSAnYScgJiYgcGllY2VUeXBlIDw9ICdoJykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gc2FuLm1hdGNoKC9bYS1oXVxcZC4qW2EtaF1cXGQvKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBV047XG4gICAgfVxuICAgIHBpZWNlVHlwZSA9IHBpZWNlVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwaWVjZVR5cGUgPT09ICdvJykge1xuICAgICAgICByZXR1cm4gS0lORztcbiAgICB9XG4gICAgcmV0dXJuIHBpZWNlVHlwZTtcbn1cbi8vIHBhcnNlcyBhbGwgb2YgdGhlIGRlY29yYXRvcnMgb3V0IG9mIGEgU0FOIHN0cmluZ1xuZnVuY3Rpb24gc3RyaXBwZWRTYW4obW92ZSkge1xuICAgIHJldHVybiBtb3ZlLnJlcGxhY2UoLz0vLCAnJykucmVwbGFjZSgvWysjXT9bPyFdKiQvLCAnJyk7XG59XG5mdW5jdGlvbiB0cmltRmVuKGZlbikge1xuICAgIC8qXG4gICAgICogcmVtb3ZlIGxhc3QgdHdvIGZpZWxkcyBpbiBGRU4gc3RyaW5nIGFzIHRoZXkncmUgbm90IG5lZWRlZCB3aGVuIGNoZWNraW5nXG4gICAgICogZm9yIHJlcGV0aXRpb25cbiAgICAgKi9cbiAgICByZXR1cm4gZmVuLnNwbGl0KCcgJykuc2xpY2UoMCwgNCkuam9pbignICcpO1xufVxuZXhwb3J0IGNsYXNzIENoZXNzIHtcbiAgICBfYm9hcmQgPSBuZXcgQXJyYXkoMTI4KTtcbiAgICBfdHVybiA9IFdISVRFO1xuICAgIF9oZWFkZXIgPSB7fTtcbiAgICBfa2luZ3MgPSB7IHc6IEVNUFRZLCBiOiBFTVBUWSB9O1xuICAgIF9lcFNxdWFyZSA9IC0xO1xuICAgIF9oYWxmTW92ZXMgPSAwO1xuICAgIF9tb3ZlTnVtYmVyID0gMDtcbiAgICBfaGlzdG9yeSA9IFtdO1xuICAgIF9jb21tZW50cyA9IHt9O1xuICAgIF9jYXN0bGluZyA9IHsgdzogMCwgYjogMCB9O1xuICAgIC8vIHRyYWNrcyBudW1iZXIgb2YgdGltZXMgYSBwb3NpdGlvbiBoYXMgYmVlbiBzZWVuIGZvciByZXBldGl0aW9uIGNoZWNraW5nXG4gICAgX3Bvc2l0aW9uQ291bnQgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcihmZW4gPSBERUZBVUxUX1BPU0lUSU9OLCB7IHNraXBWYWxpZGF0aW9uID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMubG9hZChmZW4sIHsgc2tpcFZhbGlkYXRpb24gfSk7XG4gICAgfVxuICAgIGNsZWFyKHsgcHJlc2VydmVIZWFkZXJzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2JvYXJkID0gbmV3IEFycmF5KDEyOCk7XG4gICAgICAgIHRoaXMuX2tpbmdzID0geyB3OiBFTVBUWSwgYjogRU1QVFkgfTtcbiAgICAgICAgdGhpcy5fdHVybiA9IFdISVRFO1xuICAgICAgICB0aGlzLl9jYXN0bGluZyA9IHsgdzogMCwgYjogMCB9O1xuICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSAwO1xuICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyID0gMTtcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLl9jb21tZW50cyA9IHt9O1xuICAgICAgICB0aGlzLl9oZWFkZXIgPSBwcmVzZXJ2ZUhlYWRlcnMgPyB0aGlzLl9oZWFkZXIgOiB7fTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudCA9IHt9O1xuICAgICAgICAvKlxuICAgICAgICAgKiBEZWxldGUgdGhlIFNldFVwIGFuZCBGRU4gaGVhZGVycyAoaWYgcHJlc2VydmVkKSwgdGhlIGJvYXJkIGlzIGVtcHR5IGFuZFxuICAgICAgICAgKiB0aGVzZSBoZWFkZXJzIGRvbid0IG1ha2Ugc2Vuc2UgaW4gdGhpcyBzdGF0ZS4gVGhleSdsbCBnZXQgYWRkZWQgbGF0ZXJcbiAgICAgICAgICogdmlhIC5sb2FkKCkgb3IgLnB1dCgpXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyWydTZXRVcCddO1xuICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyWydGRU4nXTtcbiAgICB9XG4gICAgbG9hZChmZW4sIHsgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSwgcHJlc2VydmVIZWFkZXJzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIGxldCB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgLy8gYXBwZW5kIGNvbW1vbmx5IG9taXR0ZWQgZmVuIHRva2Vuc1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vucy5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50cyA9IFsnLScsICctJywgJzAnLCAnMSddO1xuICAgICAgICAgICAgZmVuID0gdG9rZW5zLmNvbmNhdChhZGp1c3RtZW50cy5zbGljZSgtKDYgLSB0b2tlbnMubGVuZ3RoKSkpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKCFza2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBvaywgZXJyb3IgfSA9IHZhbGlkYXRlRmVuKGZlbik7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRva2Vuc1swXTtcbiAgICAgICAgbGV0IHNxdWFyZSA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXIoeyBwcmVzZXJ2ZUhlYWRlcnMgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcG9zaXRpb24uY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKHBpZWNlID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGlnaXQocGllY2UpKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IHBhcnNlSW50KHBpZWNlLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHBpZWNlIDwgJ2EnID8gV0hJVEUgOiBCTEFDSztcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXQoeyB0eXBlOiBwaWVjZS50b0xvd2VyQ2FzZSgpLCBjb2xvciB9LCBhbGdlYnJhaWMoc3F1YXJlKSk7XG4gICAgICAgICAgICAgICAgc3F1YXJlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHVybiA9IHRva2Vuc1sxXTtcbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdLJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyB8PSBCSVRTLktTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ1EnKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53IHw9IEJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignaycpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgfD0gQklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdxJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiB8PSBCSVRTLlFTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IHRva2Vuc1szXSA9PT0gJy0nID8gRU1QVFkgOiBPeDg4W3Rva2Vuc1szXV07XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyID0gcGFyc2VJbnQodG9rZW5zWzVdLCAxMCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKGZlbik7XG4gICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQoZmVuKTtcbiAgICB9XG4gICAgZmVuKCkge1xuICAgICAgICBsZXQgZW1wdHkgPSAwO1xuICAgICAgICBsZXQgZmVuID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2xvciwgdHlwZTogcGllY2UgfSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgICAgIGZlbiArPSBjb2xvciA9PT0gV0hJVEUgPyBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtcHR5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSBlbXB0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IE94ODguaDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9ICcvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW1wdHkgPSAwO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FzdGxpbmcgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW1dISVRFXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnSyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW1dISVRFXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnUSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW0JMQUNLXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnayc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW0JMQUNLXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAncSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gd2UgaGF2ZSBhbiBlbXB0eSBjYXN0bGluZyBmbGFnP1xuICAgICAgICBjYXN0bGluZyA9IGNhc3RsaW5nIHx8ICctJztcbiAgICAgICAgbGV0IGVwU3F1YXJlID0gJy0nO1xuICAgICAgICAvKlxuICAgICAgICAgKiBvbmx5IHByaW50IHRoZSBlcCBzcXVhcmUgaWYgZW4gcGFzc2FudCBpcyBhIHZhbGlkIG1vdmUgKHBhd24gaXMgcHJlc2VudFxuICAgICAgICAgKiBhbmQgZXAgY2FwdHVyZSBpcyBub3QgcGlubmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuX2VwU3F1YXJlICE9PSBFTVBUWSkge1xuICAgICAgICAgICAgY29uc3QgYmlnUGF3blNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gMTYgOiAtMTYpO1xuICAgICAgICAgICAgY29uc3Qgc3F1YXJlcyA9IFtiaWdQYXduU3F1YXJlICsgMSwgYmlnUGF3blNxdWFyZSAtIDFdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcXVhcmUgb2Ygc3F1YXJlcykge1xuICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBzcXVhcmUgb2ZmIHRoZSBib2FyZD9cbiAgICAgICAgICAgICAgICBpZiAoc3F1YXJlICYgMHg4OCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl90dXJuO1xuICAgICAgICAgICAgICAgIC8vIGlzIHRoZXJlIGEgcGF3biB0aGF0IGNhbiBjYXB0dXJlIHRoZSBlcFNxdWFyZT9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IGNvbG9yICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LnR5cGUgPT09IFBBV04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhd24gbWFrZXMgYW4gZXAgY2FwdHVyZSwgZG9lcyBpdCBsZWF2ZSBpdCdzIGtpbmcgaW4gY2hlY2s/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogc3F1YXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuX2VwU3F1YXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGllY2U6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlZDogUEFXTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiBCSVRTLkVQX0NBUFRVUkUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xlZ2FsID0gIXRoaXMuX2lzS2luZ0F0dGFja2VkKGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5kb01vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXAgaXMgbGVnYWwsIGJyZWFrIGFuZCBzZXQgdGhlIGVwIHNxdWFyZSBpbiB0aGUgRkVOIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWdhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBhbGdlYnJhaWModGhpcy5fZXBTcXVhcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZlbixcbiAgICAgICAgICAgIHRoaXMuX3R1cm4sXG4gICAgICAgICAgICBjYXN0bGluZyxcbiAgICAgICAgICAgIGVwU3F1YXJlLFxuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzLFxuICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcixcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGluaXRpYWwgYm9hcmQgc2V0dXAgaXMgY2hhbmdlZCB3aXRoIHB1dCgpIG9yIHJlbW92ZSgpLlxuICAgICAqIG1vZGlmaWVzIHRoZSBTZXRVcCBhbmQgRkVOIHByb3BlcnRpZXMgb2YgdGhlIGhlYWRlciBvYmplY3QuIElmIHRoZSBGRU5cbiAgICAgKiBpcyBlcXVhbCB0byB0aGUgZGVmYXVsdCBwb3NpdGlvbiwgdGhlIFNldFVwIGFuZCBGRU4gYXJlIGRlbGV0ZWQgdGhlIHNldHVwXG4gICAgICogaXMgb25seSB1cGRhdGVkIGlmIGhpc3RvcnkubGVuZ3RoIGlzIHplcm8sIGllIG1vdmVzIGhhdmVuJ3QgYmVlbiBtYWRlLlxuICAgICAqL1xuICAgIF91cGRhdGVTZXR1cChmZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGZlbiAhPT0gREVGQVVMVF9QT1NJVElPTikge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyWydTZXRVcCddID0gJzEnO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyWydGRU4nXSA9IGZlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJbJ1NldFVwJ107XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyWydGRU4nXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5sb2FkKERFRkFVTFRfUE9TSVRJT04pO1xuICAgIH1cbiAgICBnZXQoc3F1YXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2FyZFtPeDg4W3NxdWFyZV1dO1xuICAgIH1cbiAgICBwdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3B1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVFblBhc3NhbnRTcXVhcmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBwaWVjZVxuICAgICAgICBpZiAoU1lNQk9MUy5pbmRleE9mKHR5cGUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIHZhbGlkIHNxdWFyZVxuICAgICAgICBpZiAoIShzcXVhcmUgaW4gT3g4OCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgLy8gZG9uJ3QgbGV0IHRoZSB1c2VyIHBsYWNlIG1vcmUgdGhhbiBvbmUga2luZ1xuICAgICAgICBpZiAodHlwZSA9PSBLSU5HICYmXG4gICAgICAgICAgICAhKHRoaXMuX2tpbmdzW2NvbG9yXSA9PSBFTVBUWSB8fCB0aGlzLl9raW5nc1tjb2xvcl0gPT0gc3EpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFBpZWNlT25TcXVhcmUgPSB0aGlzLl9ib2FyZFtzcV07XG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUga2luZ3Mgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgcGllY2UgZnJvbSBhcmdzLCBzZXQgdGhlIGBfa2luZ3NgIHJlc3BlY3RpdmUgZW50cnkgdG8gYEVNUFRZYFxuICAgICAgICBpZiAoY3VycmVudFBpZWNlT25TcXVhcmUgJiYgY3VycmVudFBpZWNlT25TcXVhcmUudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbY3VycmVudFBpZWNlT25TcXVhcmUuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm9hcmRbc3FdID0geyB0eXBlOiB0eXBlLCBjb2xvcjogY29sb3IgfTtcbiAgICAgICAgaWYgKHR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2NvbG9yXSA9IHNxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1vdmUoc3F1YXJlKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gdGhpcy5nZXQoc3F1YXJlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW094ODhbc3F1YXJlXV07XG4gICAgICAgIGlmIChwaWVjZSAmJiBwaWVjZS50eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1twaWVjZS5jb2xvcl0gPSBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xuICAgICAgICB0aGlzLl91cGRhdGVFblBhc3NhbnRTcXVhcmUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2V0dXAodGhpcy5mZW4oKSk7XG4gICAgICAgIHJldHVybiBwaWVjZTtcbiAgICB9XG4gICAgX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCkge1xuICAgICAgICBjb25zdCB3aGl0ZUtpbmdJblBsYWNlID0gdGhpcy5fYm9hcmRbT3g4OC5lMV0/LnR5cGUgPT09IEtJTkcgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguZTFdPy5jb2xvciA9PT0gV0hJVEU7XG4gICAgICAgIGNvbnN0IGJsYWNrS2luZ0luUGxhY2UgPSB0aGlzLl9ib2FyZFtPeDg4LmU4XT8udHlwZSA9PT0gS0lORyAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5lOF0/LmNvbG9yID09PSBCTEFDSztcbiAgICAgICAgaWYgKCF3aGl0ZUtpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmExXT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hMV0/LmNvbG9yICE9PSBXSElURSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSB+QklUUy5RU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aGl0ZUtpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmgxXT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LmNvbG9yICE9PSBXSElURSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSB+QklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmE4XT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hOF0/LmNvbG9yICE9PSBCTEFDSykge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiAmPSB+QklUUy5RU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4Lmg4XT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oOF0/LmNvbG9yICE9PSBCTEFDSykge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiAmPSB+QklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3VwZGF0ZUVuUGFzc2FudFNxdWFyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VwU3F1YXJlID09PSBFTVBUWSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0U3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gV0hJVEUgPyAtMTYgOiAxNik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IDE2IDogLTE2KTtcbiAgICAgICAgY29uc3QgYXR0YWNrZXJzID0gW2N1cnJlbnRTcXVhcmUgKyAxLCBjdXJyZW50U3F1YXJlIC0gMV07XG4gICAgICAgIGlmICh0aGlzLl9ib2FyZFtzdGFydFNxdWFyZV0gIT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3RoaXMuX2VwU3F1YXJlXSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbY3VycmVudFNxdWFyZV0/LmNvbG9yICE9PSBzd2FwQ29sb3IodGhpcy5fdHVybikgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW2N1cnJlbnRTcXVhcmVdPy50eXBlICE9PSBQQVdOKSB7XG4gICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbkNhcHR1cmUgPSAoc3F1YXJlKSA9PiAhKHNxdWFyZSAmIDB4ODgpICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy5jb2xvciA9PT0gdGhpcy5fdHVybiAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbc3F1YXJlXT8udHlwZSA9PT0gUEFXTjtcbiAgICAgICAgaWYgKCFhdHRhY2tlcnMuc29tZShjYW5DYXB0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXR0YWNrZWQoY29sb3IsIHNxdWFyZSwgdmVyYm9zZSkge1xuICAgICAgICBjb25zdCBhdHRhY2tlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZW1wdHkgc3F1YXJlIG9yIHdyb25nIGNvbG9yXG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ib2FyZFtpXS5jb2xvciAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gdGhpcy5fYm9hcmRbaV07XG4gICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gaSAtIHNxdWFyZTtcbiAgICAgICAgICAgIC8vIHNraXAgLSB0by9mcm9tIHNxdWFyZSBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGRpZmZlcmVuY2UgKyAxMTk7XG4gICAgICAgICAgICBpZiAoQVRUQUNLU1tpbmRleF0gJiBQSUVDRV9NQVNLU1twaWVjZS50eXBlXSkge1xuICAgICAgICAgICAgICAgIGlmIChwaWVjZS50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZGlmZmVyZW5jZSA+IDAgJiYgcGllY2UuY29sb3IgPT09IFdISVRFKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRpZmZlcmVuY2UgPD0gMCAmJiBwaWVjZS5jb2xvciA9PT0gQkxBQ0spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwaWVjZSBpcyBhIGtuaWdodCBvciBhIGtpbmdcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ24nIHx8IHBpZWNlLnR5cGUgPT09ICdrJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNrZXJzLnB1c2goYWxnZWJyYWljKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IFJBWVNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBqID0gaSArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqICE9PSBzcXVhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2pdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaiArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNrZXJzLnB1c2goYWxnZWJyYWljKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXR0YWNrZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFja2VycyhzcXVhcmUsIGF0dGFja2VkQnkpIHtcbiAgICAgICAgaWYgKCFhdHRhY2tlZEJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQodGhpcy5fdHVybiwgT3g4OFtzcXVhcmVdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2tlZChhdHRhY2tlZEJ5LCBPeDg4W3NxdWFyZV0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc0tpbmdBdHRhY2tlZChjb2xvcikge1xuICAgICAgICBjb25zdCBzcXVhcmUgPSB0aGlzLl9raW5nc1tjb2xvcl07XG4gICAgICAgIHJldHVybiBzcXVhcmUgPT09IC0xID8gZmFsc2UgOiB0aGlzLl9hdHRhY2tlZChzd2FwQ29sb3IoY29sb3IpLCBzcXVhcmUpO1xuICAgIH1cbiAgICBpc0F0dGFja2VkKHNxdWFyZSwgYXR0YWNrZWRCeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQoYXR0YWNrZWRCeSwgT3g4OFtzcXVhcmVdKTtcbiAgICB9XG4gICAgaXNDaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzS2luZ0F0dGFja2VkKHRoaXMuX3R1cm4pO1xuICAgIH1cbiAgICBpbkNoZWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrKCk7XG4gICAgfVxuICAgIGlzQ2hlY2ttYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrKCkgJiYgdGhpcy5fbW92ZXMoKS5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGlzU3RhbGVtYXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc0luc3VmZmljaWVudE1hdGVyaWFsKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBrLmIuIHZzIGsuYi4gKG9mIG9wcG9zaXRlIGNvbG9ycykgd2l0aCBtYXRlIGluIDE6XG4gICAgICAgICAqIDgvOC84LzgvMWI2LzgvQjFrNS9LNyBiIC0gLSAwIDFcbiAgICAgICAgICpcbiAgICAgICAgICogay5iLiB2cyBrLm4uIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFuNi84L0I3L0sxazUgYiAtIC0gMiAxXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwaWVjZXMgPSB7XG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgbjogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICBxOiAwLFxuICAgICAgICAgICAgazogMCxcbiAgICAgICAgICAgIHA6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJpc2hvcHMgPSBbXTtcbiAgICAgICAgbGV0IG51bVBpZWNlcyA9IDA7XG4gICAgICAgIGxldCBzcXVhcmVDb2xvciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgc3F1YXJlQ29sb3IgPSAoc3F1YXJlQ29sb3IgKyAxKSAlIDI7XG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgaWYgKHBpZWNlKSB7XG4gICAgICAgICAgICAgICAgcGllY2VzW3BpZWNlLnR5cGVdID0gcGllY2UudHlwZSBpbiBwaWVjZXMgPyBwaWVjZXNbcGllY2UudHlwZV0gKyAxIDogMTtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gQklTSE9QKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpc2hvcHMucHVzaChzcXVhcmVDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bVBpZWNlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGsgdnMuIGtcbiAgICAgICAgaWYgKG51bVBpZWNlcyA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIGsgdnMuIGtuIC4uLi4gb3IgLi4uLiBrIHZzLiBrYlxuICAgICAgICBudW1QaWVjZXMgPT09IDMgJiZcbiAgICAgICAgICAgIChwaWVjZXNbQklTSE9QXSA9PT0gMSB8fCBwaWVjZXNbS05JR0hUXSA9PT0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bVBpZWNlcyA9PT0gcGllY2VzW0JJU0hPUF0gKyAyKSB7XG4gICAgICAgICAgICAvLyBrYiB2cy4ga2Igd2hlcmUgYW55IG51bWJlciBvZiBiaXNob3BzIGFyZSBhbGwgb24gdGhlIHNhbWUgY29sb3JcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYmlzaG9wcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGJpc2hvcHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VtID09PSAwIHx8IHN1bSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1RocmVlZm9sZFJlcGV0aXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQb3NpdGlvbkNvdW50KHRoaXMuZmVuKCkpID49IDM7XG4gICAgfVxuICAgIGlzRHJhd0J5RmlmdHlNb3ZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbGZNb3ZlcyA+PSAxMDA7IC8vIDUwIG1vdmVzIHBlciBzaWRlID0gMTAwIGhhbGYgbW92ZXNcbiAgICB9XG4gICAgaXNEcmF3KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNEcmF3QnlGaWZ0eU1vdmVzKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNTdGFsZW1hdGUoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0luc3VmZmljaWVudE1hdGVyaWFsKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkpO1xuICAgIH1cbiAgICBpc0dhbWVPdmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrbWF0ZSgpIHx8IHRoaXMuaXNTdGFsZW1hdGUoKSB8fCB0aGlzLmlzRHJhdygpO1xuICAgIH1cbiAgICBtb3Zlcyh7IHZlcmJvc2UgPSBmYWxzZSwgc3F1YXJlID0gdW5kZWZpbmVkLCBwaWVjZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBzcXVhcmUsIHBpZWNlIH0pO1xuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gbmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gdGhpcy5fbW92ZVRvU2FuKG1vdmUsIG1vdmVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21vdmVzKHsgbGVnYWwgPSB0cnVlLCBwaWVjZSA9IHVuZGVmaW5lZCwgc3F1YXJlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZm9yU3F1YXJlID0gc3F1YXJlID8gc3F1YXJlLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZvclBpZWNlID0gcGllY2U/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIGxldCBmaXJzdFNxdWFyZSA9IE94ODguYTg7XG4gICAgICAgIGxldCBsYXN0U3F1YXJlID0gT3g4OC5oMTtcbiAgICAgICAgbGV0IHNpbmdsZVNxdWFyZSA9IGZhbHNlO1xuICAgICAgICAvLyBhcmUgd2UgZ2VuZXJhdGluZyBtb3ZlcyBmb3IgYSBzaW5nbGUgc3F1YXJlP1xuICAgICAgICBpZiAoZm9yU3F1YXJlKSB7XG4gICAgICAgICAgICAvLyBpbGxlZ2FsIHNxdWFyZSwgcmV0dXJuIGVtcHR5IG1vdmVzXG4gICAgICAgICAgICBpZiAoIShmb3JTcXVhcmUgaW4gT3g4OCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdFNxdWFyZSA9IGxhc3RTcXVhcmUgPSBPeDg4W2ZvclNxdWFyZV07XG4gICAgICAgICAgICAgICAgc2luZ2xlU3F1YXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBmcm9tID0gZmlyc3RTcXVhcmU7IGZyb20gPD0gbGFzdFNxdWFyZTsgZnJvbSsrKSB7XG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxuICAgICAgICAgICAgaWYgKGZyb20gJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgZnJvbSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW1wdHkgc3F1YXJlIG9yIG9wcG9uZW50LCBza2lwXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Zyb21dIHx8IHRoaXMuX2JvYXJkW2Zyb21dLmNvbG9yID09PSB0aGVtKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHRoaXMuX2JvYXJkW2Zyb21dO1xuICAgICAgICAgICAgbGV0IHRvO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBBV04pIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yUGllY2UgJiYgZm9yUGllY2UgIT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcXVhcmUsIG5vbi1jYXB0dXJpbmdcbiAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdWzBdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbdG9dKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvdWJsZSBzcXVhcmVcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNFQ09ORF9SQU5LW3VzXSA9PT0gcmFuayhmcm9tKSAmJiAhdGhpcy5fYm9hcmRbdG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIHVuZGVmaW5lZCwgQklUUy5CSUdfUEFXTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGF3biBjYXB0dXJlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAyOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bal07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3RvXT8uY29sb3IgPT09IHRoZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTiwgdGhpcy5fYm9hcmRbdG9dLnR5cGUsIEJJVFMuQ0FQVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IHRoaXMuX2VwU3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIFBBV04sIEJJVFMuRVBfQ0FQVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yUGllY2UgJiYgZm9yUGllY2UgIT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBsZW4gPSBQSUVDRV9PRkZTRVRTW3R5cGVdLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IFBJRUNFX09GRlNFVFNbdHlwZV1bal07XG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvd24gY29sb3IsIHN0b3AgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10uY29sb3IgPT09IHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUsIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYnJlYWssIGlmIGtuaWdodCBvciBraW5nICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gS05JR0hUIHx8IHR5cGUgPT09IEtJTkcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogY2hlY2sgZm9yIGNhc3RsaW5nIGlmIHdlJ3JlOlxuICAgICAgICAgKiAgIGEpIGdlbmVyYXRpbmcgYWxsIG1vdmVzLCBvclxuICAgICAgICAgKiAgIGIpIGRvaW5nIHNpbmdsZSBzcXVhcmUgbW92ZSBnZW5lcmF0aW9uIG9uIHRoZSBraW5nJ3Mgc3F1YXJlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZm9yUGllY2UgPT09IHVuZGVmaW5lZCB8fCBmb3JQaWVjZSA9PT0gS0lORykge1xuICAgICAgICAgICAgaWYgKCFzaW5nbGVTcXVhcmUgfHwgbGFzdFNxdWFyZSA9PT0gdGhpcy5fa2luZ3NbdXNdKSB7XG4gICAgICAgICAgICAgICAgLy8ga2luZy1zaWRlIGNhc3RsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IHRoaXMuX2tpbmdzW3VzXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IGNhc3RsaW5nRnJvbSArIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tICsgMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ1RvXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIHRoaXMuX2tpbmdzW3VzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gKyAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nVG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgdGhpcy5fa2luZ3NbdXNdLCBjYXN0bGluZ1RvLCBLSU5HLCB1bmRlZmluZWQsIEJJVFMuS1NJREVfQ0FTVExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBxdWVlbi1zaWRlIGNhc3RsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IHRoaXMuX2tpbmdzW3VzXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IGNhc3RsaW5nRnJvbSAtIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAyXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDNdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgdGhpcy5fa2luZ3NbdXNdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nRnJvbSAtIDEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdUbykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCB0aGlzLl9raW5nc1t1c10sIGNhc3RsaW5nVG8sIEtJTkcsIHVuZGVmaW5lZCwgQklUUy5RU0lERV9DQVNUTEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIHJldHVybiBhbGwgcHNldWRvLWxlZ2FsIG1vdmVzICh0aGlzIGluY2x1ZGVzIG1vdmVzIHRoYXQgYWxsb3cgdGhlIGtpbmdcbiAgICAgICAgICogdG8gYmUgY2FwdHVyZWQpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWxlZ2FsIHx8IHRoaXMuX2tpbmdzW3VzXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGlsbGVnYWwgbW92ZXNcbiAgICAgICAgY29uc3QgbGVnYWxNb3ZlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNLaW5nQXR0YWNrZWQodXMpKSB7XG4gICAgICAgICAgICAgICAgbGVnYWxNb3Zlcy5wdXNoKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZ2FsTW92ZXM7XG4gICAgfVxuICAgIG1vdmUobW92ZSwgeyBzdHJpY3QgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIG1vdmUgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB3aXRoIGluIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgICAgICpcbiAgICAgICAgICogLm1vdmUoJ054YjcnKSAgICAgICA8LSBhcmd1bWVudCBpcyBhIGNhc2Utc2Vuc2l0aXZlIFNBTiBzdHJpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogLm1vdmUoeyBmcm9tOiAnaDcnLCA8LSBhcmd1bWVudCBpcyBhIG1vdmUgb2JqZWN0XG4gICAgICAgICAqICAgICAgICAgdG8gOidoOCcsXG4gICAgICAgICAqICAgICAgICAgcHJvbW90aW9uOiAncScgfSlcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQW4gb3B0aW9uYWwgc3RyaWN0IGFyZ3VtZW50IG1heSBiZSBzdXBwbGllZCB0byB0ZWxsIGNoZXNzLmpzIHRvXG4gICAgICAgICAqIHN0cmljdGx5IGZvbGxvdyB0aGUgU0FOIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbW92ZU9iaiA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1vdmVPYmogPSB0aGlzLl9tb3ZlRnJvbVNhbihtb3ZlLCBzdHJpY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb3ZlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3ZlcygpO1xuICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcHJldHR5IG1vdmUgb2JqZWN0IHRvIGFuIHVnbHkgbW92ZSBvYmplY3RcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLmZyb20gPT09IGFsZ2VicmFpYyhtb3Zlc1tpXS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb3ZlLnRvID09PSBhbGdlYnJhaWMobW92ZXNbaV0udG8pICYmXG4gICAgICAgICAgICAgICAgICAgICghKCdwcm9tb3Rpb24nIGluIG1vdmVzW2ldKSB8fCBtb3ZlLnByb21vdGlvbiA9PT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlT2JqID0gbW92ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmYWlsZWQgdG8gZmluZCBtb3ZlXG4gICAgICAgIGlmICghbW92ZU9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3ZlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlOiAke21vdmV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZTogJHtKU09OLnN0cmluZ2lmeShtb3ZlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBuZWVkIHRvIG1ha2UgYSBjb3B5IG9mIG1vdmUgYmVjYXVzZSB3ZSBjYW4ndCBnZW5lcmF0ZSBTQU4gYWZ0ZXIgdGhlIG1vdmVcbiAgICAgICAgICogaXMgbWFkZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmVPYmopO1xuICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlT2JqKTtcbiAgICAgICAgdGhpcy5faW5jUG9zaXRpb25Db3VudChwcmV0dHlNb3ZlLmFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eU1vdmU7XG4gICAgfVxuICAgIF9wdXNoKG1vdmUpIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgIG1vdmUsXG4gICAgICAgICAgICBraW5nczogeyBiOiB0aGlzLl9raW5ncy5iLCB3OiB0aGlzLl9raW5ncy53IH0sXG4gICAgICAgICAgICB0dXJuOiB0aGlzLl90dXJuLFxuICAgICAgICAgICAgY2FzdGxpbmc6IHsgYjogdGhpcy5fY2FzdGxpbmcuYiwgdzogdGhpcy5fY2FzdGxpbmcudyB9LFxuICAgICAgICAgICAgZXBTcXVhcmU6IHRoaXMuX2VwU3F1YXJlLFxuICAgICAgICAgICAgaGFsZk1vdmVzOiB0aGlzLl9oYWxmTW92ZXMsXG4gICAgICAgICAgICBtb3ZlTnVtYmVyOiB0aGlzLl9tb3ZlTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX21ha2VNb3ZlKG1vdmUpIHtcbiAgICAgICAgY29uc3QgdXMgPSB0aGlzLl90dXJuO1xuICAgICAgICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKTtcbiAgICAgICAgdGhpcy5fcHVzaChtb3ZlKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50b10gPSB0aGlzLl9ib2FyZFttb3ZlLmZyb21dO1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbbW92ZS5mcm9tXTtcbiAgICAgICAgLy8gaWYgZXAgY2FwdHVyZSwgcmVtb3ZlIHRoZSBjYXB0dXJlZCBwYXduXG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHVybiA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbbW92ZS50byAtIDE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFttb3ZlLnRvICsgMTZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHBhd24gcHJvbW90aW9uLCByZXBsYWNlIHdpdGggbmV3IHBpZWNlXG4gICAgICAgIGlmIChtb3ZlLnByb21vdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50b10gPSB7IHR5cGU6IG1vdmUucHJvbW90aW9uLCBjb2xvcjogdXMgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBtb3ZlZCB0aGUga2luZ1xuICAgICAgICBpZiAodGhpcy5fYm9hcmRbbW92ZS50b10udHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbdXNdID0gbW92ZS50bztcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhc3RsZWQsIG1vdmUgdGhlIHJvb2sgbmV4dCB0byB0aGUga2luZ1xuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBtb3ZlLnRvIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSBtb3ZlLnRvICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtjYXN0bGluZ1RvXSA9IHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gbW92ZS50byAtIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmdcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgbW92ZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3VzXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLmZyb20gPT09IFJPT0tTW3VzXVtpXS5zcXVhcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdICYgUk9PS1NbdXNdW2ldLmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdIF49IFJPT0tTW3VzXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgY2FwdHVyZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3RoZW1dKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gUk9PS1NbdGhlbV0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS50byA9PT0gUk9PS1NbdGhlbV1baV0uc3F1YXJlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3RoZW1dICYgUk9PS1NbdGhlbV1baV0uZmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t0aGVtXSBePSBST09LU1t0aGVtXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYmlnIHBhd24gbW92ZSwgdXBkYXRlIHRoZSBlbiBwYXNzYW50IHNxdWFyZVxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuQklHX1BBV04pIHtcbiAgICAgICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IG1vdmUudG8gLSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gbW92ZS50byArIDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0aGUgNTAgbW92ZSBjb3VudGVyIGlmIGEgcGF3biBpcyBtb3ZlZCBvciBhIHBpZWNlIGlzIGNhcHR1cmVkXG4gICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBQQVdOKSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5DQVBUVVJFIHwgQklUUy5FUF9DQVBUVVJFKSkge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90dXJuID0gdGhlbTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV0dHlNb3ZlID0gbmV3IE1vdmUodGhpcywgbW92ZSk7XG4gICAgICAgICAgICB0aGlzLl9kZWNQb3NpdGlvbkNvdW50KHByZXR0eU1vdmUuYWZ0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXR0eU1vdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF91bmRvTW92ZSgpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5faGlzdG9yeS5wb3AoKTtcbiAgICAgICAgaWYgKG9sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb3ZlID0gb2xkLm1vdmU7XG4gICAgICAgIHRoaXMuX2tpbmdzID0gb2xkLmtpbmdzO1xuICAgICAgICB0aGlzLl90dXJuID0gb2xkLnR1cm47XG4gICAgICAgIHRoaXMuX2Nhc3RsaW5nID0gb2xkLmNhc3RsaW5nO1xuICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IG9sZC5lcFNxdWFyZTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gb2xkLmhhbGZNb3ZlcztcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IG9sZC5tb3ZlTnVtYmVyO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLmZyb21dID0gdGhpcy5fYm9hcmRbbW92ZS50b107XG4gICAgICAgIHRoaXMuX2JvYXJkW21vdmUuZnJvbV0udHlwZSA9IG1vdmUucGllY2U7IC8vIHRvIHVuZG8gYW55IHByb21vdGlvbnNcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUudG9dO1xuICAgICAgICBpZiAobW92ZS5jYXB0dXJlZCkge1xuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkVQX0NBUFRVUkUpIHtcbiAgICAgICAgICAgICAgICAvLyBlbiBwYXNzYW50IGNhcHR1cmVcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHVzID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1vdmUudG8gLSAxNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbW92ZS50byArIDE2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtpbmRleF0gPSB7IHR5cGU6IFBBV04sIGNvbG9yOiB0aGVtIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWd1bGFyIGNhcHR1cmVcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLnRvXSA9IHsgdHlwZTogbW92ZS5jYXB0dXJlZCwgY29sb3I6IHRoZW0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIChCSVRTLktTSURFX0NBU1RMRSB8IEJJVFMuUVNJREVfQ0FTVExFKSkge1xuICAgICAgICAgICAgbGV0IGNhc3RsaW5nVG8sIGNhc3RsaW5nRnJvbTtcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ1RvID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdGcm9tID0gbW92ZS50byAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ1RvID0gbW92ZS50byAtIDI7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdGcm9tID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjYXN0bGluZ1RvXSA9IHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW92ZTtcbiAgICB9XG4gICAgcGduKHsgbmV3bGluZSA9ICdcXG4nLCBtYXhXaWR0aCA9IDAsIH0gPSB7fSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiB1c2luZyB0aGUgc3BlY2lmaWNhdGlvbiBmcm9tIGh0dHA6Ly93d3cuY2hlc3NjbHViLmNvbS9oZWxwL1BHTi1zcGVjXG4gICAgICAgICAqIGV4YW1wbGUgZm9yIGh0bWwgdXNhZ2U6IC5wZ24oeyBtYXhfd2lkdGg6IDcyLCBuZXdsaW5lX2NoYXI6IFwiPGJyIC8+XCIgfSlcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaGVhZGVyRXhpc3RzID0gZmFsc2U7XG4gICAgICAgIC8qIGFkZCB0aGUgUEdOIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5faGVhZGVyKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVE9ETzogb3JkZXIgb2YgZW51bWVyYXRlZCBwcm9wZXJ0aWVzIGluIGhlYWRlciBvYmplY3QgaXMgbm90XG4gICAgICAgICAgICAgKiBndWFyYW50ZWVkLCBzZWUgRUNNQS0yNjIgc3BlYyAoc2VjdGlvbiAxMi42LjQpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdbJyArIGkgKyAnIFwiJyArIHRoaXMuX2hlYWRlcltpXSArICdcIl0nICsgbmV3bGluZSk7XG4gICAgICAgICAgICBoZWFkZXJFeGlzdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJFeGlzdHMgJiYgdGhpcy5faGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGVuZENvbW1lbnQgPSAobW92ZVN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlciA9IG1vdmVTdHJpbmcubGVuZ3RoID4gMCA/ICcgJyA6ICcnO1xuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSBgJHttb3ZlU3RyaW5nfSR7ZGVsaW1pdGVyfXske2NvbW1lbnR9fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW92ZVN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcG9wIGFsbCBvZiBoaXN0b3J5IG9udG8gcmV2ZXJzZWRfaGlzdG9yeVxuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZXMgPSBbXTtcbiAgICAgICAgbGV0IG1vdmVTdHJpbmcgPSAnJztcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIG9mIGEgY29tbWVudGVkIHN0YXJ0aW5nIHBvc2l0aW9uIHdpdGggbm8gbW92ZXNcbiAgICAgICAgaWYgKHJldmVyc2VkSGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goYXBwZW5kQ29tbWVudCgnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIHRoZSBsaXN0IG9mIG1vdmVzLiAgYSBtb3ZlX3N0cmluZyBsb29rcyBsaWtlOiBcIjMuIGUzIGU2XCJcbiAgICAgICAgd2hpbGUgKHJldmVyc2VkSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtb3ZlU3RyaW5nID0gYXBwZW5kQ29tbWVudChtb3ZlU3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSByZXZlcnNlZEhpc3RvcnkucG9wKCk7XG4gICAgICAgICAgICAvLyBtYWtlIFR5cGVTY3JpcHQgc3RvcCBjb21wbGFpbmluZyBhYm91dCBtb3ZlIGJlaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9zaXRpb24gc3RhcnRlZCB3aXRoIGJsYWNrIHRvIG1vdmUsIHN0YXJ0IFBHTiB3aXRoICMuIC4uLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oaXN0b3J5Lmxlbmd0aCAmJiBtb3ZlLmNvbG9yID09PSAnYicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBgJHt0aGlzLl9tb3ZlTnVtYmVyfS4gLi4uYDtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIGNvbW1lbnQgcHJlY2VkaW5nIHRoZSBmaXJzdCBtb3ZlP1xuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSBtb3ZlU3RyaW5nID8gYCR7bW92ZVN0cmluZ30gJHtwcmVmaXh9YCA6IHByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vdmUuY29sb3IgPT09ICd3Jykge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBnZW5lcmF0ZWQgbW92ZV9zdHJpbmcgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgICAgICAgICBpZiAobW92ZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZXMucHVzaChtb3ZlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyA9IHRoaXMuX21vdmVOdW1iZXIgKyAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3ZlU3RyaW5nID1cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nICsgJyAnICsgdGhpcy5fbW92ZVRvU2FuKG1vdmUsIHRoaXMuX21vdmVzKHsgbGVnYWw6IHRydWUgfSkpO1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBvdGhlciBsZWZ0b3ZlciBtb3Zlcz9cbiAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQobW92ZVN0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzIHRoZXJlIGEgcmVzdWx0P1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2hlYWRlci5SZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKHRoaXMuX2hlYWRlci5SZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIGhpc3Rvcnkgc2hvdWxkIGJlIGJhY2sgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHN0YXJ0ZWQgZ2VuZXJhdGluZyBQR04sXG4gICAgICAgICAqIHNvIGpvaW4gdG9nZXRoZXIgbW92ZXNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChtYXhXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKSArIG1vdmVzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIChqYWgpOiBodWg/XG4gICAgICAgIGNvbnN0IHN0cmlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTkI6IHRoaXMgZG9lcyBub3QgcHJlc2VydmUgY29tbWVudCB3aGl0ZXNwYWNlLlxuICAgICAgICBjb25zdCB3cmFwQ29tbWVudCA9IGZ1bmN0aW9uICh3aWR0aCwgbW92ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBtb3ZlLnNwbGl0KCcgJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2lkdGggKyB0b2tlbi5sZW5ndGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyaXAoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgd2lkdGggKz0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgd2lkdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpcCgpKSB7XG4gICAgICAgICAgICAgICAgd2lkdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gd3JhcCB0aGUgUEdOIG91dHB1dCBhdCBtYXhfd2lkdGhcbiAgICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggKyBtb3Zlc1tpXS5sZW5ndGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3Zlc1tpXS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IHdyYXBDb21tZW50KGN1cnJlbnRXaWR0aCwgbW92ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBtb3ZlIHdpbGwgcHVzaCBwYXN0IG1heF93aWR0aFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCArIG1vdmVzW2ldLmxlbmd0aCA+IG1heFdpZHRoICYmIGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBlbmQgdGhlIGxpbmUgd2l0aCB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaWR0aCArPSBtb3Zlc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHNldEhlYWRlcmAgYW5kIGBnZXRIZWFkZXJzYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGhlYWRlciguLi5hcmdzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnc1tpICsgMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyW2FyZ3NbaV1dID0gYXJnc1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9XG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVhZGVyW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9XG4gICAgcmVtb3ZlSGVhZGVyKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcltrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuICAgIH1cbiAgICBsb2FkUGduKHBnbiwgeyBzdHJpY3QgPSBmYWxzZSwgbmV3bGluZUNoYXIgPSAnXFxyP1xcbicsIH0gPSB7fSkge1xuICAgICAgICBmdW5jdGlvbiBtYXNrKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VQZ25IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJPYmogPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBoZWFkZXIuc3BsaXQobmV3IFJlZ0V4cChtYXNrKG5ld2xpbmVDaGFyKSkpO1xuICAgICAgICAgICAgbGV0IGtleSA9ICcnO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IC9eXFxzKlxcW1xccyooW0EtWmEtel0rKVxccypcIiguKilcIlxccypcXF1cXHMqJC87XG4gICAgICAgICAgICAgICAga2V5ID0gaGVhZGVyc1tpXS5yZXBsYWNlKHJlZ2V4LCAnJDEnKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhlYWRlcnNbaV0ucmVwbGFjZShyZWdleCwgJyQyJyk7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJPYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJPYmo7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyaXAgd2hpdGVzcGFjZSBmcm9tIGhlYWQvdGFpbCBvZiBQR04gYmxvY2tcbiAgICAgICAgcGduID0gcGduLnRyaW0oKTtcbiAgICAgICAgLypcbiAgICAgICAgICogUmVnRXhwIHRvIHNwbGl0IGhlYWRlci4gVGFrZXMgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgaGVhZGVyIGFuZCBtb3ZldGV4dFxuICAgICAgICAgKiB3aWxsIGFsd2F5cyBoYXZlIGEgYmxhbmsgbGluZSBiZXR3ZWVuIHRoZW0gKGllLCB0d28gbmV3bGluZV9jaGFyJ3MpLiBIYW5kbGVzXG4gICAgICAgICAqIGNhc2Ugd2hlcmUgbW92ZXRleHQgaXMgZW1wdHkgYnkgbWF0Y2hpbmcgbmV3bGluZUNoYXIgdW50aWwgZW5kIG9mIHN0cmluZyBpc1xuICAgICAgICAgKiBtYXRjaGVkIC0gZWZmZWN0aXZlbHkgdHJpbW1pbmcgZnJvbSB0aGUgZW5kIGV4dHJhIG5ld2xpbmVDaGFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGRlZmF1bHQgbmV3bGluZV9jaGFyLCB3aWxsIGVxdWFsOlxuICAgICAgICAgKiAvXihcXFsoKD86XFxyP1xcbil8LikqXFxdKSgoPzpcXHMqXFxyP1xcbil7Mn18KD86XFxzKlxccj9cXG4pKiQpL1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaGVhZGVyUmVnZXggPSBuZXcgUmVnRXhwKCdeKFxcXFxbKCg/OicgK1xuICAgICAgICAgICAgbWFzayhuZXdsaW5lQ2hhcikgK1xuICAgICAgICAgICAgJyl8LikqXFxcXF0pJyArXG4gICAgICAgICAgICAnKCg/OlxcXFxzKicgK1xuICAgICAgICAgICAgbWFzayhuZXdsaW5lQ2hhcikgK1xuICAgICAgICAgICAgJyl7Mn18KD86XFxcXHMqJyArXG4gICAgICAgICAgICBtYXNrKG5ld2xpbmVDaGFyKSArXG4gICAgICAgICAgICAnKSokKScpO1xuICAgICAgICAvLyBJZiBubyBoZWFkZXIgZ2l2ZW4sIGJlZ2luIHdpdGggbW92ZXMuXG4gICAgICAgIGNvbnN0IGhlYWRlclJlZ2V4UmVzdWx0cyA9IGhlYWRlclJlZ2V4LmV4ZWMocGduKTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RyaW5nID0gaGVhZGVyUmVnZXhSZXN1bHRzXG4gICAgICAgICAgICA/IGhlYWRlclJlZ2V4UmVzdWx0cy5sZW5ndGggPj0gMlxuICAgICAgICAgICAgICAgID8gaGVhZGVyUmVnZXhSZXN1bHRzWzFdXG4gICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgLy8gUHV0IHRoZSBib2FyZCBpbiB0aGUgc3RhcnRpbmcgcG9zaXRpb25cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAvLyBwYXJzZSBQR04gaGVhZGVyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZVBnbkhlYWRlcihoZWFkZXJTdHJpbmcpO1xuICAgICAgICBsZXQgZmVuID0gJyc7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSB1c2VyIGlzIGluY2x1ZGluZyBmZW4gKHBvc3NpYmx5IHdpdGggd3JvbmcgdGFnIGNhc2UpXG4gICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdmZW4nKSB7XG4gICAgICAgICAgICAgICAgZmVuID0gaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIHRoZSBwZXJtaXNzaXZlIHBhcnNlciBzaG91bGQgYXR0ZW1wdCB0byBsb2FkIGEgZmVuIHRhZywgZXZlbiBpZiBpdCdzIHRoZVxuICAgICAgICAgKiB3cm9uZyBjYXNlIGFuZCBkb2Vzbid0IGluY2x1ZGUgYSBjb3JyZXNwb25kaW5nIFtTZXRVcCBcIjFcIl0gdGFnXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZlbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZChmZW4sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHN0cmljdCBwYXJzZXIgLSBsb2FkIHRoZSBzdGFydGluZyBwb3NpdGlvbiBpbmRpY2F0ZWQgYnkgW1NldHVwICcxJ11cbiAgICAgICAgICAgICAqIGFuZCBbRkVOIHBvc2l0aW9uXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1snU2V0VXAnXSA9PT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoJ0ZFTicgaW4gaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBHTjogRkVOIHRhZyBtdXN0IGJlIHN1cHBsaWVkIHdpdGggU2V0VXAgdGFnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNsZWFyIHRoZSBoZWFkZXJzIHdoZW4gbG9hZGluZ1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZChoZWFkZXJzWydGRU4nXSwgeyBwcmVzZXJ2ZUhlYWRlcnM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogTkI6IHRoZSByZWdleGVzIGJlbG93IHRoYXQgZGVsZXRlIG1vdmUgbnVtYmVycywgcmVjdXJzaXZlIGFubm90YXRpb25zLFxuICAgICAgICAgKiBhbmQgbnVtZXJpYyBhbm5vdGF0aW9uIGdseXBocyBtYXkgYWxzbyBtYXRjaCB0ZXh0IGluIGNvbW1lbnRzLiBUb1xuICAgICAgICAgKiBwcmV2ZW50IHRoaXMsIHdlIHRyYW5zZm9ybSBjb21tZW50cyBieSBoZXgtZW5jb2RpbmcgdGhlbSBpbiBwbGFjZSBhbmRcbiAgICAgICAgICogZGVjb2RpbmcgdGhlbSBhZ2FpbiBhZnRlciB0aGUgb3RoZXIgdG9rZW5zIGhhdmUgYmVlbiBkZWxldGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGlsZSB0aGUgc3BlYyBzdGF0ZXMgdGhhdCBQR04gZmlsZXMgc2hvdWxkIGJlIEFTQ0lJIGVuY29kZWQsIHdlIHVzZVxuICAgICAgICAgKiB7ZW4sZGV9Y29kZVVSSUNvbXBvbmVudCBoZXJlIHRvIHN1cHBvcnQgYXJiaXRyYXJ5IFVURjggYXMgYSBjb252ZW5pZW5jZVxuICAgICAgICAgKiBmb3IgbW9kZXJuIHVzZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0b0hleChzKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGVuY29kZVVSSSBkb2Vzbid0IHRyYW5zZm9ybSBtb3N0IEFTQ0lJIGNoYXJhY3RlcnMsIHNvIHdlIGhhbmRsZVxuICAgICAgICAgICAgICAgICAqIHRoZXNlIG91cnNlbHZlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgPCAxMjhcbiAgICAgICAgICAgICAgICAgICAgPyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50KGMpLnJlcGxhY2UoLyUvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmcm9tSGV4KHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmxlbmd0aCA9PSAwXG4gICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgIDogZGVjb2RlVVJJQ29tcG9uZW50KCclJyArIChzLm1hdGNoKC8uezEsMn0vZykgfHwgW10pLmpvaW4oJyUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlQ29tbWVudCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhciksICdnJyksICcgJyk7XG4gICAgICAgICAgICByZXR1cm4gYHske3RvSGV4KHMuc2xpY2UoMSwgcy5sZW5ndGggLSAxKSl9fWA7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlY29kZUNvbW1lbnQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgaWYgKHMuc3RhcnRzV2l0aCgneycpICYmIHMuZW5kc1dpdGgoJ30nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHMuc2xpY2UoMSwgcy5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlbGV0ZSBoZWFkZXIgdG8gZ2V0IHRoZSBtb3Zlc1xuICAgICAgICBsZXQgbXMgPSBwZ25cbiAgICAgICAgICAgIC5yZXBsYWNlKGhlYWRlclN0cmluZywgJycpXG4gICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgLy8gZW5jb2RlIGNvbW1lbnRzIHNvIHRoZXkgZG9uJ3QgZ2V0IGRlbGV0ZWQgYmVsb3dcbiAgICAgICAgbmV3IFJlZ0V4cChgKHtbXn1dKn0pKz98OyhbXiR7bWFzayhuZXdsaW5lQ2hhcil9XSopYCwgJ2cnKSwgZnVuY3Rpb24gKF9tYXRjaCwgYnJhY2tldCwgc2VtaWNvbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJhY2tldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBlbmNvZGVDb21tZW50KGJyYWNrZXQpXG4gICAgICAgICAgICAgICAgOiAnICcgKyBlbmNvZGVDb21tZW50KGB7JHtzZW1pY29sb24uc2xpY2UoMSl9fWApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChtYXNrKG5ld2xpbmVDaGFyKSwgJ2cnKSwgJyAnKTtcbiAgICAgICAgLy8gZGVsZXRlIHJlY3Vyc2l2ZSBhbm5vdGF0aW9uIHZhcmlhdGlvbnNcbiAgICAgICAgY29uc3QgcmF2UmVnZXggPSAvKFxcKFteKCldK1xcKSkrPy9nO1xuICAgICAgICB3aGlsZSAocmF2UmVnZXgudGVzdChtcykpIHtcbiAgICAgICAgICAgIG1zID0gbXMucmVwbGFjZShyYXZSZWdleCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlbGV0ZSBtb3ZlIG51bWJlcnNcbiAgICAgICAgbXMgPSBtcy5yZXBsYWNlKC9cXGQrXFwuKFxcLlxcLik/L2csICcnKTtcbiAgICAgICAgLy8gZGVsZXRlIC4uLiBpbmRpY2F0aW5nIGJsYWNrIHRvIG1vdmVcbiAgICAgICAgbXMgPSBtcy5yZXBsYWNlKC9cXC5cXC5cXC4vZywgJycpO1xuICAgICAgICAvKiBkZWxldGUgbnVtZXJpYyBhbm5vdGF0aW9uIGdseXBocyAqL1xuICAgICAgICBtcyA9IG1zLnJlcGxhY2UoL1xcJFxcZCsvZywgJycpO1xuICAgICAgICAvLyB0cmltIGFuZCBnZXQgYXJyYXkgb2YgbW92ZXNcbiAgICAgICAgbGV0IG1vdmVzID0gbXMudHJpbSgpLnNwbGl0KG5ldyBSZWdFeHAoL1xccysvKSk7XG4gICAgICAgIC8vIGRlbGV0ZSBlbXB0eSBlbnRyaWVzXG4gICAgICAgIG1vdmVzID0gbW92ZXMuZmlsdGVyKChtb3ZlKSA9PiBtb3ZlICE9PSAnJyk7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaGFsZk1vdmUgPSAwOyBoYWxmTW92ZSA8IG1vdmVzLmxlbmd0aDsgaGFsZk1vdmUrKykge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IGRlY29kZUNvbW1lbnQobW92ZXNbaGFsZk1vdmVdKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gdGhpcy5fbW92ZUZyb21TYW4obW92ZXNbaGFsZk1vdmVdLCBzdHJpY3QpO1xuICAgICAgICAgICAgLy8gaW52YWxpZCBtb3ZlXG4gICAgICAgICAgICBpZiAobW92ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2FzIHRoZSBtb3ZlIGFuIGVuZCBvZiBnYW1lIG1hcmtlclxuICAgICAgICAgICAgICAgIGlmIChURVJNSU5BVElPTl9NQVJLRVJTLmluZGV4T2YobW92ZXNbaGFsZk1vdmVdKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1vdmVzW2hhbGZNb3ZlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlIGluIFBHTjogJHttb3Zlc1toYWxmTW92ZV19YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGVuZCBvZiBnYW1lIG1hcmtlciBpZiBtYWtpbmcgYSB2YWxpZCBtb3ZlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jUG9zaXRpb25Db3VudCh0aGlzLmZlbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBQZXIgc2VjdGlvbiA4LjIuNiBvZiB0aGUgUEdOIHNwZWMsIHRoZSBSZXN1bHQgdGFnIHBhaXIgbXVzdCBtYXRjaCBtYXRjaFxuICAgICAgICAgKiB0aGUgdGVybWluYXRpb24gbWFya2VyLiBPbmx5IGRvIHRoaXMgd2hlbiBoZWFkZXJzIGFyZSBwcmVzZW50LCBidXQgdGhlXG4gICAgICAgICAqIHJlc3VsdCB0YWcgaXMgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlc3VsdCAmJiBPYmplY3Qua2V5cyh0aGlzLl9oZWFkZXIpLmxlbmd0aCAmJiAhdGhpcy5faGVhZGVyWydSZXN1bHQnXSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXIoJ1Jlc3VsdCcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGEgbW92ZSBmcm9tIDB4ODggY29vcmRpbmF0ZXMgdG8gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uXG4gICAgICogKFNBTilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RyaWN0IFVzZSB0aGUgc3RyaWN0IFNBTiBwYXJzZXIuIEl0IHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgICogb24gb3Zlcmx5IGRpc2FtYmlndWF0ZWQgbW92ZXMgKHNlZSBiZWxvdyk6XG4gICAgICpcbiAgICAgKiByMWJxa2Juci9wcHAycHBwLzJuNS8xQjFwUDMvNFAzLzgvUFBQUDJQUC9STkJRSzFOUiBiIEtRa3EgLSAyIDRcbiAgICAgKiA0LiAuLi4gTmdlNyBpcyBvdmVybHkgZGlzYW1iaWd1YXRlZCBiZWNhdXNlIHRoZSBrbmlnaHQgb24gYzYgaXMgcGlubmVkXG4gICAgICogNC4gLi4uIE5lNyBpcyB0ZWNobmljYWxseSB0aGUgdmFsaWQgU0FOXG4gICAgICovXG4gICAgX21vdmVUb1Nhbihtb3ZlLCBtb3Zlcykge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gJ08tTy1PJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb3ZlLnBpZWNlICE9PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYW1iaWd1YXRvciA9IGdldERpc2FtYmlndWF0b3IobW92ZSwgbW92ZXMpO1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBtb3ZlLnBpZWNlLnRvVXBwZXJDYXNlKCkgKyBkaXNhbWJpZ3VhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5DQVBUVVJFIHwgQklUUy5FUF9DQVBUVVJFKSkge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBhbGdlYnJhaWMobW92ZS5mcm9tKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICd4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCArPSBhbGdlYnJhaWMobW92ZS50byk7XG4gICAgICAgICAgICBpZiAobW92ZS5wcm9tb3Rpb24pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJz0nICsgbW92ZS5wcm9tb3Rpb24udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDaGVjaygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NoZWNrbWF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICcjJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnKyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdW5kb01vdmUoKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLy8gY29udmVydCBhIG1vdmUgZnJvbSBTdGFuZGFyZCBBbGdlYnJhaWMgTm90YXRpb24gKFNBTikgdG8gMHg4OCBjb29yZGluYXRlc1xuICAgIF9tb3ZlRnJvbVNhbihtb3ZlLCBzdHJpY3QgPSBmYWxzZSkge1xuICAgICAgICAvLyBzdHJpcCBvZmYgYW55IG1vdmUgZGVjb3JhdGlvbnM6IGUuZyBOZjMrPyEgYmVjb21lcyBOZjNcbiAgICAgICAgY29uc3QgY2xlYW5Nb3ZlID0gc3RyaXBwZWRTYW4obW92ZSk7XG4gICAgICAgIGxldCBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xuICAgICAgICBsZXQgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlLCBwaWVjZTogcGllY2VUeXBlIH0pO1xuICAgICAgICAvLyBzdHJpY3QgcGFyc2VyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT0gc3RyaXBwZWRTYW4odGhpcy5fbW92ZVRvU2FuKG1vdmVzW2ldLCBtb3ZlcykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBzdHJpY3QgcGFyc2VyIGZhaWxlZFxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGllY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBtYXRjaGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcHJvbW90aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBwZXJtaXNzaXZlIChub24tc3RyaWN0KSBwYXJzZXIgYWxsb3dzIHRoZSB1c2VyIHRvIHBhcnNlXG4gICAgICAgICAqIG5vbi1zdGFuZGFyZCBjaGVzcyBub3RhdGlvbnMuIFRoaXMgcGFyc2VyIGlzIG9ubHkgcnVuIGFmdGVyIHRoZSBzdHJpY3RcbiAgICAgICAgICogU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHBhcnNlciBoYXMgZmFpbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHJ1bm5pbmcgdGhlIHBlcm1pc3NpdmUgcGFyc2VyLCB3ZSdsbCBydW4gYSByZWdleCB0byBncmFiIHRoZSBwaWVjZSwgdGhlXG4gICAgICAgICAqIHRvL2Zyb20gc3F1YXJlLCBhbmQgYW4gb3B0aW9uYWwgcHJvbW90aW9uIHBpZWNlLiBUaGlzIHJlZ2V4IHdpbGxcbiAgICAgICAgICogcGFyc2UgY29tbW9uIG5vbi1zdGFuZGFyZCBub3RhdGlvbiBsaWtlOiBQZTItZTQsIFJjMWM0LCBRZjN4ZjcsXG4gICAgICAgICAqIGY3ZjhxLCBiMWMzXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNvbWUgcG9zaXRpb25zIGFuZCBtb3ZlcyBtYXkgYmUgYW1iaWd1b3VzIHdoZW4gdXNpbmcgdGhlIHBlcm1pc3NpdmVcbiAgICAgICAgICogcGFyc2VyLiBGb3IgZXhhbXBsZSwgaW4gdGhpcyBwb3NpdGlvbjogNmsxLzgvOC9CNy84LzgvOC9CTjRLMSB3IC0gLSAwIDEsXG4gICAgICAgICAqIHRoZSBtb3ZlIGIxYzMgbWF5IGJlIGludGVycHJldGVkIGFzIE5jMyBvciBCMWMzIChhIGRpc2FtYmlndWF0ZWQgYmlzaG9wXG4gICAgICAgICAqIG1vdmUpLiBJbiB0aGVzZSBjYXNlcywgdGhlIHBlcm1pc3NpdmUgcGFyc2VyIHdpbGwgZGVmYXVsdCB0byB0aGUgbW9zdFxuICAgICAgICAgKiBiYXNpYyBpbnRlcnByZXRhdGlvbiAod2hpY2ggaXMgYjFjMyBwYXJzaW5nIHRvIE5jMykuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgb3Zlcmx5RGlzYW1iaWd1YXRlZCA9IGZhbHNlO1xuICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXVsxLThdKXg/LT8oW2EtaF1bMS04XSkoW3FyYm5RUkJOXSk/Lyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICBwaWVjZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBmcm9tID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIHByb21vdGlvbiA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBbYS1oXT9bMS04XT8gcG9ydGlvbiBvZiB0aGUgcmVnZXggYmVsb3cgaGFuZGxlcyBtb3ZlcyB0aGF0IG1heSBiZVxuICAgICAgICAgICAgICogb3Zlcmx5IGRpc2FtYmlndWF0ZWQgKGUuZy4gTmdlNyBpcyB1bm5lY2Vzc2FyeSBhbmQgbm9uLXN0YW5kYXJkIHdoZW5cbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG9uZSBsZWdhbCBrbmlnaHQgbW92ZSB0byBlNykuIEluIHRoaXMgY2FzZSwgdGhlIHZhbHVlIG9mXG4gICAgICAgICAgICAgKiAnZnJvbScgdmFyaWFibGUgd2lsbCBiZSBhIHJhbmsgb3IgZmlsZSwgbm90IGEgc3F1YXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXT9bMS04XT8peD8tPyhbYS1oXVsxLThdKShbcXJiblFSQk5dKT8vKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcGllY2UgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgIGZyb20gPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xuICAgICAgICBtb3ZlcyA9IHRoaXMuX21vdmVzKHtcbiAgICAgICAgICAgIGxlZ2FsOiB0cnVlLFxuICAgICAgICAgICAgcGllY2U6IHBpZWNlID8gcGllY2UgOiBwaWVjZVR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyb20gc3F1YXJlLCBpdCBjb3VsZCBiZSBqdXN0ICd4JyBtaXNzaW5nIGZyb20gYSBjYXB0dXJlXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgc3RyaXBwZWRTYW4odGhpcy5fbW92ZVRvU2FuKG1vdmVzW2ldLCBtb3ZlcykpLnJlcGxhY2UoJ3gnLCAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kLWNvbXBhcmUgbW92ZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHJlc3VsdHMgZnJvbSBvdXIgcGVybWlzc2l2ZSByZWdleFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCFwaWVjZSB8fCBwaWVjZS50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnBpZWNlKSAmJlxuICAgICAgICAgICAgICAgIE94ODhbZnJvbV0gPT0gbW92ZXNbaV0uZnJvbSAmJlxuICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJseURpc2FtYmlndWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFNQRUNJQUwgQ0FTRTogd2UgcGFyc2VkIGEgbW92ZSBzdHJpbmcgdGhhdCBtYXkgaGF2ZSBhbiB1bm5lZWRlZFxuICAgICAgICAgICAgICAgICAqIHJhbmsvZmlsZSBkaXNhbWJpZ3VhdG9yIChlLmcuIE5nZTcpLiAgVGhlICdmcm9tJyB2YXJpYWJsZSB3aWxsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICgoIXBpZWNlIHx8IHBpZWNlLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucGllY2UpICYmXG4gICAgICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIChmcm9tID09IHNxdWFyZVswXSB8fCBmcm9tID09IHNxdWFyZVsxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc2NpaSgpIHtcbiAgICAgICAgbGV0IHMgPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpc3BsYXkgdGhlIHJhbmtcbiAgICAgICAgICAgIGlmIChmaWxlKGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICcgKyAnODc2NTQzMjEnW3JhbmsoaSldICsgJyB8JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gdGhpcy5fYm9hcmRbaV0udHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX2JvYXJkW2ldLmNvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGNvbG9yID09PSBXSElURSA/IHBpZWNlLnRvVXBwZXJDYXNlKCkgOiBwaWVjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnICsgc3ltYm9sICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSAnIC4gJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJ3xcXG4nO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzICs9ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xcbic7XG4gICAgICAgIHMgKz0gJyAgICAgYSAgYiAgYyAgZCAgZSAgZiAgZyAgaCc7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBwZXJmdChkZXB0aCkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgbGVnYWw6IGZhbHNlIH0pO1xuICAgICAgICBsZXQgbm9kZXMgPSAwO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX3R1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZXNbaV0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggLSAxID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlcyArPSB0aGlzLnBlcmZ0KGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICB0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHVybjtcbiAgICB9XG4gICAgYm9hcmQoKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBsZXQgcm93ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlOiBhbGdlYnJhaWMoaSksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuX2JvYXJkW2ldLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLl9ib2FyZFtpXS5jb2xvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgcm93ID0gW107XG4gICAgICAgICAgICAgICAgaSArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHNxdWFyZUNvbG9yKHNxdWFyZSkge1xuICAgICAgICBpZiAoc3F1YXJlIGluIE94ODgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNxID0gT3g4OFtzcXVhcmVdO1xuICAgICAgICAgICAgcmV0dXJuIChyYW5rKHNxKSArIGZpbGUoc3EpKSAlIDIgPT09IDAgPyAnbGlnaHQnIDogJ2RhcmsnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBoaXN0b3J5KHsgdmVyYm9zZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgY29uc3QgbW92ZUhpc3RvcnkgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSByZXZlcnNlZEhpc3RvcnkucG9wKCk7XG4gICAgICAgICAgICBpZiAoIW1vdmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaChuZXcgTW92ZSh0aGlzLCBtb3ZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3ZlSGlzdG9yeS5wdXNoKHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3ZlcygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW92ZUhpc3Rvcnk7XG4gICAgfVxuICAgIC8qXG4gICAgICogS2VlcHMgdHJhY2sgb2YgcG9zaXRpb24gb2NjdXJyZW5jZSBjb3VudHMgZm9yIHRoZSBwdXJwb3NlIG9mIHJlcGV0aXRpb25cbiAgICAgKiBjaGVja2luZy4gQWxsIHRocmVlIG1ldGhvZHMgKGBfaW5jYCwgYF9kZWNgLCBhbmQgYF9nZXRgKSB0cmltIHRoZVxuICAgICAqIGlycmVsZXZlbnQgaW5mb3JtYXRpb24gZnJvbSB0aGUgZmVuLCBpbml0aWFsaXNpbmcgbmV3IHBvc2l0aW9ucywgYW5kXG4gICAgICogcmVtb3Zpbmcgb2xkIHBvc2l0aW9ucyBmcm9tIHRoZSByZWNvcmQgaWYgdGhlaXIgY291bnRzIGFyZSByZWR1Y2VkIHRvIDAuXG4gICAgICovXG4gICAgX2dldFBvc2l0aW9uQ291bnQoZmVuKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWRGZW4gPSB0cmltRmVuKGZlbik7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbkNvdW50W3RyaW1tZWRGZW5dIHx8IDA7XG4gICAgfVxuICAgIF9pbmNQb3NpdGlvbkNvdW50KGZlbikge1xuICAgICAgICBjb25zdCB0cmltbWVkRmVuID0gdHJpbUZlbihmZW4pO1xuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50W3RyaW1tZWRGZW5dID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50W3RyaW1tZWRGZW5dICs9IDE7XG4gICAgfVxuICAgIF9kZWNQb3NpdGlvbkNvdW50KGZlbikge1xuICAgICAgICBjb25zdCB0cmltbWVkRmVuID0gdHJpbUZlbihmZW4pO1xuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSA9PT0gMSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Bvc2l0aW9uQ291bnRbdHJpbW1lZEZlbl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50W3RyaW1tZWRGZW5dIC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3BydW5lQ29tbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkSGlzdG9yeSA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50Q29tbWVudHMgPSB7fTtcbiAgICAgICAgY29uc3QgY29weUNvbW1lbnQgPSAoZmVuKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmVuIGluIHRoaXMuX2NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbW1lbnRzW2Zlbl0gPSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAodGhpcy5faGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXZlcnNlZEhpc3RvcnkucHVzaCh0aGlzLl91bmRvTW92ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5Q29tbWVudCh0aGlzLmZlbigpKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSByZXZlcnNlZEhpc3RvcnkucG9wKCk7XG4gICAgICAgICAgICBpZiAoIW1vdmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICAgICAgY29weUNvbW1lbnQodGhpcy5mZW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSBjdXJyZW50Q29tbWVudHM7XG4gICAgfVxuICAgIGdldENvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICB9XG4gICAgc2V0Q29tbWVudChjb21tZW50KSB7XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldID0gY29tbWVudC5yZXBsYWNlKCd7JywgJ1snKS5yZXBsYWNlKCd9JywgJ10nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudGAgZm9yIGNvbnNpc3RlbmN5XG4gICAgICovXG4gICAgZGVsZXRlQ29tbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ29tbWVudCgpO1xuICAgIH1cbiAgICByZW1vdmVDb21tZW50KCkge1xuICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuICAgIGdldENvbW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9wcnVuZUNvbW1lbnRzKCk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tZW50cykubWFwKChmZW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGZlbjogZmVuLCBjb21tZW50OiB0aGlzLl9jb21tZW50c1tmZW5dIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBSZW5hbWVkIHRvIGByZW1vdmVDb21tZW50c2AgZm9yIGNvbnNpc3RlbmN5XG4gICAgICovXG4gICAgZGVsZXRlQ29tbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbW1lbnRzKCk7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9wcnVuZUNvbW1lbnRzKCk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tZW50cykubWFwKChmZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbW1lbnRzW2Zlbl07XG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogY29tbWVudCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0Q2FzdGxpbmdSaWdodHMoY29sb3IsIHJpZ2h0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHNpZGUgb2YgW0tJTkcsIFFVRUVOXSkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0c1tzaWRlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0c1tzaWRlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1tjb2xvcl0gfD0gU0lERVNbc2lkZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJj0gflNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldENhc3RsaW5nUmlnaHRzKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuICgocmlnaHRzW0tJTkddID09PSB1bmRlZmluZWQgfHwgcmlnaHRzW0tJTkddID09PSByZXN1bHRbS0lOR10pICYmXG4gICAgICAgICAgICAocmlnaHRzW1FVRUVOXSA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0c1tRVUVFTl0gPT09IHJlc3VsdFtRVUVFTl0pKTtcbiAgICB9XG4gICAgZ2V0Q2FzdGxpbmdSaWdodHMoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtLSU5HXTogKHRoaXMuX2Nhc3RsaW5nW2NvbG9yXSAmIFNJREVTW0tJTkddKSAhPT0gMCxcbiAgICAgICAgICAgIFtRVUVFTl06ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tRVUVFTl0pICE9PSAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtb3ZlTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW92ZU51bWJlcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVzcy5qcy5tYXAiXSwibmFtZXMiOlsiV0hJVEUiLCJCTEFDSyIsIlBBV04iLCJLTklHSFQiLCJCSVNIT1AiLCJST09LIiwiUVVFRU4iLCJLSU5HIiwiREVGQVVMVF9QT1NJVElPTiIsIk1vdmUiLCJpc0NhcHR1cmUiLCJmbGFncyIsImluZGV4T2YiLCJGTEFHUyIsImlzUHJvbW90aW9uIiwiaXNFblBhc3NhbnQiLCJpc0tpbmdzaWRlQ2FzdGxlIiwiaXNRdWVlbnNpZGVDYXN0bGUiLCJpc0JpZ1Bhd24iLCJjb25zdHJ1Y3RvciIsImNoZXNzIiwiaW50ZXJuYWwiLCJjb2xvciIsInBpZWNlIiwiZnJvbSIsInRvIiwiY2FwdHVyZWQiLCJwcm9tb3Rpb24iLCJmcm9tQWxnZWJyYWljIiwiYWxnZWJyYWljIiwidG9BbGdlYnJhaWMiLCJzYW4iLCJsZWdhbCIsImxhbiIsImJlZm9yZSIsImZlbiIsImFmdGVyIiwiZmxhZyIsIkJJVFMiLCJFTVBUWSIsIk5PUk1BTCIsIkNBUFRVUkUiLCJCSUdfUEFXTiIsIkVQX0NBUFRVUkUiLCJQUk9NT1RJT04iLCJLU0lERV9DQVNUTEUiLCJRU0lERV9DQVNUTEUiLCJTUVVBUkVTIiwiT3g4OCIsImE4IiwiYjgiLCJjOCIsImQ4IiwiZTgiLCJmOCIsImc4IiwiaDgiLCJhNyIsImI3IiwiYzciLCJkNyIsImU3IiwiZjciLCJnNyIsImg3IiwiYTYiLCJiNiIsImM2IiwiZDYiLCJlNiIsImY2IiwiZzYiLCJoNiIsImE1IiwiYjUiLCJjNSIsImQ1IiwiZTUiLCJmNSIsImc1IiwiaDUiLCJhNCIsImI0IiwiYzQiLCJkNCIsImU0IiwiZjQiLCJnNCIsImg0IiwiYTMiLCJiMyIsImMzIiwiZDMiLCJlMyIsImYzIiwiZzMiLCJoMyIsImEyIiwiYjIiLCJjMiIsImQyIiwiZTIiLCJmMiIsImcyIiwiaDIiLCJhMSIsImIxIiwiYzEiLCJkMSIsImUxIiwiZjEiLCJnMSIsImgxIiwiUEFXTl9PRkZTRVRTIiwiYiIsInciLCJQSUVDRV9PRkZTRVRTIiwibiIsInIiLCJxIiwiayIsIkFUVEFDS1MiLCJSQVlTIiwiUElFQ0VfTUFTS1MiLCJwIiwiU1lNQk9MUyIsIlBST01PVElPTlMiLCJSQU5LXzEiLCJSQU5LXzIiLCJSQU5LXzciLCJSQU5LXzgiLCJTSURFUyIsIlJPT0tTIiwic3F1YXJlIiwiU0VDT05EX1JBTksiLCJURVJNSU5BVElPTl9NQVJLRVJTIiwicmFuayIsImZpbGUiLCJpc0RpZ2l0IiwiYyIsImYiLCJzdWJzdHJpbmciLCJzd2FwQ29sb3IiLCJ2YWxpZGF0ZUZlbiIsInRva2VucyIsInNwbGl0IiwibGVuZ3RoIiwib2siLCJlcnJvciIsIm1vdmVOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwiaGFsZk1vdmVzIiwidGVzdCIsInJvd3MiLCJpIiwic3VtRmllbGRzIiwicHJldmlvdXNXYXNOdW1iZXIiLCJraW5ncyIsInJlZ2V4IiwibWF0Y2giLCJBcnJheSIsInNvbWUiLCJjaGFyIiwidG9VcHBlckNhc2UiLCJnZXREaXNhbWJpZ3VhdG9yIiwibW92ZSIsIm1vdmVzIiwiYW1iaWd1aXRpZXMiLCJzYW1lUmFuayIsInNhbWVGaWxlIiwibGVuIiwiYW1iaWdGcm9tIiwiYW1iaWdUbyIsImFtYmlnUGllY2UiLCJjaGFyQXQiLCJhZGRNb3ZlIiwidW5kZWZpbmVkIiwicHVzaCIsImluZmVyUGllY2VUeXBlIiwicGllY2VUeXBlIiwibWF0Y2hlcyIsInRvTG93ZXJDYXNlIiwic3RyaXBwZWRTYW4iLCJyZXBsYWNlIiwidHJpbUZlbiIsInNsaWNlIiwiam9pbiIsIkNoZXNzIiwiY2xlYXIiLCJwcmVzZXJ2ZUhlYWRlcnMiLCJfYm9hcmQiLCJfa2luZ3MiLCJfdHVybiIsIl9jYXN0bGluZyIsIl9lcFNxdWFyZSIsIl9oYWxmTW92ZXMiLCJfbW92ZU51bWJlciIsIl9oaXN0b3J5IiwiX2NvbW1lbnRzIiwiX2hlYWRlciIsIl9wb3NpdGlvbkNvdW50IiwibG9hZCIsInNraXBWYWxpZGF0aW9uIiwiYWRqdXN0bWVudHMiLCJjb25jYXQiLCJFcnJvciIsInBvc2l0aW9uIiwiX3B1dCIsInR5cGUiLCJfdXBkYXRlU2V0dXAiLCJfaW5jUG9zaXRpb25Db3VudCIsImVtcHR5IiwiY2FzdGxpbmciLCJlcFNxdWFyZSIsImJpZ1Bhd25TcXVhcmUiLCJzcXVhcmVzIiwiX21ha2VNb3ZlIiwiaXNMZWdhbCIsIl9pc0tpbmdBdHRhY2tlZCIsIl91bmRvTW92ZSIsInJlc2V0IiwiZ2V0IiwicHV0IiwiX3VwZGF0ZUNhc3RsaW5nUmlnaHRzIiwiX3VwZGF0ZUVuUGFzc2FudFNxdWFyZSIsInNxIiwiY3VycmVudFBpZWNlT25TcXVhcmUiLCJyZW1vdmUiLCJ3aGl0ZUtpbmdJblBsYWNlIiwiYmxhY2tLaW5nSW5QbGFjZSIsInN0YXJ0U3F1YXJlIiwiY3VycmVudFNxdWFyZSIsImF0dGFja2VycyIsImNhbkNhcHR1cmUiLCJfYXR0YWNrZWQiLCJ2ZXJib3NlIiwiZGlmZmVyZW5jZSIsImluZGV4Iiwib2Zmc2V0IiwiaiIsImJsb2NrZWQiLCJhdHRhY2tlZEJ5IiwiaXNBdHRhY2tlZCIsImlzQ2hlY2siLCJpbkNoZWNrIiwiaXNDaGVja21hdGUiLCJfbW92ZXMiLCJpc1N0YWxlbWF0ZSIsImlzSW5zdWZmaWNpZW50TWF0ZXJpYWwiLCJwaWVjZXMiLCJiaXNob3BzIiwibnVtUGllY2VzIiwic3F1YXJlQ29sb3IiLCJzdW0iLCJpc1RocmVlZm9sZFJlcGV0aXRpb24iLCJfZ2V0UG9zaXRpb25Db3VudCIsImlzRHJhd0J5RmlmdHlNb3ZlcyIsImlzRHJhdyIsImlzR2FtZU92ZXIiLCJtYXAiLCJfbW92ZVRvU2FuIiwiZm9yU3F1YXJlIiwiZm9yUGllY2UiLCJ1cyIsInRoZW0iLCJmaXJzdFNxdWFyZSIsImxhc3RTcXVhcmUiLCJzaW5nbGVTcXVhcmUiLCJjYXN0bGluZ0Zyb20iLCJjYXN0bGluZ1RvIiwibGVnYWxNb3ZlcyIsInN0cmljdCIsIm1vdmVPYmoiLCJfbW92ZUZyb21TYW4iLCJKU09OIiwic3RyaW5naWZ5IiwicHJldHR5TW92ZSIsIl9wdXNoIiwidHVybiIsInVuZG8iLCJfZGVjUG9zaXRpb25Db3VudCIsIm9sZCIsInBvcCIsInBnbiIsIm5ld2xpbmUiLCJtYXhXaWR0aCIsInJlc3VsdCIsImhlYWRlckV4aXN0cyIsImFwcGVuZENvbW1lbnQiLCJtb3ZlU3RyaW5nIiwiY29tbWVudCIsImRlbGltaXRlciIsInJldmVyc2VkSGlzdG9yeSIsInByZWZpeCIsIlJlc3VsdCIsInN0cmlwIiwid3JhcENvbW1lbnQiLCJ3aWR0aCIsInRva2VuIiwiY3VycmVudFdpZHRoIiwiaW5jbHVkZXMiLCJoZWFkZXIiLCJhcmdzIiwic2V0SGVhZGVyIiwia2V5IiwidmFsdWUiLCJyZW1vdmVIZWFkZXIiLCJnZXRIZWFkZXJzIiwibG9hZFBnbiIsIm5ld2xpbmVDaGFyIiwibWFzayIsInN0ciIsInBhcnNlUGduSGVhZGVyIiwiaGVhZGVyT2JqIiwiaGVhZGVycyIsIlJlZ0V4cCIsInRyaW0iLCJoZWFkZXJSZWdleCIsImhlYWRlclJlZ2V4UmVzdWx0cyIsImV4ZWMiLCJoZWFkZXJTdHJpbmciLCJ0b0hleCIsInMiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnQiLCJmcm9tSGV4IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlQ29tbWVudCIsImRlY29kZUNvbW1lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJtcyIsIl9tYXRjaCIsImJyYWNrZXQiLCJzZW1pY29sb24iLCJyYXZSZWdleCIsImZpbHRlciIsImhhbGZNb3ZlIiwiT2JqZWN0Iiwia2V5cyIsIm91dHB1dCIsImRpc2FtYmlndWF0b3IiLCJjbGVhbk1vdmUiLCJvdmVybHlEaXNhbWJpZ3VhdGVkIiwiYXNjaWkiLCJzeW1ib2wiLCJwZXJmdCIsImRlcHRoIiwibm9kZXMiLCJib2FyZCIsInJvdyIsImhpc3RvcnkiLCJtb3ZlSGlzdG9yeSIsInRyaW1tZWRGZW4iLCJfcHJ1bmVDb21tZW50cyIsImN1cnJlbnRDb21tZW50cyIsImNvcHlDb21tZW50IiwiZ2V0Q29tbWVudCIsInNldENvbW1lbnQiLCJkZWxldGVDb21tZW50IiwicmVtb3ZlQ29tbWVudCIsImdldENvbW1lbnRzIiwiZGVsZXRlQ29tbWVudHMiLCJyZW1vdmVDb21tZW50cyIsInNldENhc3RsaW5nUmlnaHRzIiwicmlnaHRzIiwic2lkZSIsImdldENhc3RsaW5nUmlnaHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chess.js/dist/esm/chess.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n //# sourceMappingURL=navigation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdELENBRWhELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzFkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JBQUM7WUFBQztZQUFDLFNBQVNZLGdCQUFnQlosQ0FBQztnQkFBRSxJQUFHSSxNQUFJSyxjQUFhO29CQUFDLE9BQU9BLGFBQWFUO2dCQUFFO2dCQUFDLElBQUcsQ0FBQ0ksTUFBSUcsdUJBQXFCLENBQUNILENBQUFBLEtBQUlLLGNBQWE7b0JBQUNMLElBQUVLO29CQUFhLE9BQU9BLGFBQWFUO2dCQUFFO2dCQUFDLElBQUc7b0JBQUMsT0FBT0ksRUFBRUo7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0csRUFBRU8sSUFBSSxDQUFDLE1BQUtYO29CQUFFLEVBQUMsT0FBTUMsR0FBRTt3QkFBQyxPQUFPRyxFQUFFTyxJQUFJLENBQUMsSUFBSSxFQUFDWDtvQkFBRTtnQkFBQztZQUFDO1lBQUMsSUFBSWEsSUFBRSxFQUFFO1lBQUMsSUFBSUMsSUFBRTtZQUFNLElBQUlDO1lBQUUsSUFBSUMsSUFBRSxDQUFDO1lBQUUsU0FBU0M7Z0JBQWtCLElBQUcsQ0FBQ0gsS0FBRyxDQUFDQyxHQUFFO29CQUFDO2dCQUFNO2dCQUFDRCxJQUFFO2dCQUFNLElBQUdDLEVBQUVHLE1BQU0sRUFBQztvQkFBQ0wsSUFBRUUsRUFBRUksTUFBTSxDQUFDTjtnQkFBRSxPQUFLO29CQUFDRyxJQUFFLENBQUM7Z0JBQUM7Z0JBQUMsSUFBR0gsRUFBRUssTUFBTSxFQUFDO29CQUFDRTtnQkFBWTtZQUFDO1lBQUMsU0FBU0E7Z0JBQWEsSUFBR04sR0FBRTtvQkFBQztnQkFBTTtnQkFBQyxJQUFJZCxJQUFFVSxXQUFXTztnQkFBaUJILElBQUU7Z0JBQUssSUFBSWIsSUFBRVksRUFBRUssTUFBTTtnQkFBQyxNQUFNakIsRUFBRTtvQkFBQ2MsSUFBRUY7b0JBQUVBLElBQUUsRUFBRTtvQkFBQyxNQUFNLEVBQUVHLElBQUVmLEVBQUU7d0JBQUMsSUFBR2MsR0FBRTs0QkFBQ0EsQ0FBQyxDQUFDQyxFQUFFLENBQUNLLEdBQUc7d0JBQUU7b0JBQUM7b0JBQUNMLElBQUUsQ0FBQztvQkFBRWYsSUFBRVksRUFBRUssTUFBTTtnQkFBQTtnQkFBQ0gsSUFBRTtnQkFBS0QsSUFBRTtnQkFBTUYsZ0JBQWdCWjtZQUFFO1lBQUNDLEVBQUVxQixRQUFRLEdBQUMsU0FBU3RCLENBQUM7Z0JBQUUsSUFBSUMsSUFBRSxJQUFJc0IsTUFBTUMsVUFBVU4sTUFBTSxHQUFDO2dCQUFHLElBQUdNLFVBQVVOLE1BQU0sR0FBQyxHQUFFO29CQUFDLElBQUksSUFBSWYsSUFBRSxHQUFFQSxJQUFFcUIsVUFBVU4sTUFBTSxFQUFDZixJQUFJO3dCQUFDRixDQUFDLENBQUNFLElBQUUsRUFBRSxHQUFDcUIsU0FBUyxDQUFDckIsRUFBRTtvQkFBQTtnQkFBQztnQkFBQ1UsRUFBRVksSUFBSSxDQUFDLElBQUlDLEtBQUsxQixHQUFFQztnQkFBSSxJQUFHWSxFQUFFSyxNQUFNLEtBQUcsS0FBRyxDQUFDSixHQUFFO29CQUFDSixXQUFXVTtnQkFBVztZQUFDO1lBQUUsU0FBU00sS0FBSzFCLENBQUMsRUFBQ0MsQ0FBQztnQkFBRSxJQUFJLENBQUMwQixHQUFHLEdBQUMzQjtnQkFBRSxJQUFJLENBQUM0QixLQUFLLEdBQUMzQjtZQUFDO1lBQUN5QixLQUFLRyxTQUFTLENBQUNSLEdBQUcsR0FBQztnQkFBVyxJQUFJLENBQUNNLEdBQUcsQ0FBQ0csS0FBSyxDQUFDLE1BQUssSUFBSSxDQUFDRixLQUFLO1lBQUM7WUFBRTNCLEVBQUU4QixLQUFLLEdBQUM7WUFBVTlCLEVBQUUrQixPQUFPLEdBQUM7WUFBSy9CLEVBQUVnQyxHQUFHLEdBQUMsQ0FBQztZQUFFaEMsRUFBRWlDLElBQUksR0FBQyxFQUFFO1lBQUNqQyxFQUFFa0MsT0FBTyxHQUFDO1lBQUdsQyxFQUFFbUMsUUFBUSxHQUFDLENBQUM7WUFBRSxTQUFTQyxRQUFPO1lBQUNwQyxFQUFFcUMsRUFBRSxHQUFDRDtZQUFLcEMsRUFBRXNDLFdBQVcsR0FBQ0Y7WUFBS3BDLEVBQUV1QyxJQUFJLEdBQUNIO1lBQUtwQyxFQUFFd0MsR0FBRyxHQUFDSjtZQUFLcEMsRUFBRXlDLGNBQWMsR0FBQ0w7WUFBS3BDLEVBQUUwQyxrQkFBa0IsR0FBQ047WUFBS3BDLEVBQUUyQyxJQUFJLEdBQUNQO1lBQUtwQyxFQUFFNEMsZUFBZSxHQUFDUjtZQUFLcEMsRUFBRTZDLG1CQUFtQixHQUFDVDtZQUFLcEMsRUFBRThDLFNBQVMsR0FBQyxTQUFTL0MsQ0FBQztnQkFBRSxPQUFNLEVBQUU7WUFBQTtZQUFFQyxFQUFFK0MsT0FBTyxHQUFDLFNBQVNoRCxDQUFDO2dCQUFFLE1BQU0sSUFBSU0sTUFBTTtZQUFtQztZQUFFTCxFQUFFZ0QsR0FBRyxHQUFDO2dCQUFXLE9BQU07WUFBRztZQUFFaEQsRUFBRWlELEtBQUssR0FBQyxTQUFTbEQsQ0FBQztnQkFBRSxNQUFNLElBQUlNLE1BQU07WUFBaUM7WUFBRUwsRUFBRWtELEtBQUssR0FBQztnQkFBVyxPQUFPO1lBQUM7UUFBQztJQUFDO0lBQUUsSUFBSWxELElBQUUsQ0FBQztJQUFFLFNBQVNtRCxvQkFBb0JqRCxDQUFDO1FBQUUsSUFBSUMsSUFBRUgsQ0FBQyxDQUFDRSxFQUFFO1FBQUMsSUFBR0MsTUFBSWlELFdBQVU7WUFBQyxPQUFPakQsRUFBRUYsT0FBTztRQUFBO1FBQUMsSUFBSVcsSUFBRVosQ0FBQyxDQUFDRSxFQUFFLEdBQUM7WUFBQ0QsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJWSxJQUFFO1FBQUssSUFBRztZQUFDZCxDQUFDLENBQUNHLEVBQUUsQ0FBQ1UsR0FBRUEsRUFBRVgsT0FBTyxFQUFDa0Q7WUFBcUJ0QyxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT2IsQ0FBQyxDQUFDRSxFQUFFO1FBQUE7UUFBQyxPQUFPVSxFQUFFWCxPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU9rRCx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJcEQsSUFBRWlELG9CQUFvQjtJQUFLSSxPQUFPdEQsT0FBTyxHQUFDQztBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-chessboard/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-chessboard/dist/index.esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chessboard: function() { return /* binding */ Chessboard; },\n/* harmony export */   ChessboardDnDProvider: function() { return /* binding */ ChessboardDnDProvider; },\n/* harmony export */   SparePiece: function() { return /* binding */ SparePiece; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$(), _s33 = $RefreshSig$(), _s34 = $RefreshSig$(), _s35 = $RefreshSig$(), _s36 = $RefreshSig$();\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nconst COLUMNS = \"abcdefgh\".split(\"\");\nconst START_POSITION_OBJECT = {\n    a8: \"bR\",\n    b8: \"bN\",\n    c8: \"bB\",\n    d8: \"bQ\",\n    e8: \"bK\",\n    f8: \"bB\",\n    g8: \"bN\",\n    h8: \"bR\",\n    a7: \"bP\",\n    b7: \"bP\",\n    c7: \"bP\",\n    d7: \"bP\",\n    e7: \"bP\",\n    f7: \"bP\",\n    g7: \"bP\",\n    h7: \"bP\",\n    a2: \"wP\",\n    b2: \"wP\",\n    c2: \"wP\",\n    d2: \"wP\",\n    e2: \"wP\",\n    f2: \"wP\",\n    g2: \"wP\",\n    h2: \"wP\",\n    a1: \"wR\",\n    b1: \"wN\",\n    c1: \"wB\",\n    d1: \"wQ\",\n    e1: \"wK\",\n    f1: \"wB\",\n    g1: \"wN\",\n    h1: \"wR\"\n};\nconst WHITE_COLUMN_VALUES = {\n    a: 0,\n    b: 1,\n    c: 2,\n    d: 3,\n    e: 4,\n    f: 5,\n    g: 6,\n    h: 7\n};\nconst BLACK_COLUMN_VALUES = {\n    a: 7,\n    b: 6,\n    c: 5,\n    d: 4,\n    e: 3,\n    f: 2,\n    g: 1,\n    h: 0\n};\nconst WHITE_ROWS = [\n    7,\n    6,\n    5,\n    4,\n    3,\n    2,\n    1,\n    0\n];\nconst BLACK_ROWS = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7\n];\n// https://commons.wikimedia.org/wiki/Category:SVG_chess_pieces\n// By en:User:Cburnett - Own work\n// This W3C - unspecified vector image was created with Inkscape., CC BY - SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1499810\nconst defaultPieces = {\n    wP: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\",\n            style: {\n                opacity: \"1\",\n                fill: \"#ffffff\",\n                fillOpacity: \"1\",\n                fillRule: \"nonzero\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"miter\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        })\n    })),\n    wR: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"#ffffff\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 34,14 L 31,17 L 14,17 L 11,14\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 31,17 L 31,29.5 L 14,29.5 L 14,17\",\n                    style: {\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 34,14\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    wN: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\",\n                    transform: \"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                })\n            ]\n        }))\n    })),\n    wB: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillRule: \"evenodd\",\n                fillOpacity: \"1\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\"\n                    }\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\"\n                        })\n                    ]\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    wQ: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"#ffffff\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinejoin: \"round\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11.5,30 C 15,29 30,29 33.5,30\",\n                    style: {\n                        fill: \"none\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,33.5 C 18,32.5 27,32.5 33,33.5\",\n                    style: {\n                        fill: \"none\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"6\",\n                    cy: \"12\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"14\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"22.5\",\n                    cy: \"8\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"31\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"39\",\n                    cy: \"12\",\n                    r: \"2\"\n                })\n            ]\n        }))\n    })),\n    wK: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,11.63 L 22.5,6\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 20,8 L 25,8\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,30 C 18,27 27,27 32.5,30\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,37 C 18,34 27,34 32.5,37\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bP: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\",\n            style: {\n                opacity: \"1\",\n                fill: \"#000000\",\n                fillOpacity: \"1\",\n                fillRule: \"nonzero\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"miter\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        })\n    })),\n    bR: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"#000000\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \",\n                    style: {\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \",\n                    style: {\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12,35.5 L 33,35.5 L 33,35.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 13,31.5 L 32,31.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,29.5 L 31,29.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 14,16.5 L 31,16.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,14 L 34,14\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeWidth: \"1\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bN: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#ffffff\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\",\n                    transform: \"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"#ffffff\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \",\n                    style: {\n                        fill: \"#ffffff\",\n                        stroke: \"none\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bB: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                opacity: \"1\",\n                fill: \"none\",\n                fillRule: \"evenodd\",\n                fillOpacity: \"1\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\"\n                    }\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\"\n                        })\n                    ]\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\",\n                        strokeLinejoin: \"miter\"\n                    }\n                })\n            ]\n        }))\n    })),\n    bQ: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"#000000\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\",\n                    style: {\n                        strokeLinecap: \"butt\",\n                        fill: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11.5,30 C 15,29 30,29 33.5,30\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"m 12,33.5 c 6,-1 15,-1 21,0\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"6\",\n                    cy: \"12\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"14\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"22.5\",\n                    cy: \"8\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"31\",\n                    cy: \"9\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n                    cx: \"39\",\n                    cy: \"12\",\n                    r: \"2\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 11,38.5 A 35,35 1 0 0 34,38.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinecap: \"butt\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\"\n                    }\n                }, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 11,29 A 35,35 1 0 1 34,29\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 12.5,31.5 L 32.5,31.5\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\"\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                            d: \"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\"\n                        })\n                    ]\n                }))\n            ]\n        }))\n    })),\n    bK: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        width: \"45\",\n        height: \"45\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({\n            style: {\n                fill: \"none\",\n                fillOpacity: \"1\",\n                fillRule: \"evenodd\",\n                stroke: \"#000000\",\n                strokeWidth: \"1.5\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeMiterlimit: \"4\",\n                strokeDasharray: \"none\",\n                strokeOpacity: \"1\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,11.63 L 22.5,6\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    },\n                    id: \"path6570\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\",\n                    style: {\n                        fill: \"#000000\",\n                        fillOpacity: \"1\",\n                        strokeLinecap: \"butt\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\",\n                    style: {\n                        fill: \"#000000\",\n                        stroke: \"#000000\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 20,8 L 25,8\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#000000\",\n                        strokeLinejoin: \"miter\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    d: \"M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37\",\n                    style: {\n                        fill: \"none\",\n                        stroke: \"#ffffff\"\n                    }\n                })\n            ]\n        }))\n    }))\n};\n/**\r\n * Retrieves the coordinates at the centre of the requested square, relative to the top left of the board (0, 0).\r\n */ function getRelativeCoords(boardOrientation, boardWidth, square) {\n    const squareWidth = boardWidth / 8;\n    const columns = boardOrientation === \"white\" ? WHITE_COLUMN_VALUES : BLACK_COLUMN_VALUES;\n    const rows = boardOrientation === \"white\" ? WHITE_ROWS : BLACK_ROWS;\n    const x = columns[square[0]] * squareWidth + squareWidth / 2;\n    const y = rows[parseInt(square[1], 10) - 1] * squareWidth + squareWidth / 2;\n    return {\n        x,\n        y\n    };\n}\n/**\r\n * Returns whether the passed position is different from the start position.\r\n */ function isDifferentFromStart(newPosition) {\n    let isDifferent = false;\n    Object.keys(START_POSITION_OBJECT).forEach((square)=>{\n        if (newPosition[square] !== START_POSITION_OBJECT[square]) isDifferent = true;\n    });\n    Object.keys(newPosition).forEach((square)=>{\n        if (START_POSITION_OBJECT[square] !== newPosition[square]) isDifferent = true;\n    });\n    return isDifferent;\n}\n/**\r\n * Returns what pieces have been added and what pieces have been removed between board positions.\r\n */ function getPositionDifferences(currentPosition, newPosition) {\n    const difference = {\n        removed: {},\n        added: {}\n    };\n    // removed from current\n    Object.keys(currentPosition).forEach((square)=>{\n        if (newPosition[square] !== currentPosition[square]) difference.removed[square] = currentPosition[square];\n    });\n    // added from new\n    Object.keys(newPosition).forEach((square)=>{\n        if (currentPosition[square] !== newPosition[square]) difference.added[square] = newPosition[square];\n    });\n    return difference;\n}\n/**\r\n * Converts a fen string or existing position object to a position object.\r\n */ function convertPositionToObject(position) {\n    if (position === \"start\") {\n        return START_POSITION_OBJECT;\n    }\n    if (typeof position === \"string\") {\n        // attempt to convert fen to position object\n        return fenToObj(position);\n    }\n    return position;\n}\n/**\r\n * Converts a fen string to a position object.\r\n */ function fenToObj(fen) {\n    if (!isValidFen(fen)) return {};\n    // cut off any move, castling, etc info from the end. we're only interested in position information\n    fen = fen.replace(/ .+$/, \"\");\n    const rows = fen.split(\"/\");\n    const position = {};\n    let currentRow = 8;\n    for(let i = 0; i < 8; i++){\n        const row = rows[i].split(\"\");\n        let colIdx = 0;\n        // loop through each character in the FEN section\n        for(let j = 0; j < row.length; j++){\n            // number / empty squares\n            if (row[j].search(/[1-8]/) !== -1) {\n                const numEmptySquares = parseInt(row[j], 10);\n                colIdx = colIdx + numEmptySquares;\n            } else {\n                // piece\n                const square = COLUMNS[colIdx] + currentRow;\n                position[square] = fenToPieceCode(row[j]);\n                colIdx = colIdx + 1;\n            }\n        }\n        currentRow = currentRow - 1;\n    }\n    return position;\n}\n/**\r\n * Returns whether string is valid fen notation.\r\n */ function isValidFen(fen) {\n    // cut off any move, castling, etc info from the end. we're only interested in position information\n    fen = fen.replace(/ .+$/, \"\");\n    // expand the empty square numbers to just 1s\n    fen = expandFenEmptySquares(fen);\n    // fen should be 8 sections separated by slashes\n    const chunks = fen.split(\"/\");\n    if (chunks.length !== 8) return false;\n    // check each section\n    for(let i = 0; i < 8; i++){\n        if (chunks[i].length !== 8 || chunks[i].search(/[^kqrnbpKQRNBP1]/) !== -1) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * Expand out fen notation to countable characters for validation\r\n */ function expandFenEmptySquares(fen) {\n    return fen.replace(/8/g, \"11111111\").replace(/7/g, \"1111111\").replace(/6/g, \"111111\").replace(/5/g, \"11111\").replace(/4/g, \"1111\").replace(/3/g, \"111\").replace(/2/g, \"11\");\n}\n/**\r\n * Convert fen piece code to camel case notation. e.g. bP, wK.\r\n */ function fenToPieceCode(piece) {\n    // black piece\n    if (piece.toLowerCase() === piece) {\n        return \"b\" + piece.toUpperCase();\n    }\n    // white piece\n    return \"w\" + piece.toUpperCase();\n}\nconst useArrows = function(customArrows) {\n    let areArrowsAllowed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, onArrowsChange = arguments.length > 2 ? arguments[2] : void 0, customArrowColor = arguments.length > 3 ? arguments[3] : void 0;\n    _s();\n    // arrows passed programatically to `ChessBoard` as a react prop\n    const [customArrowsSet, setCustomArrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // arrows drawn with mouse by user on the board\n    const [arrows, setArrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // active arrow which user draws while dragging mouse\n    const [newArrow, setNewArrow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    // handle external `customArrows` props changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (Array.isArray(customArrows)) {\n            // so that custom arrows overwrite temporary arrows\n            clearArrows();\n            setCustomArrows(//filter out arrows which starts and ends in the same square\n            customArrows === null || customArrows === void 0 ? void 0 : customArrows.filter((arrow)=>arrow[0] !== arrow[1]));\n        }\n    }, [\n        customArrows\n    ]);\n    // callback when arrows changed after user interaction\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        onArrowsChange === null || onArrowsChange === void 0 ? void 0 : onArrowsChange(arrows);\n    }, [\n        arrows\n    ]);\n    // function clears all arrows drawed by user\n    function clearArrows() {\n        setArrows([]);\n        setNewArrow(undefined);\n    }\n    const drawNewArrow = (fromSquare, toSquare)=>{\n        if (!areArrowsAllowed) return;\n        setNewArrow([\n            fromSquare,\n            toSquare,\n            customArrowColor\n        ]);\n    };\n    const allBoardArrows = [\n        ...arrows,\n        ...customArrowsSet\n    ];\n    const onArrowDrawEnd = (fromSquare, toSquare)=>{\n        if (fromSquare === toSquare || !areArrowsAllowed) return;\n        let arrowsCopy;\n        const newArrow = [\n            fromSquare,\n            toSquare,\n            customArrowColor\n        ];\n        const isNewArrowUnique = allBoardArrows.every((param)=>{\n            let [arrowFrom, arrowTo] = param;\n            return !(arrowFrom === fromSquare && arrowTo === toSquare);\n        });\n        // add the newArrow to arrows array if it is unique\n        if (isNewArrowUnique) {\n            arrowsCopy = [\n                ...arrows,\n                newArrow\n            ];\n        } else {\n            arrowsCopy = arrows.filter((param)=>{\n                let [arrowFrom, arrowTo] = param;\n                return !(arrowFrom === fromSquare && arrowTo === toSquare);\n            });\n        }\n        setNewArrow(undefined);\n        setArrows(arrowsCopy);\n    };\n    return {\n        arrows: allBoardArrows,\n        newArrow,\n        clearArrows,\n        drawNewArrow,\n        setArrows,\n        onArrowDrawEnd\n    };\n};\n_s(useArrows, \"B8Oe7mZh7TOHj/B1f+V8TfVFMdU=\");\nconst ChessboardContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nconst useChessboard = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChessboardContext);\n};\n_s1(useChessboard, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChessboardProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s2((param, ref)=>{\n    let { allowDragOutsideBoard = true, animationDuration = 300, areArrowsAllowed = true, arePiecesDraggable = true, arePremovesAllowed = false, autoPromoteToQueen = false, boardOrientation = \"white\", boardWidth, children, clearPremovesOnRightClick = true, customArrows, customArrowColor = \"rgb(255,170,0)\", customBoardStyle, customNotationStyle, customDarkSquareStyle = {\n        backgroundColor: \"#B58863\"\n    }, customDropSquareStyle = {\n        boxShadow: \"inset 0 0 1px 6px rgba(255,255,255,0.75)\"\n    }, customLightSquareStyle = {\n        backgroundColor: \"#F0D9B5\"\n    }, customPieces, customPremoveDarkSquareStyle = {\n        backgroundColor: \"#A42323\"\n    }, customPremoveLightSquareStyle = {\n        backgroundColor: \"#BD2828\"\n    }, customSquare = \"div\", customSquareStyles, dropOffBoardAction = \"snapback\", id = 0, isDraggablePiece = ()=>true, getPositionObject = ()=>{}, onArrowsChange = ()=>{}, onDragOverSquare = ()=>{}, onMouseOutSquare = ()=>{}, onMouseOverSquare = ()=>{}, onPieceClick = ()=>{}, onPieceDragBegin = ()=>{}, onPieceDragEnd = ()=>{}, onPieceDrop = ()=>true, onPieceDropOffBoard = ()=>{}, onPromotionCheck = (sourceSquare, targetSquare, piece)=>{\n        return (piece === \"wP\" && sourceSquare[1] === \"7\" && targetSquare[1] === \"8\" || piece === \"bP\" && sourceSquare[1] === \"2\" && targetSquare[1] === \"1\") && Math.abs(sourceSquare.charCodeAt(0) - targetSquare.charCodeAt(0)) <= 1;\n    }, onPromotionPieceSelect = ()=>true, onSparePieceDrop = ()=>true, onSquareClick = ()=>{}, onSquareRightClick = ()=>{}, position = \"start\", promotionDialogVariant = \"default\", promotionToSquare = null, showBoardNotation = true, showPromotionDialog = false, snapToCursor = true } = param;\n    _s2();\n    // position stored and displayed on board\n    const [currentPosition, setCurrentPosition] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(convertPositionToObject(position));\n    // calculated differences between current and incoming positions\n    const [positionDifferences, setPositionDifferences] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        removed: {},\n        added: {}\n    });\n    // colour of last piece moved to determine if premoving\n    const [lastPieceColour, setLastPieceColour] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined);\n    // show / hide promotion dialog\n    const [showPromoteDialog, setShowPromoteDialog] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(showPromotionDialog && !autoPromoteToQueen);\n    // which square a pawn is being promoted to\n    const [promoteFromSquare, setPromoteFromSquare] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [promoteToSquare, setPromoteToSquare] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(promotionToSquare);\n    // current premoves\n    const [premoves, setPremoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // ref used to access current value during timeouts (closures)\n    const premovesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(premoves);\n    // current right mouse down square\n    const [currentRightClickDown, setCurrentRightClickDown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    // chess pieces/styling\n    const [chessPieces, setChessPieces] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Object.assign(Object.assign({}, defaultPieces), customPieces));\n    // whether the last move was a manual drop or not\n    const [wasManualDrop, setWasManualDrop] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // the most recent timeout whilst waiting for animation to complete\n    const [previousTimeout, setPreviousTimeout] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    // if currently waiting for an animation to finish\n    const [isWaitingForAnimation, setIsWaitingForAnimation] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // last square dragged over for checking in touch events\n    const [lastSquareDraggedOver, setLastSquareDraggedOver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // open clearPremoves() to allow user to call on undo/reset/whenever\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, ()=>({\n            clearPremoves () {\n                let clearLastPieceColour = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n                clearPremoves(clearLastPieceColour);\n            }\n        }));\n    // handle custom pieces change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setChessPieces(Object.assign(Object.assign({}, defaultPieces), customPieces));\n    }, [\n        customPieces\n    ]);\n    // handle promote changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setShowPromoteDialog(showPromotionDialog);\n        setPromoteToSquare(promotionToSquare);\n    }, [\n        promotionToSquare,\n        showPromotionDialog\n    ]);\n    // handle external position change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _a, _b, _c;\n        // clear any open promotion dialogs\n        clearPromotion();\n        const newPosition = convertPositionToObject(position);\n        const differences = getPositionDifferences(currentPosition, newPosition);\n        const newPieceColour = ((_a = Object.keys(differences.added)) === null || _a === void 0 ? void 0 : _a.length) <= 2 ? (_c = (_b = Object.entries(differences.added)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c[1][0] : undefined;\n        // external move has come in before animation is over\n        // cancel animation and immediately update position\n        if (isWaitingForAnimation) {\n            setCurrentPosition(newPosition);\n            setIsWaitingForAnimation(false);\n            arePremovesAllowed && attemptPremove(newPieceColour);\n            if (previousTimeout) {\n                clearTimeout(previousTimeout);\n            }\n        } else {\n            // move was made using drag and drop\n            if (wasManualDrop) {\n                setCurrentPosition(newPosition);\n                setIsWaitingForAnimation(false);\n                arePremovesAllowed && attemptPremove(newPieceColour);\n            } else {\n                // move was made by external position change\n                // if position === start then don't override newPieceColour\n                // needs isDifferentFromStart in scenario where premoves have been cleared upon board reset but first move is made by computer, the last move colour would need to be updated\n                if (isDifferentFromStart(newPosition) && lastPieceColour !== undefined) {\n                    setLastPieceColour(newPieceColour);\n                } else if (!isDifferentFromStart(newPosition)) {\n                    // position === start, likely a board reset. set to black to allow black to make premoves on first move\n                    setLastPieceColour(\"b\");\n                } else {\n                    setLastPieceColour(undefined);\n                }\n                setPositionDifferences(differences);\n                // animate external move\n                setIsWaitingForAnimation(true);\n                const newTimeout = setTimeout(()=>{\n                    setCurrentPosition(newPosition);\n                    setIsWaitingForAnimation(false);\n                    arePremovesAllowed && attemptPremove(newPieceColour);\n                }, animationDuration);\n                setPreviousTimeout(newTimeout);\n            }\n        }\n        // reset manual drop, ready for next move to be made by user or external\n        setWasManualDrop(false);\n        // inform latest position information\n        getPositionObject(newPosition);\n        // clear arrows\n        clearArrows();\n        // clear timeout on unmount\n        return ()=>{\n            clearTimeout(previousTimeout);\n        };\n    }, [\n        position\n    ]);\n    const { arrows, newArrow, clearArrows, drawNewArrow, onArrowDrawEnd } = useArrows(customArrows, areArrowsAllowed, onArrowsChange, customArrowColor);\n    // handle drop position change\n    function handleSetPosition(sourceSq, targetSq, piece, wasManualDropOverride) {\n        // if dropped back down, don't do anything\n        if (sourceSq === targetSq) {\n            return;\n        }\n        clearArrows();\n        // if second move is made for same colour, or there are still premoves queued, then this move needs to be added to premove queue instead of played\n        // premoves length check for colour is added in because white could make 3 premoves, and then black responds to the first move (changing the last piece colour) and then white pre-moves again\n        if (arePremovesAllowed && isWaitingForAnimation || arePremovesAllowed && (lastPieceColour === piece[0] || premovesRef.current.filter((p)=>p.piece[0] === piece[0]).length > 0)) {\n            const oldPremoves = [\n                ...premovesRef.current\n            ];\n            oldPremoves.push({\n                sourceSq,\n                targetSq,\n                piece\n            });\n            premovesRef.current = oldPremoves;\n            setPremoves([\n                ...oldPremoves\n            ]);\n            clearPromotion();\n            return;\n        }\n        // if transitioning, don't allow new drop\n        if (!arePremovesAllowed && isWaitingForAnimation) return;\n        const newOnDropPosition = Object.assign({}, currentPosition);\n        setWasManualDrop(!!wasManualDropOverride);\n        setLastPieceColour(piece[0]);\n        // if onPieceDrop function provided, execute it, position must be updated externally and captured by useEffect above for this move to show on board\n        if (onPieceDrop.length) {\n            const isValidMove = onPieceDrop(sourceSq, targetSq, piece);\n            if (!isValidMove) {\n                clearPremoves();\n                setWasManualDrop(false);\n            }\n        } else {\n            // delete source piece\n            delete newOnDropPosition[sourceSq];\n            // add piece in new position\n            newOnDropPosition[targetSq] = piece;\n            setCurrentPosition(newOnDropPosition);\n        }\n        clearPromotion();\n        // inform latest position information\n        getPositionObject(newOnDropPosition);\n    }\n    function deletePieceFromSquare(square) {\n        const positionCopy = Object.assign({}, currentPosition);\n        delete positionCopy[square];\n        setCurrentPosition(positionCopy);\n        // inform latest position information\n        getPositionObject(positionCopy);\n    }\n    function attemptPremove(newPieceColour) {\n        if (premovesRef.current.length === 0) return;\n        // get current value of premove as this is called in a timeout so value may have changed since timeout was set\n        const premove = premovesRef.current[0];\n        // if premove is a differing colour to last move made, then this move can be made\n        if (premove.piece[0] !== undefined && premove.piece[0] !== newPieceColour && onPieceDrop.length) {\n            setLastPieceColour(premove.piece[0]);\n            setWasManualDrop(true); // pre-move doesn't need animation\n            const isValidMove = onPieceDrop(premove.sourceSq, premove.targetSq, premove.piece);\n            // premove was successful and can be removed from queue\n            if (isValidMove) {\n                const oldPremoves = [\n                    ...premovesRef.current\n                ];\n                oldPremoves.shift();\n                premovesRef.current = oldPremoves;\n                setPremoves([\n                    ...oldPremoves\n                ]);\n            } else {\n                // premove wasn't successful, clear premove queue\n                clearPremoves();\n            }\n        }\n    }\n    function handleSparePieceDrop(piece, targetSq) {\n        const isValidDrop = onSparePieceDrop(piece, targetSq);\n        if (!isValidDrop) return;\n        const newOnDropPosition = Object.assign({}, currentPosition);\n        // add piece in new position\n        newOnDropPosition[targetSq] = piece;\n        setCurrentPosition(newOnDropPosition);\n        // inform latest position information\n        getPositionObject(newOnDropPosition);\n    }\n    function clearPremoves() {\n        let clearLastPieceColour = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        // don't clear when right clicking to clear, otherwise you won't be able to premove again before next go\n        if (clearLastPieceColour) setLastPieceColour(undefined);\n        premovesRef.current = [];\n        setPremoves([]);\n    }\n    function clearPromotion() {\n        setPromoteFromSquare(null);\n        setPromoteToSquare(null);\n        setShowPromoteDialog(false);\n    }\n    function onRightClickDown(square) {\n        setCurrentRightClickDown(square);\n    }\n    function onRightClickUp(square) {\n        if (currentRightClickDown) {\n            // same square, don't draw an arrow, but do clear premoves and run onSquareRightClick\n            if (currentRightClickDown === square) {\n                setCurrentRightClickDown(undefined);\n                clearPremovesOnRightClick && clearPremoves(false);\n                onSquareRightClick(square);\n                return;\n            }\n        } else setCurrentRightClickDown(undefined);\n    }\n    function clearCurrentRightClickDown() {\n        setCurrentRightClickDown(undefined);\n    }\n    const ChessboardProviderContextValue = {\n        allowDragOutsideBoard,\n        animationDuration,\n        arePiecesDraggable,\n        arePremovesAllowed,\n        arrows,\n        autoPromoteToQueen,\n        boardOrientation,\n        boardWidth,\n        chessPieces,\n        clearArrows,\n        clearCurrentRightClickDown,\n        currentPosition,\n        currentRightClickDown,\n        customArrowColor,\n        customBoardStyle,\n        customDarkSquareStyle,\n        customDropSquareStyle,\n        customLightSquareStyle,\n        customNotationStyle,\n        customPremoveDarkSquareStyle,\n        customPremoveLightSquareStyle,\n        customSquare,\n        customSquareStyles,\n        deletePieceFromSquare,\n        drawNewArrow,\n        dropOffBoardAction,\n        handleSetPosition,\n        handleSparePieceDrop,\n        id,\n        isDraggablePiece,\n        isWaitingForAnimation,\n        lastPieceColour,\n        lastSquareDraggedOver,\n        newArrow,\n        onArrowDrawEnd,\n        onDragOverSquare,\n        onMouseOutSquare,\n        onMouseOverSquare,\n        onPieceClick,\n        onPieceDragBegin,\n        onPieceDragEnd,\n        onPieceDrop,\n        onPieceDropOffBoard,\n        onPromotionCheck,\n        onPromotionPieceSelect,\n        onRightClickDown,\n        onRightClickUp,\n        onSparePieceDrop,\n        onSquareClick,\n        positionDifferences,\n        premoves,\n        promoteFromSquare,\n        promoteToSquare,\n        promotionDialogVariant,\n        setLastSquareDraggedOver,\n        setPromoteFromSquare,\n        setPromoteToSquare,\n        setShowPromoteDialog,\n        showBoardNotation,\n        showPromoteDialog,\n        snapToCursor\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardContext.Provider, Object.assign({\n        value: ChessboardProviderContextValue\n    }, {\n        children: children\n    }));\n}, \"xjn6JrX79HI5wm/3utF+yH65K2o=\", false, function() {\n    return [\n        useArrows\n    ];\n}));\n_c = ChessboardProvider;\nfunction Notation(param) {\n    let { row, col } = param;\n    _s3();\n    const { boardOrientation, boardWidth, customDarkSquareStyle, customLightSquareStyle, customNotationStyle } = useChessboard();\n    const whiteColor = customLightSquareStyle.backgroundColor;\n    const blackColor = customDarkSquareStyle.backgroundColor;\n    const isRow = col === 0;\n    const isColumn = row === 7;\n    const isBottomLeftSquare = isRow && isColumn;\n    function getRow() {\n        return boardOrientation === \"white\" ? 8 - row : row + 1;\n    }\n    function getColumn() {\n        return boardOrientation === \"black\" ? COLUMNS[7 - col] : COLUMNS[col];\n    }\n    function renderBottomLeft() {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                    style: Object.assign(Object.assign({\n                        zIndex: 3,\n                        position: \"absolute\"\n                    }, {\n                        color: whiteColor\n                    }), numericStyle(boardWidth, customNotationStyle))\n                }, {\n                    children: getRow()\n                })),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                    style: Object.assign(Object.assign({\n                        zIndex: 3,\n                        position: \"absolute\"\n                    }, {\n                        color: whiteColor\n                    }), alphaStyle(boardWidth, customNotationStyle))\n                }, {\n                    children: getColumn()\n                }))\n            ]\n        });\n    }\n    function renderLetters() {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: Object.assign(Object.assign({\n                userSelect: \"none\",\n                zIndex: 3,\n                position: \"absolute\"\n            }, {\n                color: col % 2 !== 0 ? blackColor : whiteColor\n            }), alphaStyle(boardWidth, customNotationStyle))\n        }, {\n            children: getColumn()\n        }));\n    }\n    function renderNumbers() {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: Object.assign(Object.assign({\n                userSelect: \"none\",\n                zIndex: 3,\n                position: \"absolute\"\n            }, boardOrientation === \"black\" ? {\n                color: row % 2 === 0 ? blackColor : whiteColor\n            } : {\n                color: row % 2 === 0 ? blackColor : whiteColor\n            }), numericStyle(boardWidth, customNotationStyle))\n        }, {\n            children: getRow()\n        }));\n    }\n    if (isBottomLeftSquare) {\n        return renderBottomLeft();\n    }\n    if (isColumn) {\n        return renderLetters();\n    }\n    if (isRow) {\n        return renderNumbers();\n    }\n    return null;\n}\n_s3(Notation, \"bATKP+vRnKt8/M8IbwRBb6kul7g=\", false, function() {\n    return [\n        useChessboard\n    ];\n});\n_c1 = Notation;\nconst alphaStyle = (width, customNotationStyle)=>Object.assign({\n        alignSelf: \"flex-end\",\n        paddingLeft: width / 8 - width / 48,\n        fontSize: width / 48\n    }, customNotationStyle);\nconst numericStyle = (width, customNotationStyle)=>Object.assign({\n        alignSelf: \"flex-start\",\n        paddingRight: width / 8 - width / 48,\n        fontSize: width / 48\n    }, customNotationStyle);\n/**\n * Create the React Context\n */ const DndContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    dragDropManager: undefined\n});\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */ function formatProdErrorMessage(code) {\n    return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + \"use the non-minified dev environment for full errors. \";\n}\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = function() {\n    return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n}();\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */ var randomString = function randomString() {\n    return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n};\nvar ActionTypes = {\n    INIT: \"@@redux/INIT\" + randomString(),\n    REPLACE: \"@@redux/REPLACE\" + randomString(),\n    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n    }\n};\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */ function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    var proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n}\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n    if (val === void 0) return \"undefined\";\n    if (val === null) return \"null\";\n    var type = typeof val;\n    switch(type){\n        case \"boolean\":\n        case \"string\":\n        case \"number\":\n        case \"symbol\":\n        case \"function\":\n            {\n                return type;\n            }\n    }\n    if (Array.isArray(val)) return \"array\";\n    if (isDate(val)) return \"date\";\n    if (isError(val)) return \"error\";\n    var constructorName = ctorName(val);\n    switch(constructorName){\n        case \"Symbol\":\n        case \"Promise\":\n        case \"WeakMap\":\n        case \"WeakSet\":\n        case \"Map\":\n        case \"Set\":\n            return constructorName;\n    } // other\n    return type.slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n    if (val instanceof Date) return true;\n    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n    var typeOfVal = typeof val;\n    if (true) {\n        typeOfVal = miniKindOf(val);\n    }\n    return typeOfVal;\n}\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */ function createStore(reducer, preloadedState, enhancer) {\n    var _ref2;\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n        throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to \" + \"createStore(). This is not supported. Instead, compose them \" + \"together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    if (typeof enhancer !== \"undefined\") {\n        if (typeof enhancer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n        }\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    if (typeof reducer !== \"function\") {\n        throw new Error( false ? 0 : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n    }\n    var currentReducer = reducer;\n    var currentState = preloadedState;\n    var currentListeners = [];\n    var nextListeners = currentListeners;\n    var isDispatching = false;\n    /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */ function ensureCanMutateNextListeners() {\n        if (nextListeners === currentListeners) {\n            nextListeners = currentListeners.slice();\n        }\n    }\n    /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */ function getState() {\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. \" + \"The reducer has already received the state as an argument. \" + \"Pass it down from the top reducer instead of reading it from the store.\");\n        }\n        return currentState;\n    }\n    /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */ function subscribe(listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. \" + \"If you would like to be notified after the store has been updated, subscribe from a \" + \"component and invoke store.getState() in the callback to access the latest state. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n        }\n        var isSubscribed = true;\n        ensureCanMutateNextListeners();\n        nextListeners.push(listener);\n        return function unsubscribe() {\n            if (!isSubscribed) {\n                return;\n            }\n            if (isDispatching) {\n                throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n            }\n            isSubscribed = false;\n            ensureCanMutateNextListeners();\n            var index = nextListeners.indexOf(listener);\n            nextListeners.splice(index, 1);\n            currentListeners = null;\n        };\n    }\n    /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */ function dispatch(action) {\n        if (!isPlainObject(action)) {\n            throw new Error( false ? 0 : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n        }\n        if (typeof action.type === \"undefined\") {\n            throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n        }\n        try {\n            isDispatching = true;\n            currentState = currentReducer(currentState, action);\n        } finally{\n            isDispatching = false;\n        }\n        var listeners = currentListeners = nextListeners;\n        for(var i = 0; i < listeners.length; i++){\n            var listener = listeners[i];\n            listener();\n        }\n        return action;\n    }\n    /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */ function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n        }\n        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n        // Any reducers that existed in both the new and old rootReducer\n        // will receive the previous state. This effectively populates\n        // the new state tree with any relevant data from the old one.\n        dispatch({\n            type: ActionTypes.REPLACE\n        });\n    }\n    /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */ function observable() {\n        var _ref;\n        var outerSubscribe = subscribe;\n        return _ref = {\n            /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe: function subscribe(observer) {\n                if (typeof observer !== \"object\" || observer === null) {\n                    throw new Error( false ? 0 : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n                }\n                function observeState() {\n                    if (observer.next) {\n                        observer.next(getState());\n                    }\n                }\n                observeState();\n                var unsubscribe = outerSubscribe(observeState);\n                return {\n                    unsubscribe: unsubscribe\n                };\n            }\n        }, _ref[$$observable] = function() {\n            return this;\n        }, _ref;\n    } // When a store is created, an \"INIT\" action is dispatched so that every\n    // reducer returns their initial state. This effectively populates\n    // the initial state tree.\n    dispatch({\n        type: ActionTypes.INIT\n    });\n    return _ref2 = {\n        dispatch: dispatch,\n        subscribe: subscribe,\n        getState: getState,\n        replaceReducer: replaceReducer\n    }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */ function warning(message) {\n    /* eslint-disable no-console */ if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    /* eslint-enable no-console */ try {\n        // This error was thrown as a convenience so that if you enable\n        // \"break on all exceptions\" in your console,\n        // it would pause the execution at this line.\n        throw new Error(message);\n    } catch (e) {} // eslint-disable-line no-empty\n}\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */ function isCrushed() {}\nif ( true && typeof isCrushed.name === \"string\" && isCrushed.name !== \"isCrushed\") {\n    warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + \"This means that you are running a slower development build of Redux. \" + \"You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify \" + \"or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) \" + \"to ensure you have the correct code for your production build.\");\n}\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ function invariant(condition, format) {\n    for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        args[_key - 2] = arguments[_key];\n    }\n    if (isProduction()) {\n        if (format === undefined) {\n            throw new Error(\"invariant requires an error message argument\");\n        }\n    }\n    if (!condition) {\n        let error;\n        if (format === undefined) {\n            error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n        } else {\n            let argIndex = 0;\n            error = new Error(format.replace(/%s/g, function() {\n                return args[argIndex++];\n            }));\n            error.name = \"Invariant Violation\";\n        }\n        error.framesToPop = 1 // we don't care about invariant's own frame\n        ;\n        throw error;\n    }\n}\nfunction isProduction() {\n    return typeof process !== \"undefined\" && \"development\" === \"production\";\n}\n// cheap lodash replacements\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */ function get(obj, path, defaultValue) {\n    return path.split(\".\").reduce((a, c)=>a && a[c] ? a[c] : defaultValue || null, obj);\n}\n/**\n * drop-in replacement for _.without\n */ function without$1(items, item) {\n    return items.filter((i)=>i !== item);\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */ function isObject(input) {\n    return typeof input === \"object\";\n}\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */ function xor(itemsA, itemsB) {\n    const map = new Map();\n    const insertItem = (item)=>{\n        map.set(item, map.has(item) ? map.get(item) + 1 : 1);\n    };\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    map.forEach((count, key)=>{\n        if (count === 1) {\n            result.push(key);\n        }\n    });\n    return result;\n}\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */ function intersection(itemsA, itemsB) {\n    return itemsA.filter((t)=>itemsB.indexOf(t) > -1);\n}\nconst INIT_COORDS = \"dnd-core/INIT_COORDS\";\nconst BEGIN_DRAG = \"dnd-core/BEGIN_DRAG\";\nconst PUBLISH_DRAG_SOURCE = \"dnd-core/PUBLISH_DRAG_SOURCE\";\nconst HOVER = \"dnd-core/HOVER\";\nconst DROP = \"dnd-core/DROP\";\nconst END_DRAG = \"dnd-core/END_DRAG\";\nfunction setClientOffset(clientOffset, sourceClientOffset) {\n    return {\n        type: INIT_COORDS,\n        payload: {\n            sourceClientOffset: sourceClientOffset || null,\n            clientOffset: clientOffset || null\n        }\n    };\n}\nconst ResetCoordinatesAction = {\n    type: INIT_COORDS,\n    payload: {\n        clientOffset: null,\n        sourceClientOffset: null\n    }\n};\nfunction createBeginDrag(manager) {\n    return function beginDrag() {\n        let sourceIds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            publishSource: true\n        };\n        const { publishSource = true, clientOffset, getSourceClientOffset } = options;\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        // Initialize the coordinates using the client offset\n        manager.dispatch(setClientOffset(clientOffset));\n        verifyInvariants$1(sourceIds, monitor, registry);\n        // Get the draggable source\n        const sourceId = getDraggableSource(sourceIds, monitor);\n        if (sourceId == null) {\n            manager.dispatch(ResetCoordinatesAction);\n            return;\n        }\n        // Get the source client offset\n        let sourceClientOffset = null;\n        if (clientOffset) {\n            if (!getSourceClientOffset) {\n                throw new Error(\"getSourceClientOffset must be defined\");\n            }\n            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);\n            sourceClientOffset = getSourceClientOffset(sourceId);\n        }\n        // Initialize the full coordinates\n        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));\n        const source = registry.getSource(sourceId);\n        const item = source.beginDrag(monitor, sourceId);\n        // If source.beginDrag returns null, this is an indicator to cancel the drag\n        if (item == null) {\n            return undefined;\n        }\n        verifyItemIsObject(item);\n        registry.pinSource(sourceId);\n        const itemType = registry.getSourceType(sourceId);\n        return {\n            type: BEGIN_DRAG,\n            payload: {\n                itemType,\n                item,\n                sourceId,\n                clientOffset: clientOffset || null,\n                sourceClientOffset: sourceClientOffset || null,\n                isSourcePublic: !!publishSource\n            }\n        };\n    };\n}\nfunction verifyInvariants$1(sourceIds, monitor, registry) {\n    invariant(!monitor.isDragging(), \"Cannot call beginDrag while dragging.\");\n    sourceIds.forEach(function(sourceId) {\n        invariant(registry.getSource(sourceId), \"Expected sourceIds to be registered.\");\n    });\n}\nfunction verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {\n    invariant(typeof getSourceClientOffset === \"function\", \"When clientOffset is provided, getSourceClientOffset must be a function.\");\n}\nfunction verifyItemIsObject(item) {\n    invariant(isObject(item), \"Item must be an object.\");\n}\nfunction getDraggableSource(sourceIds, monitor) {\n    let sourceId = null;\n    for(let i = sourceIds.length - 1; i >= 0; i--){\n        if (monitor.canDragSource(sourceIds[i])) {\n            sourceId = sourceIds[i];\n            break;\n        }\n    }\n    return sourceId;\n}\nfunction _defineProperty$4(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$4(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction createDrop(manager) {\n    return function drop() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyInvariants(monitor);\n        const targetIds = getDroppableTargets(monitor);\n        // Multiple actions are dispatched here, which is why this doesn't return an action\n        targetIds.forEach((targetId, index)=>{\n            const dropResult = determineDropResult(targetId, index, registry, monitor);\n            const action = {\n                type: DROP,\n                payload: {\n                    dropResult: _objectSpread$4({}, options, dropResult)\n                }\n            };\n            manager.dispatch(action);\n        });\n    };\n}\nfunction verifyInvariants(monitor) {\n    invariant(monitor.isDragging(), \"Cannot call drop while not dragging.\");\n    invariant(!monitor.didDrop(), \"Cannot call drop twice during one drag operation.\");\n}\nfunction determineDropResult(targetId, index, registry, monitor) {\n    const target = registry.getTarget(targetId);\n    let dropResult = target ? target.drop(monitor, targetId) : undefined;\n    verifyDropResultType(dropResult);\n    if (typeof dropResult === \"undefined\") {\n        dropResult = index === 0 ? {} : monitor.getDropResult();\n    }\n    return dropResult;\n}\nfunction verifyDropResultType(dropResult) {\n    invariant(typeof dropResult === \"undefined\" || isObject(dropResult), \"Drop result must either be an object or undefined.\");\n}\nfunction getDroppableTargets(monitor) {\n    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n    targetIds.reverse();\n    return targetIds;\n}\nfunction createEndDrag(manager) {\n    return function endDrag() {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyIsDragging(monitor);\n        const sourceId = monitor.getSourceId();\n        if (sourceId != null) {\n            const source = registry.getSource(sourceId, true);\n            source.endDrag(monitor, sourceId);\n            registry.unpinSource();\n        }\n        return {\n            type: END_DRAG\n        };\n    };\n}\nfunction verifyIsDragging(monitor) {\n    invariant(monitor.isDragging(), \"Cannot call endDrag while not dragging.\");\n}\nfunction matchesType(targetType, draggedItemType) {\n    if (draggedItemType === null) {\n        return targetType === null;\n    }\n    return Array.isArray(targetType) ? targetType.some((t)=>t === draggedItemType) : targetType === draggedItemType;\n}\nfunction createHover(manager) {\n    return function hover(targetIdsArg) {\n        let { clientOffset } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        verifyTargetIdsIsArray(targetIdsArg);\n        const targetIds = targetIdsArg.slice(0);\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        const draggedItemType = monitor.getItemType();\n        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n        checkInvariants(targetIds, monitor, registry);\n        hoverAllTargets(targetIds, monitor, registry);\n        return {\n            type: HOVER,\n            payload: {\n                targetIds,\n                clientOffset: clientOffset || null\n            }\n        };\n    };\n}\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n    invariant(Array.isArray(targetIdsArg), \"Expected targetIds to be an array.\");\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n    invariant(monitor.isDragging(), \"Cannot call hover while not dragging.\");\n    invariant(!monitor.didDrop(), \"Cannot call hover after drop.\");\n    for(let i = 0; i < targetIds.length; i++){\n        const targetId = targetIds[i];\n        invariant(targetIds.lastIndexOf(targetId) === i, \"Expected targetIds to be unique in the passed array.\");\n        const target = registry.getTarget(targetId);\n        invariant(target, \"Expected targetIds to be registered.\");\n    }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n    // Remove those targetIds that don't match the targetType.  This\n    // fixes shallow isOver which would only be non-shallow because of\n    // non-matching targets.\n    for(let i = targetIds.length - 1; i >= 0; i--){\n        const targetId = targetIds[i];\n        const targetType = registry.getTargetType(targetId);\n        if (!matchesType(targetType, draggedItemType)) {\n            targetIds.splice(i, 1);\n        }\n    }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n    // Finally call hover on all matching targets.\n    targetIds.forEach(function(targetId) {\n        const target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n    });\n}\nfunction createPublishDragSource(manager) {\n    return function publishDragSource() {\n        const monitor = manager.getMonitor();\n        if (monitor.isDragging()) {\n            return {\n                type: PUBLISH_DRAG_SOURCE\n            };\n        }\n        return;\n    };\n}\nfunction createDragDropActions(manager) {\n    return {\n        beginDrag: createBeginDrag(manager),\n        publishDragSource: createPublishDragSource(manager),\n        hover: createHover(manager),\n        drop: createDrop(manager),\n        endDrag: createEndDrag(manager)\n    };\n}\nclass DragDropManagerImpl {\n    receiveBackend(backend) {\n        this.backend = backend;\n    }\n    getMonitor() {\n        return this.monitor;\n    }\n    getBackend() {\n        return this.backend;\n    }\n    getRegistry() {\n        return this.monitor.registry;\n    }\n    getActions() {\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */ const manager = this;\n        const { dispatch } = this.store;\n        function bindActionCreator(actionCreator) {\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                const action = actionCreator.apply(manager, args);\n                if (typeof action !== \"undefined\") {\n                    dispatch(action);\n                }\n            };\n        }\n        const actions = createDragDropActions(this);\n        return Object.keys(actions).reduce((boundActions, key)=>{\n            const action = actions[key];\n            boundActions[key] = bindActionCreator(action);\n            return boundActions;\n        }, {});\n    }\n    dispatch(action) {\n        this.store.dispatch(action);\n    }\n    constructor(store, monitor){\n        this.isSetUp = false;\n        this.handleRefCountChange = ()=>{\n            const shouldSetUp = this.store.getState().refCount > 0;\n            if (this.backend) {\n                if (shouldSetUp && !this.isSetUp) {\n                    this.backend.setup();\n                    this.isSetUp = true;\n                } else if (!shouldSetUp && this.isSetUp) {\n                    this.backend.teardown();\n                    this.isSetUp = false;\n                }\n            }\n        };\n        this.store = store;\n        this.monitor = monitor;\n        store.subscribe(this.handleRefCountChange);\n    }\n}\n/**\n * Coordinate addition\n * @param a The first coordinate\n * @param b The second coordinate\n */ function add(a, b) {\n    return {\n        x: a.x + b.x,\n        y: a.y + b.y\n    };\n}\n/**\n * Coordinate subtraction\n * @param a The first coordinate\n * @param b The second coordinate\n */ function subtract(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\n/**\n * Returns the cartesian distance of the drag source component's position, based on its position\n * at the time when the current drag operation has started, and the movement difference.\n *\n * Returns null if no item is being dragged.\n *\n * @param state The offset state to compute from\n */ function getSourceClientOffset(state) {\n    const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;\n    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {\n        return null;\n    }\n    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);\n}\n/**\n * Determines the x,y offset between the client offset and the initial client offset\n *\n * @param state The offset state to compute from\n */ function getDifferenceFromInitialOffset(state) {\n    const { clientOffset, initialClientOffset } = state;\n    if (!clientOffset || !initialClientOffset) {\n        return null;\n    }\n    return subtract(clientOffset, initialClientOffset);\n}\nconst NONE = [];\nconst ALL = [];\nNONE.__IS_NONE__ = true;\nALL.__IS_ALL__ = true;\n/**\n * Determines if the given handler IDs are dirty or not.\n *\n * @param dirtyIds The set of dirty handler ids\n * @param handlerIds The set of handler ids to check\n */ function areDirty(dirtyIds, handlerIds) {\n    if (dirtyIds === NONE) {\n        return false;\n    }\n    if (dirtyIds === ALL || typeof handlerIds === \"undefined\") {\n        return true;\n    }\n    const commonIds = intersection(handlerIds, dirtyIds);\n    return commonIds.length > 0;\n}\nclass DragDropMonitorImpl {\n    subscribeToStateChange(listener) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { handlerIds } = options;\n        invariant(typeof listener === \"function\", \"listener must be a function.\");\n        invariant(typeof handlerIds === \"undefined\" || Array.isArray(handlerIds), \"handlerIds, when specified, must be an array of strings.\");\n        let prevStateId = this.store.getState().stateId;\n        const handleChange = ()=>{\n            const state = this.store.getState();\n            const currentStateId = state.stateId;\n            try {\n                const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n                if (!canSkipListener) {\n                    listener();\n                }\n            } finally{\n                prevStateId = currentStateId;\n            }\n        };\n        return this.store.subscribe(handleChange);\n    }\n    subscribeToOffsetChange(listener) {\n        invariant(typeof listener === \"function\", \"listener must be a function.\");\n        let previousState = this.store.getState().dragOffset;\n        const handleChange = ()=>{\n            const nextState = this.store.getState().dragOffset;\n            if (nextState === previousState) {\n                return;\n            }\n            previousState = nextState;\n            listener();\n        };\n        return this.store.subscribe(handleChange);\n    }\n    canDragSource(sourceId) {\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId);\n        invariant(source, \"Expected to find a valid source. sourceId=\".concat(sourceId));\n        if (this.isDragging()) {\n            return false;\n        }\n        return source.canDrag(this, sourceId);\n    }\n    canDropOnTarget(targetId) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const target = this.registry.getTarget(targetId);\n        invariant(target, \"Expected to find a valid target. targetId=\".concat(targetId));\n        if (!this.isDragging() || this.didDrop()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n    }\n    isDragging() {\n        return Boolean(this.getItemType());\n    }\n    isDraggingSource(sourceId) {\n        // undefined on initial render\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId, true);\n        invariant(source, \"Expected to find a valid source. sourceId=\".concat(sourceId));\n        if (!this.isDragging() || !this.isSourcePublic()) {\n            return false;\n        }\n        const sourceType = this.registry.getSourceType(sourceId);\n        const draggedItemType = this.getItemType();\n        if (sourceType !== draggedItemType) {\n            return false;\n        }\n        return source.isDragging(this, sourceId);\n    }\n    isOverTarget(targetId) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n            shallow: false\n        };\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const { shallow } = options;\n        if (!this.isDragging()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n            return false;\n        }\n        const targetIds = this.getTargetIds();\n        if (!targetIds.length) {\n            return false;\n        }\n        const index = targetIds.indexOf(targetId);\n        if (shallow) {\n            return index === targetIds.length - 1;\n        } else {\n            return index > -1;\n        }\n    }\n    getItemType() {\n        return this.store.getState().dragOperation.itemType;\n    }\n    getItem() {\n        return this.store.getState().dragOperation.item;\n    }\n    getSourceId() {\n        return this.store.getState().dragOperation.sourceId;\n    }\n    getTargetIds() {\n        return this.store.getState().dragOperation.targetIds;\n    }\n    getDropResult() {\n        return this.store.getState().dragOperation.dropResult;\n    }\n    didDrop() {\n        return this.store.getState().dragOperation.didDrop;\n    }\n    isSourcePublic() {\n        return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n    getInitialClientOffset() {\n        return this.store.getState().dragOffset.initialClientOffset;\n    }\n    getInitialSourceClientOffset() {\n        return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n    getClientOffset() {\n        return this.store.getState().dragOffset.clientOffset;\n    }\n    getSourceClientOffset() {\n        return getSourceClientOffset(this.store.getState().dragOffset);\n    }\n    getDifferenceFromInitialOffset() {\n        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n    constructor(store, registry){\n        this.store = store;\n        this.registry = registry;\n    }\n}\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n/* globals self */ const scope = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : self;\nconst BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        const timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        const intervalHandle = setInterval(handleTimer, 50);\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    let toggle = 1;\n    const observer = new BrowserMutationObserver(callback);\n    const node = document.createTextNode(\"\");\n    observer.observe(node, {\n        characterData: true\n    });\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\nconst makeRequestCall = typeof BrowserMutationObserver === \"function\" ? // They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nmakeRequestCallFromMutationObserver : // 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\nmakeRequestCallFromTimer;\nclass AsapQueue {\n    // Use the fastest means possible to execute a task in its own turn, with\n    // priority over other events including IO, animation, reflow, and redraw\n    // events in browsers.\n    //\n    // An exception thrown by a task will permanently interrupt the processing of\n    // subsequent tasks. The higher level `asap` function ensures that if an\n    // exception is thrown by a task, that the task queue will continue flushing as\n    // soon as possible, but if you use `rawAsap` directly, you are responsible to\n    // either ensure that no exceptions are thrown from your task, or to manually\n    // call `rawAsap.requestFlush` if an exception is thrown.\n    enqueueTask(task) {\n        const { queue: q, requestFlush } = this;\n        if (!q.length) {\n            requestFlush();\n            this.flushing = true;\n        }\n        // Equivalent to push, but avoids a function call.\n        q[q.length] = task;\n    }\n    constructor(){\n        this.queue = [];\n        // We queue errors to ensure they are thrown in right order (FIFO).\n        // Array-as-queue is good enough here, since we are just dealing with exceptions.\n        this.pendingErrors = [];\n        // Once a flush has been requested, no further calls to `requestFlush` are\n        // necessary until the next `flush` completes.\n        // @ts-ignore\n        this.flushing = false;\n        // The position of the next task to execute in the task queue. This is\n        // preserved between calls to `flush` so that it can be resumed if\n        // a task throws an exception.\n        this.index = 0;\n        // If a task schedules additional tasks recursively, the task queue can grow\n        // unbounded. To prevent memory exhaustion, the task queue will periodically\n        // truncate already-completed tasks.\n        this.capacity = 1024;\n        // The flush function processes all tasks that have been scheduled with\n        // `rawAsap` unless and until one of those tasks throws an exception.\n        // If a task throws an exception, `flush` ensures that its state will remain\n        // consistent and will resume where it left off when called again.\n        // However, `flush` does not make any arrangements to be called again if an\n        // exception is thrown.\n        this.flush = ()=>{\n            const { queue: q } = this;\n            while(this.index < q.length){\n                const currentIndex = this.index;\n                // Advance the index before calling the task. This ensures that we will\n                // begin flushing on the next task the task throws an error.\n                this.index++;\n                q[currentIndex].call();\n                // Prevent leaking memory for long chains of recursive calls to `asap`.\n                // If we call `asap` within tasks scheduled by `asap`, the queue will\n                // grow, but to avoid an O(n) walk for every task we execute, we don't\n                // shift tasks off the queue after they have been executed.\n                // Instead, we periodically shift 1024 tasks off the queue.\n                if (this.index > this.capacity) {\n                    // Manually shift all values starting at the index back to the\n                    // beginning of the queue.\n                    for(let scan = 0, newLength = q.length - this.index; scan < newLength; scan++){\n                        q[scan] = q[scan + this.index];\n                    }\n                    q.length -= this.index;\n                    this.index = 0;\n                }\n            }\n            q.length = 0;\n            this.index = 0;\n            this.flushing = false;\n        };\n        // In a web browser, exceptions are not fatal. However, to avoid\n        // slowing down the queue of pending tasks, we rethrow the error in a\n        // lower priority turn.\n        this.registerPendingError = (err)=>{\n            this.pendingErrors.push(err);\n            this.requestErrorThrow();\n        };\n        // `requestFlush` requests that the high priority event queue be flushed as\n        // soon as possible.\n        // This is useful to prevent an error thrown in a task from stalling the event\n        // queue if the exception handled by Node.jss\n        // `process.on(\"uncaughtException\")` or by a domain.\n        // `requestFlush` is implemented using a strategy based on data collected from\n        // every available SauceLabs Selenium web driver worker at time of writing.\n        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n        this.requestFlush = makeRequestCall(this.flush);\n        this.requestErrorThrow = makeRequestCallFromTimer(()=>{\n            // Throw first error\n            if (this.pendingErrors.length) {\n                throw this.pendingErrors.shift();\n            }\n        });\n    }\n} // The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// // its existence.\n// rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n// `call`, just like a function.\nclass RawTask {\n    call() {\n        try {\n            this.task && this.task();\n        } catch (error) {\n            this.onError(error);\n        } finally{\n            this.task = null;\n            this.release(this);\n        }\n    }\n    constructor(onError, release){\n        this.onError = onError;\n        this.release = release;\n        this.task = null;\n    }\n}\nclass TaskFactory {\n    create(task) {\n        const tasks = this.freeTasks;\n        const t1 = tasks.length ? tasks.pop() : new RawTask(this.onError, (t)=>tasks[tasks.length] = t);\n        t1.task = task;\n        return t1;\n    }\n    constructor(onError){\n        this.onError = onError;\n        this.freeTasks = [];\n    }\n}\nconst asapQueue = new AsapQueue();\nconst taskFactory = new TaskFactory(asapQueue.registerPendingError);\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */ function asap(task) {\n    asapQueue.enqueueTask(taskFactory.create(task));\n}\nconst ADD_SOURCE = \"dnd-core/ADD_SOURCE\";\nconst ADD_TARGET = \"dnd-core/ADD_TARGET\";\nconst REMOVE_SOURCE = \"dnd-core/REMOVE_SOURCE\";\nconst REMOVE_TARGET = \"dnd-core/REMOVE_TARGET\";\nfunction addSource(sourceId) {\n    return {\n        type: ADD_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nfunction addTarget(targetId) {\n    return {\n        type: ADD_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\nfunction removeSource(sourceId) {\n    return {\n        type: REMOVE_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nfunction removeTarget(targetId) {\n    return {\n        type: REMOVE_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\nfunction validateSourceContract(source) {\n    invariant(typeof source.canDrag === \"function\", \"Expected canDrag to be a function.\");\n    invariant(typeof source.beginDrag === \"function\", \"Expected beginDrag to be a function.\");\n    invariant(typeof source.endDrag === \"function\", \"Expected endDrag to be a function.\");\n}\nfunction validateTargetContract(target) {\n    invariant(typeof target.canDrop === \"function\", \"Expected canDrop to be a function.\");\n    invariant(typeof target.hover === \"function\", \"Expected hover to be a function.\");\n    invariant(typeof target.drop === \"function\", \"Expected beginDrag to be a function.\");\n}\nfunction validateType(type, allowArray) {\n    if (allowArray && Array.isArray(type)) {\n        type.forEach((t)=>validateType(t, false));\n        return;\n    }\n    invariant(typeof type === \"string\" || typeof type === \"symbol\", allowArray ? \"Type can only be a string, a symbol, or an array of either.\" : \"Type can only be a string or a symbol.\");\n}\nvar HandlerRole;\n(function(HandlerRole) {\n    HandlerRole[\"SOURCE\"] = \"SOURCE\";\n    HandlerRole[\"TARGET\"] = \"TARGET\";\n})(HandlerRole || (HandlerRole = {}));\nlet nextUniqueId = 0;\nfunction getNextUniqueId() {\n    return nextUniqueId++;\n}\nfunction getNextHandlerId(role) {\n    const id = getNextUniqueId().toString();\n    switch(role){\n        case HandlerRole.SOURCE:\n            return \"S\".concat(id);\n        case HandlerRole.TARGET:\n            return \"T\".concat(id);\n        default:\n            throw new Error(\"Unknown Handler Role: \".concat(role));\n    }\n}\nfunction parseRoleFromHandlerId(handlerId) {\n    switch(handlerId[0]){\n        case \"S\":\n            return HandlerRole.SOURCE;\n        case \"T\":\n            return HandlerRole.TARGET;\n        default:\n            throw new Error(\"Cannot parse handler ID: \".concat(handlerId));\n    }\n}\nfunction mapContainsValue(map, searchValue) {\n    const entries = map.entries();\n    let isDone = false;\n    do {\n        const { done, value: [, value] } = entries.next();\n        if (value === searchValue) {\n            return true;\n        }\n        isDone = !!done;\n    }while (!isDone);\n    return false;\n}\nclass HandlerRegistryImpl {\n    addSource(type, source) {\n        validateType(type);\n        validateSourceContract(source);\n        const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n        this.store.dispatch(addSource(sourceId));\n        return sourceId;\n    }\n    addTarget(type, target) {\n        validateType(type, true);\n        validateTargetContract(target);\n        const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n        this.store.dispatch(addTarget(targetId));\n        return targetId;\n    }\n    containsHandler(handler) {\n        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n    }\n    getSource(sourceId) {\n        let includePinned = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        invariant(this.isSourceId(sourceId), \"Expected a valid source ID.\");\n        const isPinned = includePinned && sourceId === this.pinnedSourceId;\n        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n        return source;\n    }\n    getTarget(targetId) {\n        invariant(this.isTargetId(targetId), \"Expected a valid target ID.\");\n        return this.dropTargets.get(targetId);\n    }\n    getSourceType(sourceId) {\n        invariant(this.isSourceId(sourceId), \"Expected a valid source ID.\");\n        return this.types.get(sourceId);\n    }\n    getTargetType(targetId) {\n        invariant(this.isTargetId(targetId), \"Expected a valid target ID.\");\n        return this.types.get(targetId);\n    }\n    isSourceId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.SOURCE;\n    }\n    isTargetId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.TARGET;\n    }\n    removeSource(sourceId) {\n        invariant(this.getSource(sourceId), \"Expected an existing source.\");\n        this.store.dispatch(removeSource(sourceId));\n        asap(()=>{\n            this.dragSources.delete(sourceId);\n            this.types.delete(sourceId);\n        });\n    }\n    removeTarget(targetId) {\n        invariant(this.getTarget(targetId), \"Expected an existing target.\");\n        this.store.dispatch(removeTarget(targetId));\n        this.dropTargets.delete(targetId);\n        this.types.delete(targetId);\n    }\n    pinSource(sourceId) {\n        const source = this.getSource(sourceId);\n        invariant(source, \"Expected an existing source.\");\n        this.pinnedSourceId = sourceId;\n        this.pinnedSource = source;\n    }\n    unpinSource() {\n        invariant(this.pinnedSource, \"No source is pinned at the time.\");\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n    }\n    addHandler(role, type, handler) {\n        const id = getNextHandlerId(role);\n        this.types.set(id, type);\n        if (role === HandlerRole.SOURCE) {\n            this.dragSources.set(id, handler);\n        } else if (role === HandlerRole.TARGET) {\n            this.dropTargets.set(id, handler);\n        }\n        return id;\n    }\n    constructor(store){\n        this.types = new Map();\n        this.dragSources = new Map();\n        this.dropTargets = new Map();\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n        this.store = store;\n    }\n}\nconst strictEquality = (a, b)=>a === b;\n/**\n * Determine if two cartesian coordinate offsets are equal\n * @param offsetA\n * @param offsetB\n */ function areCoordsEqual(offsetA, offsetB) {\n    if (!offsetA && !offsetB) {\n        return true;\n    } else if (!offsetA || !offsetB) {\n        return false;\n    } else {\n        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;\n    }\n}\n/**\n * Determines if two arrays of items are equal\n * @param a The first array of items\n * @param b The second array of items\n */ function areArraysEqual(a, b) {\n    let isEqual = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : strictEquality;\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; ++i){\n        if (!isEqual(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction reduce$5() {\n    let _state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NONE, action = arguments.length > 1 ? arguments[1] : void 0;\n    switch(action.type){\n        case HOVER:\n            break;\n        case ADD_SOURCE:\n        case ADD_TARGET:\n        case REMOVE_TARGET:\n        case REMOVE_SOURCE:\n            return NONE;\n        case BEGIN_DRAG:\n        case PUBLISH_DRAG_SOURCE:\n        case END_DRAG:\n        case DROP:\n        default:\n            return ALL;\n    }\n    const { targetIds = [], prevTargetIds = [] } = action.payload;\n    const result = xor(targetIds, prevTargetIds);\n    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);\n    if (!didChange) {\n        return NONE;\n    }\n    // Check the target ids at the innermost position. If they are valid, add them\n    // to the result\n    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];\n    const innermostTargetId = targetIds[targetIds.length - 1];\n    if (prevInnermostTargetId !== innermostTargetId) {\n        if (prevInnermostTargetId) {\n            result.push(prevInnermostTargetId);\n        }\n        if (innermostTargetId) {\n            result.push(innermostTargetId);\n        }\n    }\n    return result;\n}\nfunction _defineProperty$3(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$3(target, key, source[key]);\n        });\n    }\n    return target;\n}\nconst initialState$1 = {\n    initialSourceClientOffset: null,\n    initialClientOffset: null,\n    clientOffset: null\n};\nfunction reduce$4() {\n    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState$1, action = arguments.length > 1 ? arguments[1] : void 0;\n    const { payload } = action;\n    switch(action.type){\n        case INIT_COORDS:\n        case BEGIN_DRAG:\n            return {\n                initialSourceClientOffset: payload.sourceClientOffset,\n                initialClientOffset: payload.clientOffset,\n                clientOffset: payload.clientOffset\n            };\n        case HOVER:\n            if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {\n                return state;\n            }\n            return _objectSpread$3({}, state, {\n                clientOffset: payload.clientOffset\n            });\n        case END_DRAG:\n        case DROP:\n            return initialState$1;\n        default:\n            return state;\n    }\n}\nfunction _defineProperty$2(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$2(target, key, source[key]);\n        });\n    }\n    return target;\n}\nconst initialState = {\n    itemType: null,\n    item: null,\n    sourceId: null,\n    targetIds: [],\n    dropResult: null,\n    didDrop: false,\n    isSourcePublic: null\n};\nfunction reduce$3() {\n    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState, action = arguments.length > 1 ? arguments[1] : void 0;\n    const { payload } = action;\n    switch(action.type){\n        case BEGIN_DRAG:\n            return _objectSpread$2({}, state, {\n                itemType: payload.itemType,\n                item: payload.item,\n                sourceId: payload.sourceId,\n                isSourcePublic: payload.isSourcePublic,\n                dropResult: null,\n                didDrop: false\n            });\n        case PUBLISH_DRAG_SOURCE:\n            return _objectSpread$2({}, state, {\n                isSourcePublic: true\n            });\n        case HOVER:\n            return _objectSpread$2({}, state, {\n                targetIds: payload.targetIds\n            });\n        case REMOVE_TARGET:\n            if (state.targetIds.indexOf(payload.targetId) === -1) {\n                return state;\n            }\n            return _objectSpread$2({}, state, {\n                targetIds: without$1(state.targetIds, payload.targetId)\n            });\n        case DROP:\n            return _objectSpread$2({}, state, {\n                dropResult: payload.dropResult,\n                didDrop: true,\n                targetIds: []\n            });\n        case END_DRAG:\n            return _objectSpread$2({}, state, {\n                itemType: null,\n                item: null,\n                sourceId: null,\n                dropResult: null,\n                didDrop: false,\n                isSourcePublic: null,\n                targetIds: []\n            });\n        default:\n            return state;\n    }\n}\nfunction reduce$2() {\n    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, action = arguments.length > 1 ? arguments[1] : void 0;\n    switch(action.type){\n        case ADD_SOURCE:\n        case ADD_TARGET:\n            return state + 1;\n        case REMOVE_SOURCE:\n        case REMOVE_TARGET:\n            return state - 1;\n        default:\n            return state;\n    }\n}\nfunction reduce$1() {\n    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    return state + 1;\n}\nfunction _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$1(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction reduce() {\n    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, action = arguments.length > 1 ? arguments[1] : void 0;\n    return {\n        dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {\n            type: action.type,\n            payload: _objectSpread$1({}, action.payload, {\n                prevTargetIds: get(state, \"dragOperation.targetIds\", [])\n            })\n        }),\n        dragOffset: reduce$4(state.dragOffset, action),\n        refCount: reduce$2(state.refCount, action),\n        dragOperation: reduce$3(state.dragOperation, action),\n        stateId: reduce$1(state.stateId)\n    };\n}\nfunction createDragDropManager(backendFactory) {\n    let globalContext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : undefined, backendOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, debugMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const store = makeStoreInstance(debugMode);\n    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));\n    const manager = new DragDropManagerImpl(store, monitor);\n    const backend = backendFactory(manager, globalContext, backendOptions);\n    manager.receiveBackend(backend);\n    return manager;\n}\nfunction makeStoreInstance(debugMode) {\n    // TODO: if we ever make a react-native version of this,\n    // we'll need to consider how to pull off dev-tooling\n    const reduxDevTools =  true && window.__REDUX_DEVTOOLS_EXTENSION__;\n    return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({\n        name: \"dnd-core\",\n        instanceId: \"dnd-core\"\n    }));\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nlet refCount = 0;\nconst INSTANCE_SYM = Symbol.for(\"__REACT_DND_CONTEXT_INSTANCE__\");\nvar DndProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_s4(function DndProvider(_param) {\n    _s4();\n    var { children } = _param, props = _objectWithoutProperties(_param, [\n        \"children\"\n    ]);\n    const [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props\n    ;\n    /**\n\t\t * If the global context was used to store the DND context\n\t\t * then where theres no more references to it we should\n\t\t * clean it up to avoid memory leaks\n\t\t */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isGlobalInstance) {\n            const context = getGlobalContext();\n            ++refCount;\n            return ()=>{\n                if (--refCount === 0) {\n                    context[INSTANCE_SYM] = null;\n                }\n            };\n        }\n        return;\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DndContext.Provider, {\n        value: manager,\n        children: children\n    });\n}, \"OD7bBpZva5O2jO+Puf00hKivP7c=\"));\n_c2 = DndProvider;\nfunction getDndContextValue(props) {\n    if (\"manager\" in props) {\n        const manager = {\n            dragDropManager: props.manager\n        };\n        return [\n            manager,\n            false\n        ];\n    }\n    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);\n    const isGlobalInstance = !props.context;\n    return [\n        manager,\n        isGlobalInstance\n    ];\n}\nfunction createSingletonDndContext(backend) {\n    let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getGlobalContext(), options = arguments.length > 2 ? arguments[2] : void 0, debugMode = arguments.length > 3 ? arguments[3] : void 0;\n    const ctx = context;\n    if (!ctx[INSTANCE_SYM]) {\n        ctx[INSTANCE_SYM] = {\n            dragDropManager: createDragDropManager(backend, context, options, debugMode)\n        };\n    }\n    return ctx[INSTANCE_SYM];\n}\nfunction getGlobalContext() {\n    return typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : window;\n}\n// do not edit .js files directly - edit src/index.jst\nvar fastDeepEqual = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\n// suppress the useLayoutEffect warning on server side.\nconst useIsomorphicLayoutEffect =  true ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : 0;\n/**\n *\n * @param monitor The monitor to collect state from\n * @param collect The collecting function\n * @param onUpdate A method to invoke when updates occur\n */ function useCollector(monitor, collect, onUpdate) {\n    _s5();\n    const [collected, setCollected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>collect(monitor));\n    const updateCollected = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const nextValue = collect(monitor);\n        // This needs to be a deep-equality check because some monitor-collected values\n        // include XYCoord objects that may be equivalent, but do not have instance equality.\n        if (!fastDeepEqual(collected, nextValue)) {\n            setCollected(nextValue);\n            if (onUpdate) {\n                onUpdate();\n            }\n        }\n    }, [\n        collected,\n        monitor,\n        onUpdate\n    ]);\n    // update the collected properties after react renders.\n    // Note that the \"Dustbin Stress Test\" fails if this is not\n    // done when the component updates\n    useIsomorphicLayoutEffect(updateCollected);\n    return [\n        collected,\n        updateCollected\n    ];\n}\n_s5(useCollector, \"t5ni7gjGZ37eFeN0aYQqiZoSxzI=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction useMonitorOutput(monitor, collect, onCollect) {\n    _s6();\n    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);\n    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {\n        const handlerId = monitor.getHandlerId();\n        if (handlerId == null) {\n            return;\n        }\n        return monitor.subscribeToStateChange(updateCollected, {\n            handlerIds: [\n                handlerId\n            ]\n        });\n    }, [\n        monitor,\n        updateCollected\n    ]);\n    return collected;\n}\n_s6(useMonitorOutput, \"llDYz3yd5nnyBiYfjU01V8r5Tw0=\", false, function() {\n    return [\n        useCollector,\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction useCollectedProps(collector, monitor, connector) {\n    _s7();\n    return useMonitorOutput(monitor, collector || (()=>({})), ()=>connector.reconnect());\n}\n_s7(useCollectedProps, \"kLgYBVRDE7MYxMYS7kKhlJM5nZU=\", false, function() {\n    return [\n        useMonitorOutput\n    ];\n});\nfunction useOptionalFactory(arg, deps) {\n    _s8();\n    const memoDeps = [\n        ...deps || []\n    ];\n    if (deps == null && typeof arg !== \"function\") {\n        memoDeps.push(arg);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return typeof arg === \"function\" ? arg() : arg;\n    }, memoDeps);\n}\n_s8(useOptionalFactory, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction useConnectDragSource(connector) {\n    _s9();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dragSource(), [\n        connector\n    ]);\n}\n_s9(useConnectDragSource, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction useConnectDragPreview(connector) {\n    _s10();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dragPreview(), [\n        connector\n    ]);\n}\n_s10(useConnectDragPreview, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nlet isCallingCanDrag = false;\nlet isCallingIsDragging = false;\nclass DragSourceMonitorImpl {\n    receiveHandlerId(sourceId) {\n        this.sourceId = sourceId;\n    }\n    getHandlerId() {\n        return this.sourceId;\n    }\n    canDrag() {\n        invariant(!isCallingCanDrag, \"You may not call monitor.canDrag() inside your canDrag() implementation. \" + \"Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");\n        try {\n            isCallingCanDrag = true;\n            return this.internalMonitor.canDragSource(this.sourceId);\n        } finally{\n            isCallingCanDrag = false;\n        }\n    }\n    isDragging() {\n        if (!this.sourceId) {\n            return false;\n        }\n        invariant(!isCallingIsDragging, \"You may not call monitor.isDragging() inside your isDragging() implementation. \" + \"Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor\");\n        try {\n            isCallingIsDragging = true;\n            return this.internalMonitor.isDraggingSource(this.sourceId);\n        } finally{\n            isCallingIsDragging = false;\n        }\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    isDraggingSource(sourceId) {\n        return this.internalMonitor.isDraggingSource(sourceId);\n    }\n    isOverTarget(targetId, options) {\n        return this.internalMonitor.isOverTarget(targetId, options);\n    }\n    getTargetIds() {\n        return this.internalMonitor.getTargetIds();\n    }\n    isSourcePublic() {\n        return this.internalMonitor.isSourcePublic();\n    }\n    getSourceId() {\n        return this.internalMonitor.getSourceId();\n    }\n    subscribeToOffsetChange(listener) {\n        return this.internalMonitor.subscribeToOffsetChange(listener);\n    }\n    canDragSource(sourceId) {\n        return this.internalMonitor.canDragSource(sourceId);\n    }\n    canDropOnTarget(targetId) {\n        return this.internalMonitor.canDropOnTarget(targetId);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.sourceId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\nlet isCallingCanDrop = false;\nclass DropTargetMonitorImpl {\n    receiveHandlerId(targetId) {\n        this.targetId = targetId;\n    }\n    getHandlerId() {\n        return this.targetId;\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    canDrop() {\n        // Cut out early if the target id has not been set. This should prevent errors\n        // where the user has an older version of dnd-core like in\n        // https://github.com/react-dnd/react-dnd/issues/1310\n        if (!this.targetId) {\n            return false;\n        }\n        invariant(!isCallingCanDrop, \"You may not call monitor.canDrop() inside your canDrop() implementation. \" + \"Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor\");\n        try {\n            isCallingCanDrop = true;\n            return this.internalMonitor.canDropOnTarget(this.targetId);\n        } finally{\n            isCallingCanDrop = false;\n        }\n    }\n    isOver(options) {\n        if (!this.targetId) {\n            return false;\n        }\n        return this.internalMonitor.isOverTarget(this.targetId, options);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.targetId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\nfunction registerTarget(type, target, manager) {\n    const registry = manager.getRegistry();\n    const targetId = registry.addTarget(type, target);\n    return [\n        targetId,\n        ()=>registry.removeTarget(targetId)\n    ];\n}\nfunction registerSource(type, source, manager) {\n    const registry = manager.getRegistry();\n    const sourceId = registry.addSource(type, source);\n    return [\n        sourceId,\n        ()=>registry.removeSource(sourceId)\n    ];\n}\nfunction shallowEqual(objA, objB, compare, compareContext) {\n    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;\n    if (compareResult !== void 0) {\n        return !!compareResult;\n    }\n    if (objA === objB) {\n        return true;\n    }\n    if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n    // Test for A's keys different from B.\n    for(let idx = 0; idx < keysA.length; idx++){\n        const key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n            return false;\n        }\n        const valueA = objA[key];\n        const valueB = objB[key];\n        compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isRef(obj) {\n    return obj !== null && typeof obj === \"object\" && Object.prototype.hasOwnProperty.call(obj, \"current\");\n}\nfunction throwIfCompositeComponentElement(element) {\n    // Custom components can no longer be wrapped directly in React DnD 2.0\n    // so that we don't need to depend on findDOMNode() from react-dom.\n    if (typeof element.type === \"string\") {\n        return;\n    }\n    const displayName = element.type.displayName || element.type.name || \"the component\";\n    throw new Error(\"Only native element nodes can now be passed to React DnD connectors.\" + \"You can either wrap \".concat(displayName, \" into a <div>, or turn it into a \") + \"drag source or a drop target itself.\");\n}\nfunction wrapHookToRecognizeElement(hook) {\n    return function() {\n        let elementOrNode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n        // When passed a node, call the hook straight away.\n        if (!/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(elementOrNode)) {\n            const node = elementOrNode;\n            hook(node, options);\n            // return the node so it can be chained (e.g. when within callback refs\n            // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n            return node;\n        }\n        // If passed a ReactElement, clone it and attach this function as a ref.\n        // This helps us achieve a neat API where user doesn't even know that refs\n        // are being used under the hood.\n        const element = elementOrNode;\n        throwIfCompositeComponentElement(element);\n        // When no options are passed, use the hook directly\n        const ref = options ? (node)=>hook(node, options) : hook;\n        return cloneWithRef(element, ref);\n    };\n}\nfunction wrapConnectorHooks(hooks) {\n    const wrappedHooks = {};\n    Object.keys(hooks).forEach((key)=>{\n        const hook = hooks[key];\n        // ref objects should be passed straight through without wrapping\n        if (key.endsWith(\"Ref\")) {\n            wrappedHooks[key] = hooks[key];\n        } else {\n            const wrappedHook = wrapHookToRecognizeElement(hook);\n            wrappedHooks[key] = ()=>wrappedHook;\n        }\n    });\n    return wrappedHooks;\n}\nfunction setRef(ref, node) {\n    if (typeof ref === \"function\") {\n        ref(node);\n    } else {\n        ref.current = node;\n    }\n}\nfunction cloneWithRef(element, newRef) {\n    const previousRef = element.ref;\n    invariant(typeof previousRef !== \"string\", \"Cannot connect React DnD to an element with an existing string ref. \" + \"Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. \" + \"Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs\");\n    if (!previousRef) {\n        // When there is no ref on the element, use the new ref directly\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(element, {\n            ref: newRef\n        });\n    } else {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(element, {\n            ref: (node)=>{\n                setRef(previousRef, node);\n                setRef(newRef, node);\n            }\n        });\n    }\n}\nclass SourceConnector {\n    receiveHandlerId(newHandlerId) {\n        if (this.handlerId === newHandlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get connectTarget() {\n        return this.dragSource;\n    }\n    get dragSourceOptions() {\n        return this.dragSourceOptionsInternal;\n    }\n    set dragSourceOptions(options) {\n        this.dragSourceOptionsInternal = options;\n    }\n    get dragPreviewOptions() {\n        return this.dragPreviewOptionsInternal;\n    }\n    set dragPreviewOptions(options) {\n        this.dragPreviewOptionsInternal = options;\n    }\n    reconnect() {\n        const didChange = this.reconnectDragSource();\n        this.reconnectDragPreview(didChange);\n    }\n    reconnectDragSource() {\n        const dragSource = this.dragSource;\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();\n        if (didChange) {\n            this.disconnectDragSource();\n        }\n        if (!this.handlerId) {\n            return didChange;\n        }\n        if (!dragSource) {\n            this.lastConnectedDragSource = dragSource;\n            return didChange;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragSource = dragSource;\n            this.lastConnectedDragSourceOptions = this.dragSourceOptions;\n            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);\n        }\n        return didChange;\n    }\n    reconnectDragPreview() {\n        let forceDidChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        const dragPreview = this.dragPreview;\n        // if nothing has changed then don't resubscribe\n        const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();\n        if (didChange) {\n            this.disconnectDragPreview();\n        }\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dragPreview) {\n            this.lastConnectedDragPreview = dragPreview;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragPreview = dragPreview;\n            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;\n            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);\n        }\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didConnectedDragSourceChange() {\n        return this.lastConnectedDragSource !== this.dragSource;\n    }\n    didConnectedDragPreviewChange() {\n        return this.lastConnectedDragPreview !== this.dragPreview;\n    }\n    didDragSourceOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);\n    }\n    didDragPreviewOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);\n    }\n    disconnectDragSource() {\n        if (this.dragSourceUnsubscribe) {\n            this.dragSourceUnsubscribe();\n            this.dragSourceUnsubscribe = undefined;\n        }\n    }\n    disconnectDragPreview() {\n        if (this.dragPreviewUnsubscribe) {\n            this.dragPreviewUnsubscribe();\n            this.dragPreviewUnsubscribe = undefined;\n            this.dragPreviewNode = null;\n            this.dragPreviewRef = null;\n        }\n    }\n    get dragSource() {\n        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;\n    }\n    get dragPreview() {\n        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;\n    }\n    clearDragSource() {\n        this.dragSourceNode = null;\n        this.dragSourceRef = null;\n    }\n    clearDragPreview() {\n        this.dragPreviewNode = null;\n        this.dragPreviewRef = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dragSource: (node, options)=>{\n                this.clearDragSource();\n                this.dragSourceOptions = options || null;\n                if (isRef(node)) {\n                    this.dragSourceRef = node;\n                } else {\n                    this.dragSourceNode = node;\n                }\n                this.reconnectDragSource();\n            },\n            dragPreview: (node, options)=>{\n                this.clearDragPreview();\n                this.dragPreviewOptions = options || null;\n                if (isRef(node)) {\n                    this.dragPreviewRef = node;\n                } else {\n                    this.dragPreviewNode = node;\n                }\n                this.reconnectDragPreview();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dragSourceRef = null;\n        this.dragSourceOptionsInternal = null;\n        // The drag preview may either be attached via ref or connect function\n        this.dragPreviewRef = null;\n        this.dragPreviewOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDragSource = null;\n        this.lastConnectedDragSourceOptions = null;\n        this.lastConnectedDragPreview = null;\n        this.lastConnectedDragPreviewOptions = null;\n        this.backend = backend;\n    }\n}\nclass TargetConnector {\n    get connectTarget() {\n        return this.dropTarget;\n    }\n    reconnect() {\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();\n        if (didChange) {\n            this.disconnectDropTarget();\n        }\n        const dropTarget = this.dropTarget;\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dropTarget) {\n            this.lastConnectedDropTarget = dropTarget;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDropTarget = dropTarget;\n            this.lastConnectedDropTargetOptions = this.dropTargetOptions;\n            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);\n        }\n    }\n    receiveHandlerId(newHandlerId) {\n        if (newHandlerId === this.handlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get dropTargetOptions() {\n        return this.dropTargetOptionsInternal;\n    }\n    set dropTargetOptions(options) {\n        this.dropTargetOptionsInternal = options;\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didDropTargetChange() {\n        return this.lastConnectedDropTarget !== this.dropTarget;\n    }\n    didOptionsChange() {\n        return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);\n    }\n    disconnectDropTarget() {\n        if (this.unsubscribeDropTarget) {\n            this.unsubscribeDropTarget();\n            this.unsubscribeDropTarget = undefined;\n        }\n    }\n    get dropTarget() {\n        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;\n    }\n    clearDropTarget() {\n        this.dropTargetRef = null;\n        this.dropTargetNode = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dropTarget: (node, options)=>{\n                this.clearDropTarget();\n                this.dropTargetOptions = options;\n                if (isRef(node)) {\n                    this.dropTargetRef = node;\n                } else {\n                    this.dropTargetNode = node;\n                }\n                this.reconnect();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dropTargetRef = null;\n        this.dropTargetOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDropTarget = null;\n        this.lastConnectedDropTargetOptions = null;\n        this.backend = backend;\n    }\n}\n/**\n * A hook to retrieve the DragDropManager from Context\n */ function useDragDropManager() {\n    _s11();\n    const { dragDropManager } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DndContext);\n    invariant(dragDropManager != null, \"Expected drag drop context\");\n    return dragDropManager;\n}\n_s11(useDragDropManager, \"dqvj4PTUTqtpW4LACIdvsStf0xM=\");\nfunction useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {\n    _s12();\n    const manager = useDragDropManager();\n    const connector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new SourceConnector(manager.getBackend()), [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragSourceOptions = dragSourceOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragSource();\n    }, [\n        connector,\n        dragSourceOptions\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragPreviewOptions = dragPreviewOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragPreview();\n    }, [\n        connector,\n        dragPreviewOptions\n    ]);\n    return connector;\n}\n_s12(useDragSourceConnector, \"Y4ygiyn13MTwSMQXLpSHvIAohRw=\", false, function() {\n    return [\n        useDragDropManager,\n        useIsomorphicLayoutEffect,\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction useDragSourceMonitor() {\n    _s13();\n    const manager = useDragDropManager();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DragSourceMonitorImpl(manager), [\n        manager\n    ]);\n}\n_s13(useDragSourceMonitor, \"7FEphg5G3wLABgFM2+qPoIxm9ZM=\", false, function() {\n    return [\n        useDragDropManager\n    ];\n});\nclass DragSourceImpl {\n    beginDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        let result = null;\n        if (typeof spec.item === \"object\") {\n            result = spec.item;\n        } else if (typeof spec.item === \"function\") {\n            result = spec.item(monitor);\n        } else {\n            result = {};\n        }\n        return result !== null && result !== void 0 ? result : null;\n    }\n    canDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (typeof spec.canDrag === \"boolean\") {\n            return spec.canDrag;\n        } else if (typeof spec.canDrag === \"function\") {\n            return spec.canDrag(monitor);\n        } else {\n            return true;\n        }\n    }\n    isDragging(globalMonitor, target) {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const { isDragging } = spec;\n        return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();\n    }\n    endDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const connector = this.connector;\n        const { end } = spec;\n        if (end) {\n            end(monitor.getItem(), monitor);\n        }\n        connector.reconnect();\n    }\n    constructor(spec, monitor, connector){\n        this.spec = spec;\n        this.monitor = monitor;\n        this.connector = connector;\n    }\n}\nfunction useDragSource(spec, monitor, connector) {\n    _s14();\n    const handler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DragSourceImpl(spec, monitor, connector), [\n        monitor,\n        connector\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        handler.spec = spec;\n    }, [\n        spec\n    ]);\n    return handler;\n}\n_s14(useDragSource, \"tjtOp2Ka8CZjb6oyjbKx9eaPUoM=\");\nfunction useDragType(spec) {\n    _s15();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const result = spec.type;\n        invariant(result != null, \"spec.type must be defined\");\n        return result;\n    }, [\n        spec\n    ]);\n}\n_s15(useDragType, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction useRegisteredDragSource(spec, monitor, connector) {\n    _s16();\n    const manager = useDragDropManager();\n    const handler = useDragSource(spec, monitor, connector);\n    const itemType = useDragType(spec);\n    useIsomorphicLayoutEffect(function registerDragSource() {\n        if (itemType != null) {\n            const [handlerId, unregister] = registerSource(itemType, handler, manager);\n            monitor.receiveHandlerId(handlerId);\n            connector.receiveHandlerId(handlerId);\n            return unregister;\n        }\n        return;\n    }, [\n        manager,\n        monitor,\n        connector,\n        handler,\n        itemType\n    ]);\n}\n_s16(useRegisteredDragSource, \"MYQZVuWL165N9gIsVldBYWKjFDs=\", false, function() {\n    return [\n        useDragDropManager,\n        useDragSource,\n        useDragType,\n        useIsomorphicLayoutEffect\n    ];\n});\n/**\n * useDragSource hook\n * @param sourceSpec The drag source specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ function useDrag(specArg, deps) {\n    _s17();\n    const spec = useOptionalFactory(specArg, deps);\n    invariant(!spec.begin, \"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)\");\n    const monitor = useDragSourceMonitor();\n    const connector = useDragSourceConnector(spec.options, spec.previewOptions);\n    useRegisteredDragSource(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDragSource(connector),\n        useConnectDragPreview(connector)\n    ];\n}\n_s17(useDrag, \"pxhlF59IZeBN7/GKBe+zjkt+PnE=\", false, function() {\n    return [\n        useOptionalFactory,\n        useDragSourceMonitor,\n        useDragSourceConnector,\n        useRegisteredDragSource,\n        useCollectedProps,\n        useConnectDragSource,\n        useConnectDragPreview\n    ];\n});\n/**\n * useDragLayer Hook\n * @param collector The property collector\n */ function useDragLayer(collect) {\n    _s18();\n    const dragDropManager = useDragDropManager();\n    const monitor = dragDropManager.getMonitor();\n    const [collected, updateCollected] = useCollector(monitor, collect);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>monitor.subscribeToOffsetChange(updateCollected));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>monitor.subscribeToStateChange(updateCollected));\n    return collected;\n}\n_s18(useDragLayer, \"ePUmSxQXFagVTutlkF54S94l7z8=\", false, function() {\n    return [\n        useDragDropManager,\n        useCollector\n    ];\n});\nfunction useConnectDropTarget(connector) {\n    _s19();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dropTarget(), [\n        connector\n    ]);\n}\n_s19(useConnectDropTarget, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nfunction useDropTargetConnector(options) {\n    _s20();\n    const manager = useDragDropManager();\n    const connector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new TargetConnector(manager.getBackend()), [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dropTargetOptions = options || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDropTarget();\n    }, [\n        options\n    ]);\n    return connector;\n}\n_s20(useDropTargetConnector, \"BHuq/hGamrnYZWSevIUCWHTBENU=\", false, function() {\n    return [\n        useDragDropManager,\n        useIsomorphicLayoutEffect\n    ];\n});\nfunction useDropTargetMonitor() {\n    _s21();\n    const manager = useDragDropManager();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DropTargetMonitorImpl(manager), [\n        manager\n    ]);\n}\n_s21(useDropTargetMonitor, \"7FEphg5G3wLABgFM2+qPoIxm9ZM=\", false, function() {\n    return [\n        useDragDropManager\n    ];\n});\n/**\n * Internal utility hook to get an array-version of spec.accept.\n * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.\n * @param spec\n */ function useAccept(spec) {\n    _s22();\n    const { accept } = spec;\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        invariant(spec.accept != null, \"accept must be defined\");\n        return Array.isArray(accept) ? accept : [\n            accept\n        ];\n    }, [\n        accept\n    ]);\n}\n_s22(useAccept, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\nclass DropTargetImpl {\n    canDrop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;\n    }\n    hover() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.hover) {\n            spec.hover(monitor.getItem(), monitor);\n        }\n    }\n    drop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.drop) {\n            return spec.drop(monitor.getItem(), monitor);\n        }\n        return;\n    }\n    constructor(spec, monitor){\n        this.spec = spec;\n        this.monitor = monitor;\n    }\n}\nfunction useDropTarget(spec, monitor) {\n    _s23();\n    const dropTarget = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DropTargetImpl(spec, monitor), [\n        monitor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        dropTarget.spec = spec;\n    }, [\n        spec\n    ]);\n    return dropTarget;\n}\n_s23(useDropTarget, \"BMdq7XRlq3Z0DS1PBe1W4nZr0zg=\");\nfunction useRegisteredDropTarget(spec, monitor, connector) {\n    _s24();\n    const manager = useDragDropManager();\n    const dropTarget = useDropTarget(spec, monitor);\n    const accept = useAccept(spec);\n    useIsomorphicLayoutEffect(function registerDropTarget() {\n        const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);\n        monitor.receiveHandlerId(handlerId);\n        connector.receiveHandlerId(handlerId);\n        return unregister;\n    }, [\n        manager,\n        monitor,\n        dropTarget,\n        connector,\n        accept.map((a)=>a.toString()).join(\"|\")\n    ]);\n}\n_s24(useRegisteredDropTarget, \"GNmeYJRRELit2xyKNpJOA3cIVPY=\", false, function() {\n    return [\n        useDragDropManager,\n        useDropTarget,\n        useAccept,\n        useIsomorphicLayoutEffect\n    ];\n});\n/**\n * useDropTarget Hook\n * @param spec The drop target specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ function useDrop(specArg, deps) {\n    _s25();\n    const spec = useOptionalFactory(specArg, deps);\n    const monitor = useDropTargetMonitor();\n    const connector = useDropTargetConnector(spec.options);\n    useRegisteredDropTarget(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDropTarget(connector)\n    ];\n}\n_s25(useDrop, \"WvQADYTmdeNtorEFee92m0ayYkw=\", false, function() {\n    return [\n        useOptionalFactory,\n        useDropTargetMonitor,\n        useDropTargetConnector,\n        useRegisteredDropTarget,\n        useCollectedProps,\n        useConnectDropTarget\n    ];\n});\n// cheap lodash replacements\nfunction memoize(fn) {\n    let result = null;\n    const memoized = ()=>{\n        if (result == null) {\n            result = fn();\n        }\n        return result;\n    };\n    return memoized;\n}\n/**\n * drop-in replacement for _.without\n */ function without(items, item) {\n    return items.filter((i)=>i !== item);\n}\nfunction union(itemsA, itemsB) {\n    const set = new Set();\n    const insertItem = (item)=>set.add(item);\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    set.forEach((key)=>result.push(key));\n    return result;\n}\nclass EnterLeaveCounter {\n    enter(enteringNode) {\n        const previousLength = this.entered.length;\n        const isNodeEntered = (node)=>this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));\n        this.entered = union(this.entered.filter(isNodeEntered), [\n            enteringNode\n        ]);\n        return previousLength === 0 && this.entered.length > 0;\n    }\n    leave(leavingNode) {\n        const previousLength = this.entered.length;\n        this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);\n        return previousLength > 0 && this.entered.length === 0;\n    }\n    reset() {\n        this.entered = [];\n    }\n    constructor(isNodeInDocument){\n        this.entered = [];\n        this.isNodeInDocument = isNodeInDocument;\n    }\n}\nclass NativeDragSource {\n    initializeExposedProperties() {\n        Object.keys(this.config.exposeProperties).forEach((property)=>{\n            Object.defineProperty(this.item, property, {\n                configurable: true,\n                enumerable: true,\n                get () {\n                    // eslint-disable-next-line no-console\n                    console.warn(\"Browser doesn't allow reading \\\"\".concat(property, '\" until the drop event.'));\n                    return null;\n                }\n            });\n        });\n    }\n    loadDataTransfer(dataTransfer) {\n        if (dataTransfer) {\n            const newProperties = {};\n            Object.keys(this.config.exposeProperties).forEach((property)=>{\n                const propertyFn = this.config.exposeProperties[property];\n                if (propertyFn != null) {\n                    newProperties[property] = {\n                        value: propertyFn(dataTransfer, this.config.matchesTypes),\n                        configurable: true,\n                        enumerable: true\n                    };\n                }\n            });\n            Object.defineProperties(this.item, newProperties);\n        }\n    }\n    canDrag() {\n        return true;\n    }\n    beginDrag() {\n        return this.item;\n    }\n    isDragging(monitor, handle) {\n        return handle === monitor.getSourceId();\n    }\n    endDrag() {\n    // empty\n    }\n    constructor(config){\n        this.config = config;\n        this.item = {};\n        this.initializeExposedProperties();\n    }\n}\nconst FILE = \"__NATIVE_FILE__\";\nconst URL = \"__NATIVE_URL__\";\nconst TEXT = \"__NATIVE_TEXT__\";\nconst HTML = \"__NATIVE_HTML__\";\nvar NativeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    FILE: FILE,\n    HTML: HTML,\n    TEXT: TEXT,\n    URL: URL\n});\nfunction getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {\n    const result = typesToTry.reduce((resultSoFar, typeToTry)=>resultSoFar || dataTransfer.getData(typeToTry), \"\");\n    return result != null ? result : defaultValue;\n}\nconst nativeTypesConfig = {\n    [FILE]: {\n        exposeProperties: {\n            files: (dataTransfer)=>Array.prototype.slice.call(dataTransfer.files),\n            items: (dataTransfer)=>dataTransfer.items,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Files\"\n        ]\n    },\n    [HTML]: {\n        exposeProperties: {\n            html: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, \"\"),\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Html\",\n            \"text/html\"\n        ]\n    },\n    [URL]: {\n        exposeProperties: {\n            urls: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, \"\").split(\"\\n\"),\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Url\",\n            \"text/uri-list\"\n        ]\n    },\n    [TEXT]: {\n        exposeProperties: {\n            text: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, \"\"),\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            \"Text\",\n            \"text/plain\"\n        ]\n    }\n};\nfunction createNativeDragSource(type, dataTransfer) {\n    const config = nativeTypesConfig[type];\n    if (!config) {\n        throw new Error(\"native type \".concat(type, \" has no configuration\"));\n    }\n    const result = new NativeDragSource(config);\n    result.loadDataTransfer(dataTransfer);\n    return result;\n}\nfunction matchNativeItemType(dataTransfer) {\n    if (!dataTransfer) {\n        return null;\n    }\n    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);\n    return Object.keys(nativeTypesConfig).filter((nativeItemType)=>{\n        const typeConfig = nativeTypesConfig[nativeItemType];\n        if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {\n            return false;\n        }\n        return typeConfig.matchesTypes.some((t)=>dataTransferTypes.indexOf(t) > -1);\n    })[0] || null;\n}\nconst isFirefox = memoize(()=>/firefox/i.test(navigator.userAgent));\nconst isSafari = memoize(()=>Boolean(window.safari));\nclass MonotonicInterpolant {\n    interpolate(x) {\n        const { xs, ys, c1s, c2s, c3s } = this;\n        // The rightmost point in the dataset should give an exact result\n        let i = xs.length - 1;\n        if (x === xs[i]) {\n            return ys[i];\n        }\n        // Search for the interval x is in, returning the corresponding y if x is one of the original xs\n        let low = 0;\n        let high = c3s.length - 1;\n        let mid;\n        while(low <= high){\n            mid = Math.floor(0.5 * (low + high));\n            const xHere = xs[mid];\n            if (xHere < x) {\n                low = mid + 1;\n            } else if (xHere > x) {\n                high = mid - 1;\n            } else {\n                return ys[mid];\n            }\n        }\n        i = Math.max(0, high);\n        // Interpolate\n        const diff = x - xs[i];\n        const diffSq = diff * diff;\n        return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;\n    }\n    constructor(xs, ys){\n        const { length } = xs;\n        // Rearrange xs and ys so that xs is sorted\n        const indexes = [];\n        for(let i = 0; i < length; i++){\n            indexes.push(i);\n        }\n        indexes.sort((a, b)=>xs[a] < xs[b] ? -1 : 1);\n        const dxs = [];\n        const ms = [];\n        let dx;\n        let dy;\n        for(let i1 = 0; i1 < length - 1; i1++){\n            dx = xs[i1 + 1] - xs[i1];\n            dy = ys[i1 + 1] - ys[i1];\n            dxs.push(dx);\n            ms.push(dy / dx);\n        }\n        // Get degree-1 coefficients\n        const c1s = [\n            ms[0]\n        ];\n        for(let i2 = 0; i2 < dxs.length - 1; i2++){\n            const m2 = ms[i2];\n            const mNext = ms[i2 + 1];\n            if (m2 * mNext <= 0) {\n                c1s.push(0);\n            } else {\n                dx = dxs[i2];\n                const dxNext = dxs[i2 + 1];\n                const common = dx + dxNext;\n                c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));\n            }\n        }\n        c1s.push(ms[ms.length - 1]);\n        // Get degree-2 and degree-3 coefficients\n        const c2s = [];\n        const c3s = [];\n        let m;\n        for(let i3 = 0; i3 < c1s.length - 1; i3++){\n            m = ms[i3];\n            const c1 = c1s[i3];\n            const invDx = 1 / dxs[i3];\n            const common = c1 + c1s[i3 + 1] - m - m;\n            c2s.push((m - c1 - common) * invDx);\n            c3s.push(common * invDx * invDx);\n        }\n        this.xs = xs;\n        this.ys = ys;\n        this.c1s = c1s;\n        this.c2s = c2s;\n        this.c3s = c3s;\n    }\n}\nconst ELEMENT_NODE$1 = 1;\nfunction getNodeClientOffset$1(node) {\n    const el = node.nodeType === ELEMENT_NODE$1 ? node : node.parentElement;\n    if (!el) {\n        return null;\n    }\n    const { top, left } = el.getBoundingClientRect();\n    return {\n        x: left,\n        y: top\n    };\n}\nfunction getEventClientOffset$1(e) {\n    return {\n        x: e.clientX,\n        y: e.clientY\n    };\n}\nfunction isImageNode(node) {\n    var ref;\n    return node.nodeName === \"IMG\" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n    // Work around @2x coordinate discrepancies in browsers\n    if (isSafari() && isImage) {\n        dragPreviewHeight /= window.devicePixelRatio;\n        dragPreviewWidth /= window.devicePixelRatio;\n    }\n    return {\n        dragPreviewWidth,\n        dragPreviewHeight\n    };\n}\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n    // The browsers will use the image intrinsic size under different conditions.\n    // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n    const isImage = isImageNode(dragPreview);\n    const dragPreviewNode = isImage ? sourceNode : dragPreview;\n    const dragPreviewNodeOffsetFromClient = getNodeClientOffset$1(dragPreviewNode);\n    const offsetFromDragPreview = {\n        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n    };\n    const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;\n    const { anchorX, anchorY } = anchorPoint;\n    const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);\n    const calculateYOffset = ()=>{\n        const interpolantY = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the top\n            offsetFromDragPreview.y,\n            // Align at the center\n            offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,\n            // Dock to the bottom\n            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight\n        ]);\n        let y = interpolantY.interpolate(anchorY);\n        // Work around Safari 8 positioning bug\n        if (isSafari() && isImage) {\n            // We'll have to wait for @3x to see if this is entirely correct\n            y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n        }\n        return y;\n    };\n    const calculateXOffset = ()=>{\n        // Interpolate coordinates depending on anchor point\n        // If you know a simpler way to do this, let me know\n        const interpolantX = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the left\n            offsetFromDragPreview.x,\n            // Align at the center\n            offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,\n            // Dock to the right\n            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth\n        ]);\n        return interpolantX.interpolate(anchorX);\n    };\n    // Force offsets if specified in the options.\n    const { offsetX, offsetY } = offsetPoint;\n    const isManualOffsetX = offsetX === 0 || offsetX;\n    const isManualOffsetY = offsetY === 0 || offsetY;\n    return {\n        x: isManualOffsetX ? offsetX : calculateXOffset(),\n        y: isManualOffsetY ? offsetY : calculateYOffset()\n    };\n}\nlet OptionsReader$1 = class OptionsReader {\n    get window() {\n        if (this.globalContext) {\n            return this.globalContext;\n        } else if (true) {\n            return window;\n        }\n        return undefined;\n    }\n    get document() {\n        var ref;\n        if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {\n            return this.globalContext.document;\n        } else if (this.window) {\n            return this.window.document;\n        } else {\n            return undefined;\n        }\n    }\n    get rootElement() {\n        var ref;\n        return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;\n    }\n    constructor(globalContext, options){\n        this.ownerDocument = null;\n        this.globalContext = globalContext;\n        this.optionsArgs = options;\n    }\n};\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nclass HTML5BackendImpl {\n    /**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */ profile() {\n        var ref, ref1;\n        return {\n            sourcePreviewNodes: this.sourcePreviewNodes.size,\n            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n            sourceNodeOptions: this.sourceNodeOptions.size,\n            sourceNodes: this.sourceNodes.size,\n            dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,\n            dropTargetIds: this.dropTargetIds.length,\n            dragEnterTargetIds: this.dragEnterTargetIds.length,\n            dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0\n        };\n    }\n    // public for test\n    get window() {\n        return this.options.window;\n    }\n    get document() {\n        return this.options.document;\n    }\n    /**\n\t * Get the root element to use for event subscriptions\n\t */ get rootElement() {\n        return this.options.rootElement;\n    }\n    setup() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        if (root.__isReactDndBackendSetUp) {\n            throw new Error(\"Cannot have two HTML5 backends at the same time.\");\n        }\n        root.__isReactDndBackendSetUp = true;\n        this.addEventListeners(root);\n    }\n    teardown() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        root.__isReactDndBackendSetUp = false;\n        this.removeEventListeners(this.rootElement);\n        this.clearCurrentDragSourceNode();\n        if (this.asyncEndDragFrameId) {\n            var ref;\n            (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);\n        }\n    }\n    connectDragPreview(sourceId, node, options) {\n        this.sourcePreviewNodeOptions.set(sourceId, options);\n        this.sourcePreviewNodes.set(sourceId, node);\n        return ()=>{\n            this.sourcePreviewNodes.delete(sourceId);\n            this.sourcePreviewNodeOptions.delete(sourceId);\n        };\n    }\n    connectDragSource(sourceId, node, options) {\n        this.sourceNodes.set(sourceId, node);\n        this.sourceNodeOptions.set(sourceId, options);\n        const handleDragStart = (e)=>this.handleDragStart(e, sourceId);\n        const handleSelectStart = (e)=>this.handleSelectStart(e);\n        node.setAttribute(\"draggable\", \"true\");\n        node.addEventListener(\"dragstart\", handleDragStart);\n        node.addEventListener(\"selectstart\", handleSelectStart);\n        return ()=>{\n            this.sourceNodes.delete(sourceId);\n            this.sourceNodeOptions.delete(sourceId);\n            node.removeEventListener(\"dragstart\", handleDragStart);\n            node.removeEventListener(\"selectstart\", handleSelectStart);\n            node.setAttribute(\"draggable\", \"false\");\n        };\n    }\n    connectDropTarget(targetId, node) {\n        const handleDragEnter = (e)=>this.handleDragEnter(e, targetId);\n        const handleDragOver = (e)=>this.handleDragOver(e, targetId);\n        const handleDrop = (e)=>this.handleDrop(e, targetId);\n        node.addEventListener(\"dragenter\", handleDragEnter);\n        node.addEventListener(\"dragover\", handleDragOver);\n        node.addEventListener(\"drop\", handleDrop);\n        return ()=>{\n            node.removeEventListener(\"dragenter\", handleDragEnter);\n            node.removeEventListener(\"dragover\", handleDragOver);\n            node.removeEventListener(\"drop\", handleDrop);\n        };\n    }\n    addEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.addEventListener) {\n            return;\n        }\n        target.addEventListener(\"dragstart\", this.handleTopDragStart);\n        target.addEventListener(\"dragstart\", this.handleTopDragStartCapture, true);\n        target.addEventListener(\"dragend\", this.handleTopDragEndCapture, true);\n        target.addEventListener(\"dragenter\", this.handleTopDragEnter);\n        target.addEventListener(\"dragenter\", this.handleTopDragEnterCapture, true);\n        target.addEventListener(\"dragleave\", this.handleTopDragLeaveCapture, true);\n        target.addEventListener(\"dragover\", this.handleTopDragOver);\n        target.addEventListener(\"dragover\", this.handleTopDragOverCapture, true);\n        target.addEventListener(\"drop\", this.handleTopDrop);\n        target.addEventListener(\"drop\", this.handleTopDropCapture, true);\n    }\n    removeEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.removeEventListener) {\n            return;\n        }\n        target.removeEventListener(\"dragstart\", this.handleTopDragStart);\n        target.removeEventListener(\"dragstart\", this.handleTopDragStartCapture, true);\n        target.removeEventListener(\"dragend\", this.handleTopDragEndCapture, true);\n        target.removeEventListener(\"dragenter\", this.handleTopDragEnter);\n        target.removeEventListener(\"dragenter\", this.handleTopDragEnterCapture, true);\n        target.removeEventListener(\"dragleave\", this.handleTopDragLeaveCapture, true);\n        target.removeEventListener(\"dragover\", this.handleTopDragOver);\n        target.removeEventListener(\"dragover\", this.handleTopDragOverCapture, true);\n        target.removeEventListener(\"drop\", this.handleTopDrop);\n        target.removeEventListener(\"drop\", this.handleTopDropCapture, true);\n    }\n    getCurrentSourceNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);\n        return _objectSpread({\n            dropEffect: this.altKeyPressed ? \"copy\" : \"move\"\n        }, sourceNodeOptions || {});\n    }\n    getCurrentDropEffect() {\n        if (this.isDraggingNativeItem()) {\n            // It makes more sense to default to 'copy' for native resources\n            return \"copy\";\n        }\n        return this.getCurrentSourceNodeOptions().dropEffect;\n    }\n    getCurrentSourcePreviewNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);\n        return _objectSpread({\n            anchorX: 0.5,\n            anchorY: 0.5,\n            captureDraggingState: false\n        }, sourcePreviewNodeOptions || {});\n    }\n    isDraggingNativeItem() {\n        const itemType = this.monitor.getItemType();\n        return Object.keys(NativeTypes).some((key)=>NativeTypes[key] === itemType);\n    }\n    beginDragNativeItem(type, dataTransfer) {\n        this.clearCurrentDragSourceNode();\n        this.currentNativeSource = createNativeDragSource(type, dataTransfer);\n        this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);\n        this.actions.beginDrag([\n            this.currentNativeHandle\n        ]);\n    }\n    setCurrentDragSourceNode(node) {\n        this.clearCurrentDragSourceNode();\n        this.currentDragSourceNode = node;\n        // A timeout of > 0 is necessary to resolve Firefox issue referenced\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        const MOUSE_MOVE_TIMEOUT = 1000;\n        // Receiving a mouse event in the middle of a dragging operation\n        // means it has ended and the drag source node disappeared from DOM,\n        // so the browser didn't dispatch the dragend event.\n        //\n        // We need to wait before we start listening for mousemove events.\n        // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event\n        // immediately in some browsers.\n        //\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        //\n        this.mouseMoveTimeoutTimer = setTimeout(()=>{\n            var ref;\n            return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener(\"mousemove\", this.endDragIfSourceWasRemovedFromDOM, true);\n        }, MOUSE_MOVE_TIMEOUT);\n    }\n    clearCurrentDragSourceNode() {\n        if (this.currentDragSourceNode) {\n            this.currentDragSourceNode = null;\n            if (this.rootElement) {\n                var ref;\n                (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);\n                this.rootElement.removeEventListener(\"mousemove\", this.endDragIfSourceWasRemovedFromDOM, true);\n            }\n            this.mouseMoveTimeoutTimer = null;\n            return true;\n        }\n        return false;\n    }\n    handleDragStart(e, sourceId) {\n        if (e.defaultPrevented) {\n            return;\n        }\n        if (!this.dragStartSourceIds) {\n            this.dragStartSourceIds = [];\n        }\n        this.dragStartSourceIds.unshift(sourceId);\n    }\n    handleDragEnter(_e, targetId) {\n        this.dragEnterTargetIds.unshift(targetId);\n    }\n    handleDragOver(_e, targetId) {\n        if (this.dragOverTargetIds === null) {\n            this.dragOverTargetIds = [];\n        }\n        this.dragOverTargetIds.unshift(targetId);\n    }\n    handleDrop(_e, targetId) {\n        this.dropTargetIds.unshift(targetId);\n    }\n    constructor(manager, globalContext, options){\n        this.sourcePreviewNodes = new Map();\n        this.sourcePreviewNodeOptions = new Map();\n        this.sourceNodes = new Map();\n        this.sourceNodeOptions = new Map();\n        this.dragStartSourceIds = null;\n        this.dropTargetIds = [];\n        this.dragEnterTargetIds = [];\n        this.currentNativeSource = null;\n        this.currentNativeHandle = null;\n        this.currentDragSourceNode = null;\n        this.altKeyPressed = false;\n        this.mouseMoveTimeoutTimer = null;\n        this.asyncEndDragFrameId = null;\n        this.dragOverTargetIds = null;\n        this.lastClientOffset = null;\n        this.hoverRafId = null;\n        this.getSourceClientOffset = (sourceId)=>{\n            const source = this.sourceNodes.get(sourceId);\n            return source && getNodeClientOffset$1(source) || null;\n        };\n        this.endDragNativeItem = ()=>{\n            if (!this.isDraggingNativeItem()) {\n                return;\n            }\n            this.actions.endDrag();\n            if (this.currentNativeHandle) {\n                this.registry.removeSource(this.currentNativeHandle);\n            }\n            this.currentNativeHandle = null;\n            this.currentNativeSource = null;\n        };\n        this.isNodeInDocument = (node)=>{\n            // Check the node either in the main document or in the current context\n            return Boolean(node && this.document && this.document.body && this.document.body.contains(node));\n        };\n        this.endDragIfSourceWasRemovedFromDOM = ()=>{\n            const node = this.currentDragSourceNode;\n            if (node == null || this.isNodeInDocument(node)) {\n                return;\n            }\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.scheduleHover = (dragOverTargetIds)=>{\n            if (this.hoverRafId === null && typeof requestAnimationFrame !== \"undefined\") {\n                this.hoverRafId = requestAnimationFrame(()=>{\n                    if (this.monitor.isDragging()) {\n                        this.actions.hover(dragOverTargetIds || [], {\n                            clientOffset: this.lastClientOffset\n                        });\n                    }\n                    this.hoverRafId = null;\n                });\n            }\n        };\n        this.cancelHover = ()=>{\n            if (this.hoverRafId !== null && typeof cancelAnimationFrame !== \"undefined\") {\n                cancelAnimationFrame(this.hoverRafId);\n                this.hoverRafId = null;\n            }\n        };\n        this.handleTopDragStartCapture = ()=>{\n            this.clearCurrentDragSourceNode();\n            this.dragStartSourceIds = [];\n        };\n        this.handleTopDragStart = (e)=>{\n            if (e.defaultPrevented) {\n                return;\n            }\n            const { dragStartSourceIds } = this;\n            this.dragStartSourceIds = null;\n            const clientOffset = getEventClientOffset$1(e);\n            // Avoid crashing if we missed a drop event or our previous drag died\n            if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n                this.cancelHover();\n            }\n            // Don't publish the source just yet (see why below)\n            this.actions.beginDrag(dragStartSourceIds || [], {\n                publishSource: false,\n                getSourceClientOffset: this.getSourceClientOffset,\n                clientOffset\n            });\n            const { dataTransfer } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (this.monitor.isDragging()) {\n                if (dataTransfer && typeof dataTransfer.setDragImage === \"function\") {\n                    // Use custom drag image if user specifies it.\n                    // If child drag source refuses drag but parent agrees,\n                    // use parent's node as drag image. Neither works in IE though.\n                    const sourceId = this.monitor.getSourceId();\n                    const sourceNode = this.sourceNodes.get(sourceId);\n                    const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;\n                    if (dragPreview) {\n                        const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();\n                        const anchorPoint = {\n                            anchorX,\n                            anchorY\n                        };\n                        const offsetPoint = {\n                            offsetX,\n                            offsetY\n                        };\n                        const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);\n                        dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);\n                    }\n                }\n                try {\n                    // Firefox won't drag without setting data\n                    dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData(\"application/json\", {});\n                } catch (err) {\n                // IE doesn't support MIME types in setData\n                }\n                // Store drag source node so we can check whether\n                // it is removed from DOM and trigger endDrag manually.\n                this.setCurrentDragSourceNode(e.target);\n                // Now we are ready to publish the drag source.. or are we not?\n                const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();\n                if (!captureDraggingState) {\n                    // Usually we want to publish it in the next tick so that browser\n                    // is able to screenshot the current (not yet dragging) state.\n                    //\n                    // It also neatly avoids a situation where render() returns null\n                    // in the same tick for the source element, and browser freaks out.\n                    setTimeout(()=>this.actions.publishDragSource(), 0);\n                } else {\n                    // In some cases the user may want to override this behavior, e.g.\n                    // to work around IE not supporting custom drag previews.\n                    //\n                    // When using a custom drag layer, the only way to prevent\n                    // the default drag preview from drawing in IE is to screenshot\n                    // the dragging state in which the node itself has zero opacity\n                    // and height. In this case, though, returning null from render()\n                    // will abruptly end the dragging, which is not obvious.\n                    //\n                    // This is the reason such behavior is strictly opt-in.\n                    this.actions.publishDragSource();\n                }\n            } else if (nativeType) {\n                // A native item (such as URL) dragged from inside the document\n                this.beginDragNativeItem(nativeType);\n            } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute(\"draggable\"))) {\n                // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.\n                // Just let it drag. It's a native type (URL or text) and will be picked up in\n                // dragenter handler.\n                return;\n            } else {\n                // If by this time no drag source reacted, tell browser not to drag.\n                e.preventDefault();\n            }\n        };\n        this.handleTopDragEndCapture = ()=>{\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                // Firefox can dispatch this event in an infinite loop\n                // if dragend handler does something like showing an alert.\n                // Only proceed if we have not handled it already.\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleTopDragEnterCapture = (e)=>{\n            this.dragEnterTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n            const isFirstEnter = this.enterLeaveCounter.enter(e.target);\n            if (!isFirstEnter || this.monitor.isDragging()) {\n                return;\n            }\n            const { dataTransfer } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (nativeType) {\n                // A native item (such as file or URL) dragged from outside the document\n                this.beginDragNativeItem(nativeType, dataTransfer);\n            }\n        };\n        this.handleTopDragEnter = (e)=>{\n            const { dragEnterTargetIds } = this;\n            this.dragEnterTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            // If the target changes position as the result of `dragenter`, `dragover` might still\n            // get dispatched despite target being no longer there. The easy solution is to check\n            // whether there actually is a target before firing `hover`.\n            if (dragEnterTargetIds.length > 0) {\n                this.actions.hover(dragEnterTargetIds, {\n                    clientOffset: getEventClientOffset$1(e)\n                });\n            }\n            const canDrop = dragEnterTargetIds.some((targetId)=>this.monitor.canDropOnTarget(targetId));\n            if (canDrop) {\n                // IE requires this to fire dragover events\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            }\n        };\n        this.handleTopDragOverCapture = (e)=>{\n            this.dragOverTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n        };\n        this.handleTopDragOver = (e)=>{\n            const { dragOverTargetIds } = this;\n            this.dragOverTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                // Prevent default \"drop and blow away the whole document\" action.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = \"none\";\n                }\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            this.lastClientOffset = getEventClientOffset$1(e);\n            this.scheduleHover(dragOverTargetIds);\n            const canDrop = (dragOverTargetIds || []).some((targetId)=>this.monitor.canDropOnTarget(targetId));\n            if (canDrop) {\n                // Show user-specified drop effect.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            } else if (this.isDraggingNativeItem()) {\n                // Don't show a nice cursor but still prevent default\n                // \"drop and blow away the whole document\" action.\n                e.preventDefault();\n            } else {\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = \"none\";\n                }\n            }\n        };\n        this.handleTopDragLeaveCapture = (e)=>{\n            if (this.isDraggingNativeItem()) {\n                e.preventDefault();\n            }\n            const isLastLeave = this.enterLeaveCounter.leave(e.target);\n            if (!isLastLeave) {\n                return;\n            }\n            if (this.isDraggingNativeItem()) {\n                setTimeout(()=>this.endDragNativeItem(), 0);\n            }\n            this.cancelHover();\n        };\n        this.handleTopDropCapture = (e)=>{\n            this.dropTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                e.preventDefault();\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            } else if (matchNativeItemType(e.dataTransfer)) {\n                // Dragging some elements, like <a> and <img> may still behave like a native drag event,\n                // even if the current drag event matches a user-defined type.\n                // Stop the default behavior when we're not expecting a native item to be dropped.\n                e.preventDefault();\n            }\n            this.enterLeaveCounter.reset();\n        };\n        this.handleTopDrop = (e)=>{\n            const { dropTargetIds } = this;\n            this.dropTargetIds = [];\n            this.actions.hover(dropTargetIds, {\n                clientOffset: getEventClientOffset$1(e)\n            });\n            this.actions.drop({\n                dropEffect: this.getCurrentDropEffect()\n            });\n            if (this.isDraggingNativeItem()) {\n                this.endDragNativeItem();\n            } else if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleSelectStart = (e)=>{\n            const target = e.target;\n            // Only IE requires us to explicitly say\n            // we want drag drop operation to start\n            if (typeof target.dragDrop !== \"function\") {\n                return;\n            }\n            // Inputs and textareas should be selectable\n            if (target.tagName === \"INPUT\" || target.tagName === \"SELECT\" || target.tagName === \"TEXTAREA\" || target.isContentEditable) {\n                return;\n            }\n            // For other targets, ask IE\n            // to enable drag and drop\n            e.preventDefault();\n            target.dragDrop();\n        };\n        this.options = new OptionsReader$1(globalContext, options);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.registry = manager.getRegistry();\n        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);\n    }\n}\nlet emptyImage;\nfunction getEmptyImage() {\n    if (!emptyImage) {\n        emptyImage = new Image();\n        emptyImage.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    }\n    return emptyImage;\n}\nconst HTML5Backend = function createBackend(manager, context, options) {\n    return new HTML5BackendImpl(manager, context, options);\n};\n_c3 = HTML5Backend;\nfunction Piece(param) {\n    let { isPremovedPiece = false, piece, square, squares } = param;\n    _s26();\n    const { animationDuration, arePiecesDraggable, boardWidth, boardOrientation, chessPieces, currentPosition, deletePieceFromSquare, dropOffBoardAction, id, isDraggablePiece, isWaitingForAnimation, onPieceClick, onPieceDragBegin, onPieceDragEnd, onPieceDropOffBoard, onPromotionCheck, positionDifferences } = useChessboard();\n    const [pieceStyle, setPieceStyle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        opacity: 1,\n        zIndex: 5,\n        touchAction: \"none\",\n        cursor: arePiecesDraggable && isDraggablePiece({\n            piece,\n            sourceSquare: square\n        }) ? \"-webkit-grab\" : \"default\"\n    });\n    const [{ canDrag, isDragging }, drag, dragPreview] = useDrag(()=>({\n            type: \"piece\",\n            item: ()=>{\n                onPieceDragBegin(piece, square);\n                return {\n                    piece,\n                    square,\n                    id\n                };\n            },\n            end: (item, monitor)=>{\n                onPieceDragEnd(piece, square);\n                const wasDropOutsideTheBoard = !monitor.didDrop();\n                if (wasDropOutsideTheBoard) {\n                    if (dropOffBoardAction === \"trash\") {\n                        deletePieceFromSquare(square);\n                    }\n                    onPieceDropOffBoard === null || onPieceDropOffBoard === void 0 ? void 0 : onPieceDropOffBoard(square, piece);\n                }\n            },\n            collect: (monitor)=>({\n                    canDrag: isDraggablePiece({\n                        piece,\n                        sourceSquare: square\n                    }),\n                    isDragging: !!monitor.isDragging()\n                })\n        }), [\n        piece,\n        square,\n        currentPosition,\n        id\n    ]);\n    // hide the default preview\n    dragPreview(getEmptyImage(), {\n        captureDraggingState: true\n    });\n    // hide piece on drag\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                opacity: isDragging ? 0 : 1\n            }));\n    }, [\n        isDragging\n    ]);\n    // new move has come in\n    // if waiting for animation, then animation has started and we can perform animation\n    // we need to head towards where we need to go, we are the source, we are heading towards the target\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _a;\n        const removedPiece = (_a = positionDifferences.removed) === null || _a === void 0 ? void 0 : _a[square];\n        // return as null and not loaded yet\n        if (!positionDifferences.added || !removedPiece) return;\n        // check if piece matches or if removed piece was a pawn and new square is on 1st or 8th rank (promotion)\n        const newSquare = Object.entries(positionDifferences.added).find((param)=>{\n            let [s, p] = param;\n            return p === removedPiece || onPromotionCheck(square, s, removedPiece);\n        });\n        // we can perform animation if our square was in removed, AND the matching piece is in added AND this isn't a premoved piece\n        if (isWaitingForAnimation && removedPiece && newSquare && !isPremovedPiece) {\n            const sourceSq = square;\n            const targetSq = newSquare[0];\n            if (sourceSq && targetSq) {\n                const squareWidth = boardWidth / 8;\n                setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                        transform: \"translate(\".concat((boardOrientation === \"black\" ? -1 : 1) * (targetSq.charCodeAt(0) - sourceSq.charCodeAt(0)) * squareWidth, \"px, \").concat((boardOrientation === \"black\" ? -1 : 1) * (Number(sourceSq[1]) - Number(targetSq[1])) * squareWidth, \"px)\"),\n                        transition: \"transform \".concat(animationDuration, \"ms\"),\n                        zIndex: 6\n                    }));\n            }\n        }\n    }, [\n        positionDifferences\n    ]);\n    // translate to their own positions (repaint on undo)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { sourceSq } = getSingleSquareCoordinates();\n        if (sourceSq) {\n            setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                    transform: \"translate(\".concat(0, \"px, \", 0, \"px)\"),\n                    transition: \"transform \".concat(0, \"ms\")\n                }));\n        }\n    }, [\n        currentPosition\n    ]);\n    // update is piece draggable\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setPieceStyle((oldPieceStyle)=>Object.assign(Object.assign({}, oldPieceStyle), {\n                cursor: arePiecesDraggable && isDraggablePiece({\n                    piece,\n                    sourceSquare: square\n                }) ? \"-webkit-grab\" : \"default\"\n            }));\n    }, [\n        square,\n        currentPosition,\n        arePiecesDraggable\n    ]);\n    function getSingleSquareCoordinates() {\n        return {\n            sourceSq: squares[square]\n        };\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        ref: arePiecesDraggable && canDrag ? drag : null,\n        onClick: ()=>onPieceClick(piece, square),\n        \"data-piece\": piece,\n        style: pieceStyle\n    }, {\n        children: typeof chessPieces[piece] === \"function\" ? chessPieces[piece]({\n            squareWidth: boardWidth / 8,\n            isDragging,\n            square\n        }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n            viewBox: \"1 1 43 43\",\n            width: boardWidth / 8,\n            height: boardWidth / 8,\n            style: {\n                display: \"block\"\n            }\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                children: chessPieces[piece]\n            })\n        }))\n    }));\n}\n_s26(Piece, \"0RS4MI6zYW3klk3Ul088RU7hMJ0=\", false, function() {\n    return [\n        useChessboard,\n        useDrag\n    ];\n});\n_c4 = Piece;\nfunction Square(param) {\n    let { square, squareColor, setSquares, squareHasPremove, children } = param;\n    _s27();\n    const squareRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { autoPromoteToQueen, boardWidth, boardOrientation, clearArrows, currentPosition, currentRightClickDown, customBoardStyle, customDarkSquareStyle, customDropSquareStyle, customLightSquareStyle, customPremoveDarkSquareStyle, customPremoveLightSquareStyle, customSquare: CustomSquare, customSquareStyles, drawNewArrow, handleSetPosition, handleSparePieceDrop, isWaitingForAnimation, lastPieceColour, lastSquareDraggedOver, onArrowDrawEnd, onDragOverSquare, onMouseOutSquare, onMouseOverSquare, onPieceDrop, onPromotionCheck, onRightClickDown, onRightClickUp, onSquareClick, setLastSquareDraggedOver, setPromoteFromSquare, setPromoteToSquare, setShowPromoteDialog } = useChessboard();\n    const [{ isOver }, drop] = useDrop(()=>({\n            accept: \"piece\",\n            drop: handleDrop,\n            collect: (monitor)=>({\n                    isOver: !!monitor.isOver()\n                })\n        }), [\n        square,\n        currentPosition,\n        onPieceDrop,\n        isWaitingForAnimation,\n        lastPieceColour\n    ]);\n    function handleDrop(item) {\n        if (item.isSpare) {\n            handleSparePieceDrop(item.piece, square);\n            return;\n        }\n        if (onPromotionCheck(item.square, square, item.piece)) {\n            if (autoPromoteToQueen) {\n                handleSetPosition(item.square, square, item.piece[0] === \"w\" ? \"wQ\" : \"bQ\");\n            } else {\n                setPromoteFromSquare(item.square);\n                setPromoteToSquare(square);\n                setShowPromoteDialog(true);\n            }\n        } else {\n            handleSetPosition(item.square, square, item.piece, true);\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (squareRef.current) {\n            const { x, y } = squareRef.current.getBoundingClientRect();\n            setSquares((oldSquares)=>Object.assign(Object.assign({}, oldSquares), {\n                    [square]: {\n                        x,\n                        y\n                    }\n                }));\n        }\n    }, [\n        boardWidth,\n        boardOrientation\n    ]);\n    const defaultSquareStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, borderRadius(square, boardOrientation, customBoardStyle)), squareColor === \"black\" ? customDarkSquareStyle : customLightSquareStyle), squareHasPremove && (squareColor === \"black\" ? customPremoveDarkSquareStyle : customPremoveLightSquareStyle)), isOver && customDropSquareStyle);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        ref: drop,\n        style: defaultSquareStyle,\n        \"data-square-color\": squareColor,\n        \"data-square\": square,\n        onTouchMove: (e)=>{\n            var _a;\n            // Handle touch events on tablet and mobile not covered by onMouseOver/onDragEnter\n            const touchLocation = e.touches[0];\n            const touchElement = document.elementsFromPoint(touchLocation.clientX, touchLocation.clientY);\n            const draggedOverSquare = (_a = touchElement === null || touchElement === void 0 ? void 0 : touchElement.find((el)=>el.getAttribute(\"data-square\"))) === null || _a === void 0 ? void 0 : _a.getAttribute(\"data-square\");\n            if (draggedOverSquare && draggedOverSquare !== lastSquareDraggedOver) {\n                setLastSquareDraggedOver(draggedOverSquare);\n                onDragOverSquare(draggedOverSquare);\n            }\n        },\n        onMouseOver: (e)=>{\n            // noop if moving from child of square into square.\n            if (e.buttons === 2 && currentRightClickDown) {\n                drawNewArrow(currentRightClickDown, square);\n            }\n            if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) {\n                return;\n            }\n            onMouseOverSquare(square);\n        },\n        onMouseOut: (e)=>{\n            // noop if moving from square into a child of square.\n            if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) return;\n            onMouseOutSquare(square);\n        },\n        onMouseDown: (e)=>{\n            if (e.button === 2) onRightClickDown(square);\n        },\n        onMouseUp: (e)=>{\n            if (e.button === 2) {\n                if (currentRightClickDown) onArrowDrawEnd(currentRightClickDown, square);\n                onRightClickUp(square);\n            }\n        },\n        onDragEnter: ()=>onDragOverSquare(square),\n        onClick: ()=>{\n            const piece = currentPosition[square];\n            onSquareClick(square, piece);\n            clearArrows();\n        },\n        onContextMenu: (e)=>{\n            e.preventDefault();\n        }\n    }, {\n        children: typeof CustomSquare === \"string\" ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomSquare, Object.assign({\n            // Type is too complex to properly evaluate, so ignore this line.\n            // @ts-ignore\n            ref: squareRef,\n            style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), !squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square]))\n        }, {\n            children: children\n        })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomSquare, Object.assign({\n            ref: squareRef,\n            square: square,\n            squareColor: squareColor,\n            style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), !squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square]))\n        }, {\n            children: children\n        }))\n    }));\n}\n_s27(Square, \"HlsEkfvQxzG+oacNb6vv3lt3jvM=\", false, function() {\n    return [\n        useChessboard,\n        useDrop\n    ];\n});\n_c5 = Square;\nconst center = {\n    display: \"flex\",\n    justifyContent: \"center\"\n};\nconst size = (width)=>({\n        width: width / 8,\n        height: width / 8\n    });\nconst borderRadius = (square, boardOrientation, customBoardStyle)=>{\n    if (!(customBoardStyle === null || customBoardStyle === void 0 ? void 0 : customBoardStyle.borderRadius)) return {};\n    if (square === \"a1\") {\n        return boardOrientation === \"white\" ? {\n            borderBottomLeftRadius: customBoardStyle.borderRadius\n        } : {\n            borderTopRightRadius: customBoardStyle.borderRadius\n        };\n    }\n    if (square === \"a8\") {\n        return boardOrientation === \"white\" ? {\n            borderTopLeftRadius: customBoardStyle.borderRadius\n        } : {\n            borderBottomRightRadius: customBoardStyle.borderRadius\n        };\n    }\n    if (square === \"h1\") {\n        return boardOrientation === \"white\" ? {\n            borderBottomRightRadius: customBoardStyle.borderRadius\n        } : {\n            borderTopLeftRadius: customBoardStyle.borderRadius\n        };\n    }\n    if (square === \"h8\") {\n        return boardOrientation === \"white\" ? {\n            borderTopRightRadius: customBoardStyle.borderRadius\n        } : {\n            borderBottomLeftRadius: customBoardStyle.borderRadius\n        };\n    }\n    return {};\n};\nfunction Squares() {\n    _s28();\n    const [squares, setSquares] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const { arePremovesAllowed, boardOrientation, boardWidth, currentPosition, id, premoves, showBoardNotation } = useChessboard();\n    const premovesHistory = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const result = [];\n        // if premoves aren't allowed, don't waste time on calculations\n        if (!arePremovesAllowed) return [];\n        premoves.forEach((premove, index)=>{\n            const { sourceSq, targetSq, piece } = premove;\n            // determine if the premove is made by an already premoved piece\n            const relatedPremovedPiece = result.find((p)=>{\n                var _a;\n                return p.piece === piece && ((_a = p.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === sourceSq;\n            });\n            // if premove has been made by already premoved piece then write the move to its `premovesRoute` field to be able find its final destination later\n            if (relatedPremovedPiece) {\n                relatedPremovedPiece.premovesRoute.push({\n                    sourceSq,\n                    targetSq,\n                    index\n                });\n            } else {\n                result.push({\n                    piece,\n                    // index is useful for scenarios where two or more pieces are targeting the same square\n                    premovesRoute: [\n                        {\n                            sourceSq,\n                            targetSq,\n                            index\n                        }\n                    ]\n                });\n            }\n        });\n        return result;\n    }, [\n        premoves\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        \"data-boardid\": id\n    }, {\n        children: [\n            ...Array(8)\n        ].map((_, r)=>{\n            return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                style: {\n                    display: \"flex\",\n                    flexWrap: \"nowrap\",\n                    width: boardWidth\n                }\n            }, {\n                children: [\n                    ...Array(8)\n                ].map((_, c)=>{\n                    const square = boardOrientation === \"black\" ? COLUMNS[7 - c] + (r + 1) : COLUMNS[c] + (8 - r);\n                    const squareColor = c % 2 === r % 2 ? \"white\" : \"black\";\n                    const squareHasPremove = premoves.find((p)=>p.sourceSq === square || p.targetSq === square);\n                    const squareHasPremoveTarget = premovesHistory.filter((param)=>{\n                        let { premovesRoute } = param;\n                        var _a;\n                        return ((_a = premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === square;\n                    })//the premoved piece with the higher index will be shown, as it is the latest one\n                    .sort((a, b)=>{\n                        var _a, _b;\n                        return ((_a = b.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.index) - ((_b = a.premovesRoute.at(-1)) === null || _b === void 0 ? void 0 : _b.index);\n                    }).at(0);\n                    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Square, Object.assign({\n                        square: square,\n                        squareColor: squareColor,\n                        setSquares: setSquares,\n                        squareHasPremove: !!squareHasPremove\n                    }, {\n                        children: [\n                            !squareHasPremove && currentPosition[square] && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Piece, {\n                                piece: currentPosition[square],\n                                square: square,\n                                squares: squares\n                            }),\n                            squareHasPremoveTarget && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Piece, {\n                                isPremovedPiece: true,\n                                piece: squareHasPremoveTarget.piece,\n                                square: square,\n                                squares: squares\n                            }),\n                            showBoardNotation && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Notation, {\n                                row: r,\n                                col: c\n                            })\n                        ]\n                    }), \"\".concat(c).concat(r));\n                })\n            }), r.toString());\n        })\n    }));\n}\n_s28(Squares, \"DrWp3nKOBay89dTDfNBhAFYkbVk=\", false, function() {\n    return [\n        useChessboard\n    ];\n});\n_c6 = Squares;\nconst Arrows = ()=>{\n    _s29();\n    const { arrows, newArrow, boardOrientation, boardWidth, customArrowColor: primaryArrowCollor } = useChessboard();\n    const arrowsList = [\n        ...arrows,\n        newArrow\n    ].filter(Boolean);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        width: boardWidth,\n        height: boardWidth,\n        style: {\n            position: \"absolute\",\n            top: \"0\",\n            left: \"0\",\n            pointerEvents: \"none\",\n            zIndex: \"10\"\n        }\n    }, {\n        children: arrowsList.map((arrow, i)=>{\n            const [arrowStartField, arrowEndField, arrowColor] = arrow;\n            if (arrowStartField === arrowEndField) return null;\n            const from = getRelativeCoords(boardOrientation, boardWidth, arrowStartField);\n            const to = getRelativeCoords(boardOrientation, boardWidth, arrowEndField);\n            let ARROW_LENGTH_REDUCER = boardWidth / 32;\n            const isArrowActive = i === arrows.length;\n            // if there are different arrows targeting the same square make their length a bit shorter\n            if (arrows.some((restArrow)=>restArrow[0] !== arrowStartField && restArrow[1] === arrowEndField) && !isArrowActive) {\n                ARROW_LENGTH_REDUCER = boardWidth / 16;\n            }\n            const dx = to.x - from.x;\n            const dy = to.y - from.y;\n            const r = Math.hypot(dy, dx);\n            const end = {\n                x: from.x + dx * (r - ARROW_LENGTH_REDUCER) / r,\n                y: from.y + dy * (r - ARROW_LENGTH_REDUCER) / r\n            };\n            return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", Object.assign({\n                        id: \"arrowhead-\".concat(i),\n                        markerWidth: \"2\",\n                        markerHeight: \"2.5\",\n                        refX: \"1.25\",\n                        refY: \"1.25\",\n                        orient: \"auto\"\n                    }, {\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polygon\", {\n                            points: \"0.3 0, 2 1.25, 0.3 2.5\",\n                            fill: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor\n                        })\n                    })),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"line\", {\n                        x1: from.x,\n                        y1: from.y,\n                        x2: end.x,\n                        y2: end.y,\n                        opacity: isArrowActive ? \"0.5\" : \"0.65\",\n                        stroke: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor,\n                        strokeWidth: isArrowActive ? 0.9 * boardWidth / 40 : boardWidth / 40,\n                        markerEnd: \"url(#arrowhead-\".concat(i, \")\")\n                    })\n                ]\n            }, \"\".concat(arrowStartField, \"-\").concat(arrowEndField).concat(isArrowActive ? \"-active\" : \"\"));\n        })\n    }));\n};\n_s29(Arrows, \"bucTWcNrryDwpaA6hTeX0HDzATM=\", false, function() {\n    return [\n        useChessboard\n    ];\n});\n_c7 = Arrows;\nfunction PromotionOption(param) {\n    let { option } = param;\n    _s30();\n    const [isHover, setIsHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { boardWidth, chessPieces, customDarkSquareStyle, customLightSquareStyle, handleSetPosition, onPromotionPieceSelect, promoteFromSquare, promoteToSquare, promotionDialogVariant } = useChessboard();\n    const backgroundColor = ()=>{\n        switch(option[1]){\n            case \"Q\":\n                return customDarkSquareStyle.backgroundColor;\n            case \"R\":\n                return customLightSquareStyle.backgroundColor;\n            case \"N\":\n                return promotionDialogVariant === \"default\" ? customLightSquareStyle.backgroundColor : customDarkSquareStyle.backgroundColor;\n            case \"B\":\n                return promotionDialogVariant === \"default\" ? customDarkSquareStyle.backgroundColor : customLightSquareStyle.backgroundColor;\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        onClick: ()=>{\n            if (onPromotionPieceSelect(option, promoteFromSquare !== null && promoteFromSquare !== void 0 ? promoteFromSquare : undefined, promoteToSquare !== null && promoteToSquare !== void 0 ? promoteToSquare : undefined)) handleSetPosition(promoteFromSquare, promoteToSquare, option, true);\n        },\n        onMouseOver: ()=>setIsHover(true),\n        onMouseOut: ()=>setIsHover(false),\n        \"data-piece\": option,\n        style: {\n            cursor: \"pointer\",\n            backgroundColor: isHover ? backgroundColor() : \"\".concat(backgroundColor(), \"aa\"),\n            borderRadius: \"4px\",\n            transition: \"all 0.1s ease-out\"\n        }\n    }, {\n        children: typeof chessPieces[option] === \"function\" ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: {\n                transition: \"all 0.1s ease-out\",\n                transform: isHover ? \"scale(1)\" : \"scale(0.85)\"\n            }\n        }, {\n            children: chessPieces[option]({\n                squareWidth: boardWidth / 8,\n                isDragging: false\n            })\n        })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n            viewBox: \"1 1 43 43\",\n            width: boardWidth / 8,\n            height: boardWidth / 8,\n            style: {\n                transition: \"all 0.1s ease-out\",\n                transform: isHover ? \"scale(1)\" : \"scale(0.85)\"\n            }\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                children: chessPieces[option]\n            })\n        }))\n    }));\n}\n_s30(PromotionOption, \"oYLH96taY+t2ela3KME5IvsDRTo=\", false, function() {\n    return [\n        useChessboard\n    ];\n});\n_c8 = PromotionOption;\nfunction PromotionDialog() {\n    _s31();\n    const { boardOrientation, boardWidth, promotionDialogVariant, promoteToSquare } = useChessboard();\n    const promotePieceColor = (promoteToSquare === null || promoteToSquare === void 0 ? void 0 : promoteToSquare[1]) === \"1\" ? \"b\" : \"w\";\n    const promotionOptions = [\n        \"\".concat(promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\", \"Q\"),\n        \"\".concat(promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\", \"R\"),\n        \"\".concat(promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\", \"N\"),\n        \"\".concat(promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\", \"B\")\n    ];\n    const dialogStyles = {\n        default: {\n            display: \"grid\",\n            gridTemplateColumns: \"1fr 1fr\",\n            transform: \"translate(\".concat(-boardWidth / 8, \"px, \").concat(-boardWidth / 8, \"px)\")\n        },\n        vertical: {\n            transform: \"translate(\".concat(-boardWidth / 16, \"px, \").concat(-boardWidth / 16, \"px)\")\n        },\n        modal: {\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            transform: \"translate(0px, \".concat(3 * boardWidth / 8, \"px)\"),\n            width: \"100%\",\n            height: \"\".concat(boardWidth / 4, \"px\"),\n            top: 0,\n            backgroundColor: \"white\",\n            left: 0\n        }\n    };\n    const dialogCoords = getRelativeCoords(boardOrientation, boardWidth, promoteToSquare || \"a8\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        style: Object.assign({\n            position: \"absolute\",\n            top: \"\".concat(dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.y, \"px\"),\n            left: \"\".concat(dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.x, \"px\"),\n            zIndex: 1000\n        }, dialogStyles[promotionDialogVariant]),\n        title: \"Choose promotion piece\"\n    }, {\n        children: promotionOptions.map((option)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromotionOption, {\n                option: option\n            }, option))\n    }));\n}\n_s31(PromotionDialog, \"bt2JRjNegBeHK1bSJKJSAzhxBeM=\", false, function() {\n    return [\n        useChessboard\n    ];\n});\n_c9 = PromotionDialog;\nconst errorImage = {\n    whiteKing: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        version: \"1.1\",\n        style: {\n            shapeRendering: \"geometricPrecision\",\n            textRendering: \"geometricPrecision\",\n            imageRendering: \"crisp-edges\"\n        },\n        viewBox: \"0 0 4210 12970\",\n        x: \"0px\",\n        y: \"0px\",\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        width: \"250\",\n        height: \"250\"\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                style: {\n                    fill: \"black\",\n                    fillRule: \"nonzero\"\n                },\n                d: \"M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z\"\n            })\n        })\n    }))\n};\nfunction ErrorBoundary(param) {\n    let { children } = param;\n    try {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    } catch (error) {\n        console.log(error);\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WhiteKing, {\n            showError: true\n        });\n    }\n}\n_c10 = ErrorBoundary;\nfunction WhiteKing(param) {\n    let { showError = false } = param;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n        style: {\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            flexDirection: \"column\"\n        }\n    }, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n                style: {\n                    width: 250,\n                    height: 250,\n                    transform: \"rotate(90deg)\"\n                }\n            }, {\n                children: errorImage.whiteKing\n            })),\n            showError && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n                children: \"Something went wrong\"\n            })\n        ]\n    }));\n}\n_c11 = WhiteKing;\nfunction Board() {\n    _s32();\n    const boardRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boardWidth, clearCurrentRightClickDown, onPromotionPieceSelect, setShowPromoteDialog, showPromoteDialog, customBoardStyle } = useChessboard();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        function handleClickOutside(event) {\n            if (boardRef.current && !boardRef.current.contains(event.target)) {\n                clearCurrentRightClickDown();\n            }\n        }\n        document.addEventListener(\"mouseup\", handleClickOutside);\n        return ()=>{\n            document.removeEventListener(\"mouseup\", handleClickOutside);\n        };\n    }, []);\n    return boardWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        style: {\n            perspective: \"1000px\"\n        }\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            ref: boardRef,\n            style: Object.assign(Object.assign({\n                position: \"relative\"\n            }, boardStyles(boardWidth)), customBoardStyle)\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Squares, {}),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Arrows, {}),\n                showPromoteDialog && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                            onClick: ()=>{\n                                setShowPromoteDialog(false);\n                                onPromotionPieceSelect === null || onPromotionPieceSelect === void 0 ? void 0 : onPromotionPieceSelect();\n                            },\n                            style: {\n                                position: \"absolute\",\n                                top: \"0\",\n                                left: \"0\",\n                                zIndex: \"100\",\n                                backgroundColor: \"rgba(22,21,18,.7)\",\n                                width: boardWidth,\n                                height: boardWidth\n                            }\n                        }),\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromotionDialog, {})\n                    ]\n                })\n            ]\n        }))\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WhiteKing, {});\n}\n_s32(Board, \"3IcLaeHFVu6KF0cXWJJdBAJHhiE=\", false, function() {\n    return [\n        useChessboard\n    ];\n});\n_c12 = Board;\nconst boardStyles = (width)=>({\n        cursor: \"default\",\n        height: width,\n        width\n    });\nvar ListenerType;\n(function(ListenerType) {\n    ListenerType[\"mouse\"] = \"mouse\";\n    ListenerType[\"touch\"] = \"touch\";\n    ListenerType[\"keyboard\"] = \"keyboard\";\n})(ListenerType || (ListenerType = {}));\nclass OptionsReader {\n    get delay() {\n        var _delay;\n        return (_delay = this.args.delay) !== null && _delay !== void 0 ? _delay : 0;\n    }\n    get scrollAngleRanges() {\n        return this.args.scrollAngleRanges;\n    }\n    get getDropTargetElementsAtPoint() {\n        return this.args.getDropTargetElementsAtPoint;\n    }\n    get ignoreContextMenu() {\n        var _ignoreContextMenu;\n        return (_ignoreContextMenu = this.args.ignoreContextMenu) !== null && _ignoreContextMenu !== void 0 ? _ignoreContextMenu : false;\n    }\n    get enableHoverOutsideTarget() {\n        var _enableHoverOutsideTarget;\n        return (_enableHoverOutsideTarget = this.args.enableHoverOutsideTarget) !== null && _enableHoverOutsideTarget !== void 0 ? _enableHoverOutsideTarget : false;\n    }\n    get enableKeyboardEvents() {\n        var _enableKeyboardEvents;\n        return (_enableKeyboardEvents = this.args.enableKeyboardEvents) !== null && _enableKeyboardEvents !== void 0 ? _enableKeyboardEvents : false;\n    }\n    get enableMouseEvents() {\n        var _enableMouseEvents;\n        return (_enableMouseEvents = this.args.enableMouseEvents) !== null && _enableMouseEvents !== void 0 ? _enableMouseEvents : false;\n    }\n    get enableTouchEvents() {\n        var _enableTouchEvents;\n        return (_enableTouchEvents = this.args.enableTouchEvents) !== null && _enableTouchEvents !== void 0 ? _enableTouchEvents : true;\n    }\n    get touchSlop() {\n        return this.args.touchSlop || 0;\n    }\n    get delayTouchStart() {\n        var ref, ref1;\n        var ref2, ref3;\n        return (ref3 = (ref2 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayTouchStart) !== null && ref2 !== void 0 ? ref2 : (ref1 = this.args) === null || ref1 === void 0 ? void 0 : ref1.delay) !== null && ref3 !== void 0 ? ref3 : 0;\n    }\n    get delayMouseStart() {\n        var ref, ref4;\n        var ref5, ref6;\n        return (ref6 = (ref5 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayMouseStart) !== null && ref5 !== void 0 ? ref5 : (ref4 = this.args) === null || ref4 === void 0 ? void 0 : ref4.delay) !== null && ref6 !== void 0 ? ref6 : 0;\n    }\n    get window() {\n        if (this.context && this.context.window) {\n            return this.context.window;\n        } else if (true) {\n            return window;\n        }\n        return undefined;\n    }\n    get document() {\n        var ref;\n        if ((ref = this.context) === null || ref === void 0 ? void 0 : ref.document) {\n            return this.context.document;\n        }\n        if (this.window) {\n            return this.window.document;\n        }\n        return undefined;\n    }\n    get rootElement() {\n        var ref;\n        return ((ref = this.args) === null || ref === void 0 ? void 0 : ref.rootElement) || this.document;\n    }\n    constructor(args, context){\n        this.args = args;\n        this.context = context;\n    }\n}\nfunction distance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(Math.abs(x2 - x1), 2) + Math.pow(Math.abs(y2 - y1), 2));\n}\nfunction inAngleRanges(x1, y1, x2, y2, angleRanges) {\n    if (!angleRanges) {\n        return false;\n    }\n    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI + 180;\n    for(let i = 0; i < angleRanges.length; ++i){\n        const ar = angleRanges[i];\n        if (ar && (ar.start == null || angle >= ar.start) && (ar.end == null || angle <= ar.end)) {\n            return true;\n        }\n    }\n    return false;\n}\n// Used for MouseEvent.buttons (note the s on the end).\nconst MouseButtons = {\n    Left: 1,\n    Right: 2,\n    Center: 4\n};\n// Used for e.button (note the lack of an s on the end).\nconst MouseButton = {\n    Left: 0,\n    Center: 1,\n    Right: 2\n};\n/**\n * Only touch events and mouse events where the left button is pressed should initiate a drag.\n * @param {MouseEvent | TouchEvent} e The event\n */ function eventShouldStartDrag(e) {\n    // For touch events, button will be undefined. If e.button is defined,\n    // then it should be MouseButton.Left.\n    return e.button === undefined || e.button === MouseButton.Left;\n}\n/**\n * Only touch events and mouse events where the left mouse button is no longer held should end a drag.\n * It's possible the user mouse downs with the left mouse button, then mouse down and ups with the right mouse button.\n * We don't want releasing the right mouse button to end the drag.\n * @param {MouseEvent | TouchEvent} e The event\n */ function eventShouldEndDrag(e) {\n    // Touch events will have buttons be undefined, while mouse events will have e.buttons's left button\n    // bit field unset if the left mouse button has been released\n    return e.buttons === undefined || (e.buttons & MouseButtons.Left) === 0;\n}\nfunction isTouchEvent(e) {\n    return !!e.targetTouches;\n}\nconst ELEMENT_NODE = 1;\nfunction getNodeClientOffset(node) {\n    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n    if (!el) {\n        return undefined;\n    }\n    const { top, left } = el.getBoundingClientRect();\n    return {\n        x: left,\n        y: top\n    };\n}\nfunction getEventClientTouchOffset(e, lastTargetTouchFallback) {\n    if (e.targetTouches.length === 1) {\n        return getEventClientOffset(e.targetTouches[0]);\n    } else if (lastTargetTouchFallback && e.touches.length === 1) {\n        if (e.touches[0].target === lastTargetTouchFallback.target) {\n            return getEventClientOffset(e.touches[0]);\n        }\n    }\n    return;\n}\nfunction getEventClientOffset(e, lastTargetTouchFallback) {\n    if (isTouchEvent(e)) {\n        return getEventClientTouchOffset(e, lastTargetTouchFallback);\n    } else {\n        return {\n            x: e.clientX,\n            y: e.clientY\n        };\n    }\n}\nconst supportsPassive = (()=>{\n    // simular to jQuery's test\n    let supported = false;\n    try {\n        addEventListener(\"test\", ()=>{\n        // do nothing\n        }, Object.defineProperty({}, \"passive\", {\n            get () {\n                supported = true;\n                return true;\n            }\n        }));\n    } catch (e) {\n    // do nothing\n    }\n    return supported;\n})();\nconst eventNames = {\n    [ListenerType.mouse]: {\n        start: \"mousedown\",\n        move: \"mousemove\",\n        end: \"mouseup\",\n        contextmenu: \"contextmenu\"\n    },\n    [ListenerType.touch]: {\n        start: \"touchstart\",\n        move: \"touchmove\",\n        end: \"touchend\"\n    },\n    [ListenerType.keyboard]: {\n        keydown: \"keydown\"\n    }\n};\nclass TouchBackendImpl {\n    /**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */ profile() {\n        var ref;\n        return {\n            sourceNodes: this.sourceNodes.size,\n            sourcePreviewNodes: this.sourcePreviewNodes.size,\n            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n            targetNodes: this.targetNodes.size,\n            dragOverTargetIds: ((ref = this.dragOverTargetIds) === null || ref === void 0 ? void 0 : ref.length) || 0\n        };\n    }\n    // public for test\n    get document() {\n        return this.options.document;\n    }\n    setup() {\n        const root = this.options.rootElement;\n        if (!root) {\n            return;\n        }\n        invariant(!TouchBackendImpl.isSetUp, \"Cannot have two Touch backends at the same time.\");\n        TouchBackendImpl.isSetUp = true;\n        this.addEventListener(root, \"start\", this.getTopMoveStartHandler());\n        this.addEventListener(root, \"start\", this.handleTopMoveStartCapture, true);\n        this.addEventListener(root, \"move\", this.handleTopMove);\n        this.addEventListener(root, \"move\", this.handleTopMoveCapture, true);\n        this.addEventListener(root, \"end\", this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.addEventListener(root, \"contextmenu\", this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.addEventListener(root, \"keydown\", this.handleCancelOnEscape, true);\n        }\n    }\n    teardown() {\n        const root = this.options.rootElement;\n        if (!root) {\n            return;\n        }\n        TouchBackendImpl.isSetUp = false;\n        this._mouseClientOffset = {};\n        this.removeEventListener(root, \"start\", this.handleTopMoveStartCapture, true);\n        this.removeEventListener(root, \"start\", this.handleTopMoveStart);\n        this.removeEventListener(root, \"move\", this.handleTopMoveCapture, true);\n        this.removeEventListener(root, \"move\", this.handleTopMove);\n        this.removeEventListener(root, \"end\", this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.removeEventListener(root, \"contextmenu\", this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.removeEventListener(root, \"keydown\", this.handleCancelOnEscape, true);\n        }\n        this.uninstallSourceNodeRemovalObserver();\n    }\n    addEventListener(subject, event, handler) {\n        let capture = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n        const options = supportsPassive ? {\n            capture,\n            passive: false\n        } : capture;\n        this.listenerTypes.forEach(function(listenerType) {\n            const evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.addEventListener(evt, handler, options);\n            }\n        });\n    }\n    removeEventListener(subject, event, handler) {\n        let capture = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n        const options = supportsPassive ? {\n            capture,\n            passive: false\n        } : capture;\n        this.listenerTypes.forEach(function(listenerType) {\n            const evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.removeEventListener(evt, handler, options);\n            }\n        });\n    }\n    connectDragSource(sourceId, node) {\n        const handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n        this.sourceNodes.set(sourceId, node);\n        this.addEventListener(node, \"start\", handleMoveStart);\n        return ()=>{\n            this.sourceNodes.delete(sourceId);\n            this.removeEventListener(node, \"start\", handleMoveStart);\n        };\n    }\n    connectDragPreview(sourceId, node, options) {\n        this.sourcePreviewNodeOptions.set(sourceId, options);\n        this.sourcePreviewNodes.set(sourceId, node);\n        return ()=>{\n            this.sourcePreviewNodes.delete(sourceId);\n            this.sourcePreviewNodeOptions.delete(sourceId);\n        };\n    }\n    connectDropTarget(targetId, node) {\n        const root = this.options.rootElement;\n        if (!this.document || !root) {\n            return ()=>{\n            /* noop */ };\n        }\n        const handleMove = (e)=>{\n            if (!this.document || !root || !this.monitor.isDragging()) {\n                return;\n            }\n            let coords;\n            /**\n\t\t\t * Grab the coordinates for the current mouse/touch position\n\t\t\t */ switch(e.type){\n                case eventNames.mouse.move:\n                    coords = {\n                        x: e.clientX,\n                        y: e.clientY\n                    };\n                    break;\n                case eventNames.touch.move:\n                    var ref, ref1;\n                    coords = {\n                        x: ((ref = e.touches[0]) === null || ref === void 0 ? void 0 : ref.clientX) || 0,\n                        y: ((ref1 = e.touches[0]) === null || ref1 === void 0 ? void 0 : ref1.clientY) || 0\n                    };\n                    break;\n            }\n            /**\n\t\t\t * Use the coordinates to grab the element the drag ended on.\n\t\t\t * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n\t\t\t */ const droppedOn = coords != null ? this.document.elementFromPoint(coords.x, coords.y) : undefined;\n            const childMatch = droppedOn && node.contains(droppedOn);\n            if (droppedOn === node || childMatch) {\n                return this.handleMove(e, targetId);\n            }\n        };\n        /**\n\t\t * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n\t\t */ this.addEventListener(this.document.body, \"move\", handleMove);\n        this.targetNodes.set(targetId, node);\n        return ()=>{\n            if (this.document) {\n                this.targetNodes.delete(targetId);\n                this.removeEventListener(this.document.body, \"move\", handleMove);\n            }\n        };\n    }\n    getTopMoveStartHandler() {\n        if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n            return this.handleTopMoveStart;\n        }\n        return this.handleTopMoveStartDelay;\n    }\n    installSourceNodeRemovalObserver(node) {\n        this.uninstallSourceNodeRemovalObserver();\n        this.draggedSourceNode = node;\n        this.draggedSourceNodeRemovalObserver = new MutationObserver(()=>{\n            if (node && !node.parentElement) {\n                this.resurrectSourceNode();\n                this.uninstallSourceNodeRemovalObserver();\n            }\n        });\n        if (!node || !node.parentElement) {\n            return;\n        }\n        this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n            childList: true\n        });\n    }\n    resurrectSourceNode() {\n        if (this.document && this.draggedSourceNode) {\n            this.draggedSourceNode.style.display = \"none\";\n            this.draggedSourceNode.removeAttribute(\"data-reactid\");\n            this.document.body.appendChild(this.draggedSourceNode);\n        }\n    }\n    uninstallSourceNodeRemovalObserver() {\n        if (this.draggedSourceNodeRemovalObserver) {\n            this.draggedSourceNodeRemovalObserver.disconnect();\n        }\n        this.draggedSourceNodeRemovalObserver = undefined;\n        this.draggedSourceNode = undefined;\n    }\n    constructor(manager, context, options){\n        this.getSourceClientOffset = (sourceId)=>{\n            const element = this.sourceNodes.get(sourceId);\n            return element && getNodeClientOffset(element);\n        };\n        this.handleTopMoveStartCapture = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            this.moveStartSourceIds = [];\n        };\n        this.handleMoveStart = (sourceId)=>{\n            // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n            // We only collect start collecting drag sources on touch and left mouse events.\n            if (Array.isArray(this.moveStartSourceIds)) {\n                this.moveStartSourceIds.unshift(sourceId);\n            }\n        };\n        this.handleTopMoveStart = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            // Don't prematurely preventDefault() here since it might:\n            // 1. Mess up scrolling\n            // 2. Mess up long tap (which brings up context menu)\n            // 3. If there's an anchor link as a child, tap won't be triggered on link\n            const clientOffset = getEventClientOffset(e);\n            if (clientOffset) {\n                if (isTouchEvent(e)) {\n                    this.lastTargetTouchFallback = e.targetTouches[0];\n                }\n                this._mouseClientOffset = clientOffset;\n            }\n            this.waitingForDelay = false;\n        };\n        this.handleTopMoveStartDelay = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            const delay = e.type === eventNames.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;\n            this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e), delay);\n            this.waitingForDelay = true;\n        };\n        this.handleTopMoveCapture = ()=>{\n            this.dragOverTargetIds = [];\n        };\n        this.handleMove = (_evt, targetId)=>{\n            if (this.dragOverTargetIds) {\n                this.dragOverTargetIds.unshift(targetId);\n            }\n        };\n        this.handleTopMove = (e1)=>{\n            if (this.timeout) {\n                clearTimeout(this.timeout);\n            }\n            if (!this.document || this.waitingForDelay) {\n                return;\n            }\n            const { moveStartSourceIds, dragOverTargetIds } = this;\n            const enableHoverOutsideTarget = this.options.enableHoverOutsideTarget;\n            const clientOffset = getEventClientOffset(e1, this.lastTargetTouchFallback);\n            if (!clientOffset) {\n                return;\n            }\n            // If the touch move started as a scroll, or is is between the scroll angles\n            if (this._isScrolling || !this.monitor.isDragging() && inAngleRanges(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, this.options.scrollAngleRanges)) {\n                this._isScrolling = true;\n                return;\n            }\n            // If we're not dragging and we've moved a little, that counts as a drag start\n            if (!this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n            this._mouseClientOffset.hasOwnProperty(\"x\") && moveStartSourceIds && distance(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (this.options.touchSlop ? this.options.touchSlop : 0)) {\n                this.moveStartSourceIds = undefined;\n                this.actions.beginDrag(moveStartSourceIds, {\n                    clientOffset: this._mouseClientOffset,\n                    getSourceClientOffset: this.getSourceClientOffset,\n                    publishSource: false\n                });\n            }\n            if (!this.monitor.isDragging()) {\n                return;\n            }\n            const sourceNode = this.sourceNodes.get(this.monitor.getSourceId());\n            this.installSourceNodeRemovalObserver(sourceNode);\n            this.actions.publishDragSource();\n            if (e1.cancelable) e1.preventDefault();\n            // Get the node elements of the hovered DropTargets\n            const dragOverTargetNodes = (dragOverTargetIds || []).map((key)=>this.targetNodes.get(key)).filter((e)=>!!e);\n            // Get the a ordered list of nodes that are touched by\n            const elementsAtPoint = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : this.document.elementsFromPoint(clientOffset.x, clientOffset.y);\n            // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n            const elementsAtPointExtended = [];\n            for(const nodeId in elementsAtPoint){\n                // eslint-disable-next-line no-prototype-builtins\n                if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n                    continue;\n                }\n                let currentNode = elementsAtPoint[nodeId];\n                if (currentNode != null) {\n                    elementsAtPointExtended.push(currentNode);\n                }\n                while(currentNode){\n                    currentNode = currentNode.parentElement;\n                    if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n                        elementsAtPointExtended.push(currentNode);\n                    }\n                }\n            }\n            const orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n            .filter((node)=>dragOverTargetNodes.indexOf(node) > -1) // Map back the nodes elements to targetIds\n            .map((node)=>this._getDropTargetId(node)) // Filter off possible null rows\n            .filter((node)=>!!node).filter((id, index, ids)=>ids.indexOf(id) === index);\n            // Invoke hover for drop targets when source node is still over and pointer is outside\n            if (enableHoverOutsideTarget) {\n                for(const targetId in this.targetNodes){\n                    const targetNode = this.targetNodes.get(targetId);\n                    if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n                        orderedDragOverTargetIds.unshift(targetId);\n                        break;\n                    }\n                }\n            }\n            // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n            orderedDragOverTargetIds.reverse();\n            this.actions.hover(orderedDragOverTargetIds, {\n                clientOffset: clientOffset\n            });\n        };\n        /**\n\t *\n\t * visible for testing\n\t */ this._getDropTargetId = (node)=>{\n            const keys = this.targetNodes.keys();\n            let next = keys.next();\n            while(next.done === false){\n                const targetId = next.value;\n                if (node === this.targetNodes.get(targetId)) {\n                    return targetId;\n                } else {\n                    next = keys.next();\n                }\n            }\n            return undefined;\n        };\n        this.handleTopMoveEndCapture = (e)=>{\n            this._isScrolling = false;\n            this.lastTargetTouchFallback = undefined;\n            if (!eventShouldEndDrag(e)) {\n                return;\n            }\n            if (!this.monitor.isDragging() || this.monitor.didDrop()) {\n                this.moveStartSourceIds = undefined;\n                return;\n            }\n            if (e.cancelable) e.preventDefault();\n            this._mouseClientOffset = {};\n            this.uninstallSourceNodeRemovalObserver();\n            this.actions.drop();\n            this.actions.endDrag();\n        };\n        this.handleCancelOnEscape = (e)=>{\n            if (e.key === \"Escape\" && this.monitor.isDragging()) {\n                this._mouseClientOffset = {};\n                this.uninstallSourceNodeRemovalObserver();\n                this.actions.endDrag();\n            }\n        };\n        this.options = new OptionsReader(options, context);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.sourceNodes = new Map();\n        this.sourcePreviewNodes = new Map();\n        this.sourcePreviewNodeOptions = new Map();\n        this.targetNodes = new Map();\n        this.listenerTypes = [];\n        this._mouseClientOffset = {};\n        this._isScrolling = false;\n        if (this.options.enableMouseEvents) {\n            this.listenerTypes.push(ListenerType.mouse);\n        }\n        if (this.options.enableTouchEvents) {\n            this.listenerTypes.push(ListenerType.touch);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.listenerTypes.push(ListenerType.keyboard);\n        }\n    }\n}\nconst TouchBackend = function createBackend(manager) {\n    let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return new TouchBackendImpl(manager, context, options);\n};\n_c13 = TouchBackend;\nconst ChessboardDnDContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    isCustomDndProviderSet: false\n});\nconst EmptyProvider = (param)=>{\n    let { children } = param;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    });\n};\n_c14 = EmptyProvider;\nconst ChessboardDnDProvider = (param)=>{\n    let { children, backend, context, options, debugMode } = param;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardDnDContext.Provider, Object.assign({\n        value: {\n            isCustomDndProviderSet: true\n        }\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DndProvider, Object.assign({\n            backend: backend || (\"ontouchstart\" in window ? TouchBackend : HTML5Backend),\n            context: context,\n            options: options,\n            debugMode: debugMode !== null && debugMode !== void 0 ? debugMode : false\n        }, {\n            children: children\n        }))\n    }));\n};\n_c15 = ChessboardDnDProvider;\nconst ChessboardDnDRoot = (param)=>{\n    let { customDndBackend, customDndBackendOptions, children } = param;\n    _s33();\n    const [clientWindow, setClientWindow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [backendSet, setBackendSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isMobile, setIsMobile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { isCustomDndProviderSet } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChessboardDnDContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setIsMobile(\"ontouchstart\" in window);\n        setBackendSet(true);\n        setClientWindow(window);\n    }, []);\n    // in case we already wrapped `<Chessboard/>`  with `<DnDProvider/>` we don't need to create a new one\n    const DnDWrapper = isCustomDndProviderSet ? EmptyProvider : DndProvider;\n    if (!backendSet) {\n        return null;\n    }\n    return clientWindow ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DnDWrapper, Object.assign({\n        backend: customDndBackend || (isMobile ? TouchBackend : HTML5Backend),\n        context: clientWindow,\n        options: customDndBackend ? customDndBackendOptions : undefined\n    }, {\n        children: children\n    })) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: children\n    });\n};\n_s33(ChessboardDnDRoot, \"IKK9UGhi2VOGCvI21B8tXUfUDlU=\");\n_c16 = ChessboardDnDRoot;\nfunction CustomDragLayer(param) {\n    let { boardContainer } = param;\n    _s34();\n    const { boardWidth, chessPieces, id, snapToCursor, allowDragOutsideBoard } = useChessboard();\n    const collectedProps = useDragLayer((monitor)=>({\n            item: monitor.getItem(),\n            clientOffset: monitor.getClientOffset(),\n            sourceClientOffset: monitor.getSourceClientOffset(),\n            isDragging: monitor.isDragging()\n        }));\n    const { isDragging, item, clientOffset, sourceClientOffset } = collectedProps;\n    const getItemStyle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((clientOffset, sourceClientOffset)=>{\n        if (!clientOffset || !sourceClientOffset) return {\n            display: \"none\"\n        };\n        let { x, y } = snapToCursor ? clientOffset : sourceClientOffset;\n        const halfSquareWidth = boardWidth / 8 / 2;\n        if (snapToCursor) {\n            x -= halfSquareWidth;\n            y -= halfSquareWidth;\n        }\n        if (!allowDragOutsideBoard) {\n            const { left, top } = boardContainer;\n            // half square so the piece reaches the board\n            const maxLeft = left - halfSquareWidth;\n            const maxTop = top - halfSquareWidth;\n            const maxRight = left + boardWidth - halfSquareWidth;\n            const maxBottom = top + boardWidth - halfSquareWidth;\n            x = Math.max(maxLeft, Math.min(x, maxRight));\n            y = Math.max(maxTop, Math.min(y, maxBottom));\n        }\n        const transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n        return {\n            transform,\n            WebkitTransform: transform,\n            touchAction: \"none\"\n        };\n    }, [\n        boardWidth,\n        allowDragOutsideBoard,\n        snapToCursor,\n        boardContainer\n    ]);\n    return isDragging && item.id === id ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        style: {\n            position: \"fixed\",\n            pointerEvents: \"none\",\n            zIndex: 10,\n            left: 0,\n            top: 0\n        }\n    }, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n            style: getItemStyle(clientOffset, sourceClientOffset)\n        }, {\n            children: typeof chessPieces[item.piece] === \"function\" ? chessPieces[item.piece]({\n                squareWidth: boardWidth / 8,\n                isDragging: true\n            }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n                viewBox: \"1 1 43 43\",\n                width: boardWidth / 8,\n                height: boardWidth / 8\n            }, {\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                    children: chessPieces[item.piece]\n                })\n            }))\n        }))\n    })) : null;\n}\n_s34(CustomDragLayer, \"6dgESMAVW+9zbjR6d9hv+G2/m+U=\", false, function() {\n    return [\n        useChessboard,\n        useDragLayer\n    ];\n});\n_c17 = CustomDragLayer;\nconst SparePiece = (param)=>{\n    let { piece, width, customPieceJSX, dndId } = param;\n    _s35();\n    const renderPiece = customPieceJSX !== null && customPieceJSX !== void 0 ? customPieceJSX : defaultPieces[piece];\n    const [{ canDrag, isDragging }, drag, dragPreview] = useDrag(()=>({\n            type: \"piece\",\n            item: ()=>{\n                return {\n                    piece,\n                    isSpare: true,\n                    id: dndId\n                };\n            },\n            collect: (monitor)=>({\n                    canDrag: true,\n                    isDragging: !!monitor.isDragging()\n                })\n        }), [\n        piece,\n        dndId\n    ]);\n    // hide the default preview\n    dragPreview(getEmptyImage(), {\n        captureDraggingState: true\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({\n        ref: canDrag ? drag : null,\n        \"data-piece\": piece,\n        style: {\n            cursor: \"move\"\n        }\n    }, {\n        children: typeof renderPiece === \"function\" ? renderPiece({\n            squareWidth: width,\n            isDragging\n        }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({\n            viewBox: \"1 1 43 43\",\n            width: width,\n            height: width\n        }, {\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n                children: renderPiece\n            })\n        }))\n    }));\n};\n_s35(SparePiece, \"vqYwvUJTG+g0K9enyaW4kuPkvaY=\", false, function() {\n    return [\n        useDrag\n    ];\n});\n_c18 = SparePiece;\nconst Chessboard = /*#__PURE__*/ _s36((0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c19 = _s36((props, ref)=>{\n    _s36();\n    const { customDndBackend, customDndBackendOptions, onBoardWidthChange } = props, otherProps = __rest(props, [\n        \"customDndBackend\",\n        \"customDndBackendOptions\",\n        \"onBoardWidthChange\"\n    ]);\n    const [boardWidth, setBoardWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(props.boardWidth);\n    const boardRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const boardContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [boardContainerPos, setBoardContainerPos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        left: 0,\n        top: 0\n    });\n    const metrics = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        var _a;\n        return (_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n    }, [\n        boardRef.current\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        boardWidth && (onBoardWidthChange === null || onBoardWidthChange === void 0 ? void 0 : onBoardWidthChange(boardWidth));\n    }, [\n        boardWidth\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setBoardContainerPos({\n            left: (metrics === null || metrics === void 0 ? void 0 : metrics.left) ? metrics === null || metrics === void 0 ? void 0 : metrics.left : 0,\n            top: (metrics === null || metrics === void 0 ? void 0 : metrics.top) ? metrics === null || metrics === void 0 ? void 0 : metrics.top : 0\n        });\n    }, [\n        metrics\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _a;\n        if (props.boardWidth === undefined && ((_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth)) {\n            const resizeObserver = new ResizeObserver(()=>{\n                var _a;\n                setBoardWidth((_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth);\n            });\n            resizeObserver.observe(boardRef.current);\n            return ()=>{\n                resizeObserver.disconnect();\n            };\n        }\n    }, [\n        boardRef.current\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorBoundary, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({\n            ref: boardContainerRef,\n            style: {\n                display: \"flex\",\n                flexDirection: \"column\",\n                width: \"100%\"\n            }\n        }, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    ref: boardRef,\n                    style: {\n                        width: \"100%\"\n                    }\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardDnDRoot, Object.assign({\n                    customDndBackend: customDndBackend,\n                    customDndBackendOptions: customDndBackendOptions\n                }, {\n                    children: boardWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ChessboardProvider, Object.assign({\n                        boardWidth: boardWidth\n                    }, otherProps, {\n                        ref: ref\n                    }, {\n                        children: [\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomDragLayer, {\n                                boardContainer: boardContainerPos\n                            }),\n                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Board, {})\n                        ]\n                    }))\n                }))\n            ]\n        }))\n    });\n}, \"4UwNf5hQWiEs+5Nl2NCqDy7QvpQ=\")), \"4UwNf5hQWiEs+5Nl2NCqDy7QvpQ=\");\n_c20 = Chessboard;\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20;\n$RefreshReg$(_c, \"ChessboardProvider\");\n$RefreshReg$(_c1, \"Notation\");\n$RefreshReg$(_c2, \"DndProvider\");\n$RefreshReg$(_c3, \"HTML5Backend\");\n$RefreshReg$(_c4, \"Piece\");\n$RefreshReg$(_c5, \"Square\");\n$RefreshReg$(_c6, \"Squares\");\n$RefreshReg$(_c7, \"Arrows\");\n$RefreshReg$(_c8, \"PromotionOption\");\n$RefreshReg$(_c9, \"PromotionDialog\");\n$RefreshReg$(_c10, \"ErrorBoundary\");\n$RefreshReg$(_c11, \"WhiteKing\");\n$RefreshReg$(_c12, \"Board\");\n$RefreshReg$(_c13, \"TouchBackend\");\n$RefreshReg$(_c14, \"EmptyProvider\");\n$RefreshReg$(_c15, \"ChessboardDnDProvider\");\n$RefreshReg$(_c16, \"ChessboardDnDRoot\");\n$RefreshReg$(_c17, \"CustomDragLayer\");\n$RefreshReg$(_c18, \"SparePiece\");\n$RefreshReg$(_c19, \"Chessboard$forwardRef\");\n$RefreshReg$(_c20, \"Chessboard\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1jaGVzc2JvYXJkL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdEO0FBQzJKO0FBRW5OOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUU5RSxTQUFTaUIsT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUVBLE1BQU1XLFVBQVUsV0FBV0MsS0FBSyxDQUFDO0FBQ2pDLE1BQU1DLHdCQUF3QjtJQUMxQkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMs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cEYsc0RBQUdBLENBQUMsT0FBTztvQkFBRXFMLEtBQUs0OEI7b0JBQVU1aUMsT0FBTzt3QkFBRUgsT0FBTztvQkFBTztnQkFBRTtnQkFBSWxGLHNEQUFHQSxDQUFDa3ZDLG1CQUFtQjV0QyxPQUFPeUQsTUFBTSxDQUFDO29CQUFFb3FDLGtCQUFrQkE7b0JBQWtCQyx5QkFBeUJBO2dCQUF3QixHQUFHO29CQUFFaHFDLFVBQVUrQixjQUFlbEgsdURBQUlBLENBQUNtTCxvQkFBb0I5SixPQUFPeUQsTUFBTSxDQUFDO3dCQUFFb0MsWUFBWUE7b0JBQVcsR0FBRzBwQyxZQUFZO3dCQUFFeGxDLEtBQUtBO29CQUFJLEdBQUc7d0JBQUVqRyxVQUFVOzRCQUFDcEYsc0RBQUdBLENBQUM0dkMsaUJBQWlCO2dDQUFFQyxnQkFBZ0JtQjs0QkFBa0I7NEJBQUloeEMsc0RBQUdBLENBQUNnb0MsT0FBTyxDQUFDO3lCQUFHO29CQUFDO2dCQUFLO2FBQUk7UUFBQztJQUFJO0FBQ3RiOztBQUV5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2hlc3Nib2FyZC9kaXN0L2luZGV4LmVzbS5qcz8xZjA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwganN4cywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0LCBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUNvbnRleHQsIG1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIGlzVmFsaWRFbGVtZW50LCBjbG9uZUVsZW1lbnQsIEZyYWdtZW50IGFzIEZyYWdtZW50JDEgfSBmcm9tICdyZWFjdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmNvbnN0IENPTFVNTlMgPSBcImFiY2RlZmdoXCIuc3BsaXQoXCJcIik7XHJcbmNvbnN0IFNUQVJUX1BPU0lUSU9OX09CSkVDVCA9IHtcclxuICAgIGE4OiBcImJSXCIsXHJcbiAgICBiODogXCJiTlwiLFxyXG4gICAgYzg6IFwiYkJcIixcclxuICAgIGQ4OiBcImJRXCIsXHJcbiAgICBlODogXCJiS1wiLFxyXG4gICAgZjg6IFwiYkJcIixcclxuICAgIGc4OiBcImJOXCIsXHJcbiAgICBoODogXCJiUlwiLFxyXG4gICAgYTc6IFwiYlBcIixcclxuICAgIGI3OiBcImJQXCIsXHJcbiAgICBjNzogXCJiUFwiLFxyXG4gICAgZDc6IFwiYlBcIixcclxuICAgIGU3OiBcImJQXCIsXHJcbiAgICBmNzogXCJiUFwiLFxyXG4gICAgZzc6IFwiYlBcIixcclxuICAgIGg3OiBcImJQXCIsXHJcbiAgICBhMjogXCJ3UFwiLFxyXG4gICAgYjI6IFwid1BcIixcclxuICAgIGMyOiBcIndQXCIsXHJcbiAgICBkMjogXCJ3UFwiLFxyXG4gICAgZTI6IFwid1BcIixcclxuICAgIGYyOiBcIndQXCIsXHJcbiAgICBnMjogXCJ3UFwiLFxyXG4gICAgaDI6IFwid1BcIixcclxuICAgIGExOiBcIndSXCIsXHJcbiAgICBiMTogXCJ3TlwiLFxyXG4gICAgYzE6IFwid0JcIixcclxuICAgIGQxOiBcIndRXCIsXHJcbiAgICBlMTogXCJ3S1wiLFxyXG4gICAgZjE6IFwid0JcIixcclxuICAgIGcxOiBcIndOXCIsXHJcbiAgICBoMTogXCJ3UlwiLFxyXG59O1xyXG5jb25zdCBXSElURV9DT0xVTU5fVkFMVUVTID0ge1xyXG4gICAgYTogMCxcclxuICAgIGI6IDEsXHJcbiAgICBjOiAyLFxyXG4gICAgZDogMyxcclxuICAgIGU6IDQsXHJcbiAgICBmOiA1LFxyXG4gICAgZzogNixcclxuICAgIGg6IDcsXHJcbn07XHJcbmNvbnN0IEJMQUNLX0NPTFVNTl9WQUxVRVMgPSB7XHJcbiAgICBhOiA3LFxyXG4gICAgYjogNixcclxuICAgIGM6IDUsXHJcbiAgICBkOiA0LFxyXG4gICAgZTogMyxcclxuICAgIGY6IDIsXHJcbiAgICBnOiAxLFxyXG4gICAgaDogMCxcclxufTtcclxuY29uc3QgV0hJVEVfUk9XUyA9IFs3LCA2LCA1LCA0LCAzLCAyLCAxLCAwXTtcclxuY29uc3QgQkxBQ0tfUk9XUyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3XTtcblxuLy8gaHR0cHM6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvd2lraS9DYXRlZ29yeTpTVkdfY2hlc3NfcGllY2VzXHJcbi8vIEJ5IGVuOlVzZXI6Q2J1cm5ldHQgLSBPd24gd29ya1xyXG4vLyBUaGlzIFczQyAtIHVuc3BlY2lmaWVkIHZlY3RvciBpbWFnZSB3YXMgY3JlYXRlZCB3aXRoIElua3NjYXBlLiwgQ0MgQlkgLSBTQSAzLjAsIGh0dHBzOi8vY29tbW9ucy53aWtpbWVkaWEub3JnL3cvaW5kZXgucGhwP2N1cmlkPTE0OTk4MTBcclxuY29uc3QgZGVmYXVsdFBpZWNlcyA9IHtcclxuICAgIHdQOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSkgfSkpKSxcclxuICAgIHdSOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwzOSBMIDM2LDM5IEwgMzYsMzYgTCA5LDM2IEwgOSwzOSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLDM2IEwgMTIsMzIgTCAzMywzMiBMIDMzLDM2IEwgMTIsMzYgeiBcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDExLDkgTCAxNSw5IEwgMTUsMTEgTCAyMCwxMSBMIDIwLDkgTCAyNSw5IEwgMjUsMTEgTCAzMCwxMSBMIDMwLDkgTCAzNCw5IEwgMzQsMTRcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAzNCwxNCBMIDMxLDE3IEwgMTQsMTcgTCAxMSwxNFwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMxLDE3IEwgMzEsMjkuNSBMIDE0LDI5LjUgTCAxNCwxN1wiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMxLDI5LjUgTCAzMi41LDMyIEwgMTIuNSwzMiBMIDE0LDI5LjVcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDM0LDE0XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgd046IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMiwxMCBDIDMyLjUsMTEgMzguNSwxOCAzOCwzOSBMIDE1LDM5IEMgMTUsMzAgMjUsMzIuNSAyMywxOFwiLCBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMFwiLCBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDkuNSAyNS41IEEgMC41IDAuNSAwIDEgMSA4LjUsMjUuNSBBIDAuNSAwLjUgMCAxIDEgOS41IDI1LjUgelwiLCBzdHlsZTogeyBmaWxsOiBcIiMwMDAwMDBcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE1IDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNCwxNS41IEEgMC41IDEuNSAwIDEgMSAgMTUgMTUuNSB6XCIsIHRyYW5zZm9ybTogXCJtYXRyaXgoMC44NjYsMC41LC0wLjUsMC44NjYsOS42OTMsLTUuMTczKVwiLCBzdHlsZTogeyBmaWxsOiBcIiMwMDAwMDBcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIHdCOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDM2IEMgMTIuMzksMzUuMDMgMTkuMTEsMzYuNDMgMjIuNSwzNCBDIDI1Ljg5LDM2LjQzIDMyLjYxLDM1LjAzIDM2LDM2IEMgMzYsMzYgMzcuNjUsMzYuNTQgMzksMzggQyAzOC4zMiwzOC45NyAzNy4zNSwzOC45OSAzNiwzOC41IEMgMzIuNjEsMzcuNTMgMjUuODksMzguOTYgMjIuNSwzNy41IEMgMTkuMTEsMzguOTYgMTIuMzksMzcuNTMgOSwzOC41IEMgNy42NSwzOC45OSA2LjY4LDM4Ljk3IDYsMzggQyA3LjM1LDM2LjU0IDksMzYgOSwzNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUsMzIgQyAxNy41LDM0LjUgMjcuNSwzNC41IDMwLDMyIEMgMzAuNSwzMC41IDMwLDMwIDMwLDMwIEMgMzAsMjcuNSAyNy41LDI2IDI3LjUsMjYgQyAzMywyNC41IDMzLjUsMTQuNSAyMi41LDEwLjUgQyAxMS41LDE0LjUgMTIsMjQuNSAxNy41LDI2IEMgMTcuNSwyNiAxNSwyNy41IDE1LDMwIEMgMTUsMzAgMTQuNSwzMC41IDE1LDMyIHpcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyNSA4IEEgMi41IDIuNSAwIDEgMSAgMjAsOCBBIDIuNSAyLjUgMCAxIDEgIDI1IDggelwiIH0pXSB9KSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTcuNSwyNiBMIDI3LjUsMjYgTSAxNSwzMCBMIDMwLDMwIE0gMjIuNSwxNS41IEwgMjIuNSwyMC41IE0gMjAsMTggTCAyNSwxOFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIHdROiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDI2IEMgMTcuNSwyNC41IDMwLDI0LjUgMzYsMjYgTCAzOC41LDEzLjUgTCAzMSwyNSBMIDMwLjcsMTAuOSBMIDI1LjUsMjQuNSBMIDIyLjUsMTAgTCAxOS41LDI0LjUgTCAxNC4zLDEwLjkgTCAxNCwyNSBMIDYuNSwxMy41IEwgOSwyNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwyNiBDIDksMjggMTAuNSwyOCAxMS41LDMwIEMgMTIuNSwzMS41IDEyLjUsMzEgMTIsMzMuNSBDIDEwLjUsMzQuNSAxMSwzNiAxMSwzNiBDIDkuNSwzNy41IDExLDM4LjUgMTEsMzguNSBDIDE3LjUsMzkuNSAyNy41LDM5LjUgMzQsMzguNSBDIDM0LDM4LjUgMzUuNSwzNy41IDM0LDM2IEMgMzQsMzYgMzQuNSwzNC41IDMzLDMzLjUgQyAzMi41LDMxIDMyLjUsMzEuNSAzMy41LDMwIEMgMzQuNSwyOCAzNiwyOCAzNiwyNiBDIDI3LjUsMjQuNSAxNy41LDI0LjUgOSwyNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEuNSwzMCBDIDE1LDI5IDMwLDI5IDMzLjUsMzBcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMiwzMy41IEMgMTgsMzIuNSAyNywzMi41IDMzLDMzLjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIgfSB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiNlwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMTRcIiwgY3k6IFwiOVwiLCByOiBcIjJcIiB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMjIuNVwiLCBjeTogXCI4XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzMVwiLCBjeTogXCI5XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzOVwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KV0gfSkpIH0pKSksXHJcbiAgICB3SzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDExLjYzIEwgMjIuNSw2XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjAsOCBMIDI1LDhcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIsIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDI1IEMgMjIuNSwyNSAyNywxNy41IDI1LjUsMTQuNSBDIDI1LjUsMTQuNSAyNC41LDEyIDIyLjUsMTIgQyAyMC41LDEyIDE5LjUsMTQuNSAxOS41LDE0LjUgQyAxOCwxNy41IDIyLjUsMjUgMjIuNSwyNVwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIiNmZmZmZmZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsNDAuNSAyNyw0MC41IDMyLjUsMzcgTCAzMi41LDMwIEMgMzIuNSwzMCA0MS41LDI1LjUgMzguNSwxOS41IEMgMzQuNSwxMyAyNSwxNiAyMi41LDIzLjUgTCAyMi41LDI3IEwgMjIuNSwyMy41IEMgMjAsMTYgMTAuNSwxMyA2LjUsMTkuNSBDIDMuNSwyNS41IDEyLjUsMzAgMTIuNSwzMCBMIDEyLjUsMzdcIiwgc3R5bGU6IHsgZmlsbDogXCIjZmZmZmZmXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIGJQOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSkgfSkpKSxcclxuICAgIGJSOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwzOSBMIDM2LDM5IEwgMzYsMzYgTCA5LDM2IEwgOSwzOSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzIgTCAxNCwyOS41IEwgMzEsMjkuNSBMIDMyLjUsMzIgTCAxMi41LDMyIHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIsMzYgTCAxMiwzMiBMIDMzLDMyIEwgMzMsMzYgTCAxMiwzNiB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE0LDI5LjUgTCAxNCwxNi41IEwgMzEsMTYuNSBMIDMxLDI5LjUgTCAxNCwyOS41IHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMTYuNSBMIDExLDE0IEwgMzQsMTQgTCAzMSwxNi41IEwgMTQsMTYuNSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLDE0IEwgMTEsOSBMIDE1LDkgTCAxNSwxMSBMIDIwLDExIEwgMjAsOSBMIDI1LDkgTCAyNSwxMSBMIDMwLDExIEwgMzAsOSBMIDM0LDkgTCAzNCwxNCBMIDExLDE0IHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIsMzUuNSBMIDMzLDM1LjUgTCAzMywzNS41XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMywzMS41IEwgMzIsMzEuNVwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiNmZmZmZmZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMjkuNSBMIDMxLDI5LjVcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE0LDE2LjUgTCAzMSwxNi41XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDM0LDE0XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KV0gfSkpIH0pKSksXHJcbiAgICBiTjogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU1pdGVybGltaXQ6IFwiNFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4XCIsIHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjQsMTggQyAyNC4zOCwyMC45MSAxOC40NSwyNS4zNyAxNiwyNyBDIDEzLDI5IDEzLjE4LDMxLjM0IDExLDMxIEMgOS45NTgsMzAuMDYgMTIuNDEsMjcuOTYgMTEsMjggQyAxMCwyOCAxMS4xOSwyOS4yMyAxMCwzMCBDIDksMzAgNS45OTcsMzEgNiwyNiBDIDYsMjQgMTIsMTQgMTIsMTQgQyAxMiwxNCAxMy44OSwxMi4xIDE0LDEwLjUgQyAxMy4yNyw5LjUwNiAxMy41LDguNSAxMy41LDcuNSBDIDE0LjUsNi41IDE2LjUsMTAgMTYuNSwxMCBMIDE4LjUsMTAgQyAxOC41LDEwIDE5LjI4LDguMDA4IDIxLDcgQyAyMiw3IDIyLDEwIDIyLDEwXCIsIHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gOS41IDI1LjUgQSAwLjUgMC41IDAgMSAxIDguNSwyNS41IEEgMC41IDAuNSAwIDEgMSA5LjUgMjUuNSB6XCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHpcIiwgdHJhbnNmb3JtOiBcIm1hdHJpeCgwLjg2NiwwLjUsLTAuNSwwLjg2Niw5LjY5MywtNS4xNzMpXCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogXCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwibm9uZVwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgYkI6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMzYgQyAxMi4zOSwzNS4wMyAxOS4xMSwzNi40MyAyMi41LDM0IEMgMjUuODksMzYuNDMgMzIuNjEsMzUuMDMgMzYsMzYgQyAzNiwzNiAzNy42NSwzNi41NCAzOSwzOCBDIDM4LjMyLDM4Ljk3IDM3LjM1LDM4Ljk5IDM2LDM4LjUgQyAzMi42MSwzNy41MyAyNS44OSwzOC45NiAyMi41LDM3LjUgQyAxOS4xMSwzOC45NiAxMi4zOSwzNy41MyA5LDM4LjUgQyA3LjY1LDM4Ljk5IDYuNjgsMzguOTcgNiwzOCBDIDcuMzUsMzYuNTQgOSwzNiA5LDM2IHpcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNSwzMiBDIDE3LjUsMzQuNSAyNy41LDM0LjUgMzAsMzIgQyAzMC41LDMwLjUgMzAsMzAgMzAsMzAgQyAzMCwyNy41IDI3LjUsMjYgMjcuNSwyNiBDIDMzLDI0LjUgMzMuNSwxNC41IDIyLjUsMTAuNSBDIDExLjUsMTQuNSAxMiwyNC41IDE3LjUsMjYgQyAxNy41LDI2IDE1LDI3LjUgMTUsMzAgQyAxNSwzMCAxNC41LDMwLjUgMTUsMzIgelwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDI1IDggQSAyLjUgMi41IDAgMSAxICAyMCw4IEEgMi41IDIuNSAwIDEgMSAgMjUgOCB6XCIgfSldIH0pKSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNy41LDI2IEwgMjcuNSwyNiBNIDE1LDMwIEwgMzAsMzAgTSAyMi41LDE1LjUgTCAyMi41LDIwLjUgTSAyMCwxOCBMIDI1LDE4XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgYlE6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMjYgQyAxNy41LDI0LjUgMzAsMjQuNSAzNiwyNiBMIDM4LjUsMTMuNSBMIDMxLDI1IEwgMzAuNywxMC45IEwgMjUuNSwyNC41IEwgMjIuNSwxMCBMIDE5LjUsMjQuNSBMIDE0LjMsMTAuOSBMIDE0LDI1IEwgNi41LDEzLjUgTCA5LDI2IHpcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsIGZpbGw6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIm0gOSwyNiBjIDAsMiAxLjUsMiAyLjUsNCAxLDEuNSAxLDEgMC41LDMuNSAtMS41LDEgLTEsMi41IC0xLDIuNSAtMS41LDEuNSAwLDIuNSAwLDIuNSA2LjUsMSAxNi41LDEgMjMsMCAwLDAgMS41LC0xIDAsLTIuNSAwLDAgMC41LC0xLjUgLTEsLTIuNSAtMC41LC0yLjUgLTAuNSwtMiAwLjUsLTMuNSAxLC0yIDIuNSwtMiAyLjUsLTQgLTguNSwtMS41IC0xOC41LC0xLjUgLTI3LDAgelwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLjUsMzAgQyAxNSwyOSAzMCwyOSAzMy41LDMwXCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIm0gMTIsMzMuNSBjIDYsLTEgMTUsLTEgMjEsMFwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCI2XCIsIGN5OiBcIjEyXCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIxNFwiLCBjeTogXCI5XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIyMi41XCIsIGN5OiBcIjhcIiwgcjogXCIyXCIgfSksIGpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjMxXCIsIGN5OiBcIjlcIiwgcjogXCIyXCIgfSksIGpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjM5XCIsIGN5OiBcIjEyXCIsIHI6IFwiMlwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLDM4LjUgQSAzNSwzNSAxIDAgMCAzNCwzOC41XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjZmZmZmZmXCIgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwyOSBBIDM1LDM1IDEgMCAxIDM0LDI5XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIuNSwzMS41IEwgMzIuNSwzMS41XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEuNSwzNC41IEEgMzUsMzUgMSAwIDAgMzMuNSwzNC41XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTAuNSwzNy41IEEgMzUsMzUgMSAwIDAgMzQuNSwzNy41XCIgfSldIH0pKV0gfSkpIH0pKSksXHJcbiAgICBiSzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDExLjYzIEwgMjIuNSw2XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0sIGlkOiBcInBhdGg2NTcwXCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjIuNSwyNSBDIDIyLjUsMjUgMjcsMTcuNSAyNS41LDE0LjUgQyAyNS41LDE0LjUgMjQuNSwxMiAyMi41LDEyIEMgMjAuNSwxMiAxOS41LDE0LjUgMTkuNSwxNC41IEMgMTgsMTcuNSAyMi41LDI1IDIyLjUsMjVcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsNDAuNSAyNyw0MC41IDMyLjUsMzcgTCAzMi41LDMwIEMgMzIuNSwzMCA0MS41LDI1LjUgMzguNSwxOS41IEMgMzQuNSwxMyAyNSwxNiAyMi41LDIzLjUgTCAyMi41LDI3IEwgMjIuNSwyMy41IEMgMjAsMTYgMTAuNSwxMyA2LjUsMTkuNSBDIDMuNSwyNS41IDEyLjUsMzAgMTIuNSwzMCBMIDEyLjUsMzdcIiwgc3R5bGU6IHsgZmlsbDogXCIjMDAwMDAwXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMCw4IEwgMjUsOFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMyLDI5LjUgQyAzMiwyOS41IDQwLjUsMjUuNSAzOC4wMywxOS44NSBDIDM0LjE1LDE0IDI1LDE4IDIyLjUsMjQuNSBMIDIyLjUsMjYuNiBMIDIyLjUsMjQuNSBDIDIwLDE4IDEwLjg1LDE0IDYuOTcsMTkuODUgQyA0LjUsMjUuNSAxMywyOS41IDEzLDI5LjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjZmZmZmZmXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMCBNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjUgTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiNmZmZmZmZcIiB9IH0pXSB9KSkgfSkpKSxcclxufTtcblxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgY29vcmRpbmF0ZXMgYXQgdGhlIGNlbnRyZSBvZiB0aGUgcmVxdWVzdGVkIHNxdWFyZSwgcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IG9mIHRoZSBib2FyZCAoMCwgMCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBzcXVhcmUpIHtcclxuICAgIGNvbnN0IHNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDg7XHJcbiAgICBjb25zdCBjb2x1bW5zID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiID8gV0hJVEVfQ09MVU1OX1ZBTFVFUyA6IEJMQUNLX0NPTFVNTl9WQUxVRVM7XHJcbiAgICBjb25zdCByb3dzID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiID8gV0hJVEVfUk9XUyA6IEJMQUNLX1JPV1M7XHJcbiAgICBjb25zdCB4ID0gY29sdW1uc1tzcXVhcmVbMF1dICogc3F1YXJlV2lkdGggKyBzcXVhcmVXaWR0aCAvIDI7XHJcbiAgICBjb25zdCB5ID0gcm93c1twYXJzZUludChzcXVhcmVbMV0sIDEwKSAtIDFdICogc3F1YXJlV2lkdGggKyBzcXVhcmVXaWR0aCAvIDI7XHJcbiAgICByZXR1cm4geyB4LCB5IH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGFzc2VkIHBvc2l0aW9uIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBzdGFydCBwb3NpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGlzRGlmZmVyZW50RnJvbVN0YXJ0KG5ld1Bvc2l0aW9uKSB7XHJcbiAgICBsZXQgaXNEaWZmZXJlbnQgPSBmYWxzZTtcclxuICAgIE9iamVjdC5rZXlzKFNUQVJUX1BPU0lUSU9OX09CSkVDVCkuZm9yRWFjaCgoc3F1YXJlKSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1Bvc2l0aW9uW3NxdWFyZV0gIT09IFNUQVJUX1BPU0lUSU9OX09CSkVDVFtzcXVhcmVdKVxyXG4gICAgICAgICAgICBpc0RpZmZlcmVudCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5rZXlzKG5ld1Bvc2l0aW9uKS5mb3JFYWNoKChzcXVhcmUpID0+IHtcclxuICAgICAgICBpZiAoU1RBUlRfUE9TSVRJT05fT0JKRUNUW3NxdWFyZV0gIT09IG5ld1Bvc2l0aW9uW3NxdWFyZV0pXHJcbiAgICAgICAgICAgIGlzRGlmZmVyZW50ID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGlzRGlmZmVyZW50O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoYXQgcGllY2VzIGhhdmUgYmVlbiBhZGRlZCBhbmQgd2hhdCBwaWVjZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYmV0d2VlbiBib2FyZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkRpZmZlcmVuY2VzKGN1cnJlbnRQb3NpdGlvbiwgbmV3UG9zaXRpb24pIHtcclxuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB7XHJcbiAgICAgICAgcmVtb3ZlZDoge30sXHJcbiAgICAgICAgYWRkZWQ6IHt9LFxyXG4gICAgfTtcclxuICAgIC8vIHJlbW92ZWQgZnJvbSBjdXJyZW50XHJcbiAgICBPYmplY3Qua2V5cyhjdXJyZW50UG9zaXRpb24pLmZvckVhY2goKHNxdWFyZSkgPT4ge1xyXG4gICAgICAgIGlmIChuZXdQb3NpdGlvbltzcXVhcmVdICE9PSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSlcclxuICAgICAgICAgICAgZGlmZmVyZW5jZS5yZW1vdmVkW3NxdWFyZV0gPSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXTtcclxuICAgIH0pO1xyXG4gICAgLy8gYWRkZWQgZnJvbSBuZXdcclxuICAgIE9iamVjdC5rZXlzKG5ld1Bvc2l0aW9uKS5mb3JFYWNoKChzcXVhcmUpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uW3NxdWFyZV0gIT09IG5ld1Bvc2l0aW9uW3NxdWFyZV0pXHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UuYWRkZWRbc3F1YXJlXSA9IG5ld1Bvc2l0aW9uW3NxdWFyZV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGZlbiBzdHJpbmcgb3IgZXhpc3RpbmcgcG9zaXRpb24gb2JqZWN0IHRvIGEgcG9zaXRpb24gb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFBvc2l0aW9uVG9PYmplY3QocG9zaXRpb24pIHtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFNUQVJUX1BPU0lUSU9OX09CSkVDVDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAvLyBhdHRlbXB0IHRvIGNvbnZlcnQgZmVuIHRvIHBvc2l0aW9uIG9iamVjdFxyXG4gICAgICAgIHJldHVybiBmZW5Ub09iaihwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgZmVuIHN0cmluZyB0byBhIHBvc2l0aW9uIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGZlblRvT2JqKGZlbikge1xyXG4gICAgaWYgKCFpc1ZhbGlkRmVuKGZlbikpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgLy8gY3V0IG9mZiBhbnkgbW92ZSwgY2FzdGxpbmcsIGV0YyBpbmZvIGZyb20gdGhlIGVuZC4gd2UncmUgb25seSBpbnRlcmVzdGVkIGluIHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICBmZW4gPSBmZW4ucmVwbGFjZSgvIC4rJC8sIFwiXCIpO1xyXG4gICAgY29uc3Qgcm93cyA9IGZlbi5zcGxpdChcIi9cIik7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xyXG4gICAgbGV0IGN1cnJlbnRSb3cgPSA4O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcclxuICAgICAgICBjb25zdCByb3cgPSByb3dzW2ldLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgIGxldCBjb2xJZHggPSAwO1xyXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiB0aGUgRkVOIHNlY3Rpb25cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAvLyBudW1iZXIgLyBlbXB0eSBzcXVhcmVzXHJcbiAgICAgICAgICAgIGlmIChyb3dbal0uc2VhcmNoKC9bMS04XS8pICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRW1wdHlTcXVhcmVzID0gcGFyc2VJbnQocm93W2pdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBjb2xJZHggPSBjb2xJZHggKyBudW1FbXB0eVNxdWFyZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwaWVjZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gQ09MVU1OU1tjb2xJZHhdICsgY3VycmVudFJvdztcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uW3NxdWFyZV0gPSBmZW5Ub1BpZWNlQ29kZShyb3dbal0pO1xyXG4gICAgICAgICAgICAgICAgY29sSWR4ID0gY29sSWR4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Um93ID0gY3VycmVudFJvdyAtIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBzdHJpbmcgaXMgdmFsaWQgZmVuIG5vdGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZEZlbihmZW4pIHtcclxuICAgIC8vIGN1dCBvZmYgYW55IG1vdmUsIGNhc3RsaW5nLCBldGMgaW5mbyBmcm9tIHRoZSBlbmQuIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgZmVuID0gZmVuLnJlcGxhY2UoLyAuKyQvLCBcIlwiKTtcclxuICAgIC8vIGV4cGFuZCB0aGUgZW1wdHkgc3F1YXJlIG51bWJlcnMgdG8ganVzdCAxc1xyXG4gICAgZmVuID0gZXhwYW5kRmVuRW1wdHlTcXVhcmVzKGZlbik7XHJcbiAgICAvLyBmZW4gc2hvdWxkIGJlIDggc2VjdGlvbnMgc2VwYXJhdGVkIGJ5IHNsYXNoZXNcclxuICAgIGNvbnN0IGNodW5rcyA9IGZlbi5zcGxpdChcIi9cIik7XHJcbiAgICBpZiAoY2h1bmtzLmxlbmd0aCAhPT0gOClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBjaGVjayBlYWNoIHNlY3Rpb25cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGNodW5rc1tpXS5sZW5ndGggIT09IDggfHwgY2h1bmtzW2ldLnNlYXJjaCgvW15rcXJuYnBLUVJOQlAxXS8pICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEV4cGFuZCBvdXQgZmVuIG5vdGF0aW9uIHRvIGNvdW50YWJsZSBjaGFyYWN0ZXJzIGZvciB2YWxpZGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBleHBhbmRGZW5FbXB0eVNxdWFyZXMoZmVuKSB7XHJcbiAgICByZXR1cm4gZmVuXHJcbiAgICAgICAgLnJlcGxhY2UoLzgvZywgXCIxMTExMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC83L2csIFwiMTExMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC82L2csIFwiMTExMTExXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoLzUvZywgXCIxMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC80L2csIFwiMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC8zL2csIFwiMTExXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoLzIvZywgXCIxMVwiKTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBmZW4gcGllY2UgY29kZSB0byBjYW1lbCBjYXNlIG5vdGF0aW9uLiBlLmcuIGJQLCB3Sy5cclxuICovXHJcbmZ1bmN0aW9uIGZlblRvUGllY2VDb2RlKHBpZWNlKSB7XHJcbiAgICAvLyBibGFjayBwaWVjZVxyXG4gICAgaWYgKHBpZWNlLnRvTG93ZXJDYXNlKCkgPT09IHBpZWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIChcImJcIiArIHBpZWNlLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgfVxyXG4gICAgLy8gd2hpdGUgcGllY2VcclxuICAgIHJldHVybiAoXCJ3XCIgKyBwaWVjZS50b1VwcGVyQ2FzZSgpKTtcclxufVxuXG5jb25zdCB1c2VBcnJvd3MgPSAoY3VzdG9tQXJyb3dzLCBhcmVBcnJvd3NBbGxvd2VkID0gdHJ1ZSwgb25BcnJvd3NDaGFuZ2UsIGN1c3RvbUFycm93Q29sb3IpID0+IHtcclxuICAgIC8vIGFycm93cyBwYXNzZWQgcHJvZ3JhbWF0aWNhbGx5IHRvIGBDaGVzc0JvYXJkYCBhcyBhIHJlYWN0IHByb3BcclxuICAgIGNvbnN0IFtjdXN0b21BcnJvd3NTZXQsIHNldEN1c3RvbUFycm93c10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgICAvLyBhcnJvd3MgZHJhd24gd2l0aCBtb3VzZSBieSB1c2VyIG9uIHRoZSBib2FyZFxyXG4gICAgY29uc3QgW2Fycm93cywgc2V0QXJyb3dzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIC8vIGFjdGl2ZSBhcnJvdyB3aGljaCB1c2VyIGRyYXdzIHdoaWxlIGRyYWdnaW5nIG1vdXNlXHJcbiAgICBjb25zdCBbbmV3QXJyb3csIHNldE5ld0Fycm93XSA9IHVzZVN0YXRlKCk7XHJcbiAgICAvLyBoYW5kbGUgZXh0ZXJuYWwgYGN1c3RvbUFycm93c2AgcHJvcHMgY2hhbmdlc1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21BcnJvd3MpKSB7XHJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgY3VzdG9tIGFycm93cyBvdmVyd3JpdGUgdGVtcG9yYXJ5IGFycm93c1xyXG4gICAgICAgICAgICBjbGVhckFycm93cygpO1xyXG4gICAgICAgICAgICBzZXRDdXN0b21BcnJvd3MoXHJcbiAgICAgICAgICAgIC8vZmlsdGVyIG91dCBhcnJvd3Mgd2hpY2ggc3RhcnRzIGFuZCBlbmRzIGluIHRoZSBzYW1lIHNxdWFyZVxyXG4gICAgICAgICAgICBjdXN0b21BcnJvd3MgPT09IG51bGwgfHwgY3VzdG9tQXJyb3dzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21BcnJvd3MuZmlsdGVyKChhcnJvdykgPT4gYXJyb3dbMF0gIT09IGFycm93WzFdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1c3RvbUFycm93c10pO1xyXG4gICAgLy8gY2FsbGJhY2sgd2hlbiBhcnJvd3MgY2hhbmdlZCBhZnRlciB1c2VyIGludGVyYWN0aW9uXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIG9uQXJyb3dzQ2hhbmdlID09PSBudWxsIHx8IG9uQXJyb3dzQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkFycm93c0NoYW5nZShhcnJvd3MpO1xyXG4gICAgfSwgW2Fycm93c10pO1xyXG4gICAgLy8gZnVuY3Rpb24gY2xlYXJzIGFsbCBhcnJvd3MgZHJhd2VkIGJ5IHVzZXJcclxuICAgIGZ1bmN0aW9uIGNsZWFyQXJyb3dzKCkge1xyXG4gICAgICAgIHNldEFycm93cyhbXSk7XHJcbiAgICAgICAgc2V0TmV3QXJyb3codW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRyYXdOZXdBcnJvdyA9IChmcm9tU3F1YXJlLCB0b1NxdWFyZSkgPT4ge1xyXG4gICAgICAgIGlmICghYXJlQXJyb3dzQWxsb3dlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHNldE5ld0Fycm93KFtmcm9tU3F1YXJlLCB0b1NxdWFyZSwgY3VzdG9tQXJyb3dDb2xvcl0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGFsbEJvYXJkQXJyb3dzID0gWy4uLmFycm93cywgLi4uY3VzdG9tQXJyb3dzU2V0XTtcclxuICAgIGNvbnN0IG9uQXJyb3dEcmF3RW5kID0gKGZyb21TcXVhcmUsIHRvU3F1YXJlKSA9PiB7XHJcbiAgICAgICAgaWYgKGZyb21TcXVhcmUgPT09IHRvU3F1YXJlIHx8ICFhcmVBcnJvd3NBbGxvd2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGFycm93c0NvcHk7XHJcbiAgICAgICAgY29uc3QgbmV3QXJyb3cgPSBbZnJvbVNxdWFyZSwgdG9TcXVhcmUsIGN1c3RvbUFycm93Q29sb3JdO1xyXG4gICAgICAgIGNvbnN0IGlzTmV3QXJyb3dVbmlxdWUgPSBhbGxCb2FyZEFycm93cy5ldmVyeSgoW2Fycm93RnJvbSwgYXJyb3dUb10pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuICEoYXJyb3dGcm9tID09PSBmcm9tU3F1YXJlICYmIGFycm93VG8gPT09IHRvU3F1YXJlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBhZGQgdGhlIG5ld0Fycm93IHRvIGFycm93cyBhcnJheSBpZiBpdCBpcyB1bmlxdWVcclxuICAgICAgICBpZiAoaXNOZXdBcnJvd1VuaXF1ZSkge1xyXG4gICAgICAgICAgICBhcnJvd3NDb3B5ID0gWy4uLmFycm93cywgbmV3QXJyb3ddO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgYm9hcmQgaWYgd2UgYWxyZWFkeSBoYXZlIHNhbWUgYXJyb3cgaW4gYXJyb3dzIGFycmF5XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFycm93c0NvcHkgPSBhcnJvd3MuZmlsdGVyKChbYXJyb3dGcm9tLCBhcnJvd1RvXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoYXJyb3dGcm9tID09PSBmcm9tU3F1YXJlICYmIGFycm93VG8gPT09IHRvU3F1YXJlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE5ld0Fycm93KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgc2V0QXJyb3dzKGFycm93c0NvcHkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXJyb3dzOiBhbGxCb2FyZEFycm93cyxcclxuICAgICAgICBuZXdBcnJvdyxcclxuICAgICAgICBjbGVhckFycm93cyxcclxuICAgICAgICBkcmF3TmV3QXJyb3csXHJcbiAgICAgICAgc2V0QXJyb3dzLFxyXG4gICAgICAgIG9uQXJyb3dEcmF3RW5kLFxyXG4gICAgfTtcclxufTtcblxuY29uc3QgQ2hlc3Nib2FyZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcclxuY29uc3QgdXNlQ2hlc3Nib2FyZCA9ICgpID0+IHVzZUNvbnRleHQoQ2hlc3Nib2FyZENvbnRleHQpO1xyXG5jb25zdCBDaGVzc2JvYXJkUHJvdmlkZXIgPSBmb3J3YXJkUmVmKCh7IGFsbG93RHJhZ091dHNpZGVCb2FyZCA9IHRydWUsIGFuaW1hdGlvbkR1cmF0aW9uID0gMzAwLCBhcmVBcnJvd3NBbGxvd2VkID0gdHJ1ZSwgYXJlUGllY2VzRHJhZ2dhYmxlID0gdHJ1ZSwgYXJlUHJlbW92ZXNBbGxvd2VkID0gZmFsc2UsIGF1dG9Qcm9tb3RlVG9RdWVlbiA9IGZhbHNlLCBib2FyZE9yaWVudGF0aW9uID0gXCJ3aGl0ZVwiLCBib2FyZFdpZHRoLCBjaGlsZHJlbiwgY2xlYXJQcmVtb3Zlc09uUmlnaHRDbGljayA9IHRydWUsIGN1c3RvbUFycm93cywgY3VzdG9tQXJyb3dDb2xvciA9IFwicmdiKDI1NSwxNzAsMClcIiwgY3VzdG9tQm9hcmRTdHlsZSwgY3VzdG9tTm90YXRpb25TdHlsZSwgY3VzdG9tRGFya1NxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0I1ODg2M1wiIH0sIGN1c3RvbURyb3BTcXVhcmVTdHlsZSA9IHtcclxuICAgIGJveFNoYWRvdzogXCJpbnNldCAwIDAgMXB4IDZweCByZ2JhKDI1NSwyNTUsMjU1LDAuNzUpXCIsXHJcbn0sIGN1c3RvbUxpZ2h0U3F1YXJlU3R5bGUgPSB7IGJhY2tncm91bmRDb2xvcjogXCIjRjBEOUI1XCIgfSwgY3VzdG9tUGllY2VzLCBjdXN0b21QcmVtb3ZlRGFya1NxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0E0MjMyM1wiIH0sIGN1c3RvbVByZW1vdmVMaWdodFNxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0JEMjgyOFwiIH0sIGN1c3RvbVNxdWFyZSA9IFwiZGl2XCIsIGN1c3RvbVNxdWFyZVN0eWxlcywgZHJvcE9mZkJvYXJkQWN0aW9uID0gXCJzbmFwYmFja1wiLCBpZCA9IDAsIGlzRHJhZ2dhYmxlUGllY2UgPSAoKSA9PiB0cnVlLCBnZXRQb3NpdGlvbk9iamVjdCA9ICgpID0+IHsgfSwgb25BcnJvd3NDaGFuZ2UgPSAoKSA9PiB7IH0sIG9uRHJhZ092ZXJTcXVhcmUgPSAoKSA9PiB7IH0sIG9uTW91c2VPdXRTcXVhcmUgPSAoKSA9PiB7IH0sIG9uTW91c2VPdmVyU3F1YXJlID0gKCkgPT4geyB9LCBvblBpZWNlQ2xpY2sgPSAoKSA9PiB7IH0sIG9uUGllY2VEcmFnQmVnaW4gPSAoKSA9PiB7IH0sIG9uUGllY2VEcmFnRW5kID0gKCkgPT4geyB9LCBvblBpZWNlRHJvcCA9ICgpID0+IHRydWUsIG9uUGllY2VEcm9wT2ZmQm9hcmQgPSAoKSA9PiB7IH0sIG9uUHJvbW90aW9uQ2hlY2sgPSAoc291cmNlU3F1YXJlLCB0YXJnZXRTcXVhcmUsIHBpZWNlKSA9PiB7XHJcbiAgICByZXR1cm4gKCgocGllY2UgPT09IFwid1BcIiAmJlxyXG4gICAgICAgIHNvdXJjZVNxdWFyZVsxXSA9PT0gXCI3XCIgJiZcclxuICAgICAgICB0YXJnZXRTcXVhcmVbMV0gPT09IFwiOFwiKSB8fFxyXG4gICAgICAgIChwaWVjZSA9PT0gXCJiUFwiICYmXHJcbiAgICAgICAgICAgIHNvdXJjZVNxdWFyZVsxXSA9PT0gXCIyXCIgJiZcclxuICAgICAgICAgICAgdGFyZ2V0U3F1YXJlWzFdID09PSBcIjFcIikpICYmXHJcbiAgICAgICAgTWF0aC5hYnMoc291cmNlU3F1YXJlLmNoYXJDb2RlQXQoMCkgLSB0YXJnZXRTcXVhcmUuY2hhckNvZGVBdCgwKSkgPD0gMSk7XHJcbn0sIG9uUHJvbW90aW9uUGllY2VTZWxlY3QgPSAoKSA9PiB0cnVlLCBvblNwYXJlUGllY2VEcm9wID0gKCkgPT4gdHJ1ZSwgb25TcXVhcmVDbGljayA9ICgpID0+IHsgfSwgb25TcXVhcmVSaWdodENsaWNrID0gKCkgPT4geyB9LCBwb3NpdGlvbiA9IFwic3RhcnRcIiwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCA9IFwiZGVmYXVsdFwiLCBwcm9tb3Rpb25Ub1NxdWFyZSA9IG51bGwsIHNob3dCb2FyZE5vdGF0aW9uID0gdHJ1ZSwgc2hvd1Byb21vdGlvbkRpYWxvZyA9IGZhbHNlLCBzbmFwVG9DdXJzb3IgPSB0cnVlLCB9LCByZWYpID0+IHtcclxuICAgIC8vIHBvc2l0aW9uIHN0b3JlZCBhbmQgZGlzcGxheWVkIG9uIGJvYXJkXHJcbiAgICBjb25zdCBbY3VycmVudFBvc2l0aW9uLCBzZXRDdXJyZW50UG9zaXRpb25dID0gdXNlU3RhdGUoY29udmVydFBvc2l0aW9uVG9PYmplY3QocG9zaXRpb24pKTtcclxuICAgIC8vIGNhbGN1bGF0ZWQgZGlmZmVyZW5jZXMgYmV0d2VlbiBjdXJyZW50IGFuZCBpbmNvbWluZyBwb3NpdGlvbnNcclxuICAgIGNvbnN0IFtwb3NpdGlvbkRpZmZlcmVuY2VzLCBzZXRQb3NpdGlvbkRpZmZlcmVuY2VzXSA9IHVzZVN0YXRlKHsgcmVtb3ZlZDoge30sIGFkZGVkOiB7fSB9KTtcclxuICAgIC8vIGNvbG91ciBvZiBsYXN0IHBpZWNlIG1vdmVkIHRvIGRldGVybWluZSBpZiBwcmVtb3ZpbmdcclxuICAgIGNvbnN0IFtsYXN0UGllY2VDb2xvdXIsIHNldExhc3RQaWVjZUNvbG91cl0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xyXG4gICAgLy8gc2hvdyAvIGhpZGUgcHJvbW90aW9uIGRpYWxvZ1xyXG4gICAgY29uc3QgW3Nob3dQcm9tb3RlRGlhbG9nLCBzZXRTaG93UHJvbW90ZURpYWxvZ10gPSB1c2VTdGF0ZShzaG93UHJvbW90aW9uRGlhbG9nICYmICFhdXRvUHJvbW90ZVRvUXVlZW4pO1xyXG4gICAgLy8gd2hpY2ggc3F1YXJlIGEgcGF3biBpcyBiZWluZyBwcm9tb3RlZCB0b1xyXG4gICAgY29uc3QgW3Byb21vdGVGcm9tU3F1YXJlLCBzZXRQcm9tb3RlRnJvbVNxdWFyZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtwcm9tb3RlVG9TcXVhcmUsIHNldFByb21vdGVUb1NxdWFyZV0gPSB1c2VTdGF0ZShwcm9tb3Rpb25Ub1NxdWFyZSk7XHJcbiAgICAvLyBjdXJyZW50IHByZW1vdmVzXHJcbiAgICBjb25zdCBbcHJlbW92ZXMsIHNldFByZW1vdmVzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIC8vIHJlZiB1c2VkIHRvIGFjY2VzcyBjdXJyZW50IHZhbHVlIGR1cmluZyB0aW1lb3V0cyAoY2xvc3VyZXMpXHJcbiAgICBjb25zdCBwcmVtb3Zlc1JlZiA9IHVzZVJlZihwcmVtb3Zlcyk7XHJcbiAgICAvLyBjdXJyZW50IHJpZ2h0IG1vdXNlIGRvd24gc3F1YXJlXHJcbiAgICBjb25zdCBbY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzZXRDdXJyZW50UmlnaHRDbGlja0Rvd25dID0gdXNlU3RhdGUoKTtcclxuICAgIC8vIGNoZXNzIHBpZWNlcy9zdHlsaW5nXHJcbiAgICBjb25zdCBbY2hlc3NQaWVjZXMsIHNldENoZXNzUGllY2VzXSA9IHVzZVN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBpZWNlcyksIGN1c3RvbVBpZWNlcykpO1xyXG4gICAgLy8gd2hldGhlciB0aGUgbGFzdCBtb3ZlIHdhcyBhIG1hbnVhbCBkcm9wIG9yIG5vdFxyXG4gICAgY29uc3QgW3dhc01hbnVhbERyb3AsIHNldFdhc01hbnVhbERyb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgLy8gdGhlIG1vc3QgcmVjZW50IHRpbWVvdXQgd2hpbHN0IHdhaXRpbmcgZm9yIGFuaW1hdGlvbiB0byBjb21wbGV0ZVxyXG4gICAgY29uc3QgW3ByZXZpb3VzVGltZW91dCwgc2V0UHJldmlvdXNUaW1lb3V0XSA9IHVzZVN0YXRlKCk7XHJcbiAgICAvLyBpZiBjdXJyZW50bHkgd2FpdGluZyBmb3IgYW4gYW5pbWF0aW9uIHRvIGZpbmlzaFxyXG4gICAgY29uc3QgW2lzV2FpdGluZ0ZvckFuaW1hdGlvbiwgc2V0SXNXYWl0aW5nRm9yQW5pbWF0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIC8vIGxhc3Qgc3F1YXJlIGRyYWdnZWQgb3ZlciBmb3IgY2hlY2tpbmcgaW4gdG91Y2ggZXZlbnRzXHJcbiAgICBjb25zdCBbbGFzdFNxdWFyZURyYWdnZWRPdmVyLCBzZXRMYXN0U3F1YXJlRHJhZ2dlZE92ZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAvLyBvcGVuIGNsZWFyUHJlbW92ZXMoKSB0byBhbGxvdyB1c2VyIHRvIGNhbGwgb24gdW5kby9yZXNldC93aGVuZXZlclxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XHJcbiAgICAgICAgY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91ciA9IHRydWUpIHtcclxuICAgICAgICAgICAgY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91cik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pKTtcclxuICAgIC8vIGhhbmRsZSBjdXN0b20gcGllY2VzIGNoYW5nZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRDaGVzc1BpZWNlcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQaWVjZXMpLCBjdXN0b21QaWVjZXMpKTtcclxuICAgIH0sIFtjdXN0b21QaWVjZXNdKTtcclxuICAgIC8vIGhhbmRsZSBwcm9tb3RlIGNoYW5nZXNcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2coc2hvd1Byb21vdGlvbkRpYWxvZyk7XHJcbiAgICAgICAgc2V0UHJvbW90ZVRvU3F1YXJlKHByb21vdGlvblRvU3F1YXJlKTtcclxuICAgIH0sIFtwcm9tb3Rpb25Ub1NxdWFyZSwgc2hvd1Byb21vdGlvbkRpYWxvZ10pO1xyXG4gICAgLy8gaGFuZGxlIGV4dGVybmFsIHBvc2l0aW9uIGNoYW5nZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAvLyBjbGVhciBhbnkgb3BlbiBwcm9tb3Rpb24gZGlhbG9nc1xyXG4gICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBjb252ZXJ0UG9zaXRpb25Ub09iamVjdChwb3NpdGlvbik7XHJcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZXMgPSBnZXRQb3NpdGlvbkRpZmZlcmVuY2VzKGN1cnJlbnRQb3NpdGlvbiwgbmV3UG9zaXRpb24pO1xyXG4gICAgICAgIGNvbnN0IG5ld1BpZWNlQ29sb3VyID0gKChfYSA9IE9iamVjdC5rZXlzKGRpZmZlcmVuY2VzLmFkZGVkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPD0gMlxyXG4gICAgICAgICAgICA/IChfYyA9IChfYiA9IE9iamVjdC5lbnRyaWVzKGRpZmZlcmVuY2VzLmFkZGVkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMV1bMF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gZXh0ZXJuYWwgbW92ZSBoYXMgY29tZSBpbiBiZWZvcmUgYW5pbWF0aW9uIGlzIG92ZXJcclxuICAgICAgICAvLyBjYW5jZWwgYW5pbWF0aW9uIGFuZCBpbW1lZGlhdGVseSB1cGRhdGUgcG9zaXRpb25cclxuICAgICAgICBpZiAoaXNXYWl0aW5nRm9yQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHNldElzV2FpdGluZ0ZvckFuaW1hdGlvbihmYWxzZSk7XHJcbiAgICAgICAgICAgIGFyZVByZW1vdmVzQWxsb3dlZCAmJiBhdHRlbXB0UHJlbW92ZShuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwcmV2aW91c1RpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBtb3ZlIHdhcyBtYWRlIHVzaW5nIGRyYWcgYW5kIGRyb3BcclxuICAgICAgICAgICAgaWYgKHdhc01hbnVhbERyb3ApIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYXJlUHJlbW92ZXNBbGxvd2VkICYmIGF0dGVtcHRQcmVtb3ZlKG5ld1BpZWNlQ29sb3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgd2FzIG1hZGUgYnkgZXh0ZXJuYWwgcG9zaXRpb24gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBwb3NpdGlvbiA9PT0gc3RhcnQgdGhlbiBkb24ndCBvdmVycmlkZSBuZXdQaWVjZUNvbG91clxyXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgaXNEaWZmZXJlbnRGcm9tU3RhcnQgaW4gc2NlbmFyaW8gd2hlcmUgcHJlbW92ZXMgaGF2ZSBiZWVuIGNsZWFyZWQgdXBvbiBib2FyZCByZXNldCBidXQgZmlyc3QgbW92ZSBpcyBtYWRlIGJ5IGNvbXB1dGVyLCB0aGUgbGFzdCBtb3ZlIGNvbG91ciB3b3VsZCBuZWVkIHRvIGJlIHVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmIChpc0RpZmZlcmVudEZyb21TdGFydChuZXdQb3NpdGlvbikgJiZcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGllY2VDb2xvdXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RQaWVjZUNvbG91cihuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEaWZmZXJlbnRGcm9tU3RhcnQobmV3UG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gPT09IHN0YXJ0LCBsaWtlbHkgYSBib2FyZCByZXNldC4gc2V0IHRvIGJsYWNrIHRvIGFsbG93IGJsYWNrIHRvIG1ha2UgcHJlbW92ZXMgb24gZmlyc3QgbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RQaWVjZUNvbG91cihcImJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRMYXN0UGllY2VDb2xvdXIodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldFBvc2l0aW9uRGlmZmVyZW5jZXMoZGlmZmVyZW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gYW5pbWF0ZSBleHRlcm5hbCBtb3ZlXHJcbiAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZVByZW1vdmVzQWxsb3dlZCAmJiBhdHRlbXB0UHJlbW92ZShuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzZXRQcmV2aW91c1RpbWVvdXQobmV3VGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzZXQgbWFudWFsIGRyb3AsIHJlYWR5IGZvciBuZXh0IG1vdmUgdG8gYmUgbWFkZSBieSB1c2VyIG9yIGV4dGVybmFsXHJcbiAgICAgICAgc2V0V2FzTWFudWFsRHJvcChmYWxzZSk7XHJcbiAgICAgICAgLy8gaW5mb3JtIGxhdGVzdCBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgIGdldFBvc2l0aW9uT2JqZWN0KG5ld1Bvc2l0aW9uKTtcclxuICAgICAgICAvLyBjbGVhciBhcnJvd3NcclxuICAgICAgICBjbGVhckFycm93cygpO1xyXG4gICAgICAgIC8vIGNsZWFyIHRpbWVvdXQgb24gdW5tb3VudFxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwcmV2aW91c1RpbWVvdXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcG9zaXRpb25dKTtcclxuICAgIGNvbnN0IHsgYXJyb3dzLCBuZXdBcnJvdywgY2xlYXJBcnJvd3MsIGRyYXdOZXdBcnJvdywgb25BcnJvd0RyYXdFbmQgfSA9IHVzZUFycm93cyhjdXN0b21BcnJvd3MsIGFyZUFycm93c0FsbG93ZWQsIG9uQXJyb3dzQ2hhbmdlLCBjdXN0b21BcnJvd0NvbG9yKTtcclxuICAgIC8vIGhhbmRsZSBkcm9wIHBvc2l0aW9uIGNoYW5nZVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU2V0UG9zaXRpb24oc291cmNlU3EsIHRhcmdldFNxLCBwaWVjZSwgd2FzTWFudWFsRHJvcE92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy8gaWYgZHJvcHBlZCBiYWNrIGRvd24sIGRvbid0IGRvIGFueXRoaW5nXHJcbiAgICAgICAgaWYgKHNvdXJjZVNxID09PSB0YXJnZXRTcSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyQXJyb3dzKCk7XHJcbiAgICAgICAgLy8gaWYgc2Vjb25kIG1vdmUgaXMgbWFkZSBmb3Igc2FtZSBjb2xvdXIsIG9yIHRoZXJlIGFyZSBzdGlsbCBwcmVtb3ZlcyBxdWV1ZWQsIHRoZW4gdGhpcyBtb3ZlIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHByZW1vdmUgcXVldWUgaW5zdGVhZCBvZiBwbGF5ZWRcclxuICAgICAgICAvLyBwcmVtb3ZlcyBsZW5ndGggY2hlY2sgZm9yIGNvbG91ciBpcyBhZGRlZCBpbiBiZWNhdXNlIHdoaXRlIGNvdWxkIG1ha2UgMyBwcmVtb3ZlcywgYW5kIHRoZW4gYmxhY2sgcmVzcG9uZHMgdG8gdGhlIGZpcnN0IG1vdmUgKGNoYW5naW5nIHRoZSBsYXN0IHBpZWNlIGNvbG91cikgYW5kIHRoZW4gd2hpdGUgcHJlLW1vdmVzIGFnYWluXHJcbiAgICAgICAgaWYgKChhcmVQcmVtb3Zlc0FsbG93ZWQgJiYgaXNXYWl0aW5nRm9yQW5pbWF0aW9uKSB8fFxyXG4gICAgICAgICAgICAoYXJlUHJlbW92ZXNBbGxvd2VkICYmXHJcbiAgICAgICAgICAgICAgICAobGFzdFBpZWNlQ29sb3VyID09PSBwaWVjZVswXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQuZmlsdGVyKChwKSA9PiBwLnBpZWNlWzBdID09PSBwaWVjZVswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCA+IDApKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRQcmVtb3ZlcyA9IFsuLi5wcmVtb3Zlc1JlZi5jdXJyZW50XTtcclxuICAgICAgICAgICAgb2xkUHJlbW92ZXMucHVzaCh7IHNvdXJjZVNxLCB0YXJnZXRTcSwgcGllY2UgfSk7XHJcbiAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQgPSBvbGRQcmVtb3ZlcztcclxuICAgICAgICAgICAgc2V0UHJlbW92ZXMoWy4uLm9sZFByZW1vdmVzXSk7XHJcbiAgICAgICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdHJhbnNpdGlvbmluZywgZG9uJ3QgYWxsb3cgbmV3IGRyb3BcclxuICAgICAgICBpZiAoIWFyZVByZW1vdmVzQWxsb3dlZCAmJiBpc1dhaXRpbmdGb3JBbmltYXRpb24pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBuZXdPbkRyb3BQb3NpdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRQb3NpdGlvbik7XHJcbiAgICAgICAgc2V0V2FzTWFudWFsRHJvcCghIXdhc01hbnVhbERyb3BPdmVycmlkZSk7XHJcbiAgICAgICAgc2V0TGFzdFBpZWNlQ29sb3VyKHBpZWNlWzBdKTtcclxuICAgICAgICAvLyBpZiBvblBpZWNlRHJvcCBmdW5jdGlvbiBwcm92aWRlZCwgZXhlY3V0ZSBpdCwgcG9zaXRpb24gbXVzdCBiZSB1cGRhdGVkIGV4dGVybmFsbHkgYW5kIGNhcHR1cmVkIGJ5IHVzZUVmZmVjdCBhYm92ZSBmb3IgdGhpcyBtb3ZlIHRvIHNob3cgb24gYm9hcmRcclxuICAgICAgICBpZiAob25QaWVjZURyb3AubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRNb3ZlID0gb25QaWVjZURyb3Aoc291cmNlU3EsIHRhcmdldFNxLCBwaWVjZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyUHJlbW92ZXMoKTtcclxuICAgICAgICAgICAgICAgIHNldFdhc01hbnVhbERyb3AoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgc291cmNlIHBpZWNlXHJcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdPbkRyb3BQb3NpdGlvbltzb3VyY2VTcV07XHJcbiAgICAgICAgICAgIC8vIGFkZCBwaWVjZSBpbiBuZXcgcG9zaXRpb25cclxuICAgICAgICAgICAgbmV3T25Ecm9wUG9zaXRpb25bdGFyZ2V0U3FdID0gcGllY2U7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdPbkRyb3BQb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgLy8gaW5mb3JtIGxhdGVzdCBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgIGdldFBvc2l0aW9uT2JqZWN0KG5ld09uRHJvcFBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZShzcXVhcmUpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50UG9zaXRpb24pO1xyXG4gICAgICAgIGRlbGV0ZSBwb3NpdGlvbkNvcHlbc3F1YXJlXTtcclxuICAgICAgICBzZXRDdXJyZW50UG9zaXRpb24ocG9zaXRpb25Db3B5KTtcclxuICAgICAgICAvLyBpbmZvcm0gbGF0ZXN0IHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICAgICAgZ2V0UG9zaXRpb25PYmplY3QocG9zaXRpb25Db3B5KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGF0dGVtcHRQcmVtb3ZlKG5ld1BpZWNlQ29sb3VyKSB7XHJcbiAgICAgICAgaWYgKHByZW1vdmVzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgdmFsdWUgb2YgcHJlbW92ZSBhcyB0aGlzIGlzIGNhbGxlZCBpbiBhIHRpbWVvdXQgc28gdmFsdWUgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB0aW1lb3V0IHdhcyBzZXRcclxuICAgICAgICBjb25zdCBwcmVtb3ZlID0gcHJlbW92ZXNSZWYuY3VycmVudFswXTtcclxuICAgICAgICAvLyBpZiBwcmVtb3ZlIGlzIGEgZGlmZmVyaW5nIGNvbG91ciB0byBsYXN0IG1vdmUgbWFkZSwgdGhlbiB0aGlzIG1vdmUgY2FuIGJlIG1hZGVcclxuICAgICAgICBpZiAocHJlbW92ZS5waWVjZVswXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHByZW1vdmUucGllY2VbMF0gIT09IG5ld1BpZWNlQ29sb3VyICYmXHJcbiAgICAgICAgICAgIG9uUGllY2VEcm9wLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzZXRMYXN0UGllY2VDb2xvdXIocHJlbW92ZS5waWVjZVswXSk7XHJcbiAgICAgICAgICAgIHNldFdhc01hbnVhbERyb3AodHJ1ZSk7IC8vIHByZS1tb3ZlIGRvZXNuJ3QgbmVlZCBhbmltYXRpb25cclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZE1vdmUgPSBvblBpZWNlRHJvcChwcmVtb3ZlLnNvdXJjZVNxLCBwcmVtb3ZlLnRhcmdldFNxLCBwcmVtb3ZlLnBpZWNlKTtcclxuICAgICAgICAgICAgLy8gcHJlbW92ZSB3YXMgc3VjY2Vzc2Z1bCBhbmQgY2FuIGJlIHJlbW92ZWQgZnJvbSBxdWV1ZVxyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFByZW1vdmVzID0gWy4uLnByZW1vdmVzUmVmLmN1cnJlbnRdO1xyXG4gICAgICAgICAgICAgICAgb2xkUHJlbW92ZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQgPSBvbGRQcmVtb3ZlcztcclxuICAgICAgICAgICAgICAgIHNldFByZW1vdmVzKFsuLi5vbGRQcmVtb3Zlc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlbW92ZSB3YXNuJ3Qgc3VjY2Vzc2Z1bCwgY2xlYXIgcHJlbW92ZSBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgY2xlYXJQcmVtb3ZlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU3BhcmVQaWVjZURyb3AocGllY2UsIHRhcmdldFNxKSB7XHJcbiAgICAgICAgY29uc3QgaXNWYWxpZERyb3AgPSBvblNwYXJlUGllY2VEcm9wKHBpZWNlLCB0YXJnZXRTcSk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkRHJvcClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IG5ld09uRHJvcFBvc2l0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFBvc2l0aW9uKTtcclxuICAgICAgICAvLyBhZGQgcGllY2UgaW4gbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgbmV3T25Ecm9wUG9zaXRpb25bdGFyZ2V0U3FdID0gcGllY2U7XHJcbiAgICAgICAgc2V0Q3VycmVudFBvc2l0aW9uKG5ld09uRHJvcFBvc2l0aW9uKTtcclxuICAgICAgICAvLyBpbmZvcm0gbGF0ZXN0IHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICAgICAgZ2V0UG9zaXRpb25PYmplY3QobmV3T25Ecm9wUG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91ciA9IHRydWUpIHtcclxuICAgICAgICAvLyBkb24ndCBjbGVhciB3aGVuIHJpZ2h0IGNsaWNraW5nIHRvIGNsZWFyLCBvdGhlcndpc2UgeW91IHdvbid0IGJlIGFibGUgdG8gcHJlbW92ZSBhZ2FpbiBiZWZvcmUgbmV4dCBnb1xyXG4gICAgICAgIGlmIChjbGVhckxhc3RQaWVjZUNvbG91cilcclxuICAgICAgICAgICAgc2V0TGFzdFBpZWNlQ29sb3VyKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgcHJlbW92ZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICAgIHNldFByZW1vdmVzKFtdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyUHJvbW90aW9uKCkge1xyXG4gICAgICAgIHNldFByb21vdGVGcm9tU3F1YXJlKG51bGwpO1xyXG4gICAgICAgIHNldFByb21vdGVUb1NxdWFyZShudWxsKTtcclxuICAgICAgICBzZXRTaG93UHJvbW90ZURpYWxvZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2tEb3duKHNxdWFyZSkge1xyXG4gICAgICAgIHNldEN1cnJlbnRSaWdodENsaWNrRG93bihzcXVhcmUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25SaWdodENsaWNrVXAoc3F1YXJlKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRSaWdodENsaWNrRG93bikge1xyXG4gICAgICAgICAgICAvLyBzYW1lIHNxdWFyZSwgZG9uJ3QgZHJhdyBhbiBhcnJvdywgYnV0IGRvIGNsZWFyIHByZW1vdmVzIGFuZCBydW4gb25TcXVhcmVSaWdodENsaWNrXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UmlnaHRDbGlja0Rvd24gPT09IHNxdWFyZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFJpZ2h0Q2xpY2tEb3duKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclByZW1vdmVzT25SaWdodENsaWNrICYmIGNsZWFyUHJlbW92ZXMoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgb25TcXVhcmVSaWdodENsaWNrKHNxdWFyZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzZXRDdXJyZW50UmlnaHRDbGlja0Rvd24odW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyQ3VycmVudFJpZ2h0Q2xpY2tEb3duKCkge1xyXG4gICAgICAgIHNldEN1cnJlbnRSaWdodENsaWNrRG93bih1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgQ2hlc3Nib2FyZFByb3ZpZGVyQ29udGV4dFZhbHVlID0ge1xyXG4gICAgICAgIGFsbG93RHJhZ091dHNpZGVCb2FyZCxcclxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICBhcmVQaWVjZXNEcmFnZ2FibGUsXHJcbiAgICAgICAgYXJlUHJlbW92ZXNBbGxvd2VkLFxyXG4gICAgICAgIGFycm93cyxcclxuICAgICAgICBhdXRvUHJvbW90ZVRvUXVlZW4sXHJcbiAgICAgICAgYm9hcmRPcmllbnRhdGlvbixcclxuICAgICAgICBib2FyZFdpZHRoLFxyXG4gICAgICAgIGNoZXNzUGllY2VzLFxyXG4gICAgICAgIGNsZWFyQXJyb3dzLFxyXG4gICAgICAgIGNsZWFyQ3VycmVudFJpZ2h0Q2xpY2tEb3duLFxyXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbixcclxuICAgICAgICBjdXJyZW50UmlnaHRDbGlja0Rvd24sXHJcbiAgICAgICAgY3VzdG9tQXJyb3dDb2xvcixcclxuICAgICAgICBjdXN0b21Cb2FyZFN0eWxlLFxyXG4gICAgICAgIGN1c3RvbURhcmtTcXVhcmVTdHlsZSxcclxuICAgICAgICBjdXN0b21Ecm9wU3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSxcclxuICAgICAgICBjdXN0b21Ob3RhdGlvblN0eWxlLFxyXG4gICAgICAgIGN1c3RvbVByZW1vdmVEYXJrU3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tUHJlbW92ZUxpZ2h0U3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tU3F1YXJlLFxyXG4gICAgICAgIGN1c3RvbVNxdWFyZVN0eWxlcyxcclxuICAgICAgICBkZWxldGVQaWVjZUZyb21TcXVhcmUsXHJcbiAgICAgICAgZHJhd05ld0Fycm93LFxyXG4gICAgICAgIGRyb3BPZmZCb2FyZEFjdGlvbixcclxuICAgICAgICBoYW5kbGVTZXRQb3NpdGlvbixcclxuICAgICAgICBoYW5kbGVTcGFyZVBpZWNlRHJvcCxcclxuICAgICAgICBpZCxcclxuICAgICAgICBpc0RyYWdnYWJsZVBpZWNlLFxyXG4gICAgICAgIGlzV2FpdGluZ0ZvckFuaW1hdGlvbixcclxuICAgICAgICBsYXN0UGllY2VDb2xvdXIsXHJcbiAgICAgICAgbGFzdFNxdWFyZURyYWdnZWRPdmVyLFxyXG4gICAgICAgIG5ld0Fycm93LFxyXG4gICAgICAgIG9uQXJyb3dEcmF3RW5kLFxyXG4gICAgICAgIG9uRHJhZ092ZXJTcXVhcmUsXHJcbiAgICAgICAgb25Nb3VzZU91dFNxdWFyZSxcclxuICAgICAgICBvbk1vdXNlT3ZlclNxdWFyZSxcclxuICAgICAgICBvblBpZWNlQ2xpY2ssXHJcbiAgICAgICAgb25QaWVjZURyYWdCZWdpbixcclxuICAgICAgICBvblBpZWNlRHJhZ0VuZCxcclxuICAgICAgICBvblBpZWNlRHJvcCxcclxuICAgICAgICBvblBpZWNlRHJvcE9mZkJvYXJkLFxyXG4gICAgICAgIG9uUHJvbW90aW9uQ2hlY2ssXHJcbiAgICAgICAgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCxcclxuICAgICAgICBvblJpZ2h0Q2xpY2tEb3duLFxyXG4gICAgICAgIG9uUmlnaHRDbGlja1VwLFxyXG4gICAgICAgIG9uU3BhcmVQaWVjZURyb3AsXHJcbiAgICAgICAgb25TcXVhcmVDbGljayxcclxuICAgICAgICBwb3NpdGlvbkRpZmZlcmVuY2VzLFxyXG4gICAgICAgIHByZW1vdmVzLFxyXG4gICAgICAgIHByb21vdGVGcm9tU3F1YXJlLFxyXG4gICAgICAgIHByb21vdGVUb1NxdWFyZSxcclxuICAgICAgICBwcm9tb3Rpb25EaWFsb2dWYXJpYW50LFxyXG4gICAgICAgIHNldExhc3RTcXVhcmVEcmFnZ2VkT3ZlcixcclxuICAgICAgICBzZXRQcm9tb3RlRnJvbVNxdWFyZSxcclxuICAgICAgICBzZXRQcm9tb3RlVG9TcXVhcmUsXHJcbiAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2csXHJcbiAgICAgICAgc2hvd0JvYXJkTm90YXRpb24sXHJcbiAgICAgICAgc2hvd1Byb21vdGVEaWFsb2csXHJcbiAgICAgICAgc25hcFRvQ3Vyc29yLFxyXG4gICAgfTtcclxuICAgIHJldHVybiAoanN4KENoZXNzYm9hcmRDb250ZXh0LlByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgdmFsdWU6IENoZXNzYm9hcmRQcm92aWRlckNvbnRleHRWYWx1ZSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xyXG59KTtcblxuZnVuY3Rpb24gTm90YXRpb24oeyByb3csIGNvbCB9KSB7XHJcbiAgICBjb25zdCB7IGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1c3RvbURhcmtTcXVhcmVTdHlsZSwgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSwgY3VzdG9tTm90YXRpb25TdHlsZSwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IHdoaXRlQ29sb3IgPSBjdXN0b21MaWdodFNxdWFyZVN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgIGNvbnN0IGJsYWNrQ29sb3IgPSBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgY29uc3QgaXNSb3cgPSBjb2wgPT09IDA7XHJcbiAgICBjb25zdCBpc0NvbHVtbiA9IHJvdyA9PT0gNztcclxuICAgIGNvbnN0IGlzQm90dG9tTGVmdFNxdWFyZSA9IGlzUm93ICYmIGlzQ29sdW1uO1xyXG4gICAgZnVuY3Rpb24gZ2V0Um93KCkge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCIgPyA4IC0gcm93IDogcm93ICsgMTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbHVtbigpIHtcclxuICAgICAgICByZXR1cm4gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gQ09MVU1OU1s3IC0gY29sXSA6IENPTFVNTlNbY29sXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckJvdHRvbUxlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgekluZGV4OiAzLCBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiIH0sIHsgY29sb3I6IHdoaXRlQ29sb3IgfSksIG51bWVyaWNTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Um93KCkgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB6SW5kZXg6IDMsIHBvc2l0aW9uOiBcImFic29sdXRlXCIgfSwgeyBjb2xvcjogd2hpdGVDb2xvciB9KSwgYWxwaGFTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Q29sdW1uKCkgfSkpXSB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJMZXR0ZXJzKCkge1xyXG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdXNlclNlbGVjdDogXCJub25lXCIsIHpJbmRleDogMywgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9LCB7IGNvbG9yOiBjb2wgJSAyICE9PSAwID8gYmxhY2tDb2xvciA6IHdoaXRlQ29sb3IgfSksIGFscGhhU3R5bGUoYm9hcmRXaWR0aCwgY3VzdG9tTm90YXRpb25TdHlsZSkpIH0sIHsgY2hpbGRyZW46IGdldENvbHVtbigpIH0pKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJOdW1iZXJzKCkge1xyXG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdXNlclNlbGVjdDogXCJub25lXCIsIHpJbmRleDogMywgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9LCAoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgICAgICA/IHsgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBibGFja0NvbG9yIDogd2hpdGVDb2xvciB9XHJcbiAgICAgICAgICAgICAgICA6IHsgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBibGFja0NvbG9yIDogd2hpdGVDb2xvciB9KSksIG51bWVyaWNTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Um93KCkgfSkpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0JvdHRvbUxlZnRTcXVhcmUpIHtcclxuICAgICAgICByZXR1cm4gcmVuZGVyQm90dG9tTGVmdCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQ29sdW1uKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckxldHRlcnMoKTtcclxuICAgIH1cclxuICAgIGlmIChpc1Jvdykge1xyXG4gICAgICAgIHJldHVybiByZW5kZXJOdW1iZXJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5jb25zdCBhbHBoYVN0eWxlID0gKHdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbih7IGFsaWduU2VsZjogXCJmbGV4LWVuZFwiLCBwYWRkaW5nTGVmdDogd2lkdGggLyA4IC0gd2lkdGggLyA0OCwgZm9udFNpemU6IHdpZHRoIC8gNDggfSwgY3VzdG9tTm90YXRpb25TdHlsZSkpO1xyXG5jb25zdCBudW1lcmljU3R5bGUgPSAod2lkdGgsIGN1c3RvbU5vdGF0aW9uU3R5bGUpID0+IChPYmplY3QuYXNzaWduKHsgYWxpZ25TZWxmOiBcImZsZXgtc3RhcnRcIiwgcGFkZGluZ1JpZ2h0OiB3aWR0aCAvIDggLSB3aWR0aCAvIDQ4LCBmb250U2l6ZTogd2lkdGggLyA0OCB9LCBjdXN0b21Ob3RhdGlvblN0eWxlKSk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBSZWFjdCBDb250ZXh0XG4gKi8gY29uc3QgRG5kQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGRyYWdEcm9wTWFuYWdlcjogdW5kZWZpbmVkXG59KTtcblxuLyoqXG4gKiBBZGFwdGVkIGZyb20gUmVhY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS5qc1xuICpcbiAqIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIHRocm93IGVycm9yIGNhbGxzLiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgY29kZXNcbiAqIGR1cmluZyBidWlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gXCJNaW5pZmllZCBSZWR1eCBlcnJvciAjXCIgKyBjb2RlICsgXCI7IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPVwiICsgY29kZSArIFwiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIFwiICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuICc7XG59XG5cbi8vIElubGluZWQgdmVyc2lvbiBvZiB0aGUgYHN5bWJvbC1vYnNlcnZhYmxlYCBwb2x5ZmlsbFxudmFyICQkb2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSkoKTtcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciByYW5kb21TdHJpbmcgPSBmdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbn07XG5cbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogXCJAQHJlZHV4L0lOSVRcIiArIHJhbmRvbVN0cmluZygpLFxuICBSRVBMQUNFOiBcIkBAcmVkdXgvUkVQTEFDRVwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFBST0JFX1VOS05PV05fQUNUSU9OOiBmdW5jdGlvbiBQUk9CRV9VTktOT1dOX0FDVElPTigpIHtcbiAgICByZXR1cm4gXCJAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXCIgKyByYW5kb21TdHJpbmcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IG9iajtcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG87XG59XG5cbi8vIElubGluZWQgLyBzaG9ydGVuZWQgdmVyc2lvbiBvZiBga2luZE9mYCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2tpbmQtb2ZcbmZ1bmN0aW9uIG1pbmlLaW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICB2YXIgY29uc3RydWN0b3JOYW1lID0gY3Rvck5hbWUodmFsKTtcblxuICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnTWFwJzpcbiAgICBjYXNlICdTZXQnOlxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfSAvLyBvdGhlclxuXG5cbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn1cblxuZnVuY3Rpb24gY3Rvck5hbWUodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHZhbC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgdmFyIHR5cGVPZlZhbCA9IHR5cGVvZiB2YWw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdHlwZU9mVmFsO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBjb25maWd1cmVTdG9yZWAgbWV0aG9kXG4gKiBvZiB0aGUgYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYC5cbiAqXG4gKiBSZWR1eCBUb29sa2l0IGlzIG91ciByZWNvbW1lbmRlZCBhcHByb2FjaCBmb3Igd3JpdGluZyBSZWR1eCBsb2dpYyB0b2RheSxcbiAqIGluY2x1ZGluZyBzdG9yZSBzZXR1cCwgcmVkdWNlcnMsIGRhdGEgZmV0Y2hpbmcsIGFuZCBtb3JlLlxuICpcbiAqICoqRm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlYWQgdGhpcyBSZWR1eCBkb2NzIHBhZ2U6KipcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIGBjb25maWd1cmVTdG9yZWAgZnJvbSBSZWR1eCBUb29sa2l0IGlzIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgYGNyZWF0ZVN0b3JlYCB0aGF0XG4gKiBzaW1wbGlmaWVzIHNldHVwIGFuZCBoZWxwcyBhdm9pZCBjb21tb24gYnVncy5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5vdCBiZSB1c2luZyB0aGUgYHJlZHV4YCBjb3JlIHBhY2thZ2UgYnkgaXRzZWxmIHRvZGF5LCBleGNlcHQgZm9yIGxlYXJuaW5nIHB1cnBvc2VzLlxuICogVGhlIGBjcmVhdGVTdG9yZWAgbWV0aG9kIGZyb20gdGhlIGNvcmUgYHJlZHV4YCBwYWNrYWdlIHdpbGwgbm90IGJlIHJlbW92ZWQsIGJ1dCB3ZSBlbmNvdXJhZ2VcbiAqIGFsbCB1c2VycyB0byBtaWdyYXRlIHRvIHVzaW5nIFJlZHV4IFRvb2xraXQgZm9yIGFsbCBSZWR1eCBjb2RlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBgY3JlYXRlU3RvcmVgIHdpdGhvdXQgdGhpcyB2aXN1YWwgZGVwcmVjYXRpb24gd2FybmluZywgdXNlXG4gKiB0aGUgYGxlZ2FjeV9jcmVhdGVTdG9yZWAgaW1wb3J0IGluc3RlYWQ6XG4gKlxuICogYGltcG9ydCB7IGxlZ2FjeV9jcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiAnSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gJyArICdjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSAnICsgJ3RvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjY3JlYXRpbmctYS1zdG9yZS13aXRoLWVuaGFuY2VycyBmb3IgYW4gZXhhbXBsZS4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihlbmhhbmNlcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyKSA6IFwiRXhwZWN0ZWQgdGhlIHJvb3QgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKHJlZHVjZXIpICsgXCInXCIpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIGEgc2hhbGxvdyBjb3B5IG9mIGN1cnJlbnRMaXN0ZW5lcnMgc28gd2UgY2FuIHVzZVxuICAgKiBuZXh0TGlzdGVuZXJzIGFzIGEgdGVtcG9yYXJ5IGxpc3Qgd2hpbGUgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIFRoaXMgcHJldmVudHMgYW55IGJ1Z3MgYXJvdW5kIGNvbnN1bWVycyBjYWxsaW5nXG4gICAqIHN1YnNjcmliZS91bnN1YnNjcmliZSBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6ICdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihsaXN0ZW5lcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ0lmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhICcgKyAnY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiAnWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNykgOiBcIkFjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnXCIgKyBraW5kT2YoYWN0aW9uKSArIFwiJy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6ICdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGFuIGFjdGlvbiB0eXBlIHN0cmluZyBjb25zdGFudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOSkgOiAnUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cblxuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2YobmV4dFJlZHVjZXIpKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyOyAvLyBUaGlzIGFjdGlvbiBoYXMgYSBzaW1pbGlhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKG9ic2VydmVyKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9IC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuXG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSk7XG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG4vKlxuICogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuICogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuICovXG5cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBzZXR0aW5nIG1vZGUgdG8gcHJvZHVjdGlvbiBpbiB3ZWJwYWNrIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmNlcHRzL21vZGUvKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovIGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncykge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24oKSkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMSAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgICAgICA7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUHJvZHVjdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52WydOT0RFX0VOViddID09PSAncHJvZHVjdGlvbic7XG59XG5cbi8vIGNoZWFwIGxvZGFzaCByZXBsYWNlbWVudHNcbi8qKlxuICogZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgXy5nZXRcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gKi8gZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKGEsIGMpPT5hICYmIGFbY10gPyBhW2NdIDogZGVmYXVsdFZhbHVlIHx8IG51bGxcbiAgICAsIG9iaik7XG59XG4vKipcbiAqIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIF8ud2l0aG91dFxuICovIGZ1bmN0aW9uIHdpdGhvdXQkMShpdGVtcywgaXRlbSkge1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGkpPT5pICE9PSBpdGVtXG4gICAgKTtcbn1cbi8qKlxuICogZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgXy5pc1N0cmluZ1xuICogQHBhcmFtIGlucHV0XG4gKi8gZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogcmVwbGFjZW1lbnQgZm9yIF8ueG9yXG4gKiBAcGFyYW0gaXRlbXNBXG4gKiBAcGFyYW0gaXRlbXNCXG4gKi8gZnVuY3Rpb24geG9yKGl0ZW1zQSwgaXRlbXNCKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGluc2VydEl0ZW0gPSAoaXRlbSk9PntcbiAgICAgICAgbWFwLnNldChpdGVtLCBtYXAuaGFzKGl0ZW0pID8gbWFwLmdldChpdGVtKSArIDEgOiAxKTtcbiAgICB9O1xuICAgIGl0ZW1zQS5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGl0ZW1zQi5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIG1hcC5mb3JFYWNoKChjb3VudCwga2V5KT0+e1xuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiByZXBsYWNlbWVudCBmb3IgXy5pbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSBpdGVtc0FcbiAqIEBwYXJhbSBpdGVtc0JcbiAqLyBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oaXRlbXNBLCBpdGVtc0IpIHtcbiAgICByZXR1cm4gaXRlbXNBLmZpbHRlcigodCk9Pml0ZW1zQi5pbmRleE9mKHQpID4gLTFcbiAgICApO1xufVxuXG5jb25zdCBJTklUX0NPT1JEUyA9ICdkbmQtY29yZS9JTklUX0NPT1JEUyc7XG5jb25zdCBCRUdJTl9EUkFHID0gJ2RuZC1jb3JlL0JFR0lOX0RSQUcnO1xuY29uc3QgUFVCTElTSF9EUkFHX1NPVVJDRSA9ICdkbmQtY29yZS9QVUJMSVNIX0RSQUdfU09VUkNFJztcbmNvbnN0IEhPVkVSID0gJ2RuZC1jb3JlL0hPVkVSJztcbmNvbnN0IERST1AgPSAnZG5kLWNvcmUvRFJPUCc7XG5jb25zdCBFTkRfRFJBRyA9ICdkbmQtY29yZS9FTkRfRFJBRyc7XG5cbmZ1bmN0aW9uIHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IElOSVRfQ09PUkRTLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBzb3VyY2VDbGllbnRPZmZzZXQ6IHNvdXJjZUNsaWVudE9mZnNldCB8fCBudWxsLFxuICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBjbGllbnRPZmZzZXQgfHwgbnVsbFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3QgUmVzZXRDb29yZGluYXRlc0FjdGlvbiA9IHtcbiAgICB0eXBlOiBJTklUX0NPT1JEUyxcbiAgICBwYXlsb2FkOiB7XG4gICAgICAgIGNsaWVudE9mZnNldDogbnVsbCxcbiAgICAgICAgc291cmNlQ2xpZW50T2Zmc2V0OiBudWxsXG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJlZ2luRHJhZyhtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJlZ2luRHJhZyhzb3VyY2VJZHMgPSBbXSwgb3B0aW9ucyA9IHtcbiAgICAgICAgcHVibGlzaFNvdXJjZTogdHJ1ZVxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgeyBwdWJsaXNoU291cmNlID10cnVlICwgY2xpZW50T2Zmc2V0ICwgZ2V0U291cmNlQ2xpZW50T2Zmc2V0ICwgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBjb29yZGluYXRlcyB1c2luZyB0aGUgY2xpZW50IG9mZnNldFxuICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQpKTtcbiAgICAgICAgdmVyaWZ5SW52YXJpYW50cyQxKHNvdXJjZUlkcywgbW9uaXRvciwgcmVnaXN0cnkpO1xuICAgICAgICAvLyBHZXQgdGhlIGRyYWdnYWJsZSBzb3VyY2VcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSBnZXREcmFnZ2FibGVTb3VyY2Uoc291cmNlSWRzLCBtb25pdG9yKTtcbiAgICAgICAgaWYgKHNvdXJjZUlkID09IG51bGwpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuZGlzcGF0Y2goUmVzZXRDb29yZGluYXRlc0FjdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBzb3VyY2UgY2xpZW50IG9mZnNldFxuICAgICAgICBsZXQgc291cmNlQ2xpZW50T2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKGNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgaWYgKCFnZXRTb3VyY2VDbGllbnRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlcmlmeUdldFNvdXJjZUNsaWVudE9mZnNldElzRnVuY3Rpb24oZ2V0U291cmNlQ2xpZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIHNvdXJjZUNsaWVudE9mZnNldCA9IGdldFNvdXJjZUNsaWVudE9mZnNldChzb3VyY2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnVsbCBjb29yZGluYXRlc1xuICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSByZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpO1xuICAgICAgICBjb25zdCBpdGVtID0gc291cmNlLmJlZ2luRHJhZyhtb25pdG9yLCBzb3VyY2VJZCk7XG4gICAgICAgIC8vIElmIHNvdXJjZS5iZWdpbkRyYWcgcmV0dXJucyBudWxsLCB0aGlzIGlzIGFuIGluZGljYXRvciB0byBjYW5jZWwgdGhlIGRyYWdcbiAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2ZXJpZnlJdGVtSXNPYmplY3QoaXRlbSk7XG4gICAgICAgIHJlZ2lzdHJ5LnBpblNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gcmVnaXN0cnkuZ2V0U291cmNlVHlwZShzb3VyY2VJZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBCRUdJTl9EUkFHLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGl0ZW1UeXBlLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgc291cmNlSWQsXG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBjbGllbnRPZmZzZXQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzb3VyY2VDbGllbnRPZmZzZXQ6IHNvdXJjZUNsaWVudE9mZnNldCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiAhIXB1Ymxpc2hTb3VyY2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5SW52YXJpYW50cyQxKHNvdXJjZUlkcywgbW9uaXRvciwgcmVnaXN0cnkpIHtcbiAgICBpbnZhcmlhbnQoIW1vbml0b3IuaXNEcmFnZ2luZygpLCAnQ2Fubm90IGNhbGwgYmVnaW5EcmFnIHdoaWxlIGRyYWdnaW5nLicpO1xuICAgIHNvdXJjZUlkcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZUlkKSB7XG4gICAgICAgIGludmFyaWFudChyZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpLCAnRXhwZWN0ZWQgc291cmNlSWRzIHRvIGJlIHJlZ2lzdGVyZWQuJyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlHZXRTb3VyY2VDbGllbnRPZmZzZXRJc0Z1bmN0aW9uKGdldFNvdXJjZUNsaWVudE9mZnNldCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID09PSAnZnVuY3Rpb24nLCAnV2hlbiBjbGllbnRPZmZzZXQgaXMgcHJvdmlkZWQsIGdldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG59XG5mdW5jdGlvbiB2ZXJpZnlJdGVtSXNPYmplY3QoaXRlbSkge1xuICAgIGludmFyaWFudChpc09iamVjdChpdGVtKSwgJ0l0ZW0gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG59XG5mdW5jdGlvbiBnZXREcmFnZ2FibGVTb3VyY2Uoc291cmNlSWRzLCBtb25pdG9yKSB7XG4gICAgbGV0IHNvdXJjZUlkID0gbnVsbDtcbiAgICBmb3IobGV0IGkgPSBzb3VyY2VJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBpZiAobW9uaXRvci5jYW5EcmFnU291cmNlKHNvdXJjZUlkc1tpXSkpIHtcbiAgICAgICAgICAgIHNvdXJjZUlkID0gc291cmNlSWRzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUlkO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkkNChvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSQ0KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gY3JlYXRlRHJvcChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRyb3Aob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHZlcmlmeUludmFyaWFudHMobW9uaXRvcik7XG4gICAgICAgIGNvbnN0IHRhcmdldElkcyA9IGdldERyb3BwYWJsZVRhcmdldHMobW9uaXRvcik7XG4gICAgICAgIC8vIE11bHRpcGxlIGFjdGlvbnMgYXJlIGRpc3BhdGNoZWQgaGVyZSwgd2hpY2ggaXMgd2h5IHRoaXMgZG9lc24ndCByZXR1cm4gYW4gYWN0aW9uXG4gICAgICAgIHRhcmdldElkcy5mb3JFYWNoKCh0YXJnZXRJZCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBkcm9wUmVzdWx0ID0gZGV0ZXJtaW5lRHJvcFJlc3VsdCh0YXJnZXRJZCwgaW5kZXgsIHJlZ2lzdHJ5LCBtb25pdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEUk9QLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcFJlc3VsdDogX29iamVjdFNwcmVhZCQ0KHt9LCBvcHRpb25zLCBkcm9wUmVzdWx0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiB2ZXJpZnlJbnZhcmlhbnRzKG1vbml0b3IpIHtcbiAgICBpbnZhcmlhbnQobW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBkcm9wIHdoaWxlIG5vdCBkcmFnZ2luZy4nKTtcbiAgICBpbnZhcmlhbnQoIW1vbml0b3IuZGlkRHJvcCgpLCAnQ2Fubm90IGNhbGwgZHJvcCB0d2ljZSBkdXJpbmcgb25lIGRyYWcgb3BlcmF0aW9uLicpO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lRHJvcFJlc3VsdCh0YXJnZXRJZCwgaW5kZXgsIHJlZ2lzdHJ5LCBtb25pdG9yKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gcmVnaXN0cnkuZ2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICBsZXQgZHJvcFJlc3VsdCA9IHRhcmdldCA/IHRhcmdldC5kcm9wKG1vbml0b3IsIHRhcmdldElkKSA6IHVuZGVmaW5lZDtcbiAgICB2ZXJpZnlEcm9wUmVzdWx0VHlwZShkcm9wUmVzdWx0KTtcbiAgICBpZiAodHlwZW9mIGRyb3BSZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRyb3BSZXN1bHQgPSBpbmRleCA9PT0gMCA/IHt9IDogbW9uaXRvci5nZXREcm9wUmVzdWx0KCk7XG4gICAgfVxuICAgIHJldHVybiBkcm9wUmVzdWx0O1xufVxuZnVuY3Rpb24gdmVyaWZ5RHJvcFJlc3VsdFR5cGUoZHJvcFJlc3VsdCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgZHJvcFJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNPYmplY3QoZHJvcFJlc3VsdCksICdEcm9wIHJlc3VsdCBtdXN0IGVpdGhlciBiZSBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkLicpO1xufVxuZnVuY3Rpb24gZ2V0RHJvcHBhYmxlVGFyZ2V0cyhtb25pdG9yKSB7XG4gICAgY29uc3QgdGFyZ2V0SWRzID0gbW9uaXRvci5nZXRUYXJnZXRJZHMoKS5maWx0ZXIobW9uaXRvci5jYW5Ecm9wT25UYXJnZXQsIG1vbml0b3IpO1xuICAgIHRhcmdldElkcy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHRhcmdldElkcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5kRHJhZyhtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVuZERyYWcoKSB7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHZlcmlmeUlzRHJhZ2dpbmcobW9uaXRvcik7XG4gICAgICAgIGNvbnN0IHNvdXJjZUlkID0gbW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICBpZiAoc291cmNlSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gcmVnaXN0cnkuZ2V0U291cmNlKHNvdXJjZUlkLCB0cnVlKTtcbiAgICAgICAgICAgIHNvdXJjZS5lbmREcmFnKG1vbml0b3IsIHNvdXJjZUlkKTtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LnVucGluU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IEVORF9EUkFHXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUlzRHJhZ2dpbmcobW9uaXRvcikge1xuICAgIGludmFyaWFudChtb25pdG9yLmlzRHJhZ2dpbmcoKSwgJ0Nhbm5vdCBjYWxsIGVuZERyYWcgd2hpbGUgbm90IGRyYWdnaW5nLicpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzVHlwZSh0YXJnZXRUeXBlLCBkcmFnZ2VkSXRlbVR5cGUpIHtcbiAgICBpZiAoZHJhZ2dlZEl0ZW1UeXBlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRUeXBlID09PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXRUeXBlKSA/IHRhcmdldFR5cGUuc29tZSgodCk9PnQgPT09IGRyYWdnZWRJdGVtVHlwZVxuICAgICkgOiB0YXJnZXRUeXBlID09PSBkcmFnZ2VkSXRlbVR5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvdmVyKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaG92ZXIodGFyZ2V0SWRzQXJnLCB7IGNsaWVudE9mZnNldCAgfSA9IHt9KSB7XG4gICAgICAgIHZlcmlmeVRhcmdldElkc0lzQXJyYXkodGFyZ2V0SWRzQXJnKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWRzID0gdGFyZ2V0SWRzQXJnLnNsaWNlKDApO1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbVR5cGUgPSBtb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgICAgIHJlbW92ZU5vbk1hdGNoaW5nVGFyZ2V0SWRzKHRhcmdldElkcywgcmVnaXN0cnksIGRyYWdnZWRJdGVtVHlwZSk7XG4gICAgICAgIGNoZWNrSW52YXJpYW50cyh0YXJnZXRJZHMsIG1vbml0b3IsIHJlZ2lzdHJ5KTtcbiAgICAgICAgaG92ZXJBbGxUYXJnZXRzKHRhcmdldElkcywgbW9uaXRvciwgcmVnaXN0cnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogSE9WRVIsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzLFxuICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogY2xpZW50T2Zmc2V0IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5VGFyZ2V0SWRzSXNBcnJheSh0YXJnZXRJZHNBcmcpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh0YXJnZXRJZHNBcmcpLCAnRXhwZWN0ZWQgdGFyZ2V0SWRzIHRvIGJlIGFuIGFycmF5LicpO1xufVxuZnVuY3Rpb24gY2hlY2tJbnZhcmlhbnRzKHRhcmdldElkcywgbW9uaXRvciwgcmVnaXN0cnkpIHtcbiAgICBpbnZhcmlhbnQobW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBob3ZlciB3aGlsZSBub3QgZHJhZ2dpbmcuJyk7XG4gICAgaW52YXJpYW50KCFtb25pdG9yLmRpZERyb3AoKSwgJ0Nhbm5vdCBjYWxsIGhvdmVyIGFmdGVyIGRyb3AuJyk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRhcmdldElkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0SWRzW2ldO1xuICAgICAgICBpbnZhcmlhbnQodGFyZ2V0SWRzLmxhc3RJbmRleE9mKHRhcmdldElkKSA9PT0gaSwgJ0V4cGVjdGVkIHRhcmdldElkcyB0byBiZSB1bmlxdWUgaW4gdGhlIHBhc3NlZCBhcnJheS4nKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVnaXN0cnkuZ2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaW52YXJpYW50KHRhcmdldCwgJ0V4cGVjdGVkIHRhcmdldElkcyB0byBiZSByZWdpc3RlcmVkLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZU5vbk1hdGNoaW5nVGFyZ2V0SWRzKHRhcmdldElkcywgcmVnaXN0cnksIGRyYWdnZWRJdGVtVHlwZSkge1xuICAgIC8vIFJlbW92ZSB0aG9zZSB0YXJnZXRJZHMgdGhhdCBkb24ndCBtYXRjaCB0aGUgdGFyZ2V0VHlwZS4gIFRoaXNcbiAgICAvLyBmaXhlcyBzaGFsbG93IGlzT3ZlciB3aGljaCB3b3VsZCBvbmx5IGJlIG5vbi1zaGFsbG93IGJlY2F1c2Ugb2ZcbiAgICAvLyBub24tbWF0Y2hpbmcgdGFyZ2V0cy5cbiAgICBmb3IobGV0IGkgPSB0YXJnZXRJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldElkc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHJlZ2lzdHJ5LmdldFRhcmdldFR5cGUodGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIW1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgIHRhcmdldElkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBob3ZlckFsbFRhcmdldHModGFyZ2V0SWRzLCBtb25pdG9yLCByZWdpc3RyeSkge1xuICAgIC8vIEZpbmFsbHkgY2FsbCBob3ZlciBvbiBhbGwgbWF0Y2hpbmcgdGFyZ2V0cy5cbiAgICB0YXJnZXRJZHMuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSByZWdpc3RyeS5nZXRUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXQuaG92ZXIobW9uaXRvciwgdGFyZ2V0SWQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQdWJsaXNoRHJhZ1NvdXJjZShtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHB1Ymxpc2hEcmFnU291cmNlKCkge1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGlmIChtb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQVUJMSVNIX0RSQUdfU09VUkNFXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEcmFnRHJvcEFjdGlvbnMobWFuYWdlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZ2luRHJhZzogY3JlYXRlQmVnaW5EcmFnKG1hbmFnZXIpLFxuICAgICAgICBwdWJsaXNoRHJhZ1NvdXJjZTogY3JlYXRlUHVibGlzaERyYWdTb3VyY2UobWFuYWdlciksXG4gICAgICAgIGhvdmVyOiBjcmVhdGVIb3ZlcihtYW5hZ2VyKSxcbiAgICAgICAgZHJvcDogY3JlYXRlRHJvcChtYW5hZ2VyKSxcbiAgICAgICAgZW5kRHJhZzogY3JlYXRlRW5kRHJhZyhtYW5hZ2VyKVxuICAgIH07XG59XG5cbmNsYXNzIERyYWdEcm9wTWFuYWdlckltcGwge1xuICAgIHJlY2VpdmVCYWNrZW5kKGJhY2tlbmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG4gICAgZ2V0TW9uaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9uaXRvcjtcbiAgICB9XG4gICAgZ2V0QmFja2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZDtcbiAgICB9XG4gICAgZ2V0UmVnaXN0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbml0b3IucmVnaXN0cnk7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyAqLyBjb25zdCBtYW5hZ2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkaXNwYXRjaCAgfSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25DcmVhdG9yLmFwcGx5KG1hbmFnZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGNyZWF0ZURyYWdEcm9wQWN0aW9ucyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFjdGlvbnMpLnJlZHVjZSgoYm91bmRBY3Rpb25zLCBrZXkpPT57XG4gICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW2tleV07XG4gICAgICAgICAgICBib3VuZEFjdGlvbnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRBY3Rpb25zO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0b3JlLCBtb25pdG9yKXtcbiAgICAgICAgdGhpcy5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVmQ291bnRDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2V0VXAgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkucmVmQ291bnQgPiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFja2VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTZXRVcCAmJiAhdGhpcy5pc1NldFVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja2VuZC5zZXR1cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU2V0VXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNob3VsZFNldFVwICYmIHRoaXMuaXNTZXRVcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tlbmQudGVhcmRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgICAgIHN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZVJlZkNvdW50Q2hhbmdlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29vcmRpbmF0ZSBhZGRpdGlvblxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgY29vcmRpbmF0ZVxuICovIGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogYS54ICsgYi54LFxuICAgICAgICB5OiBhLnkgKyBiLnlcbiAgICB9O1xufVxuLyoqXG4gKiBDb29yZGluYXRlIHN1YnRyYWN0aW9uXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgY29vcmRpbmF0ZVxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBjb29yZGluYXRlXG4gKi8gZnVuY3Rpb24gc3VidHJhY3QoYSwgYikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGEueCAtIGIueCxcbiAgICAgICAgeTogYS55IC0gYi55XG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIG9mIHRoZSBkcmFnIHNvdXJjZSBjb21wb25lbnQncyBwb3NpdGlvbiwgYmFzZWQgb24gaXRzIHBvc2l0aW9uXG4gKiBhdCB0aGUgdGltZSB3aGVuIHRoZSBjdXJyZW50IGRyYWcgb3BlcmF0aW9uIGhhcyBzdGFydGVkLCBhbmQgdGhlIG1vdmVtZW50IGRpZmZlcmVuY2UuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIG5vIGl0ZW0gaXMgYmVpbmcgZHJhZ2dlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgVGhlIG9mZnNldCBzdGF0ZSB0byBjb21wdXRlIGZyb21cbiAqLyBmdW5jdGlvbiBnZXRTb3VyY2VDbGllbnRPZmZzZXQoc3RhdGUpIHtcbiAgICBjb25zdCB7IGNsaWVudE9mZnNldCAsIGluaXRpYWxDbGllbnRPZmZzZXQgLCBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0ICB9ID0gc3RhdGU7XG4gICAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIWluaXRpYWxDbGllbnRPZmZzZXQgfHwgIWluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdWJ0cmFjdChhZGQoY2xpZW50T2Zmc2V0LCBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KSwgaW5pdGlhbENsaWVudE9mZnNldCk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHgseSBvZmZzZXQgYmV0d2VlbiB0aGUgY2xpZW50IG9mZnNldCBhbmQgdGhlIGluaXRpYWwgY2xpZW50IG9mZnNldFxuICpcbiAqIEBwYXJhbSBzdGF0ZSBUaGUgb2Zmc2V0IHN0YXRlIHRvIGNvbXB1dGUgZnJvbVxuICovIGZ1bmN0aW9uIGdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldChzdGF0ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50T2Zmc2V0ICwgaW5pdGlhbENsaWVudE9mZnNldCAgfSA9IHN0YXRlO1xuICAgIGlmICghY2xpZW50T2Zmc2V0IHx8ICFpbml0aWFsQ2xpZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3VidHJhY3QoY2xpZW50T2Zmc2V0LCBpbml0aWFsQ2xpZW50T2Zmc2V0KTtcbn1cblxuY29uc3QgTk9ORSA9IFtdO1xuY29uc3QgQUxMID0gW107XG5OT05FLl9fSVNfTk9ORV9fID0gdHJ1ZTtcbkFMTC5fX0lTX0FMTF9fID0gdHJ1ZTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gaGFuZGxlciBJRHMgYXJlIGRpcnR5IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gZGlydHlJZHMgVGhlIHNldCBvZiBkaXJ0eSBoYW5kbGVyIGlkc1xuICogQHBhcmFtIGhhbmRsZXJJZHMgVGhlIHNldCBvZiBoYW5kbGVyIGlkcyB0byBjaGVja1xuICovIGZ1bmN0aW9uIGFyZURpcnR5KGRpcnR5SWRzLCBoYW5kbGVySWRzKSB7XG4gICAgaWYgKGRpcnR5SWRzID09PSBOT05FKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpcnR5SWRzID09PSBBTEwgfHwgdHlwZW9mIGhhbmRsZXJJZHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25JZHMgPSBpbnRlcnNlY3Rpb24oaGFuZGxlcklkcywgZGlydHlJZHMpO1xuICAgIHJldHVybiBjb21tb25JZHMubGVuZ3RoID4gMDtcbn1cblxuY2xhc3MgRHJhZ0Ryb3BNb25pdG9ySW1wbCB7XG4gICAgc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShsaXN0ZW5lciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlcklkcyAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicsICdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgaGFuZGxlcklkcyA9PT0gJ3VuZGVmaW5lZCcgfHwgQXJyYXkuaXNBcnJheShoYW5kbGVySWRzKSwgJ2hhbmRsZXJJZHMsIHdoZW4gc3BlY2lmaWVkLCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuJyk7XG4gICAgICAgIGxldCBwcmV2U3RhdGVJZCA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5zdGF0ZUlkO1xuICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGVJZCA9IHN0YXRlLnN0YXRlSWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhblNraXBMaXN0ZW5lciA9IGN1cnJlbnRTdGF0ZUlkID09PSBwcmV2U3RhdGVJZCB8fCBjdXJyZW50U3RhdGVJZCA9PT0gcHJldlN0YXRlSWQgKyAxICYmICFhcmVEaXJ0eShzdGF0ZS5kaXJ0eUhhbmRsZXJJZHMsIGhhbmRsZXJJZHMpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuU2tpcExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHByZXZTdGF0ZUlkID0gY3VycmVudFN0YXRlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2UpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb09mZnNldENoYW5nZShsaXN0ZW5lcikge1xuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nLCAnbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICBsZXQgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT2Zmc2V0O1xuICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXRlID09PSBwcmV2aW91c1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2UpO1xuICAgIH1cbiAgICBjYW5EcmFnU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIGlmICghc291cmNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlZ2lzdHJ5LmdldFNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAgIGludmFyaWFudChzb3VyY2UsIGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgc291cmNlLiBzb3VyY2VJZD0ke3NvdXJjZUlkfWApO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlLmNhbkRyYWcodGhpcywgc291cmNlSWQpO1xuICAgIH1cbiAgICBjYW5Ecm9wT25UYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIG9uIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIGlmICghdGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnJlZ2lzdHJ5LmdldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGludmFyaWFudCh0YXJnZXQsIGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgdGFyZ2V0LiB0YXJnZXRJZD0ke3RhcmdldElkfWApO1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpIHx8IHRoaXMuZGlkRHJvcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtVHlwZSA9IHRoaXMuZ2V0SXRlbVR5cGUoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkgJiYgdGFyZ2V0LmNhbkRyb3AodGhpcywgdGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldEl0ZW1UeXBlKCkpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBvbiBpbml0aWFsIHJlbmRlclxuICAgICAgICBpZiAoIXNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5yZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQsIHRydWUpO1xuICAgICAgICBpbnZhcmlhbnQoc291cmNlLCBgRXhwZWN0ZWQgdG8gZmluZCBhIHZhbGlkIHNvdXJjZS4gc291cmNlSWQ9JHtzb3VyY2VJZH1gKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhdGhpcy5pc1NvdXJjZVB1YmxpYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlVHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0U291cmNlVHlwZShzb3VyY2VJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtVHlwZSA9IHRoaXMuZ2V0SXRlbVR5cGUoKTtcbiAgICAgICAgaWYgKHNvdXJjZVR5cGUgIT09IGRyYWdnZWRJdGVtVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UuaXNEcmFnZ2luZyh0aGlzLCBzb3VyY2VJZCk7XG4gICAgfVxuICAgIGlzT3ZlclRhcmdldCh0YXJnZXRJZCwgb3B0aW9ucyA9IHtcbiAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICB9KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBvbiBpbml0aWFsIHJlbmRlclxuICAgICAgICBpZiAoIXRhcmdldElkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ICB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSB0aGlzLnJlZ2lzdHJ5LmdldFRhcmdldFR5cGUodGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbVR5cGUgPSB0aGlzLmdldEl0ZW1UeXBlKCk7XG4gICAgICAgIGlmIChkcmFnZ2VkSXRlbVR5cGUgJiYgIW1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJZHMgPSB0aGlzLmdldFRhcmdldElkcygpO1xuICAgICAgICBpZiAoIXRhcmdldElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRhcmdldElkcy5pbmRleE9mKHRhcmdldElkKTtcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gdGFyZ2V0SWRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJdGVtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLml0ZW1UeXBlO1xuICAgIH1cbiAgICBnZXRJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uaXRlbTtcbiAgICB9XG4gICAgZ2V0U291cmNlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5zb3VyY2VJZDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0SWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24udGFyZ2V0SWRzO1xuICAgIH1cbiAgICBnZXREcm9wUmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uZHJvcFJlc3VsdDtcbiAgICB9XG4gICAgZGlkRHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLmRpZERyb3A7XG4gICAgfVxuICAgIGlzU291cmNlUHVibGljKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5pc1NvdXJjZVB1YmxpYyk7XG4gICAgfVxuICAgIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldC5pbml0aWFsQ2xpZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldDtcbiAgICB9XG4gICAgZ2V0Q2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuY2xpZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRTb3VyY2VDbGllbnRPZmZzZXQodGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQpO1xuICAgIH1cbiAgICBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQodGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSwgcmVnaXN0cnkpe1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICB9XG59XG5cbi8vIFNhZmFyaSA2IGFuZCA2LjEgZm9yIGRlc2t0b3AsIGlQYWQsIGFuZCBpUGhvbmUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXRcbi8vIGhhdmUgV2ViS2l0TXV0YXRpb25PYnNlcnZlciBidXQgbm90IHVuLXByZWZpeGVkIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXN0IHVzZSBgZ2xvYmFsYCBvciBgc2VsZmAgaW5zdGVhZCBvZiBgd2luZG93YCB0byB3b3JrIGluIGJvdGggZnJhbWVzIGFuZCB3ZWJcbi8vIHdvcmtlcnMuIGBnbG9iYWxgIGlzIGEgcHJvdmlzaW9uIG9mIEJyb3dzZXJpZnksIE1yLCBNcnMsIG9yIE1vcC5cbi8qIGdsb2JhbHMgc2VsZiAqLyBjb25zdCBzY29wZSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogc2VsZjtcbmNvbnN0IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gc2NvcGUuTXV0YXRpb25PYnNlcnZlciB8fCBzY29wZS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIGNvbnN0IGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoaGFuZGxlVGltZXIsIDUwKTtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRvZ2dsZSA9IDE7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7XG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuY29uc3QgbWFrZVJlcXVlc3RDYWxsID0gdHlwZW9mIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nID8gLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xubWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIgOiAvLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG4vLyBUaW1lcnMgYXJlIGltcGxlbWVudGVkIHVuaXZlcnNhbGx5LlxuLy8gV2UgZmFsbCBiYWNrIHRvIHRpbWVycyBpbiB3b3JrZXJzIGluIG1vc3QgZW5naW5lcywgYW5kIGluIGZvcmVncm91bmRcbi8vIGNvbnRleHRzIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnMuXG4vLyBIb3dldmVyLCBub3RlIHRoYXQgZXZlbiB0aGlzIHNpbXBsZSBjYXNlIHJlcXVpcmVzIG51YW5jZXMgdG8gb3BlcmF0ZSBpbiBhXG4vLyBicm9hZCBzcGVjdHJ1bSBvZiBicm93c2Vycy5cbi8vXG4vLyAtIEZpcmVmb3ggMy0xM1xuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciA2LTlcbi8vIC0gaVBhZCBTYWZhcmkgNC4zXG4vLyAtIEx5bnggMi44Ljdcbm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuY2xhc3MgQXNhcFF1ZXVlIHtcbiAgICAvLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4gICAgLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIElPLCBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlZHJhd1xuICAgIC8vIGV2ZW50cyBpbiBicm93c2Vycy5cbiAgICAvL1xuICAgIC8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4gICAgLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4gICAgLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuICAgIC8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuICAgIC8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4gICAgLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgICBjb25zdCB7IHF1ZXVlOiBxICwgcmVxdWVzdEZsdXNoICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICBxW3EubGVuZ3RoXSA9IHRhc2s7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuICAgICAgICAvLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbiAgICAgICAgdGhpcy5wZW5kaW5nRXJyb3JzID0gW107XG4gICAgICAgIC8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4gICAgICAgIC8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbiAgICAgICAgLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4gICAgICAgIC8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuICAgICAgICAvLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4gICAgICAgIC8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gMTAyNDtcbiAgICAgICAgLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbiAgICAgICAgLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbiAgICAgICAgLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4gICAgICAgIC8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuICAgICAgICAvLyBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICB0aGlzLmZsdXNoID0gKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgcXVldWU6IHEgIH0gPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUodGhpcy5pbmRleCA8IHEubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgIHFbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID4gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxLmxlbmd0aCAtIHRoaXMuaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3NjYW5dID0gcVtzY2FuICsgdGhpcy5pbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcS5sZW5ndGggLT0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHR1cm4uXG4gICAgICAgIHRoaXMucmVnaXN0ZXJQZW5kaW5nRXJyb3IgPSAoZXJyKT0+e1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEVycm9yVGhyb3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYHJlcXVlc3RGbHVzaGAgcmVxdWVzdHMgdGhhdCB0aGUgaGlnaCBwcmlvcml0eSBldmVudCBxdWV1ZSBiZSBmbHVzaGVkIGFzXG4gICAgICAgIC8vIHNvb24gYXMgcG9zc2libGUuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuICAgICAgICAvLyBxdWV1ZSBpZiB0aGUgZXhjZXB0aW9uIGhhbmRsZWQgYnkgTm9kZS5qc+KAmXNcbiAgICAgICAgLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG4gICAgICAgIC8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuICAgICAgICAvLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMW1HLTVVWUd1cDVxeEdkRU1Xa2hQNkJXQ3owNTNOVWIyRTFRb1VUVTE2dUEvZWRpdCNnaWQ9NzgzNzI0NTkzXG4gICAgICAgIHRoaXMucmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsKHRoaXMuZmx1c2gpO1xuICAgICAgICB0aGlzLnJlcXVlc3RFcnJvclRocm93ID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKCgpPT57XG4gICAgICAgICAgICAvLyBUaHJvdyBmaXJzdCBlcnJvclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSAvLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbiAvLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4gLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAvLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4gLy8gcGFnZSdzIGZpcnN0IGxvYWQuIFRoYW5rZnVsbHksIHRoaXMgdmVyc2lvbiBvZiBTYWZhcmkgc3VwcG9ydHNcbiAvLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuIC8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NZXNzYWdlQ2hhbm5lbChjYWxsYmFjaykge1xuIC8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuIC8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuIC8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuIC8vICAgICB9O1xuIC8vIH1cbiAvLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbiAvLyB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbiAvLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuIC8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4gLy8gYHNldEltbWVkaWF0ZWAgbXVzdCBiZSBjYWxsZWQgKmJ5IG5hbWUqIGFuZCB0aGVyZWZvcmUgbXVzdCBiZSB3cmFwcGVkIGluIGFcbiAvLyBjbG9zdXJlLlxuIC8vIE5ldmVyIGZvcmdldC5cbiAvLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAvLyAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gLy8gICAgIH07XG4gLy8gfVxuIC8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuIC8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuIC8vIG11dGF0aW9uIG9ic2VydmVycywgc28gdGhhdCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGluc3RlYWQuXG4gLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuIC8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuIC8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuIC8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3RcbiAvLyBldmVuIHRoZW4uXG4gLy8gVGhpcyBpcyBmb3IgYGFzYXAuanNgIG9ubHkuXG4gLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbiAvLyAvLyBpdHMgZXhpc3RlbmNlLlxuIC8vIHJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyXG4gLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4gLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbiAvLyBhbWVuZG1lbnRzLiBUaGVzZSBkZWNpc2lvbnMsIHBhcnRpY3VsYXJseSB0byBtYXJnaW5hbGl6ZSBNZXNzYWdlQ2hhbm5lbCBhbmRcbiAvLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4gLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9jZGRmNzIzMjU0NmE5Y2Y4NTg1MjRiNzVjZGU2ZjllZGY3MjYyMGE3L2xpYi9yc3ZwL2FzYXAuanNcblxuLy8gYGNhbGxgLCBqdXN0IGxpa2UgYSBmdW5jdGlvbi5cbmNsYXNzIFJhd1Rhc2sge1xuICAgIGNhbGwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRhc2sgJiYgdGhpcy50YXNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9uRXJyb3IsIHJlbGVhc2Upe1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgICB0aGlzLnJlbGVhc2UgPSByZWxlYXNlO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbn1cblxuY2xhc3MgVGFza0ZhY3Rvcnkge1xuICAgIGNyZWF0ZSh0YXNrKSB7XG4gICAgICAgIGNvbnN0IHRhc2tzID0gdGhpcy5mcmVlVGFza3M7XG4gICAgICAgIGNvbnN0IHQxID0gdGFza3MubGVuZ3RoID8gdGFza3MucG9wKCkgOiBuZXcgUmF3VGFzayh0aGlzLm9uRXJyb3IsICh0KT0+dGFza3NbdGFza3MubGVuZ3RoXSA9IHRcbiAgICAgICAgKTtcbiAgICAgICAgdDEudGFzayA9IHRhc2s7XG4gICAgICAgIHJldHVybiB0MTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob25FcnJvcil7XG4gICAgICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG4gICAgICAgIHRoaXMuZnJlZVRhc2tzID0gW107XG4gICAgfVxufVxuXG5jb25zdCBhc2FwUXVldWUgPSBuZXcgQXNhcFF1ZXVlKCk7XG5jb25zdCB0YXNrRmFjdG9yeSA9IG5ldyBUYXNrRmFjdG9yeShhc2FwUXVldWUucmVnaXN0ZXJQZW5kaW5nRXJyb3IpO1xuLyoqXG4gKiBDYWxscyBhIHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciByZXR1cm5pbmcsIGluIGl0cyBvd24gZXZlbnQsIHdpdGggcHJpb3JpdHlcbiAqIG92ZXIgb3RoZXIgZXZlbnRzIGxpa2UgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZXBhaW50LiBBbiBlcnJvciB0aHJvd24gZnJvbSBhblxuICogZXZlbnQgd2lsbCBub3QgaW50ZXJydXB0LCBub3IgZXZlbiBzdWJzdGFudGlhbGx5IHNsb3cgZG93biB0aGUgcHJvY2Vzc2luZyBvZlxuICogb3RoZXIgZXZlbnRzLCBidXQgd2lsbCBiZSByYXRoZXIgcG9zdHBvbmVkIHRvIGEgbG93ZXIgcHJpb3JpdHkgZXZlbnQuXG4gKiBAcGFyYW0ge3tjYWxsfX0gdGFzayBBIGNhbGxhYmxlIG9iamVjdCwgdHlwaWNhbGx5IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzLlxuICovIGZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIGFzYXBRdWV1ZS5lbnF1ZXVlVGFzayh0YXNrRmFjdG9yeS5jcmVhdGUodGFzaykpO1xufVxuXG5jb25zdCBBRERfU09VUkNFID0gJ2RuZC1jb3JlL0FERF9TT1VSQ0UnO1xuY29uc3QgQUREX1RBUkdFVCA9ICdkbmQtY29yZS9BRERfVEFSR0VUJztcbmNvbnN0IFJFTU9WRV9TT1VSQ0UgPSAnZG5kLWNvcmUvUkVNT1ZFX1NPVVJDRSc7XG5jb25zdCBSRU1PVkVfVEFSR0VUID0gJ2RuZC1jb3JlL1JFTU9WRV9UQVJHRVQnO1xuZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogQUREX1NPVVJDRSxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgc291cmNlSWRcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBBRERfVEFSR0VULFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICB0YXJnZXRJZFxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZShzb3VyY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJFTU9WRV9TT1VSQ0UsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHNvdXJjZUlkXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUkVNT1ZFX1RBUkdFVCxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgdGFyZ2V0SWRcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU291cmNlQ29udHJhY3Qoc291cmNlKSB7XG4gICAgaW52YXJpYW50KHR5cGVvZiBzb3VyY2UuY2FuRHJhZyA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIGNhbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHNvdXJjZS5iZWdpbkRyYWcgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBiZWdpbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHNvdXJjZS5lbmREcmFnID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgZW5kRHJhZyB0byBiZSBhIGZ1bmN0aW9uLicpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRDb250cmFjdCh0YXJnZXQpIHtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHRhcmdldC5jYW5Ecm9wID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgY2FuRHJvcCB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIGludmFyaWFudCh0eXBlb2YgdGFyZ2V0LmhvdmVyID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgaG92ZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHRhcmdldC5kcm9wID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgYmVnaW5EcmFnIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZSwgYWxsb3dBcnJheSkge1xuICAgIGlmIChhbGxvd0FycmF5ICYmIEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZS5mb3JFYWNoKCh0KT0+dmFsaWRhdGVUeXBlKHQsIGZhbHNlKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnLCBhbGxvd0FycmF5ID8gJ1R5cGUgY2FuIG9ubHkgYmUgYSBzdHJpbmcsIGEgc3ltYm9sLCBvciBhbiBhcnJheSBvZiBlaXRoZXIuJyA6ICdUeXBlIGNhbiBvbmx5IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sLicpO1xufVxuXG52YXIgSGFuZGxlclJvbGU7XG4oZnVuY3Rpb24oSGFuZGxlclJvbGUpIHtcbiAgICBIYW5kbGVyUm9sZVtcIlNPVVJDRVwiXSA9IFwiU09VUkNFXCI7XG4gICAgSGFuZGxlclJvbGVbXCJUQVJHRVRcIl0gPSBcIlRBUkdFVFwiO1xufSkoSGFuZGxlclJvbGUgfHwgKEhhbmRsZXJSb2xlID0ge30pKTtcblxubGV0IG5leHRVbmlxdWVJZCA9IDA7XG5mdW5jdGlvbiBnZXROZXh0VW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIG5leHRVbmlxdWVJZCsrO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SGFuZGxlcklkKHJvbGUpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRVbmlxdWVJZCgpLnRvU3RyaW5nKCk7XG4gICAgc3dpdGNoKHJvbGUpe1xuICAgICAgICBjYXNlIEhhbmRsZXJSb2xlLlNPVVJDRTpcbiAgICAgICAgICAgIHJldHVybiBgUyR7aWR9YDtcbiAgICAgICAgY2FzZSBIYW5kbGVyUm9sZS5UQVJHRVQ6XG4gICAgICAgICAgICByZXR1cm4gYFQke2lkfWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSGFuZGxlciBSb2xlOiAke3JvbGV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpIHtcbiAgICBzd2l0Y2goaGFuZGxlcklkWzBdKXtcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICByZXR1cm4gSGFuZGxlclJvbGUuU09VUkNFO1xuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHJldHVybiBIYW5kbGVyUm9sZS5UQVJHRVQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBoYW5kbGVyIElEOiAke2hhbmRsZXJJZH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDb250YWluc1ZhbHVlKG1hcCwgc2VhcmNoVmFsdWUpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gbWFwLmVudHJpZXMoKTtcbiAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgZG8ge1xuICAgICAgICBjb25zdCB7IGRvbmUgLCB2YWx1ZTogWywgdmFsdWVdICwgIH0gPSBlbnRyaWVzLm5leHQoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBzZWFyY2hWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNEb25lID0gISFkb25lO1xuICAgIH13aGlsZSAoIWlzRG9uZSlcbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBIYW5kbGVyUmVnaXN0cnlJbXBsIHtcbiAgICBhZGRTb3VyY2UodHlwZSwgc291cmNlKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZSh0eXBlKTtcbiAgICAgICAgdmFsaWRhdGVTb3VyY2VDb250cmFjdChzb3VyY2UpO1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IHRoaXMuYWRkSGFuZGxlcihIYW5kbGVyUm9sZS5TT1VSQ0UsIHR5cGUsIHNvdXJjZSk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWRkU291cmNlKHNvdXJjZUlkKSk7XG4gICAgICAgIHJldHVybiBzb3VyY2VJZDtcbiAgICB9XG4gICAgYWRkVGFyZ2V0KHR5cGUsIHRhcmdldCkge1xuICAgICAgICB2YWxpZGF0ZVR5cGUodHlwZSwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlVGFyZ2V0Q29udHJhY3QodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB0aGlzLmFkZEhhbmRsZXIoSGFuZGxlclJvbGUuVEFSR0VULCB0eXBlLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFkZFRhcmdldCh0YXJnZXRJZCkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgfVxuICAgIGNvbnRhaW5zSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBtYXBDb250YWluc1ZhbHVlKHRoaXMuZHJhZ1NvdXJjZXMsIGhhbmRsZXIpIHx8IG1hcENvbnRhaW5zVmFsdWUodGhpcy5kcm9wVGFyZ2V0cywgaGFuZGxlcik7XG4gICAgfVxuICAgIGdldFNvdXJjZShzb3VyY2VJZCwgaW5jbHVkZVBpbm5lZCA9IGZhbHNlKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmlzU291cmNlSWQoc291cmNlSWQpLCAnRXhwZWN0ZWQgYSB2YWxpZCBzb3VyY2UgSUQuJyk7XG4gICAgICAgIGNvbnN0IGlzUGlubmVkID0gaW5jbHVkZVBpbm5lZCAmJiBzb3VyY2VJZCA9PT0gdGhpcy5waW5uZWRTb3VyY2VJZDtcbiAgICAgICAgY29uc3Qgc291cmNlID0gaXNQaW5uZWQgPyB0aGlzLnBpbm5lZFNvdXJjZSA6IHRoaXMuZHJhZ1NvdXJjZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmlzVGFyZ2V0SWQodGFyZ2V0SWQpLCAnRXhwZWN0ZWQgYSB2YWxpZCB0YXJnZXQgSUQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXRzLmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGdldFNvdXJjZVR5cGUoc291cmNlSWQpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuaXNTb3VyY2VJZChzb3VyY2VJZCksICdFeHBlY3RlZCBhIHZhbGlkIHNvdXJjZSBJRC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5pc1RhcmdldElkKHRhcmdldElkKSwgJ0V4cGVjdGVkIGEgdmFsaWQgdGFyZ2V0IElELicpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlcy5nZXQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpc1NvdXJjZUlkKGhhbmRsZXJJZCkge1xuICAgICAgICBjb25zdCByb2xlID0gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICByZXR1cm4gcm9sZSA9PT0gSGFuZGxlclJvbGUuU09VUkNFO1xuICAgIH1cbiAgICBpc1RhcmdldElkKGhhbmRsZXJJZCkge1xuICAgICAgICBjb25zdCByb2xlID0gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICByZXR1cm4gcm9sZSA9PT0gSGFuZGxlclJvbGUuVEFSR0VUO1xuICAgIH1cbiAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuZ2V0U291cmNlKHNvdXJjZUlkKSwgJ0V4cGVjdGVkIGFuIGV4aXN0aW5nIHNvdXJjZS4nKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChyZW1vdmVTb3VyY2Uoc291cmNlSWQpKTtcbiAgICAgICAgYXNhcCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy50eXBlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmdldFRhcmdldCh0YXJnZXRJZCksICdFeHBlY3RlZCBhbiBleGlzdGluZyB0YXJnZXQuJyk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gocmVtb3ZlVGFyZ2V0KHRhcmdldElkKSk7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgdGhpcy50eXBlcy5kZWxldGUodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBwaW5Tb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRTb3VyY2Uoc291cmNlSWQpO1xuICAgICAgICBpbnZhcmlhbnQoc291cmNlLCAnRXhwZWN0ZWQgYW4gZXhpc3Rpbmcgc291cmNlLicpO1xuICAgICAgICB0aGlzLnBpbm5lZFNvdXJjZUlkID0gc291cmNlSWQ7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICB1bnBpblNvdXJjZSgpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMucGlubmVkU291cmNlLCAnTm8gc291cmNlIGlzIHBpbm5lZCBhdCB0aGUgdGltZS4nKTtcbiAgICAgICAgdGhpcy5waW5uZWRTb3VyY2VJZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihyb2xlLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0TmV4dEhhbmRsZXJJZChyb2xlKTtcbiAgICAgICAgdGhpcy50eXBlcy5zZXQoaWQsIHR5cGUpO1xuICAgICAgICBpZiAocm9sZSA9PT0gSGFuZGxlclJvbGUuU09VUkNFKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAocm9sZSA9PT0gSGFuZGxlclJvbGUuVEFSR0VUKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXRzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSl7XG4gICAgICAgIHRoaXMudHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbm5lZFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG59XG5cbmNvbnN0IHN0cmljdEVxdWFsaXR5ID0gKGEsIGIpPT5hID09PSBiXG47XG4vKipcbiAqIERldGVybWluZSBpZiB0d28gY2FydGVzaWFuIGNvb3JkaW5hdGUgb2Zmc2V0cyBhcmUgZXF1YWxcbiAqIEBwYXJhbSBvZmZzZXRBXG4gKiBAcGFyYW0gb2Zmc2V0QlxuICovIGZ1bmN0aW9uIGFyZUNvb3Jkc0VxdWFsKG9mZnNldEEsIG9mZnNldEIpIHtcbiAgICBpZiAoIW9mZnNldEEgJiYgIW9mZnNldEIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghb2Zmc2V0QSB8fCAhb2Zmc2V0Qikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldEEueCA9PT0gb2Zmc2V0Qi54ICYmIG9mZnNldEEueSA9PT0gb2Zmc2V0Qi55O1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0d28gYXJyYXlzIG9mIGl0ZW1zIGFyZSBlcXVhbFxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGFycmF5IG9mIGl0ZW1zXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGFycmF5IG9mIGl0ZW1zXG4gKi8gZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYiwgaXNFcXVhbCA9IHN0cmljdEVxdWFsaXR5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaWYgKCFpc0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZSQ1KC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9zdGF0ZSA9IE5PTkUsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgSE9WRVI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBRERfU09VUkNFOlxuICAgICAgICBjYXNlIEFERF9UQVJHRVQ6XG4gICAgICAgIGNhc2UgUkVNT1ZFX1RBUkdFVDpcbiAgICAgICAgY2FzZSBSRU1PVkVfU09VUkNFOlxuICAgICAgICAgICAgcmV0dXJuIE5PTkU7XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgY2FzZSBQVUJMSVNIX0RSQUdfU09VUkNFOlxuICAgICAgICBjYXNlIEVORF9EUkFHOlxuICAgICAgICBjYXNlIERST1A6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQUxMO1xuICAgIH1cbiAgICBjb25zdCB7IHRhcmdldElkcyA9W10gLCBwcmV2VGFyZ2V0SWRzID1bXSAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHJlc3VsdCA9IHhvcih0YXJnZXRJZHMsIHByZXZUYXJnZXRJZHMpO1xuICAgIGNvbnN0IGRpZENoYW5nZSA9IHJlc3VsdC5sZW5ndGggPiAwIHx8ICFhcmVBcnJheXNFcXVhbCh0YXJnZXRJZHMsIHByZXZUYXJnZXRJZHMpO1xuICAgIGlmICghZGlkQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBOT05FO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgdGFyZ2V0IGlkcyBhdCB0aGUgaW5uZXJtb3N0IHBvc2l0aW9uLiBJZiB0aGV5IGFyZSB2YWxpZCwgYWRkIHRoZW1cbiAgICAvLyB0byB0aGUgcmVzdWx0XG4gICAgY29uc3QgcHJldklubmVybW9zdFRhcmdldElkID0gcHJldlRhcmdldElkc1twcmV2VGFyZ2V0SWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGlubmVybW9zdFRhcmdldElkID0gdGFyZ2V0SWRzW3RhcmdldElkcy5sZW5ndGggLSAxXTtcbiAgICBpZiAocHJldklubmVybW9zdFRhcmdldElkICE9PSBpbm5lcm1vc3RUYXJnZXRJZCkge1xuICAgICAgICBpZiAocHJldklubmVybW9zdFRhcmdldElkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwcmV2SW5uZXJtb3N0VGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbm5lcm1vc3RUYXJnZXRJZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5uZXJtb3N0VGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQzKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5JDModGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBpbml0aWFsU3RhdGUkMSA9IHtcbiAgICBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0OiBudWxsLFxuICAgIGluaXRpYWxDbGllbnRPZmZzZXQ6IG51bGwsXG4gICAgY2xpZW50T2Zmc2V0OiBudWxsXG59O1xuZnVuY3Rpb24gcmVkdWNlJDQoc3RhdGUgPSBpbml0aWFsU3RhdGUkMSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkICB9ID0gYWN0aW9uO1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgSU5JVF9DT09SRFM6XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldDogcGF5bG9hZC5zb3VyY2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbENsaWVudE9mZnNldDogcGF5bG9hZC5jbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBwYXlsb2FkLmNsaWVudE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBIT1ZFUjpcbiAgICAgICAgICAgIGlmIChhcmVDb29yZHNFcXVhbChzdGF0ZS5jbGllbnRPZmZzZXQsIHBheWxvYWQuY2xpZW50T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBwYXlsb2FkLmNsaWVudE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgRU5EX0RSQUc6XG4gICAgICAgIGNhc2UgRFJPUDpcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsU3RhdGUkMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQyKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5JDIodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgaXRlbVR5cGU6IG51bGwsXG4gICAgaXRlbTogbnVsbCxcbiAgICBzb3VyY2VJZDogbnVsbCxcbiAgICB0YXJnZXRJZHM6IFtdLFxuICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgZGlkRHJvcDogZmFsc2UsXG4gICAgaXNTb3VyY2VQdWJsaWM6IG51bGxcbn07XG5mdW5jdGlvbiByZWR1Y2UkMyhzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkICB9ID0gYWN0aW9uO1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDIoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgaXRlbVR5cGU6IHBheWxvYWQuaXRlbVR5cGUsXG4gICAgICAgICAgICAgICAgaXRlbTogcGF5bG9hZC5pdGVtLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXlsb2FkLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiBwYXlsb2FkLmlzU291cmNlUHVibGljLFxuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlkRHJvcDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIFBVQkxJU0hfRFJBR19TT1VSQ0U6XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBIT1ZFUjpcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDIoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzOiBwYXlsb2FkLnRhcmdldElkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgUkVNT1ZFX1RBUkdFVDpcbiAgICAgICAgICAgIGlmIChzdGF0ZS50YXJnZXRJZHMuaW5kZXhPZihwYXlsb2FkLnRhcmdldElkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIHRhcmdldElkczogd2l0aG91dCQxKHN0YXRlLnRhcmdldElkcywgcGF5bG9hZC50YXJnZXRJZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIERST1A6XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IHBheWxvYWQuZHJvcFJlc3VsdCxcbiAgICAgICAgICAgICAgICBkaWREcm9wOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldElkczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIEVORF9EUkFHOlxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMih7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtOiBudWxsLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBudWxsLFxuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlkRHJvcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNTb3VyY2VQdWJsaWM6IG51bGwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2UkMihzdGF0ZSA9IDAsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQUREX1NPVVJDRTpcbiAgICAgICAgY2FzZSBBRERfVEFSR0VUOlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlICsgMTtcbiAgICAgICAgY2FzZSBSRU1PVkVfU09VUkNFOlxuICAgICAgICBjYXNlIFJFTU9WRV9UQVJHRVQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgLSAxO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlJDEoc3RhdGUgPSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlICsgMTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5JDEob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkkMSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHJlZHVjZShzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXJ0eUhhbmRsZXJJZHM6IHJlZHVjZSQ1KHN0YXRlLmRpcnR5SGFuZGxlcklkcywge1xuICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkOiBfb2JqZWN0U3ByZWFkJDEoe30sIGFjdGlvbi5wYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldElkczogZ2V0KHN0YXRlLCAnZHJhZ09wZXJhdGlvbi50YXJnZXRJZHMnLCBbXSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICBkcmFnT2Zmc2V0OiByZWR1Y2UkNChzdGF0ZS5kcmFnT2Zmc2V0LCBhY3Rpb24pLFxuICAgICAgICByZWZDb3VudDogcmVkdWNlJDIoc3RhdGUucmVmQ291bnQsIGFjdGlvbiksXG4gICAgICAgIGRyYWdPcGVyYXRpb246IHJlZHVjZSQzKHN0YXRlLmRyYWdPcGVyYXRpb24sIGFjdGlvbiksXG4gICAgICAgIHN0YXRlSWQ6IHJlZHVjZSQxKHN0YXRlLnN0YXRlSWQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHJhZ0Ryb3BNYW5hZ2VyKGJhY2tlbmRGYWN0b3J5LCBnbG9iYWxDb250ZXh0ID0gdW5kZWZpbmVkLCBiYWNrZW5kT3B0aW9ucyA9IHt9LCBkZWJ1Z01vZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0b3JlID0gbWFrZVN0b3JlSW5zdGFuY2UoZGVidWdNb2RlKTtcbiAgICBjb25zdCBtb25pdG9yID0gbmV3IERyYWdEcm9wTW9uaXRvckltcGwoc3RvcmUsIG5ldyBIYW5kbGVyUmVnaXN0cnlJbXBsKHN0b3JlKSk7XG4gICAgY29uc3QgbWFuYWdlciA9IG5ldyBEcmFnRHJvcE1hbmFnZXJJbXBsKHN0b3JlLCBtb25pdG9yKTtcbiAgICBjb25zdCBiYWNrZW5kID0gYmFja2VuZEZhY3RvcnkobWFuYWdlciwgZ2xvYmFsQ29udGV4dCwgYmFja2VuZE9wdGlvbnMpO1xuICAgIG1hbmFnZXIucmVjZWl2ZUJhY2tlbmQoYmFja2VuZCk7XG4gICAgcmV0dXJuIG1hbmFnZXI7XG59XG5mdW5jdGlvbiBtYWtlU3RvcmVJbnN0YW5jZShkZWJ1Z01vZGUpIHtcbiAgICAvLyBUT0RPOiBpZiB3ZSBldmVyIG1ha2UgYSByZWFjdC1uYXRpdmUgdmVyc2lvbiBvZiB0aGlzLFxuICAgIC8vIHdlJ2xsIG5lZWQgdG8gY29uc2lkZXIgaG93IHRvIHB1bGwgb2ZmIGRldi10b29saW5nXG4gICAgY29uc3QgcmVkdXhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fO1xuICAgIHJldHVybiBjcmVhdGVTdG9yZShyZWR1Y2UsIGRlYnVnTW9kZSAmJiByZWR1eERldlRvb2xzICYmIHJlZHV4RGV2VG9vbHMoe1xuICAgICAgICBuYW1lOiAnZG5kLWNvcmUnLFxuICAgICAgICBpbnN0YW5jZUlkOiAnZG5kLWNvcmUnXG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5sZXQgcmVmQ291bnQgPSAwO1xuY29uc3QgSU5TVEFOQ0VfU1lNID0gU3ltYm9sLmZvcignX19SRUFDVF9ETkRfQ09OVEVYVF9JTlNUQU5DRV9fJyk7XG52YXIgRG5kUHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovIG1lbW8oZnVuY3Rpb24gRG5kUHJvdmlkZXIoX3BhcmFtKSB7XG4gICAgdmFyIHsgY2hpbGRyZW4gIH0gPSBfcGFyYW0sIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wYXJhbSwgW1xuICAgICAgICBcImNoaWxkcmVuXCJcbiAgICBdKTtcbiAgICBjb25zdCBbbWFuYWdlciwgaXNHbG9iYWxJbnN0YW5jZV0gPSBnZXREbmRDb250ZXh0VmFsdWUocHJvcHMpIC8vIG1lbW9pemVkIGZyb20gcHJvcHNcbiAgICA7XG4gICAgLyoqXG5cdFx0ICogSWYgdGhlIGdsb2JhbCBjb250ZXh0IHdhcyB1c2VkIHRvIHN0b3JlIHRoZSBETkQgY29udGV4dFxuXHRcdCAqIHRoZW4gd2hlcmUgdGhlcmVzIG5vIG1vcmUgcmVmZXJlbmNlcyB0byBpdCB3ZSBzaG91bGRcblx0XHQgKiBjbGVhbiBpdCB1cCB0byBhdm9pZCBtZW1vcnkgbGVha3Ncblx0XHQgKi8gdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChpc0dsb2JhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0R2xvYmFsQ29udGV4dCgpO1xuICAgICAgICAgICAgKytyZWZDb3VudDtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGlmICgtLXJlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRbSU5TVEFOQ0VfU1lNXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIGpzeChEbmRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBtYW5hZ2VyLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn0pO1xuZnVuY3Rpb24gZ2V0RG5kQ29udGV4dFZhbHVlKHByb3BzKSB7XG4gICAgaWYgKCdtYW5hZ2VyJyBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0ge1xuICAgICAgICAgICAgZHJhZ0Ryb3BNYW5hZ2VyOiBwcm9wcy5tYW5hZ2VyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYW5hZ2VyLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgbWFuYWdlciA9IGNyZWF0ZVNpbmdsZXRvbkRuZENvbnRleHQocHJvcHMuYmFja2VuZCwgcHJvcHMuY29udGV4dCwgcHJvcHMub3B0aW9ucywgcHJvcHMuZGVidWdNb2RlKTtcbiAgICBjb25zdCBpc0dsb2JhbEluc3RhbmNlID0gIXByb3BzLmNvbnRleHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFuYWdlcixcbiAgICAgICAgaXNHbG9iYWxJbnN0YW5jZVxuICAgIF07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25EbmRDb250ZXh0KGJhY2tlbmQsIGNvbnRleHQgPSBnZXRHbG9iYWxDb250ZXh0KCksIG9wdGlvbnMsIGRlYnVnTW9kZSkge1xuICAgIGNvbnN0IGN0eCA9IGNvbnRleHQ7XG4gICAgaWYgKCFjdHhbSU5TVEFOQ0VfU1lNXSkge1xuICAgICAgICBjdHhbSU5TVEFOQ0VfU1lNXSA9IHtcbiAgICAgICAgICAgIGRyYWdEcm9wTWFuYWdlcjogY3JlYXRlRHJhZ0Ryb3BNYW5hZ2VyKGJhY2tlbmQsIGNvbnRleHQsIG9wdGlvbnMsIGRlYnVnTW9kZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eFtJTlNUQU5DRV9TWU1dO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG59XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxudmFyIGZhc3REZWVwRXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxuLy8gc3VwcHJlc3MgdGhlIHVzZUxheW91dEVmZmVjdCB3YXJuaW5nIG9uIHNlcnZlciBzaWRlLlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gbW9uaXRvciBUaGUgbW9uaXRvciB0byBjb2xsZWN0IHN0YXRlIGZyb21cbiAqIEBwYXJhbSBjb2xsZWN0IFRoZSBjb2xsZWN0aW5nIGZ1bmN0aW9uXG4gKiBAcGFyYW0gb25VcGRhdGUgQSBtZXRob2QgdG8gaW52b2tlIHdoZW4gdXBkYXRlcyBvY2N1clxuICovIGZ1bmN0aW9uIHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0LCBvblVwZGF0ZSkge1xuICAgIGNvbnN0IFtjb2xsZWN0ZWQsIHNldENvbGxlY3RlZF0gPSB1c2VTdGF0ZSgoKT0+Y29sbGVjdChtb25pdG9yKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlQ29sbGVjdGVkID0gdXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY29sbGVjdChtb25pdG9yKTtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhIGRlZXAtZXF1YWxpdHkgY2hlY2sgYmVjYXVzZSBzb21lIG1vbml0b3ItY29sbGVjdGVkIHZhbHVlc1xuICAgICAgICAvLyBpbmNsdWRlIFhZQ29vcmQgb2JqZWN0cyB0aGF0IG1heSBiZSBlcXVpdmFsZW50LCBidXQgZG8gbm90IGhhdmUgaW5zdGFuY2UgZXF1YWxpdHkuXG4gICAgICAgIGlmICghZmFzdERlZXBFcXVhbChjb2xsZWN0ZWQsIG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHNldENvbGxlY3RlZChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgb25VcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgY29sbGVjdGVkLFxuICAgICAgICBtb25pdG9yLFxuICAgICAgICBvblVwZGF0ZVxuICAgIF0pO1xuICAgIC8vIHVwZGF0ZSB0aGUgY29sbGVjdGVkIHByb3BlcnRpZXMgYWZ0ZXIgcmVhY3QgcmVuZGVycy5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIFwiRHVzdGJpbiBTdHJlc3MgVGVzdFwiIGZhaWxzIGlmIHRoaXMgaXMgbm90XG4gICAgLy8gZG9uZSB3aGVuIHRoZSBjb21wb25lbnQgdXBkYXRlc1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QodXBkYXRlQ29sbGVjdGVkKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb2xsZWN0ZWQsXG4gICAgICAgIHVwZGF0ZUNvbGxlY3RlZFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZU1vbml0b3JPdXRwdXQobW9uaXRvciwgY29sbGVjdCwgb25Db2xsZWN0KSB7XG4gICAgY29uc3QgW2NvbGxlY3RlZCwgdXBkYXRlQ29sbGVjdGVkXSA9IHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0LCBvbkNvbGxlY3QpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gc3Vic2NyaWJlVG9Nb25pdG9yU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJJZCA9IG1vbml0b3IuZ2V0SGFuZGxlcklkKCk7XG4gICAgICAgIGlmIChoYW5kbGVySWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UodXBkYXRlQ29sbGVjdGVkLCB7XG4gICAgICAgICAgICBoYW5kbGVySWRzOiBbXG4gICAgICAgICAgICAgICAgaGFuZGxlcklkXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgbW9uaXRvcixcbiAgICAgICAgdXBkYXRlQ29sbGVjdGVkXG4gICAgXSk7XG4gICAgcmV0dXJuIGNvbGxlY3RlZDtcbn1cblxuZnVuY3Rpb24gdXNlQ29sbGVjdGVkUHJvcHMoY29sbGVjdG9yLCBtb25pdG9yLCBjb25uZWN0b3IpIHtcbiAgICByZXR1cm4gdXNlTW9uaXRvck91dHB1dChtb25pdG9yLCBjb2xsZWN0b3IgfHwgKCgpPT4oe30pXG4gICAgKSwgKCk9PmNvbm5lY3Rvci5yZWNvbm5lY3QoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHVzZU9wdGlvbmFsRmFjdG9yeShhcmcsIGRlcHMpIHtcbiAgICBjb25zdCBtZW1vRGVwcyA9IFtcbiAgICAgICAgLi4uZGVwcyB8fCBbXVxuICAgIF07XG4gICAgaWYgKGRlcHMgPT0gbnVsbCAmJiB0eXBlb2YgYXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1lbW9EZXBzLnB1c2goYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBhcmcoKSA6IGFyZztcbiAgICB9LCBtZW1vRGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbm5lY3REcmFnU291cmNlKGNvbm5lY3Rvcikge1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5jb25uZWN0b3IuaG9va3MuZHJhZ1NvdXJjZSgpXG4gICAgLCBbXG4gICAgICAgIGNvbm5lY3RvclxuICAgIF0pO1xufVxuZnVuY3Rpb24gdXNlQ29ubmVjdERyYWdQcmV2aWV3KGNvbm5lY3Rvcikge1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5jb25uZWN0b3IuaG9va3MuZHJhZ1ByZXZpZXcoKVxuICAgICwgW1xuICAgICAgICBjb25uZWN0b3JcbiAgICBdKTtcbn1cblxubGV0IGlzQ2FsbGluZ0NhbkRyYWcgPSBmYWxzZTtcbmxldCBpc0NhbGxpbmdJc0RyYWdnaW5nID0gZmFsc2U7XG5jbGFzcyBEcmFnU291cmNlTW9uaXRvckltcGwge1xuICAgIHJlY2VpdmVIYW5kbGVySWQoc291cmNlSWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJZCA9IHNvdXJjZUlkO1xuICAgIH1cbiAgICBnZXRIYW5kbGVySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUlkO1xuICAgIH1cbiAgICBjYW5EcmFnKCkge1xuICAgICAgICBpbnZhcmlhbnQoIWlzQ2FsbGluZ0NhbkRyYWcsICdZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuY2FuRHJhZygpIGluc2lkZSB5b3VyIGNhbkRyYWcoKSBpbXBsZW1lbnRhdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcmFnLXNvdXJjZS1tb25pdG9yJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5EcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5EcmFnU291cmNlKHRoaXMuc291cmNlSWQpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5EcmFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KCFpc0NhbGxpbmdJc0RyYWdnaW5nLCAnWW91IG1heSBub3QgY2FsbCBtb25pdG9yLmlzRHJhZ2dpbmcoKSBpbnNpZGUgeW91ciBpc0RyYWdnaW5nKCkgaW1wbGVtZW50YXRpb24uICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy9hcGkvZHJhZy1zb3VyY2UtbW9uaXRvcicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNEcmFnZ2luZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKTtcbiAgICB9XG4gICAgaXNPdmVyVGFyZ2V0KHRhcmdldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc092ZXJUYXJnZXQodGFyZ2V0SWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRJZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRUYXJnZXRJZHMoKTtcbiAgICB9XG4gICAgaXNTb3VyY2VQdWJsaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc1NvdXJjZVB1YmxpYygpO1xuICAgIH1cbiAgICBnZXRTb3VyY2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvT2Zmc2V0Q2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5zdWJzY3JpYmVUb09mZnNldENoYW5nZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIGNhbkRyYWdTb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyYWdTb3VyY2Uoc291cmNlSWQpO1xuICAgIH1cbiAgICBjYW5Ecm9wT25UYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyb3BPblRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGdldEl0ZW1UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SXRlbVR5cGUoKTtcbiAgICB9XG4gICAgZ2V0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW0oKTtcbiAgICB9XG4gICAgZ2V0RHJvcFJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldERyb3BSZXN1bHQoKTtcbiAgICB9XG4gICAgZGlkRHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmRpZERyb3AoKTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldENsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldENsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgICBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWFuYWdlcil7XG4gICAgICAgIHRoaXMuc291cmNlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVybmFsTW9uaXRvciA9IG1hbmFnZXIuZ2V0TW9uaXRvcigpO1xuICAgIH1cbn1cblxubGV0IGlzQ2FsbGluZ0NhbkRyb3AgPSBmYWxzZTtcbmNsYXNzIERyb3BUYXJnZXRNb25pdG9ySW1wbCB7XG4gICAgcmVjZWl2ZUhhbmRsZXJJZCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgfVxuICAgIGdldEhhbmRsZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0SWQ7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYW5Ecm9wKCkge1xuICAgICAgICAvLyBDdXQgb3V0IGVhcmx5IGlmIHRoZSB0YXJnZXQgaWQgaGFzIG5vdCBiZWVuIHNldC4gVGhpcyBzaG91bGQgcHJldmVudCBlcnJvcnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIHVzZXIgaGFzIGFuIG9sZGVyIHZlcnNpb24gb2YgZG5kLWNvcmUgbGlrZSBpblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvMTMxMFxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnZhcmlhbnQoIWlzQ2FsbGluZ0NhbkRyb3AsICdZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuY2FuRHJvcCgpIGluc2lkZSB5b3VyIGNhbkRyb3AoKSBpbXBsZW1lbnRhdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcm9wLXRhcmdldC1tb25pdG9yJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5Ecm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5Ecm9wT25UYXJnZXQodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlzQ2FsbGluZ0NhbkRyb3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc092ZXIob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNPdmVyVGFyZ2V0KHRoaXMudGFyZ2V0SWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRJdGVtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgfVxuICAgIGdldEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJdGVtKCk7XG4gICAgfVxuICAgIGdldERyb3BSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREcm9wUmVzdWx0KCk7XG4gICAgfVxuICAgIGRpZERyb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5kaWREcm9wKCk7XG4gICAgfVxuICAgIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldFNvdXJjZUNsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgICBnZXRDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIpe1xuICAgICAgICB0aGlzLnRhcmdldElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbE1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFyZ2V0KHR5cGUsIHRhcmdldCwgbWFuYWdlcikge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgIGNvbnN0IHRhcmdldElkID0gcmVnaXN0cnkuYWRkVGFyZ2V0KHR5cGUsIHRhcmdldCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGFyZ2V0SWQsXG4gICAgICAgICgpPT5yZWdpc3RyeS5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU291cmNlKHR5cGUsIHNvdXJjZSwgbWFuYWdlcikge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgIGNvbnN0IHNvdXJjZUlkID0gcmVnaXN0cnkuYWRkU291cmNlKHR5cGUsIHNvdXJjZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgICgpPT5yZWdpc3RyeS5yZW1vdmVTb3VyY2Uoc291cmNlSWQpXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG4gICAgbGV0IGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcbiAgICBpZiAoY29tcGFyZVJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiAhIWNvbXBhcmVSZXN1bHQ7XG4gICAgfVxuICAgIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8ICFvYmpBIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCAhb2JqQikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gICAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgICBmb3IobGV0IGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4Kyspe1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzQVtpZHhdO1xuICAgICAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgICAgICBjb25zdCB2YWx1ZUIgPSBvYmpCW2tleV07XG4gICAgICAgIGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IGZhbHNlIHx8IGNvbXBhcmVSZXN1bHQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1JlZihvYmopIHtcbiAgICByZXR1cm4oLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY3VycmVudCcpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dJZkNvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8vIEN1c3RvbSBjb21wb25lbnRzIGNhbiBubyBsb25nZXIgYmUgd3JhcHBlZCBkaXJlY3RseSBpbiBSZWFjdCBEbkQgMi4wXG4gICAgLy8gc28gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIGRlcGVuZCBvbiBmaW5kRE9NTm9kZSgpIGZyb20gcmVhY3QtZG9tLlxuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICd0aGUgY29tcG9uZW50JztcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbmF0aXZlIGVsZW1lbnQgbm9kZXMgY2FuIG5vdyBiZSBwYXNzZWQgdG8gUmVhY3QgRG5EIGNvbm5lY3RvcnMuJyArIGBZb3UgY2FuIGVpdGhlciB3cmFwICR7ZGlzcGxheU5hbWV9IGludG8gYSA8ZGl2Piwgb3IgdHVybiBpdCBpbnRvIGEgYCArICdkcmFnIHNvdXJjZSBvciBhIGRyb3AgdGFyZ2V0IGl0c2VsZi4nKTtcbn1cbmZ1bmN0aW9uIHdyYXBIb29rVG9SZWNvZ25pemVFbGVtZW50KGhvb2spIHtcbiAgICByZXR1cm4gKGVsZW1lbnRPck5vZGUgPSBudWxsLCBvcHRpb25zID0gbnVsbCk9PntcbiAgICAgICAgLy8gV2hlbiBwYXNzZWQgYSBub2RlLCBjYWxsIHRoZSBob29rIHN0cmFpZ2h0IGF3YXkuXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoZWxlbWVudE9yTm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50T3JOb2RlO1xuICAgICAgICAgICAgaG9vayhub2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbm9kZSBzbyBpdCBjYW4gYmUgY2hhaW5lZCAoZS5nLiB3aGVuIHdpdGhpbiBjYWxsYmFjayByZWZzXG4gICAgICAgICAgICAvLyA8ZGl2IHJlZj17bm9kZSA9PiBjb25uZWN0RHJhZ1NvdXJjZShjb25uZWN0RHJvcFRhcmdldChub2RlKSl9Lz5cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHBhc3NlZCBhIFJlYWN0RWxlbWVudCwgY2xvbmUgaXQgYW5kIGF0dGFjaCB0aGlzIGZ1bmN0aW9uIGFzIGEgcmVmLlxuICAgICAgICAvLyBUaGlzIGhlbHBzIHVzIGFjaGlldmUgYSBuZWF0IEFQSSB3aGVyZSB1c2VyIGRvZXNuJ3QgZXZlbiBrbm93IHRoYXQgcmVmc1xuICAgICAgICAvLyBhcmUgYmVpbmcgdXNlZCB1bmRlciB0aGUgaG9vZC5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRPck5vZGU7XG4gICAgICAgIHRocm93SWZDb21wb3NpdGVDb21wb25lbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAvLyBXaGVuIG5vIG9wdGlvbnMgYXJlIHBhc3NlZCwgdXNlIHRoZSBob29rIGRpcmVjdGx5XG4gICAgICAgIGNvbnN0IHJlZiA9IG9wdGlvbnMgPyAobm9kZSk9Pmhvb2sobm9kZSwgb3B0aW9ucylcbiAgICAgICAgIDogaG9vaztcbiAgICAgICAgcmV0dXJuIGNsb25lV2l0aFJlZihlbGVtZW50LCByZWYpO1xuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwQ29ubmVjdG9ySG9va3MoaG9va3MpIHtcbiAgICBjb25zdCB3cmFwcGVkSG9va3MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhob29rcykuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBjb25zdCBob29rID0gaG9va3Nba2V5XTtcbiAgICAgICAgLy8gcmVmIG9iamVjdHMgc2hvdWxkIGJlIHBhc3NlZCBzdHJhaWdodCB0aHJvdWdoIHdpdGhvdXQgd3JhcHBpbmdcbiAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnUmVmJykpIHtcbiAgICAgICAgICAgIHdyYXBwZWRIb29rc1trZXldID0gaG9va3Nba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gd3JhcEhvb2tUb1JlY29nbml6ZUVsZW1lbnQoaG9vayk7XG4gICAgICAgICAgICB3cmFwcGVkSG9va3Nba2V5XSA9ICgpPT53cmFwcGVkSG9va1xuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rcztcbn1cbmZ1bmN0aW9uIHNldFJlZihyZWYsIG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lV2l0aFJlZihlbGVtZW50LCBuZXdSZWYpIHtcbiAgICBjb25zdCBwcmV2aW91c1JlZiA9IGVsZW1lbnQucmVmO1xuICAgIGludmFyaWFudCh0eXBlb2YgcHJldmlvdXNSZWYgIT09ICdzdHJpbmcnLCAnQ2Fubm90IGNvbm5lY3QgUmVhY3QgRG5EIHRvIGFuIGVsZW1lbnQgd2l0aCBhbiBleGlzdGluZyBzdHJpbmcgcmVmLiAnICsgJ1BsZWFzZSBjb252ZXJ0IGl0IHRvIHVzZSBhIGNhbGxiYWNrIHJlZiBpbnN0ZWFkLCBvciB3cmFwIGl0IGludG8gYSA8c3Bhbj4gb3IgPGRpdj4uICcgKyAnUmVhZCBtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVmcy1hbmQtdGhlLWRvbS5odG1sI2NhbGxiYWNrLXJlZnMnKTtcbiAgICBpZiAoIXByZXZpb3VzUmVmKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcmVmIG9uIHRoZSBlbGVtZW50LCB1c2UgdGhlIG5ldyByZWYgZGlyZWN0bHlcbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICByZWY6IG5ld1JlZlxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHJlZjogKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgc2V0UmVmKHByZXZpb3VzUmVmLCBub2RlKTtcbiAgICAgICAgICAgICAgICBzZXRSZWYobmV3UmVmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBTb3VyY2VDb25uZWN0b3Ige1xuICAgIHJlY2VpdmVIYW5kbGVySWQobmV3SGFuZGxlcklkKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXJJZCA9PT0gbmV3SGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBuZXdIYW5kbGVySWQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfVxuICAgIGdldCBjb25uZWN0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU291cmNlO1xuICAgIH1cbiAgICBnZXQgZHJhZ1NvdXJjZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTb3VyY2VPcHRpb25zSW50ZXJuYWw7XG4gICAgfVxuICAgIHNldCBkcmFnU291cmNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZU9wdGlvbnNJbnRlcm5hbCA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBkcmFnUHJldmlld09wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdQcmV2aWV3T3B0aW9uc0ludGVybmFsO1xuICAgIH1cbiAgICBzZXQgZHJhZ1ByZXZpZXdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnNJbnRlcm5hbCA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gdGhpcy5yZWNvbm5lY3REcmFnU291cmNlKCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RHJhZ1ByZXZpZXcoZGlkQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVjb25uZWN0RHJhZ1NvdXJjZSgpIHtcbiAgICAgICAgY29uc3QgZHJhZ1NvdXJjZSA9IHRoaXMuZHJhZ1NvdXJjZTtcbiAgICAgICAgLy8gaWYgbm90aGluZyBoYXMgY2hhbmdlZCB0aGVuIGRvbid0IHJlc3Vic2NyaWJlXG4gICAgICAgIGNvbnN0IGRpZENoYW5nZSA9IHRoaXMuZGlkSGFuZGxlcklkQ2hhbmdlKCkgfHwgdGhpcy5kaWRDb25uZWN0ZWREcmFnU291cmNlQ2hhbmdlKCkgfHwgdGhpcy5kaWREcmFnU291cmNlT3B0aW9uc0NoYW5nZSgpO1xuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3REcmFnU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZENoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBkcmFnU291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIGRpZENoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBkcmFnU291cmNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZU9wdGlvbnMgPSB0aGlzLmRyYWdTb3VyY2VPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmUgPSB0aGlzLmJhY2tlbmQuY29ubmVjdERyYWdTb3VyY2UodGhpcy5oYW5kbGVySWQsIGRyYWdTb3VyY2UsIHRoaXMuZHJhZ1NvdXJjZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWRDaGFuZ2U7XG4gICAgfVxuICAgIHJlY29ubmVjdERyYWdQcmV2aWV3KGZvcmNlRGlkQ2hhbmdlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZHJhZ1ByZXZpZXcgPSB0aGlzLmRyYWdQcmV2aWV3O1xuICAgICAgICAvLyBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkIHRoZW4gZG9uJ3QgcmVzdWJzY3JpYmVcbiAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gZm9yY2VEaWRDaGFuZ2UgfHwgdGhpcy5kaWRIYW5kbGVySWRDaGFuZ2UoKSB8fCB0aGlzLmRpZENvbm5lY3RlZERyYWdQcmV2aWV3Q2hhbmdlKCkgfHwgdGhpcy5kaWREcmFnUHJldmlld09wdGlvbnNDaGFuZ2UoKTtcbiAgICAgICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcmFnUHJldmlldykge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXcgPSBkcmFnUHJldmlldztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3ID0gZHJhZ1ByZXZpZXc7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlld09wdGlvbnMgPSB0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSA9IHRoaXMuYmFja2VuZC5jb25uZWN0RHJhZ1ByZXZpZXcodGhpcy5oYW5kbGVySWQsIGRyYWdQcmV2aWV3LCB0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlkSGFuZGxlcklkQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkICE9PSB0aGlzLmhhbmRsZXJJZDtcbiAgICB9XG4gICAgZGlkQ29ubmVjdGVkRHJhZ1NvdXJjZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgIT09IHRoaXMuZHJhZ1NvdXJjZTtcbiAgICB9XG4gICAgZGlkQ29ubmVjdGVkRHJhZ1ByZXZpZXdDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlldyAhPT0gdGhpcy5kcmFnUHJldmlldztcbiAgICB9XG4gICAgZGlkRHJhZ1NvdXJjZU9wdGlvbnNDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2VPcHRpb25zLCB0aGlzLmRyYWdTb3VyY2VPcHRpb25zKTtcbiAgICB9XG4gICAgZGlkRHJhZ1ByZXZpZXdPcHRpb25zQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlld09wdGlvbnMsIHRoaXMuZHJhZ1ByZXZpZXdPcHRpb25zKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdERyYWdTb3VyY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdTb3VyY2VVbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NvdXJjZVVuc3Vic2NyaWJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3REcmFnUHJldmlldygpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnUHJldmlld1Vuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3VW5zdWJzY3JpYmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZHJhZ1NvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1NvdXJjZU5vZGUgfHwgdGhpcy5kcmFnU291cmNlUmVmICYmIHRoaXMuZHJhZ1NvdXJjZVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBnZXQgZHJhZ1ByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdQcmV2aWV3Tm9kZSB8fCB0aGlzLmRyYWdQcmV2aWV3UmVmICYmIHRoaXMuZHJhZ1ByZXZpZXdSZWYuY3VycmVudDtcbiAgICB9XG4gICAgY2xlYXJEcmFnU291cmNlKCkge1xuICAgICAgICB0aGlzLmRyYWdTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlUmVmID0gbnVsbDtcbiAgICB9XG4gICAgY2xlYXJEcmFnUHJldmlldygpIHtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYmFja2VuZCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSB3cmFwQ29ubmVjdG9ySG9va3Moe1xuICAgICAgICAgICAgZHJhZ1NvdXJjZTogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VPcHRpb25zID0gb3B0aW9ucyB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VSZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NvdXJjZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmFnUHJldmlldzogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWdQcmV2aWV3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnMgPSBvcHRpb25zIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdSZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REcmFnUHJldmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBudWxsO1xuICAgICAgICAvLyBUaGUgZHJvcCB0YXJnZXQgbWF5IGVpdGhlciBiZSBhdHRhY2hlZCB2aWEgcmVmIG9yIGNvbm5lY3QgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5kcmFnU291cmNlUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlT3B0aW9uc0ludGVybmFsID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGRyYWcgcHJldmlldyBtYXkgZWl0aGVyIGJlIGF0dGFjaGVkIHZpYSByZWYgb3IgY29ubmVjdCBmdW5jdGlvblxuICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnNJbnRlcm5hbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcmFnU291cmNlT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXdPcHRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG59XG5cbmNsYXNzIFRhcmdldENvbm5lY3RvciB7XG4gICAgZ2V0IGNvbm5lY3RUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXQ7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgLy8gaWYgbm90aGluZyBoYXMgY2hhbmdlZCB0aGVuIGRvbid0IHJlc3Vic2NyaWJlXG4gICAgICAgIGNvbnN0IGRpZENoYW5nZSA9IHRoaXMuZGlkSGFuZGxlcklkQ2hhbmdlKCkgfHwgdGhpcy5kaWREcm9wVGFyZ2V0Q2hhbmdlKCkgfHwgdGhpcy5kaWRPcHRpb25zQ2hhbmdlKCk7XG4gICAgICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdERyb3BUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gdGhpcy5kcm9wVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMgPSB0aGlzLmRyb3BUYXJnZXRPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZURyb3BUYXJnZXQgPSB0aGlzLmJhY2tlbmQuY29ubmVjdERyb3BUYXJnZXQodGhpcy5oYW5kbGVySWQsIGRyb3BUYXJnZXQsIHRoaXMuZHJvcFRhcmdldE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY2VpdmVIYW5kbGVySWQobmV3SGFuZGxlcklkKSB7XG4gICAgICAgIGlmIChuZXdIYW5kbGVySWQgPT09IHRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBuZXdIYW5kbGVySWQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfVxuICAgIGdldCBkcm9wVGFyZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbDtcbiAgICB9XG4gICAgc2V0IGRyb3BUYXJnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0T3B0aW9uc0ludGVybmFsID0gb3B0aW9ucztcbiAgICB9XG4gICAgZGlkSGFuZGxlcklkQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkICE9PSB0aGlzLmhhbmRsZXJJZDtcbiAgICB9XG4gICAgZGlkRHJvcFRhcmdldENoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgIT09IHRoaXMuZHJvcFRhcmdldDtcbiAgICB9XG4gICAgZGlkT3B0aW9uc0NoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMsIHRoaXMuZHJvcFRhcmdldE9wdGlvbnMpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0RHJvcFRhcmdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVEcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRHJvcFRhcmdldCgpO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZURyb3BUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRyb3BUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXROb2RlIHx8IHRoaXMuZHJvcFRhcmdldFJlZiAmJiB0aGlzLmRyb3BUYXJnZXRSZWYuY3VycmVudDtcbiAgICB9XG4gICAgY2xlYXJEcm9wVGFyZ2V0KCkge1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXROb2RlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYmFja2VuZCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSB3cmFwQ29ubmVjdG9ySG9va3Moe1xuICAgICAgICAgICAgZHJvcFRhcmdldDogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyb3BUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWYobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wVGFyZ2V0UmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcklkID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGRyb3AgdGFyZ2V0IG1heSBlaXRoZXIgYmUgYXR0YWNoZWQgdmlhIHJlZiBvciBjb25uZWN0IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuZHJvcFRhcmdldFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcm9wVGFyZ2V0T3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgaG9vayB0byByZXRyaWV2ZSB0aGUgRHJhZ0Ryb3BNYW5hZ2VyIGZyb20gQ29udGV4dFxuICovIGZ1bmN0aW9uIHVzZURyYWdEcm9wTWFuYWdlcigpIHtcbiAgICBjb25zdCB7IGRyYWdEcm9wTWFuYWdlciAgfSA9IHVzZUNvbnRleHQoRG5kQ29udGV4dCk7XG4gICAgaW52YXJpYW50KGRyYWdEcm9wTWFuYWdlciAhPSBudWxsLCAnRXhwZWN0ZWQgZHJhZyBkcm9wIGNvbnRleHQnKTtcbiAgICByZXR1cm4gZHJhZ0Ryb3BNYW5hZ2VyO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnU291cmNlQ29ubmVjdG9yKGRyYWdTb3VyY2VPcHRpb25zLCBkcmFnUHJldmlld09wdGlvbnMpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlRHJhZ0Ryb3BNYW5hZ2VyKCk7XG4gICAgY29uc3QgY29ubmVjdG9yID0gdXNlTWVtbygoKT0+bmV3IFNvdXJjZUNvbm5lY3RvcihtYW5hZ2VyLmdldEJhY2tlbmQoKSlcbiAgICAsIFtcbiAgICAgICAgbWFuYWdlclxuICAgIF0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgY29ubmVjdG9yLmRyYWdTb3VyY2VPcHRpb25zID0gZHJhZ1NvdXJjZU9wdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gKCk9PmNvbm5lY3Rvci5kaXNjb25uZWN0RHJhZ1NvdXJjZSgpXG4gICAgICAgIDtcbiAgICB9LCBbXG4gICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgZHJhZ1NvdXJjZU9wdGlvbnNcbiAgICBdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGNvbm5lY3Rvci5kcmFnUHJldmlld09wdGlvbnMgPSBkcmFnUHJldmlld09wdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gKCk9PmNvbm5lY3Rvci5kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKVxuICAgICAgICA7XG4gICAgfSwgW1xuICAgICAgICBjb25uZWN0b3IsXG4gICAgICAgIGRyYWdQcmV2aWV3T3B0aW9uc1xuICAgIF0pO1xuICAgIHJldHVybiBjb25uZWN0b3I7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdTb3VyY2VNb25pdG9yKCkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKT0+bmV3IERyYWdTb3VyY2VNb25pdG9ySW1wbChtYW5hZ2VyKVxuICAgICwgW1xuICAgICAgICBtYW5hZ2VyXG4gICAgXSk7XG59XG5cbmNsYXNzIERyYWdTb3VyY2VJbXBsIHtcbiAgICBiZWdpbkRyYWcoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWMuaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNwZWMuaXRlbTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYy5pdGVtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzcGVjLml0ZW0obW9uaXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdm9pZCAwID8gcmVzdWx0IDogbnVsbDtcbiAgICB9XG4gICAgY2FuRHJhZygpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjLmNhbkRyYWcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWMuY2FuRHJhZztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYy5jYW5EcmFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlYy5jYW5EcmFnKG1vbml0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNEcmFnZ2luZyhnbG9iYWxNb25pdG9yLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgY29uc3QgeyBpc0RyYWdnaW5nICB9ID0gc3BlYztcbiAgICAgICAgcmV0dXJuIGlzRHJhZ2dpbmcgPyBpc0RyYWdnaW5nKG1vbml0b3IpIDogdGFyZ2V0ID09PSBnbG9iYWxNb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIGVuZERyYWcoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdG9yO1xuICAgICAgICBjb25zdCB7IGVuZCAgfSA9IHNwZWM7XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZChtb25pdG9yLmdldEl0ZW0oKSwgbW9uaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBtb25pdG9yLCBjb25uZWN0b3Ipe1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBtb25pdG9yO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdTb3VyY2Uoc3BlYywgbW9uaXRvciwgY29ubmVjdG9yKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHVzZU1lbW8oKCk9Pm5ldyBEcmFnU291cmNlSW1wbChzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpXG4gICAgLCBbXG4gICAgICAgIG1vbml0b3IsXG4gICAgICAgIGNvbm5lY3RvclxuICAgIF0pO1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBoYW5kbGVyLnNwZWMgPSBzcGVjO1xuICAgIH0sIFtcbiAgICAgICAgc3BlY1xuICAgIF0pO1xuICAgIHJldHVybiBoYW5kbGVyO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnVHlwZShzcGVjKSB7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlYy50eXBlO1xuICAgICAgICBpbnZhcmlhbnQocmVzdWx0ICE9IG51bGwsICdzcGVjLnR5cGUgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW1xuICAgICAgICBzcGVjXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdGVyZWREcmFnU291cmNlKHNwZWMsIG1vbml0b3IsIGNvbm5lY3Rvcikge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gdXNlRHJhZ1NvdXJjZShzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIGNvbnN0IGl0ZW1UeXBlID0gdXNlRHJhZ1R5cGUoc3BlYyk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiByZWdpc3RlckRyYWdTb3VyY2UoKSB7XG4gICAgICAgIGlmIChpdGVtVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBbaGFuZGxlcklkLCB1bnJlZ2lzdGVyXSA9IHJlZ2lzdGVyU291cmNlKGl0ZW1UeXBlLCBoYW5kbGVyLCBtYW5hZ2VyKTtcbiAgICAgICAgICAgIG1vbml0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICAgICAgY29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgICAgIHJldHVybiB1bnJlZ2lzdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9LCBbXG4gICAgICAgIG1hbmFnZXIsXG4gICAgICAgIG1vbml0b3IsXG4gICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgaXRlbVR5cGVcbiAgICBdKTtcbn1cblxuLyoqXG4gKiB1c2VEcmFnU291cmNlIGhvb2tcbiAqIEBwYXJhbSBzb3VyY2VTcGVjIFRoZSBkcmFnIHNvdXJjZSBzcGVjaWZpY2F0aW9uIChvYmplY3Qgb3IgZnVuY3Rpb24sIGZ1bmN0aW9uIHByZWZlcnJlZClcbiAqIEBwYXJhbSBkZXBzIFRoZSBtZW1vaXphdGlvbiBkZXBzIGFycmF5IHRvIHVzZSB3aGVuIGV2YWx1YXRpbmcgc3BlYyBjaGFuZ2VzXG4gKi8gZnVuY3Rpb24gdXNlRHJhZyhzcGVjQXJnLCBkZXBzKSB7XG4gICAgY29uc3Qgc3BlYyA9IHVzZU9wdGlvbmFsRmFjdG9yeShzcGVjQXJnLCBkZXBzKTtcbiAgICBpbnZhcmlhbnQoIXNwZWMuYmVnaW4sIGB1c2VEcmFnOjpzcGVjLmJlZ2luIHdhcyBkZXByZWNhdGVkIGluIHYxNC4gUmVwbGFjZSBzcGVjLmJlZ2luKCkgd2l0aCBzcGVjLml0ZW0oKS4gKHNlZSBtb3JlIGhlcmUgLSBodHRwczovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MvYXBpL3VzZS1kcmFnKWApO1xuICAgIGNvbnN0IG1vbml0b3IgPSB1c2VEcmFnU291cmNlTW9uaXRvcigpO1xuICAgIGNvbnN0IGNvbm5lY3RvciA9IHVzZURyYWdTb3VyY2VDb25uZWN0b3Ioc3BlYy5vcHRpb25zLCBzcGVjLnByZXZpZXdPcHRpb25zKTtcbiAgICB1c2VSZWdpc3RlcmVkRHJhZ1NvdXJjZShzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHVzZUNvbGxlY3RlZFByb3BzKHNwZWMuY29sbGVjdCwgbW9uaXRvciwgY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyYWdTb3VyY2UoY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyYWdQcmV2aWV3KGNvbm5lY3RvciksIFxuICAgIF07XG59XG5cbi8qKlxuICogdXNlRHJhZ0xheWVyIEhvb2tcbiAqIEBwYXJhbSBjb2xsZWN0b3IgVGhlIHByb3BlcnR5IGNvbGxlY3RvclxuICovIGZ1bmN0aW9uIHVzZURyYWdMYXllcihjb2xsZWN0KSB7XG4gICAgY29uc3QgZHJhZ0Ryb3BNYW5hZ2VyID0gdXNlRHJhZ0Ryb3BNYW5hZ2VyKCk7XG4gICAgY29uc3QgbW9uaXRvciA9IGRyYWdEcm9wTWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgY29uc3QgW2NvbGxlY3RlZCwgdXBkYXRlQ29sbGVjdGVkXSA9IHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0KTtcbiAgICB1c2VFZmZlY3QoKCk9Pm1vbml0b3Iuc3Vic2NyaWJlVG9PZmZzZXRDaGFuZ2UodXBkYXRlQ29sbGVjdGVkKVxuICAgICk7XG4gICAgdXNlRWZmZWN0KCgpPT5tb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UodXBkYXRlQ29sbGVjdGVkKVxuICAgICk7XG4gICAgcmV0dXJuIGNvbGxlY3RlZDtcbn1cblxuZnVuY3Rpb24gdXNlQ29ubmVjdERyb3BUYXJnZXQoY29ubmVjdG9yKSB7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PmNvbm5lY3Rvci5ob29rcy5kcm9wVGFyZ2V0KClcbiAgICAsIFtcbiAgICAgICAgY29ubmVjdG9yXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURyb3BUYXJnZXRDb25uZWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICBjb25zdCBjb25uZWN0b3IgPSB1c2VNZW1vKCgpPT5uZXcgVGFyZ2V0Q29ubmVjdG9yKG1hbmFnZXIuZ2V0QmFja2VuZCgpKVxuICAgICwgW1xuICAgICAgICBtYW5hZ2VyXG4gICAgXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBjb25uZWN0b3IuZHJvcFRhcmdldE9wdGlvbnMgPSBvcHRpb25zIHx8IG51bGw7XG4gICAgICAgIGNvbm5lY3Rvci5yZWNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuICgpPT5jb25uZWN0b3IuZGlzY29ubmVjdERyb3BUYXJnZXQoKVxuICAgICAgICA7XG4gICAgfSwgW1xuICAgICAgICBvcHRpb25zXG4gICAgXSk7XG4gICAgcmV0dXJuIGNvbm5lY3Rvcjtcbn1cblxuZnVuY3Rpb24gdXNlRHJvcFRhcmdldE1vbml0b3IoKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZURyYWdEcm9wTWFuYWdlcigpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5uZXcgRHJvcFRhcmdldE1vbml0b3JJbXBsKG1hbmFnZXIpXG4gICAgLCBbXG4gICAgICAgIG1hbmFnZXJcbiAgICBdKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB1dGlsaXR5IGhvb2sgdG8gZ2V0IGFuIGFycmF5LXZlcnNpb24gb2Ygc3BlYy5hY2NlcHQuXG4gKiBUaGUgbWFpbiB1dGlsaXR5IGhlcmUgaXMgdGhhdCB3ZSBhcmVuJ3QgY3JlYXRpbmcgYSBuZXcgYXJyYXkgb24gZXZlcnkgcmVuZGVyIGlmIGEgbm9uLWFycmF5IHNwZWMuYWNjZXB0IGlzIHBhc3NlZCBpbi5cbiAqIEBwYXJhbSBzcGVjXG4gKi8gZnVuY3Rpb24gdXNlQWNjZXB0KHNwZWMpIHtcbiAgICBjb25zdCB7IGFjY2VwdCAgfSA9IHNwZWM7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgaW52YXJpYW50KHNwZWMuYWNjZXB0ICE9IG51bGwsICdhY2NlcHQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFjY2VwdCkgPyBhY2NlcHQgOiBbXG4gICAgICAgICAgICBhY2NlcHRcbiAgICAgICAgXTtcbiAgICB9LCBbXG4gICAgICAgIGFjY2VwdFxuICAgIF0pO1xufVxuXG5jbGFzcyBEcm9wVGFyZ2V0SW1wbCB7XG4gICAgY2FuRHJvcCgpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgcmV0dXJuIHNwZWMuY2FuRHJvcCA/IHNwZWMuY2FuRHJvcChtb25pdG9yLmdldEl0ZW0oKSwgbW9uaXRvcikgOiB0cnVlO1xuICAgIH1cbiAgICBob3ZlcigpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgaWYgKHNwZWMuaG92ZXIpIHtcbiAgICAgICAgICAgIHNwZWMuaG92ZXIobW9uaXRvci5nZXRJdGVtKCksIG1vbml0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGlmIChzcGVjLmRyb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVjLmRyb3AobW9uaXRvci5nZXRJdGVtKCksIG1vbml0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3BlYywgbW9uaXRvcil7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1c2VEcm9wVGFyZ2V0KHNwZWMsIG1vbml0b3IpIHtcbiAgICBjb25zdCBkcm9wVGFyZ2V0ID0gdXNlTWVtbygoKT0+bmV3IERyb3BUYXJnZXRJbXBsKHNwZWMsIG1vbml0b3IpXG4gICAgLCBbXG4gICAgICAgIG1vbml0b3JcbiAgICBdKTtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgZHJvcFRhcmdldC5zcGVjID0gc3BlYztcbiAgICB9LCBbXG4gICAgICAgIHNwZWNcbiAgICBdKTtcbiAgICByZXR1cm4gZHJvcFRhcmdldDtcbn1cblxuZnVuY3Rpb24gdXNlUmVnaXN0ZXJlZERyb3BUYXJnZXQoc3BlYywgbW9uaXRvciwgY29ubmVjdG9yKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZURyYWdEcm9wTWFuYWdlcigpO1xuICAgIGNvbnN0IGRyb3BUYXJnZXQgPSB1c2VEcm9wVGFyZ2V0KHNwZWMsIG1vbml0b3IpO1xuICAgIGNvbnN0IGFjY2VwdCA9IHVzZUFjY2VwdChzcGVjKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIHJlZ2lzdGVyRHJvcFRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgW2hhbmRsZXJJZCwgdW5yZWdpc3Rlcl0gPSByZWdpc3RlclRhcmdldChhY2NlcHQsIGRyb3BUYXJnZXQsIG1hbmFnZXIpO1xuICAgICAgICBtb25pdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgY29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgcmV0dXJuIHVucmVnaXN0ZXI7XG4gICAgfSwgW1xuICAgICAgICBtYW5hZ2VyLFxuICAgICAgICBtb25pdG9yLFxuICAgICAgICBkcm9wVGFyZ2V0LFxuICAgICAgICBjb25uZWN0b3IsXG4gICAgICAgIGFjY2VwdC5tYXAoKGEpPT5hLnRvU3RyaW5nKClcbiAgICAgICAgKS5qb2luKCd8JyksIFxuICAgIF0pO1xufVxuXG4vKipcbiAqIHVzZURyb3BUYXJnZXQgSG9va1xuICogQHBhcmFtIHNwZWMgVGhlIGRyb3AgdGFyZ2V0IHNwZWNpZmljYXRpb24gKG9iamVjdCBvciBmdW5jdGlvbiwgZnVuY3Rpb24gcHJlZmVycmVkKVxuICogQHBhcmFtIGRlcHMgVGhlIG1lbW9pemF0aW9uIGRlcHMgYXJyYXkgdG8gdXNlIHdoZW4gZXZhbHVhdGluZyBzcGVjIGNoYW5nZXNcbiAqLyBmdW5jdGlvbiB1c2VEcm9wKHNwZWNBcmcsIGRlcHMpIHtcbiAgICBjb25zdCBzcGVjID0gdXNlT3B0aW9uYWxGYWN0b3J5KHNwZWNBcmcsIGRlcHMpO1xuICAgIGNvbnN0IG1vbml0b3IgPSB1c2VEcm9wVGFyZ2V0TW9uaXRvcigpO1xuICAgIGNvbnN0IGNvbm5lY3RvciA9IHVzZURyb3BUYXJnZXRDb25uZWN0b3Ioc3BlYy5vcHRpb25zKTtcbiAgICB1c2VSZWdpc3RlcmVkRHJvcFRhcmdldChzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHVzZUNvbGxlY3RlZFByb3BzKHNwZWMuY29sbGVjdCwgbW9uaXRvciwgY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyb3BUYXJnZXQoY29ubmVjdG9yKSwgXG4gICAgXTtcbn1cblxuLy8gY2hlYXAgbG9kYXNoIHJlcGxhY2VtZW50c1xuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGNvbnN0IG1lbW9pemVkID0gKCk9PntcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG4vKipcbiAqIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIF8ud2l0aG91dFxuICovIGZ1bmN0aW9uIHdpdGhvdXQoaXRlbXMsIGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpKT0+aSAhPT0gaXRlbVxuICAgICk7XG59XG5mdW5jdGlvbiB1bmlvbihpdGVtc0EsIGl0ZW1zQikge1xuICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnNlcnRJdGVtID0gKGl0ZW0pPT5zZXQuYWRkKGl0ZW0pXG4gICAgO1xuICAgIGl0ZW1zQS5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGl0ZW1zQi5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHNldC5mb3JFYWNoKChrZXkpPT5yZXN1bHQucHVzaChrZXkpXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jbGFzcyBFbnRlckxlYXZlQ291bnRlciB7XG4gICAgZW50ZXIoZW50ZXJpbmdOb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gdGhpcy5lbnRlcmVkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNOb2RlRW50ZXJlZCA9IChub2RlKT0+dGhpcy5pc05vZGVJbkRvY3VtZW50KG5vZGUpICYmICghbm9kZS5jb250YWlucyB8fCBub2RlLmNvbnRhaW5zKGVudGVyaW5nTm9kZSkpXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gdW5pb24odGhpcy5lbnRlcmVkLmZpbHRlcihpc05vZGVFbnRlcmVkKSwgW1xuICAgICAgICAgICAgZW50ZXJpbmdOb2RlXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gcHJldmlvdXNMZW5ndGggPT09IDAgJiYgdGhpcy5lbnRlcmVkLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGxlYXZlKGxlYXZpbmdOb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gdGhpcy5lbnRlcmVkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gd2l0aG91dCh0aGlzLmVudGVyZWQuZmlsdGVyKHRoaXMuaXNOb2RlSW5Eb2N1bWVudCksIGxlYXZpbmdOb2RlKTtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTGVuZ3RoID4gMCAmJiB0aGlzLmVudGVyZWQubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gW107XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzTm9kZUluRG9jdW1lbnQpe1xuICAgICAgICB0aGlzLmVudGVyZWQgPSBbXTtcbiAgICAgICAgdGhpcy5pc05vZGVJbkRvY3VtZW50ID0gaXNOb2RlSW5Eb2N1bWVudDtcbiAgICB9XG59XG5cbmNsYXNzIE5hdGl2ZURyYWdTb3VyY2Uge1xuICAgIGluaXRpYWxpemVFeHBvc2VkUHJvcGVydGllcygpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25maWcuZXhwb3NlUHJvcGVydGllcykuZm9yRWFjaCgocHJvcGVydHkpPT57XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5pdGVtLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQnJvd3NlciBkb2Vzbid0IGFsbG93IHJlYWRpbmcgXCIke3Byb3BlcnR5fVwiIHVudGlsIHRoZSBkcm9wIGV2ZW50LmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWREYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLmV4cG9zZVByb3BlcnRpZXMpLmZvckVhY2goKHByb3BlcnR5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5Rm4gPSB0aGlzLmNvbmZpZy5leHBvc2VQcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlGbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNbcHJvcGVydHldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb3BlcnR5Rm4oZGF0YVRyYW5zZmVyLCB0aGlzLmNvbmZpZy5tYXRjaGVzVHlwZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5pdGVtLCBuZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5EcmFnKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVnaW5EcmFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nKG1vbml0b3IsIGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlID09PSBtb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIGVuZERyYWcoKSB7XG4gICAgLy8gZW1wdHlcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZmlnKXtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuaXRlbSA9IHt9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemVFeHBvc2VkUHJvcGVydGllcygpO1xuICAgIH1cbn1cblxuY29uc3QgRklMRSA9ICdfX05BVElWRV9GSUxFX18nO1xuY29uc3QgVVJMID0gJ19fTkFUSVZFX1VSTF9fJztcbmNvbnN0IFRFWFQgPSAnX19OQVRJVkVfVEVYVF9fJztcbmNvbnN0IEhUTUwgPSAnX19OQVRJVkVfSFRNTF9fJztcblxudmFyIE5hdGl2ZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBGSUxFOiBGSUxFLFxuICAgIEhUTUw6IEhUTUwsXG4gICAgVEVYVDogVEVYVCxcbiAgICBVUkw6IFVSTFxufSk7XG5cbmZ1bmN0aW9uIGdldERhdGFGcm9tRGF0YVRyYW5zZmVyKGRhdGFUcmFuc2ZlciwgdHlwZXNUb1RyeSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHlwZXNUb1RyeS5yZWR1Y2UoKHJlc3VsdFNvRmFyLCB0eXBlVG9UcnkpPT5yZXN1bHRTb0ZhciB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSh0eXBlVG9UcnkpXG4gICAgLCAnJyk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogZGVmYXVsdFZhbHVlO1xufVxuXG5jb25zdCBuYXRpdmVUeXBlc0NvbmZpZyA9IHtcbiAgICBbRklMRV06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgZmlsZXM6IChkYXRhVHJhbnNmZXIpPT5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhVHJhbnNmZXIuZmlsZXMpXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBpdGVtczogKGRhdGFUcmFuc2Zlcik9PmRhdGFUcmFuc2Zlci5pdGVtc1xuICAgICAgICAgICAgLFxuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiAoZGF0YVRyYW5zZmVyKT0+ZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNUeXBlczogW1xuICAgICAgICAgICAgJ0ZpbGVzJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICBbSFRNTF06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgaHRtbDogKGRhdGFUcmFuc2ZlciwgbWF0Y2hlc1R5cGVzKT0+Z2V0RGF0YUZyb21EYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMsICcnKVxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiAoZGF0YVRyYW5zZmVyKT0+ZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNUeXBlczogW1xuICAgICAgICAgICAgJ0h0bWwnLFxuICAgICAgICAgICAgJ3RleHQvaHRtbCdcbiAgICAgICAgXVxuICAgIH0sXG4gICAgW1VSTF06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgdXJsczogKGRhdGFUcmFuc2ZlciwgbWF0Y2hlc1R5cGVzKT0+Z2V0RGF0YUZyb21EYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMsICcnKS5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogKGRhdGFUcmFuc2Zlcik9PmRhdGFUcmFuc2ZlclxuICAgICAgICB9LFxuICAgICAgICBtYXRjaGVzVHlwZXM6IFtcbiAgICAgICAgICAgICdVcmwnLFxuICAgICAgICAgICAgJ3RleHQvdXJpLWxpc3QnXG4gICAgICAgIF1cbiAgICB9LFxuICAgIFtURVhUXToge1xuICAgICAgICBleHBvc2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICB0ZXh0OiAoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMpPT5nZXREYXRhRnJvbURhdGFUcmFuc2ZlcihkYXRhVHJhbnNmZXIsIG1hdGNoZXNUeXBlcywgJycpXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IChkYXRhVHJhbnNmZXIpPT5kYXRhVHJhbnNmZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1R5cGVzOiBbXG4gICAgICAgICAgICAnVGV4dCcsXG4gICAgICAgICAgICAndGV4dC9wbGFpbidcbiAgICAgICAgXVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZURyYWdTb3VyY2UodHlwZSwgZGF0YVRyYW5zZmVyKSB7XG4gICAgY29uc3QgY29uZmlnID0gbmF0aXZlVHlwZXNDb25maWdbdHlwZV07XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBuYXRpdmUgdHlwZSAke3R5cGV9IGhhcyBubyBjb25maWd1cmF0aW9uYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBOYXRpdmVEcmFnU291cmNlKGNvbmZpZyk7XG4gICAgcmVzdWx0LmxvYWREYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWF0Y2hOYXRpdmVJdGVtVHlwZShkYXRhVHJhbnNmZXIpIHtcbiAgICBpZiAoIWRhdGFUcmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YVRyYW5zZmVyVHlwZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhVHJhbnNmZXIudHlwZXMgfHwgW10pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhuYXRpdmVUeXBlc0NvbmZpZykuZmlsdGVyKChuYXRpdmVJdGVtVHlwZSk9PntcbiAgICAgICAgY29uc3QgdHlwZUNvbmZpZyA9IG5hdGl2ZVR5cGVzQ29uZmlnW25hdGl2ZUl0ZW1UeXBlXTtcbiAgICAgICAgaWYgKCEodHlwZUNvbmZpZyA9PT0gbnVsbCB8fCB0eXBlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlQ29uZmlnLm1hdGNoZXNUeXBlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZUNvbmZpZy5tYXRjaGVzVHlwZXMuc29tZSgodCk9PmRhdGFUcmFuc2ZlclR5cGVzLmluZGV4T2YodCkgPiAtMVxuICAgICAgICApO1xuICAgIH0pWzBdIHx8IG51bGw7XG59XG5cbmNvbnN0IGlzRmlyZWZveCA9IG1lbW9pemUoKCk9Pi9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuKTtcbmNvbnN0IGlzU2FmYXJpID0gbWVtb2l6ZSgoKT0+Qm9vbGVhbih3aW5kb3cuc2FmYXJpKVxuKTtcblxuY2xhc3MgTW9ub3RvbmljSW50ZXJwb2xhbnQge1xuICAgIGludGVycG9sYXRlKHgpIHtcbiAgICAgICAgY29uc3QgeyB4cyAsIHlzICwgYzFzICwgYzJzICwgYzNzICB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIHJpZ2h0bW9zdCBwb2ludCBpbiB0aGUgZGF0YXNldCBzaG91bGQgZ2l2ZSBhbiBleGFjdCByZXN1bHRcbiAgICAgICAgbGV0IGkgPSB4cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoeCA9PT0geHNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB5c1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBpbnRlcnZhbCB4IGlzIGluLCByZXR1cm5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgeSBpZiB4IGlzIG9uZSBvZiB0aGUgb3JpZ2luYWwgeHNcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gYzNzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBtaWQ7XG4gICAgICAgIHdoaWxlKGxvdyA8PSBoaWdoKXtcbiAgICAgICAgICAgIG1pZCA9IE1hdGguZmxvb3IoMC41ICogKGxvdyArIGhpZ2gpKTtcbiAgICAgICAgICAgIGNvbnN0IHhIZXJlID0geHNbbWlkXTtcbiAgICAgICAgICAgIGlmICh4SGVyZSA8IHgpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4SGVyZSA+IHgpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlzW21pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSA9IE1hdGgubWF4KDAsIGhpZ2gpO1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZVxuICAgICAgICBjb25zdCBkaWZmID0geCAtIHhzW2ldO1xuICAgICAgICBjb25zdCBkaWZmU3EgPSBkaWZmICogZGlmZjtcbiAgICAgICAgcmV0dXJuIHlzW2ldICsgYzFzW2ldICogZGlmZiArIGMyc1tpXSAqIGRpZmZTcSArIGMzc1tpXSAqIGRpZmYgKiBkaWZmU3E7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHhzLCB5cyl7XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoICB9ID0geHM7XG4gICAgICAgIC8vIFJlYXJyYW5nZSB4cyBhbmQgeXMgc28gdGhhdCB4cyBpcyBzb3J0ZWRcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ZXMuc29ydCgoYSwgYik9PnhzW2FdIDwgeHNbYl0gPyAtMSA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZHhzID0gW107XG4gICAgICAgIGNvbnN0IG1zID0gW107XG4gICAgICAgIGxldCBkeDtcbiAgICAgICAgbGV0IGR5O1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBsZW5ndGggLSAxOyBpMSsrKXtcbiAgICAgICAgICAgIGR4ID0geHNbaTEgKyAxXSAtIHhzW2kxXTtcbiAgICAgICAgICAgIGR5ID0geXNbaTEgKyAxXSAtIHlzW2kxXTtcbiAgICAgICAgICAgIGR4cy5wdXNoKGR4KTtcbiAgICAgICAgICAgIG1zLnB1c2goZHkgLyBkeCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGRlZ3JlZS0xIGNvZWZmaWNpZW50c1xuICAgICAgICBjb25zdCBjMXMgPSBbXG4gICAgICAgICAgICBtc1swXVxuICAgICAgICBdO1xuICAgICAgICBmb3IobGV0IGkyID0gMDsgaTIgPCBkeHMubGVuZ3RoIC0gMTsgaTIrKyl7XG4gICAgICAgICAgICBjb25zdCBtMiA9IG1zW2kyXTtcbiAgICAgICAgICAgIGNvbnN0IG1OZXh0ID0gbXNbaTIgKyAxXTtcbiAgICAgICAgICAgIGlmIChtMiAqIG1OZXh0IDw9IDApIHtcbiAgICAgICAgICAgICAgICBjMXMucHVzaCgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHggPSBkeHNbaTJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4TmV4dCA9IGR4c1tpMiArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IGR4ICsgZHhOZXh0O1xuICAgICAgICAgICAgICAgIGMxcy5wdXNoKDMgKiBjb21tb24gLyAoKGNvbW1vbiArIGR4TmV4dCkgLyBtMiArIChjb21tb24gKyBkeCkgLyBtTmV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGMxcy5wdXNoKG1zW21zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gR2V0IGRlZ3JlZS0yIGFuZCBkZWdyZWUtMyBjb2VmZmljaWVudHNcbiAgICAgICAgY29uc3QgYzJzID0gW107XG4gICAgICAgIGNvbnN0IGMzcyA9IFtdO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgZm9yKGxldCBpMyA9IDA7IGkzIDwgYzFzLmxlbmd0aCAtIDE7IGkzKyspe1xuICAgICAgICAgICAgbSA9IG1zW2kzXTtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gYzFzW2kzXTtcbiAgICAgICAgICAgIGNvbnN0IGludkR4ID0gMSAvIGR4c1tpM107XG4gICAgICAgICAgICBjb25zdCBjb21tb24gPSBjMSArIGMxc1tpMyArIDFdIC0gbSAtIG07XG4gICAgICAgICAgICBjMnMucHVzaCgobSAtIGMxIC0gY29tbW9uKSAqIGludkR4KTtcbiAgICAgICAgICAgIGMzcy5wdXNoKGNvbW1vbiAqIGludkR4ICogaW52RHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueHMgPSB4cztcbiAgICAgICAgdGhpcy55cyA9IHlzO1xuICAgICAgICB0aGlzLmMxcyA9IGMxcztcbiAgICAgICAgdGhpcy5jMnMgPSBjMnM7XG4gICAgICAgIHRoaXMuYzNzID0gYzNzO1xuICAgIH1cbn1cblxuY29uc3QgRUxFTUVOVF9OT0RFJDEgPSAxO1xuZnVuY3Rpb24gZ2V0Tm9kZUNsaWVudE9mZnNldCQxKG5vZGUpIHtcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSQxID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHRvcCAsIGxlZnQgIH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBsZWZ0LFxuICAgICAgICB5OiB0b3BcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGllbnRPZmZzZXQkMShlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICB5OiBlLmNsaWVudFlcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNJbWFnZU5vZGUobm9kZSkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdJTUcnICYmIChpc0ZpcmVmb3goKSB8fCAhKChyZWYgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmNvbnRhaW5zKG5vZGUpKSk7XG59XG5mdW5jdGlvbiBnZXREcmFnUHJldmlld1NpemUoaXNJbWFnZSwgZHJhZ1ByZXZpZXcsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpIHtcbiAgICBsZXQgZHJhZ1ByZXZpZXdXaWR0aCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy53aWR0aCA6IHNvdXJjZVdpZHRoO1xuICAgIGxldCBkcmFnUHJldmlld0hlaWdodCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy5oZWlnaHQgOiBzb3VyY2VIZWlnaHQ7XG4gICAgLy8gV29yayBhcm91bmQgQDJ4IGNvb3JkaW5hdGUgZGlzY3JlcGFuY2llcyBpbiBicm93c2Vyc1xuICAgIGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcbiAgICAgICAgZHJhZ1ByZXZpZXdIZWlnaHQgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGRyYWdQcmV2aWV3V2lkdGggLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRyYWdQcmV2aWV3V2lkdGgsXG4gICAgICAgIGRyYWdQcmV2aWV3SGVpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERyYWdQcmV2aWV3T2Zmc2V0KHNvdXJjZU5vZGUsIGRyYWdQcmV2aWV3LCBjbGllbnRPZmZzZXQsIGFuY2hvclBvaW50LCBvZmZzZXRQb2ludCkge1xuICAgIC8vIFRoZSBicm93c2VycyB3aWxsIHVzZSB0aGUgaW1hZ2UgaW50cmluc2ljIHNpemUgdW5kZXIgZGlmZmVyZW50IGNvbmRpdGlvbnMuXG4gICAgLy8gRmlyZWZveCBvbmx5IGNhcmVzIGlmIGl0J3MgYW4gaW1hZ2UsIGJ1dCBXZWJLaXQgYWxzbyB3YW50cyBpdCB0byBiZSBkZXRhY2hlZC5cbiAgICBjb25zdCBpc0ltYWdlID0gaXNJbWFnZU5vZGUoZHJhZ1ByZXZpZXcpO1xuICAgIGNvbnN0IGRyYWdQcmV2aWV3Tm9kZSA9IGlzSW1hZ2UgPyBzb3VyY2VOb2RlIDogZHJhZ1ByZXZpZXc7XG4gICAgY29uc3QgZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudCA9IGdldE5vZGVDbGllbnRPZmZzZXQkMShkcmFnUHJldmlld05vZGUpO1xuICAgIGNvbnN0IG9mZnNldEZyb21EcmFnUHJldmlldyA9IHtcbiAgICAgICAgeDogY2xpZW50T2Zmc2V0LnggLSBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50LngsXG4gICAgICAgIHk6IGNsaWVudE9mZnNldC55IC0gZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudC55XG4gICAgfTtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoOiBzb3VyY2VXaWR0aCAsIG9mZnNldEhlaWdodDogc291cmNlSGVpZ2h0ICB9ID0gc291cmNlTm9kZTtcbiAgICBjb25zdCB7IGFuY2hvclggLCBhbmNob3JZICB9ID0gYW5jaG9yUG9pbnQ7XG4gICAgY29uc3QgeyBkcmFnUHJldmlld1dpZHRoICwgZHJhZ1ByZXZpZXdIZWlnaHQgIH0gPSBnZXREcmFnUHJldmlld1NpemUoaXNJbWFnZSwgZHJhZ1ByZXZpZXcsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVlPZmZzZXQgPSAoKT0+e1xuICAgICAgICBjb25zdCBpbnRlcnBvbGFudFkgPSBuZXcgTW9ub3RvbmljSW50ZXJwb2xhbnQoW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgLy8gRG9jayB0byB0aGUgdG9wXG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSxcbiAgICAgICAgICAgIC8vIEFsaWduIGF0IHRoZSBjZW50ZXJcbiAgICAgICAgICAgIChvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSAvIHNvdXJjZUhlaWdodCkgKiBkcmFnUHJldmlld0hlaWdodCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgb2Zmc2V0RnJvbURyYWdQcmV2aWV3LnkgKyBkcmFnUHJldmlld0hlaWdodCAtIHNvdXJjZUhlaWdodCwgXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgeSA9IGludGVycG9sYW50WS5pbnRlcnBvbGF0ZShhbmNob3JZKTtcbiAgICAgICAgLy8gV29yayBhcm91bmQgU2FmYXJpIDggcG9zaXRpb25pbmcgYnVnXG4gICAgICAgIGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gd2FpdCBmb3IgQDN4IHRvIHNlZSBpZiB0aGlzIGlzIGVudGlyZWx5IGNvcnJlY3RcbiAgICAgICAgICAgIHkgKz0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC0gMSkgKiBkcmFnUHJldmlld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbGN1bGF0ZVhPZmZzZXQgPSAoKT0+e1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gYW5jaG9yIHBvaW50XG4gICAgICAgIC8vIElmIHlvdSBrbm93IGEgc2ltcGxlciB3YXkgdG8gZG8gdGhpcywgbGV0IG1lIGtub3dcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhbnRYID0gbmV3IE1vbm90b25pY0ludGVycG9sYW50KFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICAxXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgIG9mZnNldEZyb21EcmFnUHJldmlldy54LFxuICAgICAgICAgICAgLy8gQWxpZ24gYXQgdGhlIGNlbnRlclxuICAgICAgICAgICAgKG9mZnNldEZyb21EcmFnUHJldmlldy54IC8gc291cmNlV2lkdGgpICogZHJhZ1ByZXZpZXdXaWR0aCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueCArIGRyYWdQcmV2aWV3V2lkdGggLSBzb3VyY2VXaWR0aCwgXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhbnRYLmludGVycG9sYXRlKGFuY2hvclgpO1xuICAgIH07XG4gICAgLy8gRm9yY2Ugb2Zmc2V0cyBpZiBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAgY29uc3QgeyBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IG9mZnNldFBvaW50O1xuICAgIGNvbnN0IGlzTWFudWFsT2Zmc2V0WCA9IG9mZnNldFggPT09IDAgfHwgb2Zmc2V0WDtcbiAgICBjb25zdCBpc01hbnVhbE9mZnNldFkgPSBvZmZzZXRZID09PSAwIHx8IG9mZnNldFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNNYW51YWxPZmZzZXRYID8gb2Zmc2V0WCA6IGNhbGN1bGF0ZVhPZmZzZXQoKSxcbiAgICAgICAgeTogaXNNYW51YWxPZmZzZXRZID8gb2Zmc2V0WSA6IGNhbGN1bGF0ZVlPZmZzZXQoKVxuICAgIH07XG59XG5cbmxldCBPcHRpb25zUmVhZGVyJDEgPSBjbGFzcyBPcHRpb25zUmVhZGVyIHtcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICBpZiAodGhpcy5nbG9iYWxDb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxDb250ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBkb2N1bWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmdsb2JhbENvbnRleHQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxDb250ZXh0LmRvY3VtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2luZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5vcHRpb25zQXJncykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYucm9vdEVsZW1lbnQpIHx8IHRoaXMud2luZG93O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihnbG9iYWxDb250ZXh0LCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5vd25lckRvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcbiAgICAgICAgdGhpcy5vcHRpb25zQXJncyA9IG9wdGlvbnM7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNsYXNzIEhUTUw1QmFja2VuZEltcGwge1xuICAgIC8qKlxuXHQgKiBHZW5lcmF0ZSBwcm9maWxpbmcgc3RhdGlzdGljcyBmb3IgdGhlIEhUTUw1QmFja2VuZC5cblx0ICovIHByb2ZpbGUoKSB7XG4gICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VQcmV2aWV3Tm9kZXM6IHRoaXMuc291cmNlUHJldmlld05vZGVzLnNpemUsXG4gICAgICAgICAgICBzb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnM6IHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zLnNpemUsXG4gICAgICAgICAgICBzb3VyY2VOb2RlT3B0aW9uczogdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5zaXplLFxuICAgICAgICAgICAgc291cmNlTm9kZXM6IHRoaXMuc291cmNlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIGRyYWdTdGFydFNvdXJjZUlkczogKChyZWYgPSB0aGlzLmRyYWdTdGFydFNvdXJjZUlkcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubGVuZ3RoKSB8fCAwLFxuICAgICAgICAgICAgZHJvcFRhcmdldElkczogdGhpcy5kcm9wVGFyZ2V0SWRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdFbnRlclRhcmdldElkczogdGhpcy5kcmFnRW50ZXJUYXJnZXRJZHMubGVuZ3RoLFxuICAgICAgICAgICAgZHJhZ092ZXJUYXJnZXRJZHM6ICgocmVmMSA9IHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEubGVuZ3RoKSB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHB1YmxpYyBmb3IgdGVzdFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud2luZG93O1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBHZXQgdGhlIHJvb3QgZWxlbWVudCB0byB1c2UgZm9yIGV2ZW50IHN1YnNjcmlwdGlvbnNcblx0ICovIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICB9XG4gICAgc2V0dXAoKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIHR3byBIVE1MNSBiYWNrZW5kcyBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycyhyb290KTtcbiAgICB9XG4gICAgdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5fX2lzUmVhY3REbmRCYWNrZW5kU2V0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJvb3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICBpZiAodGhpcy5hc3luY0VuZERyYWdGcmFtZUlkKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgKHJlZiA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFzeW5jRW5kRHJhZ0ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3REcmFnUHJldmlldyhzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5zZXQoc291cmNlSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25uZWN0RHJhZ1NvdXJjZShzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZU5vZGVzLnNldChzb3VyY2VJZCwgbm9kZSk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZU9wdGlvbnMuc2V0KHNvdXJjZUlkLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gKGUpPT50aGlzLmhhbmRsZURyYWdTdGFydChlLCBzb3VyY2VJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVTZWxlY3RTdGFydCA9IChlKT0+dGhpcy5oYW5kbGVTZWxlY3RTdGFydChlKVxuICAgICAgICA7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCAndHJ1ZScpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBoYW5kbGVTZWxlY3RTdGFydCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2Rlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGhhbmRsZVNlbGVjdFN0YXJ0KTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29ubmVjdERyb3BUYXJnZXQodGFyZ2V0SWQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKGUpPT50aGlzLmhhbmRsZURyYWdFbnRlcihlLCB0YXJnZXRJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IChlKT0+dGhpcy5oYW5kbGVEcmFnT3ZlcihlLCB0YXJnZXRJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVEcm9wID0gKGUpPT50aGlzLmhhbmRsZURyb3AoZSwgdGFyZ2V0SWQpXG4gICAgICAgIDtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVEcmFnRW50ZXIpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBoYW5kbGVEcm9wKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIGhhbmRsZURyYWdFbnRlcik7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgaGFuZGxlRHJvcCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCkge1xuICAgICAgICAvLyBTU1IgRml4IChodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9wdWxsLzgxM1xuICAgICAgICBpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdFbnRlcik7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdFbnRlckNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgdGhpcy5oYW5kbGVUb3BEcmFnTGVhdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpcy5oYW5kbGVUb3BEcmFnT3Zlcik7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZVRvcERyb3ApO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUsIHRydWUpO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQpIHtcbiAgICAgICAgLy8gU1NSIEZpeCAoaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvcHVsbC84MTNcbiAgICAgICAgaWYgKCF0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcERyYWdTdGFydCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcERyYWdTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlVG9wRHJhZ0VuZENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIHRoaXMuaGFuZGxlVG9wRHJhZ0xlYXZlQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdPdmVyQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5oYW5kbGVUb3BEcm9wKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZVRvcERyb3BDYXB0dXJlLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IHRoaXMubW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VOb2RlT3B0aW9ucyA9IHRoaXMuc291cmNlTm9kZU9wdGlvbnMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgZHJvcEVmZmVjdDogdGhpcy5hbHRLZXlQcmVzc2VkID8gJ2NvcHknIDogJ21vdmUnXG4gICAgICAgIH0sIHNvdXJjZU5vZGVPcHRpb25zIHx8IHt9KTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudERyb3BFZmZlY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgIC8vIEl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVmYXVsdCB0byAnY29weScgZm9yIG5hdGl2ZSByZXNvdXJjZXNcbiAgICAgICAgICAgIHJldHVybiAnY29weSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zKCkuZHJvcEVmZmVjdDtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSB0aGlzLm1vbml0b3IuZ2V0U291cmNlSWQoKTtcbiAgICAgICAgY29uc3Qgc291cmNlUHJldmlld05vZGVPcHRpb25zID0gdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgYW5jaG9yWDogMC41LFxuICAgICAgICAgICAgYW5jaG9yWTogMC41LFxuICAgICAgICAgICAgY2FwdHVyZURyYWdnaW5nU3RhdGU6IGZhbHNlXG4gICAgICAgIH0sIHNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyB8fCB7fSk7XG4gICAgfVxuICAgIGlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkge1xuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHRoaXMubW9uaXRvci5nZXRJdGVtVHlwZSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoTmF0aXZlVHlwZXMpLnNvbWUoKGtleSk9Pk5hdGl2ZVR5cGVzW2tleV0gPT09IGl0ZW1UeXBlXG4gICAgICAgICk7XG4gICAgfVxuICAgIGJlZ2luRHJhZ05hdGl2ZUl0ZW0odHlwZSwgZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlU291cmNlID0gY3JlYXRlTmF0aXZlRHJhZ1NvdXJjZSh0eXBlLCBkYXRhVHJhbnNmZXIpO1xuICAgICAgICB0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUgPSB0aGlzLnJlZ2lzdHJ5LmFkZFNvdXJjZSh0eXBlLCB0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpO1xuICAgICAgICB0aGlzLmFjdGlvbnMuYmVnaW5EcmFnKFtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc2V0Q3VycmVudERyYWdTb3VyY2VOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSA9IG5vZGU7XG4gICAgICAgIC8vIEEgdGltZW91dCBvZiA+IDAgaXMgbmVjZXNzYXJ5IHRvIHJlc29sdmUgRmlyZWZveCBpc3N1ZSByZWZlcmVuY2VkXG4gICAgICAgIC8vIFNlZTpcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL3B1bGwvOTI4XG4gICAgICAgIC8vICAgKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvODY5XG4gICAgICAgIGNvbnN0IE1PVVNFX01PVkVfVElNRU9VVCA9IDEwMDA7XG4gICAgICAgIC8vIFJlY2VpdmluZyBhIG1vdXNlIGV2ZW50IGluIHRoZSBtaWRkbGUgb2YgYSBkcmFnZ2luZyBvcGVyYXRpb25cbiAgICAgICAgLy8gbWVhbnMgaXQgaGFzIGVuZGVkIGFuZCB0aGUgZHJhZyBzb3VyY2Ugbm9kZSBkaXNhcHBlYXJlZCBmcm9tIERPTSxcbiAgICAgICAgLy8gc28gdGhlIGJyb3dzZXIgZGlkbid0IGRpc3BhdGNoIHRoZSBkcmFnZW5kIGV2ZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHdhaXQgYmVmb3JlIHdlIHN0YXJ0IGxpc3RlbmluZyBmb3IgbW91c2Vtb3ZlIGV2ZW50cy5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgZHJhZyBwcmV2aWV3IG5lZWRzIHRvIGJlIGRyYXduIG9yIGVsc2UgaXQgZmlyZXMgYW4gJ21vdXNlbW92ZScgZXZlbnRcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlOlxuICAgICAgICAvLyAgICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvcHVsbC85MjhcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL2lzc3Vlcy84NjlcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5tb3VzZU1vdmVUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLnJvb3RFbGVtZW50KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCB0cnVlKTtcbiAgICAgICAgfSwgTU9VU0VfTU9WRV9USU1FT1VUKTtcbiAgICB9XG4gICAgY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIChyZWYgPSB0aGlzLndpbmRvdykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY2xlYXJUaW1lb3V0KHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRHJhZ1N0YXJ0KGUsIHNvdXJjZUlkKSB7XG4gICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydFNvdXJjZUlkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzLnVuc2hpZnQoc291cmNlSWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcmFnRW50ZXIoX2UsIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcmFnT3ZlcihfZSwgdGFyZ2V0SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcm9wKF9lLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRJZHMudW5zaGlmdCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGdsb2JhbENvbnRleHQsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZU9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0SWRzID0gW107XG4gICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudERyYWdTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbHRLZXlQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hc3luY0VuZERyYWdGcmFtZUlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnT3ZlclRhcmdldElkcyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENsaWVudE9mZnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaG92ZXJSYWZJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2VOb2Rlcy5nZXQoc291cmNlSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSAmJiBnZXROb2RlQ2xpZW50T2Zmc2V0JDEoc291cmNlKSB8fCBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZERyYWdOYXRpdmVJdGVtID0gKCk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJlbW92ZVNvdXJjZSh0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlSGFuZGxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNOb2RlSW5Eb2N1bWVudCA9IChub2RlKT0+e1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIG5vZGUgZWl0aGVyIGluIHRoZSBtYWluIGRvY3VtZW50IG9yIGluIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG5vZGUgJiYgdGhpcy5kb2N1bWVudCAmJiB0aGlzLmRvY3VtZW50LmJvZHkgJiYgdGhpcy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKG5vZGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmREcmFnSWZTb3VyY2VXYXNSZW1vdmVkRnJvbURPTSA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IHRoaXMuaXNOb2RlSW5Eb2N1bWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNsZWFyQ3VycmVudERyYWdTb3VyY2VOb2RlKCkgJiYgdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEhvdmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZWR1bGVIb3ZlciA9IChkcmFnT3ZlclRhcmdldElkcyk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyUmFmSWQgPT09IG51bGwgJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3ZlcihkcmFnT3ZlclRhcmdldElkcyB8fCBbXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogdGhpcy5sYXN0Q2xpZW50T2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyUmFmSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbmNlbEhvdmVyID0gKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyUmFmSWQgIT09IG51bGwgJiYgdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuaG92ZXJSYWZJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlclJhZklkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnU3RhcnRDYXB0dXJlID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkcmFnU3RhcnRTb3VyY2VJZHMgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRTb3VyY2VJZHMgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50T2Zmc2V0ID0gZ2V0RXZlbnRDbGllbnRPZmZzZXQkMShlKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIGNyYXNoaW5nIGlmIHdlIG1pc3NlZCBhIGRyb3AgZXZlbnQgb3Igb3VyIHByZXZpb3VzIGRyYWcgZGllZFxuICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuZW5kRHJhZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHB1Ymxpc2ggdGhlIHNvdXJjZSBqdXN0IHlldCAoc2VlIHdoeSBiZWxvdylcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5iZWdpbkRyYWcoZHJhZ1N0YXJ0U291cmNlSWRzIHx8IFtdLCB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFNvdXJjZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0U291cmNlQ2xpZW50T2Zmc2V0OiB0aGlzLmdldFNvdXJjZUNsaWVudE9mZnNldCxcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhVHJhbnNmZXIgIH0gPSBlO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlVHlwZSA9IG1hdGNoTmF0aXZlSXRlbVR5cGUoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiB0eXBlb2YgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY3VzdG9tIGRyYWcgaW1hZ2UgaWYgdXNlciBzcGVjaWZpZXMgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNoaWxkIGRyYWcgc291cmNlIHJlZnVzZXMgZHJhZyBidXQgcGFyZW50IGFncmVlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHBhcmVudCdzIG5vZGUgYXMgZHJhZyBpbWFnZS4gTmVpdGhlciB3b3JrcyBpbiBJRSB0aG91Z2guXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUlkID0gdGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSB0aGlzLnNvdXJjZU5vZGVzLmdldChzb3VyY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdQcmV2aWV3ID0gdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuZ2V0KHNvdXJjZUlkKSB8fCBzb3VyY2VOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yWCAsIGFuY2hvclkgLCBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IHRoaXMuZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JZXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0UG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHJhZ1ByZXZpZXdPZmZzZXQgPSBnZXREcmFnUHJldmlld09mZnNldChzb3VyY2VOb2RlLCBkcmFnUHJldmlldywgY2xpZW50T2Zmc2V0LCBhbmNob3JQb2ludCwgb2Zmc2V0UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnUHJldmlldywgZHJhZ1ByZXZpZXdPZmZzZXQueCwgZHJhZ1ByZXZpZXdPZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCB3b24ndCBkcmFnIHdpdGhvdXQgc2V0dGluZyBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2ZlciA9PT0gbnVsbCB8fCBkYXRhVHJhbnNmZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFUcmFuc2Zlci5zZXREYXRhKCdhcHBsaWNhdGlvbi9qc29uJywge30pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBNSU1FIHR5cGVzIGluIHNldERhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgZHJhZyBzb3VyY2Ugbm9kZSBzbyB3ZSBjYW4gY2hlY2sgd2hldGhlclxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHJlbW92ZWQgZnJvbSBET00gYW5kIHRyaWdnZXIgZW5kRHJhZyBtYW51YWxseS5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnREcmFnU291cmNlTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgLy8gTm93IHdlIGFyZSByZWFkeSB0byBwdWJsaXNoIHRoZSBkcmFnIHNvdXJjZS4uIG9yIGFyZSB3ZSBub3Q/XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYXB0dXJlRHJhZ2dpbmdTdGF0ZSAgfSA9IHRoaXMuZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIGlmICghY2FwdHVyZURyYWdnaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXN1YWxseSB3ZSB3YW50IHRvIHB1Ymxpc2ggaXQgaW4gdGhlIG5leHQgdGljayBzbyB0aGF0IGJyb3dzZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYWJsZSB0byBzY3JlZW5zaG90IHRoZSBjdXJyZW50IChub3QgeWV0IGRyYWdnaW5nKSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgYWxzbyBuZWF0bHkgYXZvaWRzIGEgc2l0dWF0aW9uIHdoZXJlIHJlbmRlcigpIHJldHVybnMgbnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgc2FtZSB0aWNrIGZvciB0aGUgc291cmNlIGVsZW1lbnQsIGFuZCBicm93c2VyIGZyZWFrcyBvdXQuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnRoaXMuYWN0aW9ucy5wdWJsaXNoRHJhZ1NvdXJjZSgpXG4gICAgICAgICAgICAgICAgICAgICwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB0aGUgdXNlciBtYXkgd2FudCB0byBvdmVycmlkZSB0aGlzIGJlaGF2aW9yLCBlLmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHdvcmsgYXJvdW5kIElFIG5vdCBzdXBwb3J0aW5nIGN1c3RvbSBkcmFnIHByZXZpZXdzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGEgY3VzdG9tIGRyYWcgbGF5ZXIsIHRoZSBvbmx5IHdheSB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IGRyYWcgcHJldmlldyBmcm9tIGRyYXdpbmcgaW4gSUUgaXMgdG8gc2NyZWVuc2hvdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZHJhZ2dpbmcgc3RhdGUgaW4gd2hpY2ggdGhlIG5vZGUgaXRzZWxmIGhhcyB6ZXJvIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGhlaWdodC4gSW4gdGhpcyBjYXNlLCB0aG91Z2gsIHJldHVybmluZyBudWxsIGZyb20gcmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBhYnJ1cHRseSBlbmQgdGhlIGRyYWdnaW5nLCB3aGljaCBpcyBub3Qgb2J2aW91cy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhc29uIHN1Y2ggYmVoYXZpb3IgaXMgc3RyaWN0bHkgb3B0LWluLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMucHVibGlzaERyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBIG5hdGl2ZSBpdGVtIChzdWNoIGFzIFVSTCkgZHJhZ2dlZCBmcm9tIGluc2lkZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFUcmFuc2ZlciAmJiAhZGF0YVRyYW5zZmVyLnR5cGVzICYmIChlLnRhcmdldCAmJiAhZS50YXJnZXQuaGFzQXR0cmlidXRlIHx8ICFlLnRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpKSkge1xuICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgYSBTYWZhcmkgYnVnOiBkYXRhVHJhbnNmZXIudHlwZXMgaXMgbnVsbCwgYnV0IHRoZXJlIHdhcyBubyBkcmFnZ2FibGUuXG4gICAgICAgICAgICAgICAgLy8gSnVzdCBsZXQgaXQgZHJhZy4gSXQncyBhIG5hdGl2ZSB0eXBlIChVUkwgb3IgdGV4dCkgYW5kIHdpbGwgYmUgcGlja2VkIHVwIGluXG4gICAgICAgICAgICAgICAgLy8gZHJhZ2VudGVyIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBieSB0aGlzIHRpbWUgbm8gZHJhZyBzb3VyY2UgcmVhY3RlZCwgdGVsbCBicm93c2VyIG5vdCB0byBkcmFnLlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpICYmIHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGNhbiBkaXNwYXRjaCB0aGlzIGV2ZW50IGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICAvLyBpZiBkcmFnZW5kIGhhbmRsZXIgZG9lcyBzb21ldGhpbmcgbGlrZSBzaG93aW5nIGFuIGFsZXJ0LlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VlZCBpZiB3ZSBoYXZlIG5vdCBoYW5kbGVkIGl0IGFscmVhZHkuXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlID0gKGUpPT57XG4gICAgICAgICAgICB0aGlzLmRyYWdFbnRlclRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgKHJlZiA9IHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubG9hZERhdGFUcmFuc2ZlcihlLmRhdGFUcmFuc2Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0RW50ZXIgPSB0aGlzLmVudGVyTGVhdmVDb3VudGVyLmVudGVyKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaXNGaXJzdEVudGVyIHx8IHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFUcmFuc2ZlciAgfSA9IGU7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVUeXBlID0gbWF0Y2hOYXRpdmVJdGVtVHlwZShkYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgaWYgKG5hdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBIG5hdGl2ZSBpdGVtIChzdWNoIGFzIGZpbGUgb3IgVVJMKSBkcmFnZ2VkIGZyb20gb3V0c2lkZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSwgZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ0VudGVyVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmF0aXZlIGl0ZW0gdHlwZSB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWx0S2V5UHJlc3NlZCA9IGUuYWx0S2V5O1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBjaGFuZ2VzIHBvc2l0aW9uIGFzIHRoZSByZXN1bHQgb2YgYGRyYWdlbnRlcmAsIGBkcmFnb3ZlcmAgbWlnaHQgc3RpbGxcbiAgICAgICAgICAgIC8vIGdldCBkaXNwYXRjaGVkIGRlc3BpdGUgdGFyZ2V0IGJlaW5nIG5vIGxvbmdlciB0aGVyZS4gVGhlIGVhc3kgc29sdXRpb24gaXMgdG8gY2hlY2tcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgYWN0dWFsbHkgaXMgYSB0YXJnZXQgYmVmb3JlIGZpcmluZyBgaG92ZXJgLlxuICAgICAgICAgICAgaWYgKGRyYWdFbnRlclRhcmdldElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmhvdmVyKGRyYWdFbnRlclRhcmdldElkcywge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbkRyb3AgPSBkcmFnRW50ZXJUYXJnZXRJZHMuc29tZSgodGFyZ2V0SWQpPT50aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjYW5Ecm9wKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgcmVxdWlyZXMgdGhpcyB0byBmaXJlIGRyYWdvdmVyIGV2ZW50c1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHRoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlID0gKGUpPT57XG4gICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAocmVmID0gdGhpcy5jdXJyZW50TmF0aXZlU291cmNlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sb2FkRGF0YVRyYW5zZmVyKGUuZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnT3ZlciA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnT3ZlclRhcmdldElkcyAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmF0aXZlIGl0ZW0gdHlwZSB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBcImRyb3AgYW5kIGJsb3cgYXdheSB0aGUgd2hvbGUgZG9jdW1lbnRcIiBhY3Rpb24uXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFsdEtleVByZXNzZWQgPSBlLmFsdEtleTtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWVudE9mZnNldCA9IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlSG92ZXIoZHJhZ092ZXJUYXJnZXRJZHMpO1xuICAgICAgICAgICAgY29uc3QgY2FuRHJvcCA9IChkcmFnT3ZlclRhcmdldElkcyB8fCBbXSkuc29tZSgodGFyZ2V0SWQpPT50aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjYW5Ecm9wKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyB1c2VyLXNwZWNpZmllZCBkcm9wIGVmZmVjdC5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSB0aGlzLmdldEN1cnJlbnREcm9wRWZmZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGEgbmljZSBjdXJzb3IgYnV0IHN0aWxsIHByZXZlbnQgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIFwiZHJvcCBhbmQgYmxvdyBhd2F5IHRoZSB3aG9sZSBkb2N1bWVudFwiIGFjdGlvbi5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ0xlYXZlQ2FwdHVyZSA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdExlYXZlID0gdGhpcy5lbnRlckxlYXZlQ291bnRlci5sZWF2ZShlLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWlzTGFzdExlYXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnRoaXMuZW5kRHJhZ05hdGl2ZUl0ZW0oKVxuICAgICAgICAgICAgICAgICwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEhvdmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUgPSAoZSk9PntcbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIChyZWYgPSB0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmxvYWREYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaE5hdGl2ZUl0ZW1UeXBlKGUuZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIERyYWdnaW5nIHNvbWUgZWxlbWVudHMsIGxpa2UgPGE+IGFuZCA8aW1nPiBtYXkgc3RpbGwgYmVoYXZlIGxpa2UgYSBuYXRpdmUgZHJhZyBldmVudCxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBjdXJyZW50IGRyYWcgZXZlbnQgbWF0Y2hlcyBhIHVzZXItZGVmaW5lZCB0eXBlLlxuICAgICAgICAgICAgICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiB3ZSdyZSBub3QgZXhwZWN0aW5nIGEgbmF0aXZlIGl0ZW0gdG8gYmUgZHJvcHBlZC5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVudGVyTGVhdmVDb3VudGVyLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJvcCA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBkcm9wVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmhvdmVyKGRyb3BUYXJnZXRJZHMsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICAgICAgICAgIGRyb3BFZmZlY3Q6IHRoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmREcmFnTmF0aXZlSXRlbSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAvLyBPbmx5IElFIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2F5XG4gICAgICAgICAgICAvLyB3ZSB3YW50IGRyYWcgZHJvcCBvcGVyYXRpb24gdG8gc3RhcnRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LmRyYWdEcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5wdXRzIGFuZCB0ZXh0YXJlYXMgc2hvdWxkIGJlIHNlbGVjdGFibGVcbiAgICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHwgdGFyZ2V0LnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIG90aGVyIHRhcmdldHMsIGFzayBJRVxuICAgICAgICAgICAgLy8gdG8gZW5hYmxlIGRyYWcgYW5kIGRyb3BcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRhcmdldC5kcmFnRHJvcCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXcgT3B0aW9uc1JlYWRlciQxKGdsb2JhbENvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuZW50ZXJMZWF2ZUNvdW50ZXIgPSBuZXcgRW50ZXJMZWF2ZUNvdW50ZXIodGhpcy5pc05vZGVJbkRvY3VtZW50KTtcbiAgICB9XG59XG5cbmxldCBlbXB0eUltYWdlO1xuZnVuY3Rpb24gZ2V0RW1wdHlJbWFnZSgpIHtcbiAgICBpZiAoIWVtcHR5SW1hZ2UpIHtcbiAgICAgICAgZW1wdHlJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBlbXB0eUltYWdlLnNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PSc7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eUltYWdlO1xufVxuXG5jb25zdCBIVE1MNUJhY2tlbmQgPSBmdW5jdGlvbiBjcmVhdGVCYWNrZW5kKG1hbmFnZXIsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEhUTUw1QmFja2VuZEltcGwobWFuYWdlciwgY29udGV4dCwgb3B0aW9ucyk7XG59O1xuXG5mdW5jdGlvbiBQaWVjZSh7IGlzUHJlbW92ZWRQaWVjZSA9IGZhbHNlLCBwaWVjZSwgc3F1YXJlLCBzcXVhcmVzLCB9KSB7XHJcbiAgICBjb25zdCB7IGFuaW1hdGlvbkR1cmF0aW9uLCBhcmVQaWVjZXNEcmFnZ2FibGUsIGJvYXJkV2lkdGgsIGJvYXJkT3JpZW50YXRpb24sIGNoZXNzUGllY2VzLCBjdXJyZW50UG9zaXRpb24sIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZSwgZHJvcE9mZkJvYXJkQWN0aW9uLCBpZCwgaXNEcmFnZ2FibGVQaWVjZSwgaXNXYWl0aW5nRm9yQW5pbWF0aW9uLCBvblBpZWNlQ2xpY2ssIG9uUGllY2VEcmFnQmVnaW4sIG9uUGllY2VEcmFnRW5kLCBvblBpZWNlRHJvcE9mZkJvYXJkLCBvblByb21vdGlvbkNoZWNrLCBwb3NpdGlvbkRpZmZlcmVuY2VzLCB9ID0gdXNlQ2hlc3Nib2FyZCgpO1xyXG4gICAgY29uc3QgW3BpZWNlU3R5bGUsIHNldFBpZWNlU3R5bGVdID0gdXNlU3RhdGUoe1xyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgekluZGV4OiA1LFxyXG4gICAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcclxuICAgICAgICBjdXJzb3I6IGFyZVBpZWNlc0RyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZVBpZWNlKHsgcGllY2UsIHNvdXJjZVNxdWFyZTogc3F1YXJlIH0pXHJcbiAgICAgICAgICAgID8gXCItd2Via2l0LWdyYWJcIlxyXG4gICAgICAgICAgICA6IFwiZGVmYXVsdFwiLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBbeyBjYW5EcmFnLCBpc0RyYWdnaW5nIH0sIGRyYWcsIGRyYWdQcmV2aWV3XSA9IHVzZURyYWcoKCkgPT4gKHtcclxuICAgICAgICB0eXBlOiBcInBpZWNlXCIsXHJcbiAgICAgICAgaXRlbTogKCkgPT4ge1xyXG4gICAgICAgICAgICBvblBpZWNlRHJhZ0JlZ2luKHBpZWNlLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBwaWVjZSwgc3F1YXJlLCBpZCB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kOiAoaXRlbSwgbW9uaXRvcikgPT4ge1xyXG4gICAgICAgICAgICBvblBpZWNlRHJhZ0VuZChwaWVjZSwgc3F1YXJlKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRHJvcE91dHNpZGVUaGVCb2FyZCA9ICFtb25pdG9yLmRpZERyb3AoKTtcclxuICAgICAgICAgICAgaWYgKHdhc0Ryb3BPdXRzaWRlVGhlQm9hcmQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcm9wT2ZmQm9hcmRBY3Rpb24gPT09IFwidHJhc2hcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZShzcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb25QaWVjZURyb3BPZmZCb2FyZCA9PT0gbnVsbCB8fCBvblBpZWNlRHJvcE9mZkJvYXJkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblBpZWNlRHJvcE9mZkJvYXJkKHNxdWFyZSwgcGllY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0OiAobW9uaXRvcikgPT4gKHtcclxuICAgICAgICAgICAgY2FuRHJhZzogaXNEcmFnZ2FibGVQaWVjZSh7IHBpZWNlLCBzb3VyY2VTcXVhcmU6IHNxdWFyZSB9KSxcclxuICAgICAgICAgICAgaXNEcmFnZ2luZzogISFtb25pdG9yLmlzRHJhZ2dpbmcoKSxcclxuICAgICAgICB9KSxcclxuICAgIH0pLCBbcGllY2UsIHNxdWFyZSwgY3VycmVudFBvc2l0aW9uLCBpZF0pO1xyXG4gICAgLy8gaGlkZSB0aGUgZGVmYXVsdCBwcmV2aWV3XHJcbiAgICBkcmFnUHJldmlldyhnZXRFbXB0eUltYWdlKCksIHsgY2FwdHVyZURyYWdnaW5nU3RhdGU6IHRydWUgfSk7XHJcbiAgICAvLyBoaWRlIHBpZWNlIG9uIGRyYWdcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0UGllY2VTdHlsZSgob2xkUGllY2VTdHlsZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkUGllY2VTdHlsZSksIHsgb3BhY2l0eTogaXNEcmFnZ2luZyA/IDAgOiAxIH0pKSk7XHJcbiAgICB9LCBbaXNEcmFnZ2luZ10pO1xyXG4gICAgLy8gbmV3IG1vdmUgaGFzIGNvbWUgaW5cclxuICAgIC8vIGlmIHdhaXRpbmcgZm9yIGFuaW1hdGlvbiwgdGhlbiBhbmltYXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHdlIGNhbiBwZXJmb3JtIGFuaW1hdGlvblxyXG4gICAgLy8gd2UgbmVlZCB0byBoZWFkIHRvd2FyZHMgd2hlcmUgd2UgbmVlZCB0byBnbywgd2UgYXJlIHRoZSBzb3VyY2UsIHdlIGFyZSBoZWFkaW5nIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFBpZWNlID0gKF9hID0gcG9zaXRpb25EaWZmZXJlbmNlcy5yZW1vdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fbc3F1YXJlXTtcclxuICAgICAgICAvLyByZXR1cm4gYXMgbnVsbCBhbmQgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICBpZiAoIXBvc2l0aW9uRGlmZmVyZW5jZXMuYWRkZWQgfHwgIXJlbW92ZWRQaWVjZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBpZWNlIG1hdGNoZXMgb3IgaWYgcmVtb3ZlZCBwaWVjZSB3YXMgYSBwYXduIGFuZCBuZXcgc3F1YXJlIGlzIG9uIDFzdCBvciA4dGggcmFuayAocHJvbW90aW9uKVxyXG4gICAgICAgIGNvbnN0IG5ld1NxdWFyZSA9IE9iamVjdC5lbnRyaWVzKHBvc2l0aW9uRGlmZmVyZW5jZXMuYWRkZWQpLmZpbmQoKFtzLCBwXSkgPT4gcCA9PT0gcmVtb3ZlZFBpZWNlIHx8IG9uUHJvbW90aW9uQ2hlY2soc3F1YXJlLCBzLCByZW1vdmVkUGllY2UpKTtcclxuICAgICAgICAvLyB3ZSBjYW4gcGVyZm9ybSBhbmltYXRpb24gaWYgb3VyIHNxdWFyZSB3YXMgaW4gcmVtb3ZlZCwgQU5EIHRoZSBtYXRjaGluZyBwaWVjZSBpcyBpbiBhZGRlZCBBTkQgdGhpcyBpc24ndCBhIHByZW1vdmVkIHBpZWNlXHJcbiAgICAgICAgaWYgKGlzV2FpdGluZ0ZvckFuaW1hdGlvbiAmJlxyXG4gICAgICAgICAgICByZW1vdmVkUGllY2UgJiZcclxuICAgICAgICAgICAgbmV3U3F1YXJlICYmXHJcbiAgICAgICAgICAgICFpc1ByZW1vdmVkUGllY2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlU3EgPSBzcXVhcmU7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNxID0gbmV3U3F1YXJlWzBdO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlU3EgJiYgdGFyZ2V0U3EpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDg7XHJcbiAgICAgICAgICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gLTEgOiAxKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0YXJnZXRTcS5jaGFyQ29kZUF0KDApIC0gc291cmNlU3EuY2hhckNvZGVBdCgwKSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weCwgJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gLTEgOiAxKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChOdW1iZXIoc291cmNlU3FbMV0pIC0gTnVtYmVyKHRhcmdldFNxWzFdKSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weClgLCB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7YW5pbWF0aW9uRHVyYXRpb259bXNgLCB6SW5kZXg6IDYgfSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtwb3NpdGlvbkRpZmZlcmVuY2VzXSk7XHJcbiAgICAvLyB0cmFuc2xhdGUgdG8gdGhlaXIgb3duIHBvc2l0aW9ucyAocmVwYWludCBvbiB1bmRvKVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHNvdXJjZVNxIH0gPSBnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcygpO1xyXG4gICAgICAgIGlmIChzb3VyY2VTcSkge1xyXG4gICAgICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHswfXB4LCAkezB9cHgpYCwgdHJhbnNpdGlvbjogYHRyYW5zZm9ybSAkezB9bXNgIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRQb3NpdGlvbl0pO1xyXG4gICAgLy8gdXBkYXRlIGlzIHBpZWNlIGRyYWdnYWJsZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyBjdXJzb3I6IGFyZVBpZWNlc0RyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZVBpZWNlKHsgcGllY2UsIHNvdXJjZVNxdWFyZTogc3F1YXJlIH0pXHJcbiAgICAgICAgICAgICAgICA/IFwiLXdlYmtpdC1ncmFiXCJcclxuICAgICAgICAgICAgICAgIDogXCJkZWZhdWx0XCIgfSkpKTtcclxuICAgIH0sIFtzcXVhcmUsIGN1cnJlbnRQb3NpdGlvbiwgYXJlUGllY2VzRHJhZ2dhYmxlXSk7XHJcbiAgICBmdW5jdGlvbiBnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcygpIHtcclxuICAgICAgICByZXR1cm4geyBzb3VyY2VTcTogc3F1YXJlc1tzcXVhcmVdIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBhcmVQaWVjZXNEcmFnZ2FibGUgJiYgY2FuRHJhZyA/IGRyYWcgOiBudWxsLCBvbkNsaWNrOiAoKSA9PiBvblBpZWNlQ2xpY2socGllY2UsIHNxdWFyZSksIFwiZGF0YS1waWVjZVwiOiBwaWVjZSwgc3R5bGU6IHBpZWNlU3R5bGUgfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW3BpZWNlXSA9PT0gXCJmdW5jdGlvblwiID8gKGNoZXNzUGllY2VzW3BpZWNlXSh7XHJcbiAgICAgICAgICAgIHNxdWFyZVdpZHRoOiBib2FyZFdpZHRoIC8gOCxcclxuICAgICAgICAgICAgaXNEcmFnZ2luZyxcclxuICAgICAgICAgICAgc3F1YXJlLFxyXG4gICAgICAgIH0pKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiBib2FyZFdpZHRoIC8gOCwgaGVpZ2h0OiBib2FyZFdpZHRoIC8gOCwgc3R5bGU6IHsgZGlzcGxheTogXCJibG9ja1wiIH0gfSwgeyBjaGlsZHJlbjoganN4KFwiZ1wiLCB7IGNoaWxkcmVuOiBjaGVzc1BpZWNlc1twaWVjZV0gfSkgfSkpKSB9KSkpO1xyXG59XG5cbmZ1bmN0aW9uIFNxdWFyZSh7IHNxdWFyZSwgc3F1YXJlQ29sb3IsIHNldFNxdWFyZXMsIHNxdWFyZUhhc1ByZW1vdmUsIGNoaWxkcmVuLCB9KSB7XHJcbiAgICBjb25zdCBzcXVhcmVSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCB7IGF1dG9Qcm9tb3RlVG9RdWVlbiwgYm9hcmRXaWR0aCwgYm9hcmRPcmllbnRhdGlvbiwgY2xlYXJBcnJvd3MsIGN1cnJlbnRQb3NpdGlvbiwgY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBjdXN0b21Cb2FyZFN0eWxlLCBjdXN0b21EYXJrU3F1YXJlU3R5bGUsIGN1c3RvbURyb3BTcXVhcmVTdHlsZSwgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSwgY3VzdG9tUHJlbW92ZURhcmtTcXVhcmVTdHlsZSwgY3VzdG9tUHJlbW92ZUxpZ2h0U3F1YXJlU3R5bGUsIGN1c3RvbVNxdWFyZTogQ3VzdG9tU3F1YXJlLCBjdXN0b21TcXVhcmVTdHlsZXMsIGRyYXdOZXdBcnJvdywgaGFuZGxlU2V0UG9zaXRpb24sIGhhbmRsZVNwYXJlUGllY2VEcm9wLCBpc1dhaXRpbmdGb3JBbmltYXRpb24sIGxhc3RQaWVjZUNvbG91ciwgbGFzdFNxdWFyZURyYWdnZWRPdmVyLCBvbkFycm93RHJhd0VuZCwgb25EcmFnT3ZlclNxdWFyZSwgb25Nb3VzZU91dFNxdWFyZSwgb25Nb3VzZU92ZXJTcXVhcmUsIG9uUGllY2VEcm9wLCBvblByb21vdGlvbkNoZWNrLCBvblJpZ2h0Q2xpY2tEb3duLCBvblJpZ2h0Q2xpY2tVcCwgb25TcXVhcmVDbGljaywgc2V0TGFzdFNxdWFyZURyYWdnZWRPdmVyLCBzZXRQcm9tb3RlRnJvbVNxdWFyZSwgc2V0UHJvbW90ZVRvU3F1YXJlLCBzZXRTaG93UHJvbW90ZURpYWxvZywgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IFt7IGlzT3ZlciB9LCBkcm9wXSA9IHVzZURyb3AoKCkgPT4gKHtcclxuICAgICAgICBhY2NlcHQ6IFwicGllY2VcIixcclxuICAgICAgICBkcm9wOiBoYW5kbGVEcm9wLFxyXG4gICAgICAgIGNvbGxlY3Q6IChtb25pdG9yKSA9PiAoe1xyXG4gICAgICAgICAgICBpc092ZXI6ICEhbW9uaXRvci5pc092ZXIoKSxcclxuICAgICAgICB9KSxcclxuICAgIH0pLCBbXHJcbiAgICAgICAgc3F1YXJlLFxyXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbixcclxuICAgICAgICBvblBpZWNlRHJvcCxcclxuICAgICAgICBpc1dhaXRpbmdGb3JBbmltYXRpb24sXHJcbiAgICAgICAgbGFzdFBpZWNlQ29sb3VyLFxyXG4gICAgXSk7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVEcm9wKGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbS5pc1NwYXJlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNwYXJlUGllY2VEcm9wKGl0ZW0ucGllY2UsIHNxdWFyZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uUHJvbW90aW9uQ2hlY2soaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZSkpIHtcclxuICAgICAgICAgICAgaWYgKGF1dG9Qcm9tb3RlVG9RdWVlbikge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0UG9zaXRpb24oaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZVswXSA9PT0gXCJ3XCIgPyBcIndRXCIgOiBcImJRXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbW90ZUZyb21TcXVhcmUoaXRlbS5zcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbW90ZVRvU3F1YXJlKHNxdWFyZSk7XHJcbiAgICAgICAgICAgICAgICBzZXRTaG93UHJvbW90ZURpYWxvZyh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0UG9zaXRpb24oaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3F1YXJlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBzcXVhcmVSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgc2V0U3F1YXJlcygob2xkU3F1YXJlcykgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkU3F1YXJlcyksIHsgW3NxdWFyZV06IHsgeCwgeSB9IH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2JvYXJkV2lkdGgsIGJvYXJkT3JpZW50YXRpb25dKTtcclxuICAgIGNvbnN0IGRlZmF1bHRTcXVhcmVTdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJvcmRlclJhZGl1cyhzcXVhcmUsIGJvYXJkT3JpZW50YXRpb24sIGN1c3RvbUJvYXJkU3R5bGUpKSwgKHNxdWFyZUNvbG9yID09PSBcImJsYWNrXCJcclxuICAgICAgICA/IGN1c3RvbURhcmtTcXVhcmVTdHlsZVxyXG4gICAgICAgIDogY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSkpLCAoc3F1YXJlSGFzUHJlbW92ZSAmJlxyXG4gICAgICAgIChzcXVhcmVDb2xvciA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgID8gY3VzdG9tUHJlbW92ZURhcmtTcXVhcmVTdHlsZVxyXG4gICAgICAgICAgICA6IGN1c3RvbVByZW1vdmVMaWdodFNxdWFyZVN0eWxlKSkpLCAoaXNPdmVyICYmIGN1c3RvbURyb3BTcXVhcmVTdHlsZSkpO1xyXG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogZHJvcCwgc3R5bGU6IGRlZmF1bHRTcXVhcmVTdHlsZSwgXCJkYXRhLXNxdWFyZS1jb2xvclwiOiBzcXVhcmVDb2xvciwgXCJkYXRhLXNxdWFyZVwiOiBzcXVhcmUsIG9uVG91Y2hNb3ZlOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0b3VjaCBldmVudHMgb24gdGFibGV0IGFuZCBtb2JpbGUgbm90IGNvdmVyZWQgYnkgb25Nb3VzZU92ZXIvb25EcmFnRW50ZXJcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hMb2NhdGlvbiA9IGUudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQodG91Y2hMb2NhdGlvbi5jbGllbnRYLCB0b3VjaExvY2F0aW9uLmNsaWVudFkpO1xyXG4gICAgICAgICAgICBjb25zdCBkcmFnZ2VkT3ZlclNxdWFyZSA9IChfYSA9IHRvdWNoRWxlbWVudCA9PT0gbnVsbCB8fCB0b3VjaEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvdWNoRWxlbWVudC5maW5kKChlbCkgPT4gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcXVhcmVcIikpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcXVhcmVcIik7XHJcbiAgICAgICAgICAgIGlmIChkcmFnZ2VkT3ZlclNxdWFyZSAmJiBkcmFnZ2VkT3ZlclNxdWFyZSAhPT0gbGFzdFNxdWFyZURyYWdnZWRPdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRMYXN0U3F1YXJlRHJhZ2dlZE92ZXIoZHJhZ2dlZE92ZXJTcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgb25EcmFnT3ZlclNxdWFyZShkcmFnZ2VkT3ZlclNxdWFyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvbk1vdXNlT3ZlcjogKGUpID0+IHtcclxuICAgICAgICAgICAgLy8gbm9vcCBpZiBtb3ZpbmcgZnJvbSBjaGlsZCBvZiBzcXVhcmUgaW50byBzcXVhcmUuXHJcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgPT09IDIgJiYgY3VycmVudFJpZ2h0Q2xpY2tEb3duKSB7XHJcbiAgICAgICAgICAgICAgICBkcmF3TmV3QXJyb3coY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgJiZcclxuICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25Nb3VzZU92ZXJTcXVhcmUoc3F1YXJlKTtcclxuICAgICAgICB9LCBvbk1vdXNlT3V0OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBub29wIGlmIG1vdmluZyBmcm9tIHNxdWFyZSBpbnRvIGEgY2hpbGQgb2Ygc3F1YXJlLlxyXG4gICAgICAgICAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ICYmXHJcbiAgICAgICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgb25Nb3VzZU91dFNxdWFyZShzcXVhcmUpO1xyXG4gICAgICAgIH0sIG9uTW91c2VEb3duOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpXHJcbiAgICAgICAgICAgICAgICBvblJpZ2h0Q2xpY2tEb3duKHNxdWFyZSk7XHJcbiAgICAgICAgfSwgb25Nb3VzZVVwOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmlnaHRDbGlja0Rvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgb25BcnJvd0RyYXdFbmQoY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgb25SaWdodENsaWNrVXAoc3F1YXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9uRHJhZ0VudGVyOiAoKSA9PiBvbkRyYWdPdmVyU3F1YXJlKHNxdWFyZSksIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXTtcclxuICAgICAgICAgICAgb25TcXVhcmVDbGljayhzcXVhcmUsIHBpZWNlKTtcclxuICAgICAgICAgICAgY2xlYXJBcnJvd3MoKTtcclxuICAgICAgICB9LCBvbkNvbnRleHRNZW51OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiB0eXBlb2YgQ3VzdG9tU3F1YXJlID09PSBcInN0cmluZ1wiID8gKGpzeChDdXN0b21TcXVhcmVcclxuICAgICAgICAvLyBUeXBlIGlzIHRvbyBjb21wbGV4IHRvIHByb3Blcmx5IGV2YWx1YXRlLCBzbyBpZ25vcmUgdGhpcyBsaW5lLlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAsIE9iamVjdC5hc3NpZ24oeyBcclxuICAgICAgICAgICAgLy8gVHlwZSBpcyB0b28gY29tcGxleCB0byBwcm9wZXJseSBldmFsdWF0ZSwgc28gaWdub3JlIHRoaXMgbGluZS5cclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICByZWY6IHNxdWFyZVJlZiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaXplKGJvYXJkV2lkdGgpKSwgY2VudGVyKSwgKCFzcXVhcmVIYXNQcmVtb3ZlICYmIChjdXN0b21TcXVhcmVTdHlsZXMgPT09IG51bGwgfHwgY3VzdG9tU3F1YXJlU3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21TcXVhcmVTdHlsZXNbc3F1YXJlXSkpKSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpIDogKGpzeChDdXN0b21TcXVhcmUsIE9iamVjdC5hc3NpZ24oeyByZWY6IHNxdWFyZVJlZiwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZUNvbG9yOiBzcXVhcmVDb2xvciwgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaXplKGJvYXJkV2lkdGgpKSwgY2VudGVyKSwgKCFzcXVhcmVIYXNQcmVtb3ZlICYmIChjdXN0b21TcXVhcmVTdHlsZXMgPT09IG51bGwgfHwgY3VzdG9tU3F1YXJlU3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21TcXVhcmVTdHlsZXNbc3F1YXJlXSkpKSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpIH0pKSk7XHJcbn1cclxuY29uc3QgY2VudGVyID0ge1xyXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxufTtcclxuY29uc3Qgc2l6ZSA9ICh3aWR0aCkgPT4gKHtcclxuICAgIHdpZHRoOiB3aWR0aCAvIDgsXHJcbiAgICBoZWlnaHQ6IHdpZHRoIC8gOCxcclxufSk7XHJcbmNvbnN0IGJvcmRlclJhZGl1cyA9IChzcXVhcmUsIGJvYXJkT3JpZW50YXRpb24sIGN1c3RvbUJvYXJkU3R5bGUpID0+IHtcclxuICAgIGlmICghKGN1c3RvbUJvYXJkU3R5bGUgPT09IG51bGwgfHwgY3VzdG9tQm9hcmRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMpKVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIGlmIChzcXVhcmUgPT09IFwiYTFcIikge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCJcclxuICAgICAgICAgICAgPyB7IGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGN1c3RvbUJvYXJkU3R5bGUuYm9yZGVyUmFkaXVzIH1cclxuICAgICAgICAgICAgOiB7IGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHNxdWFyZSA9PT0gXCJhOFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGJvYXJkT3JpZW50YXRpb24gPT09IFwid2hpdGVcIlxyXG4gICAgICAgICAgICA/IHsgYm9yZGVyVG9wTGVmdFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfVxyXG4gICAgICAgICAgICA6IHsgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGN1c3RvbUJvYXJkU3R5bGUuYm9yZGVyUmFkaXVzIH07XHJcbiAgICB9XHJcbiAgICBpZiAoc3F1YXJlID09PSBcImgxXCIpIHtcclxuICAgICAgICByZXR1cm4gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiXHJcbiAgICAgICAgICAgID8geyBib3JkZXJCb3R0b21SaWdodFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfVxyXG4gICAgICAgICAgICA6IHsgYm9yZGVyVG9wTGVmdFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfTtcclxuICAgIH1cclxuICAgIGlmIChzcXVhcmUgPT09IFwiaDhcIikge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCJcclxuICAgICAgICAgICAgPyB7IGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9XHJcbiAgICAgICAgICAgIDogeyBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG59O1xuXG5mdW5jdGlvbiBTcXVhcmVzKCkge1xyXG4gICAgY29uc3QgW3NxdWFyZXMsIHNldFNxdWFyZXNdID0gdXNlU3RhdGUoe30pO1xyXG4gICAgY29uc3QgeyBhcmVQcmVtb3Zlc0FsbG93ZWQsIGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1cnJlbnRQb3NpdGlvbiwgaWQsIHByZW1vdmVzLCBzaG93Qm9hcmROb3RhdGlvbiwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IHByZW1vdmVzSGlzdG9yeSA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIC8vIGlmIHByZW1vdmVzIGFyZW4ndCBhbGxvd2VkLCBkb24ndCB3YXN0ZSB0aW1lIG9uIGNhbGN1bGF0aW9uc1xyXG4gICAgICAgIGlmICghYXJlUHJlbW92ZXNBbGxvd2VkKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgcHJlbW92ZXMuZm9yRWFjaCgocHJlbW92ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIHBpZWNlIH0gPSBwcmVtb3ZlO1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIHByZW1vdmUgaXMgbWFkZSBieSBhbiBhbHJlYWR5IHByZW1vdmVkIHBpZWNlXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWRQcmVtb3ZlZFBpZWNlID0gcmVzdWx0LmZpbmQoKHApID0+IHsgdmFyIF9hOyByZXR1cm4gcC5waWVjZSA9PT0gcGllY2UgJiYgKChfYSA9IHAucHJlbW92ZXNSb3V0ZS5hdCgtMSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXRTcSkgPT09IHNvdXJjZVNxOyB9KTtcclxuICAgICAgICAgICAgLy8gaWYgcHJlbW92ZSBoYXMgYmVlbiBtYWRlIGJ5IGFscmVhZHkgcHJlbW92ZWQgcGllY2UgdGhlbiB3cml0ZSB0aGUgbW92ZSB0byBpdHMgYHByZW1vdmVzUm91dGVgIGZpZWxkIHRvIGJlIGFibGUgZmluZCBpdHMgZmluYWwgZGVzdGluYXRpb24gbGF0ZXJcclxuICAgICAgICAgICAgaWYgKHJlbGF0ZWRQcmVtb3ZlZFBpZWNlKSB7XHJcbiAgICAgICAgICAgICAgICByZWxhdGVkUHJlbW92ZWRQaWVjZS5wcmVtb3Zlc1JvdXRlLnB1c2goeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIGluZGV4IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHByZW1vdmUgaGFzIGJlZW4gbWFkZSBieSBzdGFuZGFyZCBwaWVjZSBjcmVhdGUgbmV3IG9iamVjdCBpbiBgcHJlbW92ZXNIaXN0b3J5YCB3aGVyZSB3ZSB3aWxsIGtlZXAgaXRzIG93biBwcmVtb3Zlc1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwaWVjZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCBpcyB1c2VmdWwgZm9yIHNjZW5hcmlvcyB3aGVyZSB0d28gb3IgbW9yZSBwaWVjZXMgYXJlIHRhcmdldGluZyB0aGUgc2FtZSBzcXVhcmVcclxuICAgICAgICAgICAgICAgICAgICBwcmVtb3Zlc1JvdXRlOiBbeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIGluZGV4IH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgW3ByZW1vdmVzXSk7XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgXCJkYXRhLWJvYXJkaWRcIjogaWQgfSwgeyBjaGlsZHJlbjogWy4uLkFycmF5KDgpXS5tYXAoKF8sIHIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJvYXJkV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFsuLi5BcnJheSg4KV0ubWFwKChfLCBjKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKENPTFVNTlNbNyAtIGNdICsgKHIgKyAxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoQ09MVU1OU1tjXSArICg4IC0gcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZUNvbG9yID0gYyAlIDIgPT09IHIgJSAyID8gXCJ3aGl0ZVwiIDogXCJibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZUhhc1ByZW1vdmUgPSBwcmVtb3Zlcy5maW5kKChwKSA9PiBwLnNvdXJjZVNxID09PSBzcXVhcmUgfHwgcC50YXJnZXRTcSA9PT0gc3F1YXJlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcXVhcmVIYXNQcmVtb3ZlVGFyZ2V0ID0gcHJlbW92ZXNIaXN0b3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgcHJlbW92ZXNSb3V0ZSB9KSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBwcmVtb3Zlc1JvdXRlLmF0KC0xKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldFNxKSA9PT0gc3F1YXJlOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBwcmVtb3ZlZCBwaWVjZSB3aXRoIHRoZSBoaWdoZXIgaW5kZXggd2lsbCBiZSBzaG93biwgYXMgaXQgaXMgdGhlIGxhdGVzdCBvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBiLnByZW1vdmVzUm91dGUuYXQoLTEpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXgpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBhLnByZW1vdmVzUm91dGUuYXQoLTEpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGpzeHMoU3F1YXJlLCBPYmplY3QuYXNzaWduKHsgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZUNvbG9yOiBzcXVhcmVDb2xvciwgc2V0U3F1YXJlczogc2V0U3F1YXJlcywgc3F1YXJlSGFzUHJlbW92ZTogISFzcXVhcmVIYXNQcmVtb3ZlIH0sIHsgY2hpbGRyZW46IFshc3F1YXJlSGFzUHJlbW92ZSAmJiBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSAmJiAoanN4KFBpZWNlLCB7IHBpZWNlOiBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZXM6IHNxdWFyZXMgfSkpLCBzcXVhcmVIYXNQcmVtb3ZlVGFyZ2V0ICYmIChqc3goUGllY2UsIHsgaXNQcmVtb3ZlZFBpZWNlOiB0cnVlLCBwaWVjZTogc3F1YXJlSGFzUHJlbW92ZVRhcmdldC5waWVjZSwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZXM6IHNxdWFyZXMgfSkpLCBzaG93Qm9hcmROb3RhdGlvbiAmJiBqc3goTm90YXRpb24sIHsgcm93OiByLCBjb2w6IGMgfSldIH0pLCBgJHtjfSR7cn1gKSk7XHJcbiAgICAgICAgICAgICAgICB9KSB9KSwgci50b1N0cmluZygpKSk7XHJcbiAgICAgICAgfSkgfSkpKTtcclxufVxuXG5jb25zdCBBcnJvd3MgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IGFycm93cywgbmV3QXJyb3csIGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1c3RvbUFycm93Q29sb3I6IHByaW1hcnlBcnJvd0NvbGxvciwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IGFycm93c0xpc3QgPSBbLi4uYXJyb3dzLCBuZXdBcnJvd10uZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHdpZHRoOiBib2FyZFdpZHRoLCBoZWlnaHQ6IGJvYXJkV2lkdGgsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXHJcbiAgICAgICAgICAgIGxlZnQ6IFwiMFwiLFxyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgekluZGV4OiBcIjEwXCIsXHJcbiAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBhcnJvd3NMaXN0Lm1hcCgoYXJyb3csIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2Fycm93U3RhcnRGaWVsZCwgYXJyb3dFbmRGaWVsZCwgYXJyb3dDb2xvcl0gPSBhcnJvdztcclxuICAgICAgICAgICAgaWYgKGFycm93U3RhcnRGaWVsZCA9PT0gYXJyb3dFbmRGaWVsZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gZ2V0UmVsYXRpdmVDb29yZHMoYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgYXJyb3dTdGFydEZpZWxkKTtcclxuICAgICAgICAgICAgY29uc3QgdG8gPSBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBhcnJvd0VuZEZpZWxkKTtcclxuICAgICAgICAgICAgbGV0IEFSUk9XX0xFTkdUSF9SRURVQ0VSID0gYm9hcmRXaWR0aCAvIDMyO1xyXG4gICAgICAgICAgICBjb25zdCBpc0Fycm93QWN0aXZlID0gaSA9PT0gYXJyb3dzLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGRpZmZlcmVudCBhcnJvd3MgdGFyZ2V0aW5nIHRoZSBzYW1lIHNxdWFyZSBtYWtlIHRoZWlyIGxlbmd0aCBhIGJpdCBzaG9ydGVyXHJcbiAgICAgICAgICAgIGlmIChhcnJvd3Muc29tZSgocmVzdEFycm93KSA9PiByZXN0QXJyb3dbMF0gIT09IGFycm93U3RhcnRGaWVsZCAmJiByZXN0QXJyb3dbMV0gPT09IGFycm93RW5kRmllbGQpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNBcnJvd0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgQVJST1dfTEVOR1RIX1JFRFVDRVIgPSBib2FyZFdpZHRoIC8gMTY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZHggPSB0by54IC0gZnJvbS54O1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IHRvLnkgLSBmcm9tLnk7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBNYXRoLmh5cG90KGR5LCBkeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGZyb20ueCArIChkeCAqIChyIC0gQVJST1dfTEVOR1RIX1JFRFVDRVIpKSAvIHIsXHJcbiAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyAoZHkgKiAociAtIEFSUk9XX0xFTkdUSF9SRURVQ0VSKSkgLyByLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW2pzeChcIm1hcmtlclwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IGBhcnJvd2hlYWQtJHtpfWAsIG1hcmtlcldpZHRoOiBcIjJcIiwgbWFya2VySGVpZ2h0OiBcIjIuNVwiLCByZWZYOiBcIjEuMjVcIiwgcmVmWTogXCIxLjI1XCIsIG9yaWVudDogXCJhdXRvXCIgfSwgeyBjaGlsZHJlbjoganN4KFwicG9seWdvblwiLCB7IHBvaW50czogXCIwLjMgMCwgMiAxLjI1LCAwLjMgMi41XCIsIGZpbGw6IGFycm93Q29sb3IgIT09IG51bGwgJiYgYXJyb3dDb2xvciAhPT0gdm9pZCAwID8gYXJyb3dDb2xvciA6IHByaW1hcnlBcnJvd0NvbGxvciB9KSB9KSksIGpzeChcImxpbmVcIiwgeyB4MTogZnJvbS54LCB5MTogZnJvbS55LCB4MjogZW5kLngsIHkyOiBlbmQueSwgb3BhY2l0eTogaXNBcnJvd0FjdGl2ZSA/IFwiMC41XCIgOiBcIjAuNjVcIiwgc3Ryb2tlOiBhcnJvd0NvbG9yICE9PSBudWxsICYmIGFycm93Q29sb3IgIT09IHZvaWQgMCA/IGFycm93Q29sb3IgOiBwcmltYXJ5QXJyb3dDb2xsb3IsIHN0cm9rZVdpZHRoOiBpc0Fycm93QWN0aXZlID8gKDAuOSAqIGJvYXJkV2lkdGgpIC8gNDAgOiBib2FyZFdpZHRoIC8gNDAsIG1hcmtlckVuZDogYHVybCgjYXJyb3doZWFkLSR7aX0pYCB9KV0gfSwgYCR7YXJyb3dTdGFydEZpZWxkfS0ke2Fycm93RW5kRmllbGR9JHtpc0Fycm93QWN0aXZlID8gXCItYWN0aXZlXCIgOiBcIlwifWApKTtcclxuICAgICAgICB9KSB9KSkpO1xyXG59O1xuXG5mdW5jdGlvbiBQcm9tb3Rpb25PcHRpb24oeyBvcHRpb24gfSkge1xyXG4gICAgY29uc3QgW2lzSG92ZXIsIHNldElzSG92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgeyBib2FyZFdpZHRoLCBjaGVzc1BpZWNlcywgY3VzdG9tRGFya1NxdWFyZVN0eWxlLCBjdXN0b21MaWdodFNxdWFyZVN0eWxlLCBoYW5kbGVTZXRQb3NpdGlvbiwgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCwgcHJvbW90ZUZyb21TcXVhcmUsIHByb21vdGVUb1NxdWFyZSwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9ICgpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKG9wdGlvblsxXSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbURhcmtTcXVhcmVTdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tTGlnaHRTcXVhcmVTdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGNhc2UgXCJOXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbW90aW9uRGlhbG9nVmFyaWFudCA9PT0gXCJkZWZhdWx0XCJcclxuICAgICAgICAgICAgICAgICAgICA/IGN1c3RvbUxpZ2h0U3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICBjYXNlIFwiQlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21vdGlvbkRpYWxvZ1ZhcmlhbnQgPT09IFwiZGVmYXVsdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21MaWdodFNxdWFyZVN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uUHJvbW90aW9uUGllY2VTZWxlY3Qob3B0aW9uLCBwcm9tb3RlRnJvbVNxdWFyZSAhPT0gbnVsbCAmJiBwcm9tb3RlRnJvbVNxdWFyZSAhPT0gdm9pZCAwID8gcHJvbW90ZUZyb21TcXVhcmUgOiB1bmRlZmluZWQsIHByb21vdGVUb1NxdWFyZSAhPT0gbnVsbCAmJiBwcm9tb3RlVG9TcXVhcmUgIT09IHZvaWQgMCA/IHByb21vdGVUb1NxdWFyZSA6IHVuZGVmaW5lZCkpXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXRQb3NpdGlvbihwcm9tb3RlRnJvbVNxdWFyZSwgcHJvbW90ZVRvU3F1YXJlLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sIG9uTW91c2VPdmVyOiAoKSA9PiBzZXRJc0hvdmVyKHRydWUpLCBvbk1vdXNlT3V0OiAoKSA9PiBzZXRJc0hvdmVyKGZhbHNlKSwgXCJkYXRhLXBpZWNlXCI6IG9wdGlvbiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0hvdmVyID8gYmFja2dyb3VuZENvbG9yKCkgOiBgJHtiYWNrZ3JvdW5kQ29sb3IoKX1hYWAsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC4xcyBlYXNlLW91dFwiLFxyXG4gICAgICAgIH0gfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW29wdGlvbl0gPT09IFwiZnVuY3Rpb25cIiA/IChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBcImFsbCAwLjFzIGVhc2Utb3V0XCIsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzSG92ZXIgPyBcInNjYWxlKDEpXCIgOiBcInNjYWxlKDAuODUpXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogY2hlc3NQaWVjZXNbb3B0aW9uXSh7XHJcbiAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aDogYm9hcmRXaWR0aCAvIDgsXHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgfSkgfSkpKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiBib2FyZFdpZHRoIC8gOCwgaGVpZ2h0OiBib2FyZFdpZHRoIC8gOCwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFwiYWxsIDAuMXMgZWFzZS1vdXRcIixcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNIb3ZlciA/IFwic2NhbGUoMSlcIiA6IFwic2NhbGUoMC44NSlcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IGNoZXNzUGllY2VzW29wdGlvbl0gfSkgfSkpKSB9KSkpO1xyXG59XG5cbmZ1bmN0aW9uIFByb21vdGlvbkRpYWxvZygpIHtcclxuICAgIGNvbnN0IHsgYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCwgcHJvbW90ZVRvU3F1YXJlLCB9ID0gdXNlQ2hlc3Nib2FyZCgpO1xyXG4gICAgY29uc3QgcHJvbW90ZVBpZWNlQ29sb3IgPSAocHJvbW90ZVRvU3F1YXJlID09PSBudWxsIHx8IHByb21vdGVUb1NxdWFyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvbW90ZVRvU3F1YXJlWzFdKSA9PT0gXCIxXCIgPyBcImJcIiA6IFwid1wiO1xyXG4gICAgY29uc3QgcHJvbW90aW9uT3B0aW9ucyA9IFtcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1RYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1SYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1OYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1CYCxcclxuICAgIF07XHJcbiAgICBjb25zdCBkaWFsb2dTdHlsZXMgPSB7XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiBcImdyaWRcIixcclxuICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogXCIxZnIgMWZyXCIsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1ib2FyZFdpZHRoIC8gOH1weCwgJHstYm9hcmRXaWR0aCAvIDh9cHgpYCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1ib2FyZFdpZHRoIC8gMTZ9cHgsICR7LWJvYXJkV2lkdGggLyAxNn1weClgLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9kYWw6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoMHB4LCAkeygzICogYm9hcmRXaWR0aCkgLyA4fXB4KWAsXHJcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtib2FyZFdpZHRoIC8gNH1weGAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBjb25zdCBkaWFsb2dDb29yZHMgPSBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBwcm9tb3RlVG9TcXVhcmUgfHwgXCJhOFwiKTtcclxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogYCR7ZGlhbG9nQ29vcmRzID09PSBudWxsIHx8IGRpYWxvZ0Nvb3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlhbG9nQ29vcmRzLnl9cHhgLCBsZWZ0OiBgJHtkaWFsb2dDb29yZHMgPT09IG51bGwgfHwgZGlhbG9nQ29vcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaWFsb2dDb29yZHMueH1weGAsIHpJbmRleDogMTAwMCB9LCBkaWFsb2dTdHlsZXNbcHJvbW90aW9uRGlhbG9nVmFyaWFudF0pLCB0aXRsZTogXCJDaG9vc2UgcHJvbW90aW9uIHBpZWNlXCIgfSwgeyBjaGlsZHJlbjogcHJvbW90aW9uT3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gKGpzeChQcm9tb3Rpb25PcHRpb24sIHsgb3B0aW9uOiBvcHRpb24gfSwgb3B0aW9uKSkpIH0pKSk7XHJcbn1cblxuY29uc3QgZXJyb3JJbWFnZSA9IHtcclxuICAgIHdoaXRlS2luZzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgc2hhcGVSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXHJcbiAgICAgICAgICAgIHRleHRSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXHJcbiAgICAgICAgICAgIGltYWdlUmVuZGVyaW5nOiBcImNyaXNwLWVkZ2VzXCIsXHJcbiAgICAgICAgfSwgdmlld0JveDogXCIwIDAgNDIxMCAxMjk3MFwiLCB4OiBcIjBweFwiLCB5OiBcIjBweFwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIGNsaXBSdWxlOiBcImV2ZW5vZGRcIiwgd2lkdGg6IFwiMjUwXCIsIGhlaWdodDogXCIyNTBcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICB9LCBkOiBcIk0yMTA1IDBjMTY5LDAgMjg2LDE2MCAyNDksMzE1bDIwMCAwYy0xNzIsMjY2IC0yMzEsNDc5IC0yNTYsNzkyIDMxNSwtMjQgNTMwLC04NiA3OTIsLTI1NWwwIDg5N2MtMjY1LC0xNzEgLTQ3OSwtMjMxIC03OTIsLTI1NiAxOCwyMzQgNzUsNDk1IDE4NSw2ODJsMzM5IDBjMjMzLDAgMzY5LDI2OSAyMjUsNDU2bDU0NSAwIC01OTUgMTkxNmMxMzAsOTQgMTU4LDI3NSA1OSw0MDIgNDY1LDAgNDE2LDU2OCA1MSw1NjhsLTMzNCAwIDQ2NSAyODY3IDMzMiAwYzI1MCwwIDM4MSwzMDYgMTk5LDQ4NSAxNjIsNjMgMjczLDIyMCAyNzMsMzk5bDAgNjMzIDE2OCAwIDAgNDc1Yy0xNDAzLDAgLTI4MDcsMCAtNDIxMCwwbDAgLTQ3NSAxNjcgMCAwIC02MzNjMCwtMTc5IDExMiwtMzM2IDI3NCwtMzk5IC0xODEsLTE3OCAtNTIsLTQ4NSAxOTksLTQ4NWwzMzIgMCA0NjUgLTI4NjcgLTMzNSAwYy0zNTMsMCAtNDE4LC01NjggNTEsLTU2OCAtOTgsLTEyNyAtNzAsLTMwOCA1OSwtNDAybC01OTQgLTE5MTZjMTgxLDAgMzYzLDAgNTQ1LDAgLTE0NCwtMTg3IC05LC00NTYgMjI1LC00NTZsMzM5IDBjMTEwLC0xODcgMTY3LC00NDggMTg1LC02ODIgLTMxNSwyNSAtNTMwLDg3IC03OTMsMjU2bDAgLTg5N2MyNjYsMTcxIDQ4MCwyMzEgNzkzLDI1NSAtMjUsLTMxNSAtODcsLTUyOSAtMjU2LC03OTJsMTk5IDBjLTM2LC0xNTUgODEsLTMxNSAyNTAsLTMxNXptLTE5OTQgMTAwMTJsMCAyNTMgMzk4OCAwIDAgLTI1M2MtMTMzMCwwIC0yNjU5LDAgLTM5ODgsMHptNDg0IC0xMDYwYy0xNzQsMCAtMzE2LDE0MiAtMzE2LDMxNmwwIDYzMyAzNjUyIDAgMCAtNjMzYzAsLTE3NCAtMTQyLC0zMTYgLTMxNiwtMzE2IC0xMDA3LDAgLTIwMTMsMCAtMzAyMCwwem00NSAtNDU3Yy0yMzAsMCAtMjI1LDM0NSAwLDM0NWwyOTMwIDBjMjMwLDAgMjI1LC0zNDUgMCwtMzQ1IC05NzcsMCAtMTk1MywwIC0yOTMwLDB6bTIwMjAgLTI5NzhsLTExMTEgMCAtNDY1IDI4NjcgMjA0MSAwIC00NjUgLTI4Njd6bS0xNTU4IC00NTZjLTIyOSwwIC0yMjQsMzQ1IDAsMzQ1IDY2OSwwIDEzMzcsMCAyMDA1LDAgMjMwLDAgMjI1LC0zNDUgMCwtMzQ1IC02NjgsMCAtMTMzNiwwIC0yMDA1LDB6bTE3MzAgLTQ1N2wtMTQ1NCAwYy0yMjksMCAtMjI0LDM0NSAwLDM0NWwxNDU0IDBjMjI5LDAgMjI0LC0zNDUgMCwtMzQ1em0tMjA2NCAtMTg2Mmw1NDQgMTc1MWM1MjksMCAxMDU3LDAgMTU4NiwwbDU0NCAtMTc1MWMtODkyLDAgLTE3ODMsMCAtMjY3NCwwem0xMDg1IC01NjdsNTA0IDBjLTEyNiwtMjQ3IC0xNjMsLTUyNiAtMTc3LC04MDAgMjczLDE1IDU1Myw1MiA4MDAsMTc3bDAgLTUwNGMtMjQ3LDEyNiAtNTI3LDE2MyAtODAwLDE3NyAxNCwtMjczIDUxLC01NTIgMTc3LC03OTkgLTE2OCwwIC0zMzYsMCAtNTA0LDAgMTI1LDI0NyAxNjIsNTI2IDE3Nyw3OTkgLTI3NCwtMTQgLTU1MywtNTEgLTgwMCwtMTc3bDAgNTA0YzI0NywtMTI1IDUyNywtMTYyIDgwMCwtMTc3IC0xNSwyNzQgLTUyLDU1MyAtMTc3LDgwMHptOTY5IDExMWwtMTQzNCAwYy0yMzAsMCAtMjI1LDM0NSAwLDM0NWwxNDM0IDBjMjMwLDAgMjI1LC0zNDUgMCwtMzQ1em0tNzE3IC0yMTc1Yy0xMDUsMCAtMTc1LDEwOSAtMTMzLDIwNGwyNjYgMGM0MiwtOTYgLTMwLC0yMDUgLTEzMywtMjA0elwiIH0pIH0pIH0pKSksXHJcbn07XG5cbmZ1bmN0aW9uIEVycm9yQm91bmRhcnkoeyBjaGlsZHJlbiB9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBqc3goV2hpdGVLaW5nLCB7IHNob3dFcnJvcjogdHJ1ZSB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBXaGl0ZUtpbmcoeyBzaG93RXJyb3IgPSBmYWxzZSB9KSB7XHJcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcclxuICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDI1MCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDI1MCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlKDkwZGVnKVwiLFxyXG4gICAgICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBlcnJvckltYWdlLndoaXRlS2luZyB9KSksIHNob3dFcnJvciAmJiBqc3goXCJoMVwiLCB7IGNoaWxkcmVuOiBcIlNvbWV0aGluZyB3ZW50IHdyb25nXCIgfSldIH0pKSk7XHJcbn1cblxuZnVuY3Rpb24gQm9hcmQoKSB7XHJcbiAgICBjb25zdCBib2FyZFJlZiA9IHVzZVJlZihudWxsKTtcclxuICAgIGNvbnN0IHsgYm9hcmRXaWR0aCwgY2xlYXJDdXJyZW50UmlnaHRDbGlja0Rvd24sIG9uUHJvbW90aW9uUGllY2VTZWxlY3QsIHNldFNob3dQcm9tb3RlRGlhbG9nLCBzaG93UHJvbW90ZURpYWxvZywgY3VzdG9tQm9hcmRTdHlsZSwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChib2FyZFJlZi5jdXJyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAhYm9hcmRSZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckN1cnJlbnRSaWdodENsaWNrRG93bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIGJvYXJkV2lkdGggPyAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogeyBwZXJzcGVjdGl2ZTogXCIxMDAwcHhcIiB9IH0sIHsgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogYm9hcmRSZWYsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0sIGJvYXJkU3R5bGVzKGJvYXJkV2lkdGgpKSwgY3VzdG9tQm9hcmRTdHlsZSkgfSwgeyBjaGlsZHJlbjogW2pzeChTcXVhcmVzLCB7fSksIGpzeChBcnJvd3MsIHt9KSwgc2hvd1Byb21vdGVEaWFsb2cgJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBvbkNsaWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2coZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUHJvbW90aW9uUGllY2VTZWxlY3QgPT09IG51bGwgfHwgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiBcIjEwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDIyLDIxLDE4LC43KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib2FyZFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYm9hcmRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChQcm9tb3Rpb25EaWFsb2csIHt9KV0gfSkpXSB9KSkgfSkpKSA6IChqc3goV2hpdGVLaW5nLCB7fSkpO1xyXG59XHJcbmNvbnN0IGJvYXJkU3R5bGVzID0gKHdpZHRoKSA9PiAoe1xyXG4gICAgY3Vyc29yOiBcImRlZmF1bHRcIixcclxuICAgIGhlaWdodDogd2lkdGgsXHJcbiAgICB3aWR0aCxcclxufSk7XG5cbnZhciBMaXN0ZW5lclR5cGU7XG4oZnVuY3Rpb24oTGlzdGVuZXJUeXBlKSB7XG4gICAgTGlzdGVuZXJUeXBlW1wibW91c2VcIl0gPSBcIm1vdXNlXCI7XG4gICAgTGlzdGVuZXJUeXBlW1widG91Y2hcIl0gPSBcInRvdWNoXCI7XG4gICAgTGlzdGVuZXJUeXBlW1wia2V5Ym9hcmRcIl0gPSBcImtleWJvYXJkXCI7XG59KShMaXN0ZW5lclR5cGUgfHwgKExpc3RlbmVyVHlwZSA9IHt9KSk7XG5cbmNsYXNzIE9wdGlvbnNSZWFkZXIge1xuICAgIGdldCBkZWxheSgpIHtcbiAgICAgICAgdmFyIF9kZWxheTtcbiAgICAgICAgcmV0dXJuIChfZGVsYXkgPSB0aGlzLmFyZ3MuZGVsYXkpICE9PSBudWxsICYmIF9kZWxheSAhPT0gdm9pZCAwID8gX2RlbGF5IDogMDtcbiAgICB9XG4gICAgZ2V0IHNjcm9sbEFuZ2xlUmFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLnNjcm9sbEFuZ2xlUmFuZ2VzO1xuICAgIH1cbiAgICBnZXQgZ2V0RHJvcFRhcmdldEVsZW1lbnRzQXRQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5nZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50O1xuICAgIH1cbiAgICBnZXQgaWdub3JlQ29udGV4dE1lbnUoKSB7XG4gICAgICAgIHZhciBfaWdub3JlQ29udGV4dE1lbnU7XG4gICAgICAgIHJldHVybiAoX2lnbm9yZUNvbnRleHRNZW51ID0gdGhpcy5hcmdzLmlnbm9yZUNvbnRleHRNZW51KSAhPT0gbnVsbCAmJiBfaWdub3JlQ29udGV4dE1lbnUgIT09IHZvaWQgMCA/IF9pZ25vcmVDb250ZXh0TWVudSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0KCkge1xuICAgICAgICB2YXIgX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldDtcbiAgICAgICAgcmV0dXJuIChfZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0ID0gdGhpcy5hcmdzLmVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCkgIT09IG51bGwgJiYgX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCAhPT0gdm9pZCAwID8gX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlS2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlS2V5Ym9hcmRFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZUtleWJvYXJkRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZUtleWJvYXJkRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlS2V5Ym9hcmRFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVLZXlib2FyZEV2ZW50cyA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlTW91c2VFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlTW91c2VFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZU1vdXNlRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZU1vdXNlRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlTW91c2VFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVNb3VzZUV2ZW50cyA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlVG91Y2hFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlVG91Y2hFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZVRvdWNoRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZVRvdWNoRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlVG91Y2hFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVUb3VjaEV2ZW50cyA6IHRydWU7XG4gICAgfVxuICAgIGdldCB0b3VjaFNsb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3MudG91Y2hTbG9wIHx8IDA7XG4gICAgfVxuICAgIGdldCBkZWxheVRvdWNoU3RhcnQoKSB7XG4gICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICByZXR1cm4gKHJlZjMgPSAocmVmMiA9IChyZWYgPSB0aGlzLmFyZ3MpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRlbGF5VG91Y2hTdGFydCkgIT09IG51bGwgJiYgcmVmMiAhPT0gdm9pZCAwID8gcmVmMiA6IChyZWYxID0gdGhpcy5hcmdzKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLmRlbGF5KSAhPT0gbnVsbCAmJiByZWYzICE9PSB2b2lkIDAgPyByZWYzIDogMDtcbiAgICB9XG4gICAgZ2V0IGRlbGF5TW91c2VTdGFydCgpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmNDtcbiAgICAgICAgdmFyIHJlZjUsIHJlZjY7XG4gICAgICAgIHJldHVybiAocmVmNiA9IChyZWY1ID0gKHJlZiA9IHRoaXMuYXJncykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuZGVsYXlNb3VzZVN0YXJ0KSAhPT0gbnVsbCAmJiByZWY1ICE9PSB2b2lkIDAgPyByZWY1IDogKHJlZjQgPSB0aGlzLmFyZ3MpID09PSBudWxsIHx8IHJlZjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjQuZGVsYXkpICE9PSBudWxsICYmIHJlZjYgIT09IHZvaWQgMCA/IHJlZjYgOiAwO1xuICAgIH1cbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0ICYmIHRoaXMuY29udGV4dC53aW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQud2luZG93O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBkb2N1bWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmNvbnRleHQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2luZG93LmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5hcmdzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5yb290RWxlbWVudCkgfHwgdGhpcy5kb2N1bWVudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXJncywgY29udGV4dCl7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoeDIgLSB4MSksIDIpICsgTWF0aC5wb3coTWF0aC5hYnMoeTIgLSB5MSksIDIpKTtcbn1cbmZ1bmN0aW9uIGluQW5nbGVSYW5nZXMoeDEsIHkxLCB4MiwgeTIsIGFuZ2xlUmFuZ2VzKSB7XG4gICAgaWYgKCFhbmdsZVJhbmdlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEkgKyAxODA7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFuZ2xlUmFuZ2VzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgY29uc3QgYXIgPSBhbmdsZVJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGFyICYmIChhci5zdGFydCA9PSBudWxsIHx8IGFuZ2xlID49IGFyLnN0YXJ0KSAmJiAoYXIuZW5kID09IG51bGwgfHwgYW5nbGUgPD0gYXIuZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBVc2VkIGZvciBNb3VzZUV2ZW50LmJ1dHRvbnMgKG5vdGUgdGhlIHMgb24gdGhlIGVuZCkuXG5jb25zdCBNb3VzZUJ1dHRvbnMgPSB7XG4gICAgTGVmdDogMSxcbiAgICBSaWdodDogMixcbiAgICBDZW50ZXI6IDRcbn07XG4vLyBVc2VkIGZvciBlLmJ1dHRvbiAobm90ZSB0aGUgbGFjayBvZiBhbiBzIG9uIHRoZSBlbmQpLlxuY29uc3QgTW91c2VCdXR0b24gPSB7XG4gICAgTGVmdDogMCxcbiAgICBDZW50ZXI6IDEsXG4gICAgUmlnaHQ6IDJcbn07XG4vKipcbiAqIE9ubHkgdG91Y2ggZXZlbnRzIGFuZCBtb3VzZSBldmVudHMgd2hlcmUgdGhlIGxlZnQgYnV0dG9uIGlzIHByZXNzZWQgc2hvdWxkIGluaXRpYXRlIGEgZHJhZy5cbiAqIEBwYXJhbSB7TW91c2VFdmVudCB8IFRvdWNoRXZlbnR9IGUgVGhlIGV2ZW50XG4gKi8gZnVuY3Rpb24gZXZlbnRTaG91bGRTdGFydERyYWcoZSkge1xuICAgIC8vIEZvciB0b3VjaCBldmVudHMsIGJ1dHRvbiB3aWxsIGJlIHVuZGVmaW5lZC4gSWYgZS5idXR0b24gaXMgZGVmaW5lZCxcbiAgICAvLyB0aGVuIGl0IHNob3VsZCBiZSBNb3VzZUJ1dHRvbi5MZWZ0LlxuICAgIHJldHVybiBlLmJ1dHRvbiA9PT0gdW5kZWZpbmVkIHx8IGUuYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5MZWZ0O1xufVxuLyoqXG4gKiBPbmx5IHRvdWNoIGV2ZW50cyBhbmQgbW91c2UgZXZlbnRzIHdoZXJlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBubyBsb25nZXIgaGVsZCBzaG91bGQgZW5kIGEgZHJhZy5cbiAqIEl0J3MgcG9zc2libGUgdGhlIHVzZXIgbW91c2UgZG93bnMgd2l0aCB0aGUgbGVmdCBtb3VzZSBidXR0b24sIHRoZW4gbW91c2UgZG93biBhbmQgdXBzIHdpdGggdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbi5cbiAqIFdlIGRvbid0IHdhbnQgcmVsZWFzaW5nIHRoZSByaWdodCBtb3VzZSBidXR0b24gdG8gZW5kIHRoZSBkcmFnLlxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZSBUaGUgZXZlbnRcbiAqLyBmdW5jdGlvbiBldmVudFNob3VsZEVuZERyYWcoZSkge1xuICAgIC8vIFRvdWNoIGV2ZW50cyB3aWxsIGhhdmUgYnV0dG9ucyBiZSB1bmRlZmluZWQsIHdoaWxlIG1vdXNlIGV2ZW50cyB3aWxsIGhhdmUgZS5idXR0b25zJ3MgbGVmdCBidXR0b25cbiAgICAvLyBiaXQgZmllbGQgdW5zZXQgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGhhcyBiZWVuIHJlbGVhc2VkXG4gICAgcmV0dXJuIGUuYnV0dG9ucyA9PT0gdW5kZWZpbmVkIHx8IChlLmJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnMuTGVmdCkgPT09IDA7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZSkge1xuICAgIHJldHVybiAhIWUudGFyZ2V0VG91Y2hlcztcbn1cblxuY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbmZ1bmN0aW9uIGdldE5vZGVDbGllbnRPZmZzZXQobm9kZSkge1xuICAgIGNvbnN0IGVsID0gbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHsgdG9wICwgbGVmdCAgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IHRvcFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRFdmVudENsaWVudFRvdWNoT2Zmc2V0KGUsIGxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUudGFyZ2V0VG91Y2hlc1swXSk7XG4gICAgfSBlbHNlIGlmIChsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMF0udGFyZ2V0ID09PSBsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjay50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFdmVudENsaWVudE9mZnNldChlLnRvdWNoZXNbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUsIGxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrKSB7XG4gICAgaWYgKGlzVG91Y2hFdmVudChlKSkge1xuICAgICAgICByZXR1cm4gZ2V0RXZlbnRDbGllbnRUb3VjaE9mZnNldChlLCBsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3Qgc3VwcG9ydHNQYXNzaXZlID0gKCgpPT57XG4gICAgLy8gc2ltdWxhciB0byBqUXVlcnkncyB0ZXN0XG4gICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCAoKT0+e1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufSkoKTtcblxuY29uc3QgZXZlbnROYW1lcyA9IHtcbiAgICBbTGlzdGVuZXJUeXBlLm1vdXNlXToge1xuICAgICAgICBzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgICAgICBlbmQ6ICdtb3VzZXVwJyxcbiAgICAgICAgY29udGV4dG1lbnU6ICdjb250ZXh0bWVudSdcbiAgICB9LFxuICAgIFtMaXN0ZW5lclR5cGUudG91Y2hdOiB7XG4gICAgICAgIHN0YXJ0OiAndG91Y2hzdGFydCcsXG4gICAgICAgIG1vdmU6ICd0b3VjaG1vdmUnLFxuICAgICAgICBlbmQ6ICd0b3VjaGVuZCdcbiAgICB9LFxuICAgIFtMaXN0ZW5lclR5cGUua2V5Ym9hcmRdOiB7XG4gICAgICAgIGtleWRvd246ICdrZXlkb3duJ1xuICAgIH1cbn07XG5jbGFzcyBUb3VjaEJhY2tlbmRJbXBsIHtcbiAgICAvKipcblx0ICogR2VuZXJhdGUgcHJvZmlsaW5nIHN0YXRpc3RpY3MgZm9yIHRoZSBIVE1MNUJhY2tlbmQuXG5cdCAqLyBwcm9maWxlKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlTm9kZXM6IHRoaXMuc291cmNlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZVByZXZpZXdOb2RlczogdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZVByZXZpZXdOb2RlT3B0aW9uczogdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGVzOiB0aGlzLnRhcmdldE5vZGVzLnNpemUsXG4gICAgICAgICAgICBkcmFnT3ZlclRhcmdldElkczogKChyZWYgPSB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sZW5ndGgpIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcHVibGljIGZvciB0ZXN0XG4gICAgZ2V0IGRvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRvY3VtZW50O1xuICAgIH1cbiAgICBzZXR1cCgpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KCFUb3VjaEJhY2tlbmRJbXBsLmlzU2V0VXAsICdDYW5ub3QgaGF2ZSB0d28gVG91Y2ggYmFja2VuZHMgYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICAgICAgVG91Y2hCYWNrZW5kSW1wbC5pc1NldFVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHJvb3QsICdzdGFydCcsIHRoaXMuZ2V0VG9wTW92ZVN0YXJ0SGFuZGxlcigpKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHJvb3QsICdzdGFydCcsIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW92ZScsIHRoaXMuaGFuZGxlVG9wTW92ZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW92ZScsIHRoaXMuaGFuZGxlVG9wTW92ZUNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ2VuZCcsIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZU1vdXNlRXZlbnRzICYmICF0aGlzLm9wdGlvbnMuaWdub3JlQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVG91Y2hCYWNrZW5kSW1wbC5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihyb290LCAnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ3N0YXJ0JywgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdmUnLCB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdtb3ZlJywgdGhpcy5oYW5kbGVUb3BNb3ZlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdlbmQnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVNb3VzZUV2ZW50cyAmJiAhdGhpcy5vcHRpb25zLmlnbm9yZUNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ2NvbnRleHRtZW51JywgdGhpcy5oYW5kbGVUb3BNb3ZlRW5kQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVLZXlib2FyZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdrZXlkb3duJywgdGhpcy5oYW5kbGVDYW5jZWxPbkVzY2FwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIoc3ViamVjdCwgZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgICAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0gOiBjYXB0dXJlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGV2ZW50TmFtZXNbbGlzdGVuZXJUeXBlXVtldmVudF07XG4gICAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHN1YmplY3QsIGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogY2FwdHVyZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXJUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBldnQgPSBldmVudE5hbWVzW2xpc3RlbmVyVHlwZV1bZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdERyYWdTb3VyY2Uoc291cmNlSWQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlTW92ZVN0YXJ0ID0gdGhpcy5oYW5kbGVNb3ZlU3RhcnQuYmluZCh0aGlzLCBzb3VyY2VJZCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMuc2V0KHNvdXJjZUlkLCBub2RlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2Rlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbm5lY3REcmFnUHJldmlldyhzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5zZXQoc291cmNlSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25uZWN0RHJvcFRhcmdldCh0YXJnZXRJZCwgbm9kZSkge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5vcHRpb25zLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnQgfHwgIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgLyogbm9vcCAqLyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZU1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5kb2N1bWVudCB8fCAhcm9vdCB8fCAhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb29yZHM7XG4gICAgICAgICAgICAvKipcblx0XHRcdCAqIEdyYWIgdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgY3VycmVudCBtb3VzZS90b3VjaCBwb3NpdGlvblxuXHRcdFx0ICovIHN3aXRjaChlLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgZXZlbnROYW1lcy5tb3VzZS5tb3ZlOlxuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBldmVudE5hbWVzLnRvdWNoLm1vdmU6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6ICgocmVmID0gZS50b3VjaGVzWzBdKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jbGllbnRYKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogKChyZWYxID0gZS50b3VjaGVzWzBdKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLmNsaWVudFkpIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcblx0XHRcdCAqIFVzZSB0aGUgY29vcmRpbmF0ZXMgdG8gZ3JhYiB0aGUgZWxlbWVudCB0aGUgZHJhZyBlbmRlZCBvbi5cblx0XHRcdCAqIElmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIGFzIHRoZSB0YXJnZXQgbm9kZSAob3IgYW55IG9mIGl0J3MgY2hpbGRyZW4pIHRoZW4gd2UgaGF2ZSBoaXQgYSBkcm9wIHRhcmdldCBhbmQgY2FuIGhhbmRsZSB0aGUgbW92ZS5cblx0XHRcdCAqLyBjb25zdCBkcm9wcGVkT24gPSBjb29yZHMgIT0gbnVsbCA/IHRoaXMuZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjb29yZHMueCwgY29vcmRzLnkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRNYXRjaCA9IGRyb3BwZWRPbiAmJiBub2RlLmNvbnRhaW5zKGRyb3BwZWRPbik7XG4gICAgICAgICAgICBpZiAoZHJvcHBlZE9uID09PSBub2RlIHx8IGNoaWxkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNb3ZlKGUsIHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG5cdFx0ICogQXR0YWNoaW5nIHRoZSBldmVudCBsaXN0ZW5lciB0byB0aGUgYm9keSBzbyB0aGF0IHRvdWNobW92ZSB3aWxsIHdvcmsgd2hpbGUgZHJhZ2dpbmcgb3ZlciBtdWx0aXBsZSB0YXJnZXQgZWxlbWVudHMuXG5cdFx0ICovIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmRvY3VtZW50LmJvZHksICdtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0Tm9kZXMuc2V0KHRhcmdldElkLCBub2RlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0Tm9kZXMuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb2N1bWVudC5ib2R5LCAnbW92ZScsIGhhbmRsZU1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRUb3BNb3ZlU3RhcnRIYW5kbGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWxheVRvdWNoU3RhcnQgJiYgIXRoaXMub3B0aW9ucy5kZWxheU1vdXNlU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnREZWxheTtcbiAgICB9XG4gICAgaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIobm9kZSkge1xuICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKT0+e1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgIW5vZGUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdXJyZWN0U291cmNlTm9kZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyLm9ic2VydmUobm9kZS5wYXJlbnRFbGVtZW50LCB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VycmVjdFNvdXJjZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50ICYmIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXJlYWN0aWQnKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyYWdnZWRTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgY29udGV4dCwgb3B0aW9ucyl7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuc291cmNlTm9kZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50ICYmIGdldE5vZGVDbGllbnRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0Q2FwdHVyZSA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZFN0YXJ0RHJhZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZVN0YXJ0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgLy8gSnVzdCBiZWNhdXNlIHdlIHJlY2VpdmVkIGFuIGV2ZW50IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiB3ZSBuZWVkIHRvIGNvbGxlY3QgZHJhZyBzb3VyY2VzLlxuICAgICAgICAgICAgLy8gV2Ugb25seSBjb2xsZWN0IHN0YXJ0IGNvbGxlY3RpbmcgZHJhZyBzb3VyY2VzIG9uIHRvdWNoIGFuZCBsZWZ0IG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubW92ZVN0YXJ0U291cmNlSWRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzLnVuc2hpZnQoc291cmNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZFN0YXJ0RHJhZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHByZW1hdHVyZWx5IHByZXZlbnREZWZhdWx0KCkgaGVyZSBzaW5jZSBpdCBtaWdodDpcbiAgICAgICAgICAgIC8vIDEuIE1lc3MgdXAgc2Nyb2xsaW5nXG4gICAgICAgICAgICAvLyAyLiBNZXNzIHVwIGxvbmcgdGFwICh3aGljaCBicmluZ3MgdXAgY29udGV4dCBtZW51KVxuICAgICAgICAgICAgLy8gMy4gSWYgdGhlcmUncyBhbiBhbmNob3IgbGluayBhcyBhIGNoaWxkLCB0YXAgd29uJ3QgYmUgdHJpZ2dlcmVkIG9uIGxpbmtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudE9mZnNldCA9IGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUpO1xuICAgICAgICAgICAgaWYgKGNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayA9IGUudGFyZ2V0VG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQgPSBjbGllbnRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdGb3JEZWxheSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydERlbGF5ID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoIWV2ZW50U2hvdWxkU3RhcnREcmFnKGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBlLnR5cGUgPT09IGV2ZW50TmFtZXMudG91Y2guc3RhcnQgPyB0aGlzLm9wdGlvbnMuZGVsYXlUb3VjaFN0YXJ0IDogdGhpcy5vcHRpb25zLmRlbGF5TW91c2VTdGFydDtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQuYmluZCh0aGlzLCBlKSwgZGVsYXkpO1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yRGVsYXkgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlID0gKF9ldnQsIHRhcmdldElkKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmUgPSAoZTEpPT57XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnQgfHwgdGhpcy53YWl0aW5nRm9yRGVsYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1vdmVTdGFydFNvdXJjZUlkcyAsIGRyYWdPdmVyVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCA9IHRoaXMub3B0aW9ucy5lbmFibGVIb3Zlck91dHNpZGVUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRPZmZzZXQgPSBnZXRFdmVudENsaWVudE9mZnNldChlMSwgdGhpcy5sYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoIWNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0b3VjaCBtb3ZlIHN0YXJ0ZWQgYXMgYSBzY3JvbGwsIG9yIGlzIGlzIGJldHdlZW4gdGhlIHNjcm9sbCBhbmdsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Njcm9sbGluZyB8fCAhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSAmJiBpbkFuZ2xlUmFuZ2VzKHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0LnggfHwgMCwgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQueSB8fCAwLCBjbGllbnRPZmZzZXQueCwgY2xpZW50T2Zmc2V0LnksIHRoaXMub3B0aW9ucy5zY3JvbGxBbmdsZVJhbmdlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIGFuZCB3ZSd2ZSBtb3ZlZCBhIGxpdHRsZSwgdGhhdCBjb3VudHMgYXMgYSBkcmFnIHN0YXJ0XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQuaGFzT3duUHJvcGVydHkoJ3gnKSAmJiBtb3ZlU3RhcnRTb3VyY2VJZHMgJiYgZGlzdGFuY2UodGhpcy5fbW91c2VDbGllbnRPZmZzZXQueCB8fCAwLCB0aGlzLl9tb3VzZUNsaWVudE9mZnNldC55IHx8IDAsIGNsaWVudE9mZnNldC54LCBjbGllbnRPZmZzZXQueSkgPiAodGhpcy5vcHRpb25zLnRvdWNoU2xvcCA/IHRoaXMub3B0aW9ucy50b3VjaFNsb3AgOiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5iZWdpbkRyYWcobW92ZVN0YXJ0U291cmNlSWRzLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogdGhpcy5fbW91c2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGdldFNvdXJjZUNsaWVudE9mZnNldDogdGhpcy5nZXRTb3VyY2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hTb3VyY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gdGhpcy5zb3VyY2VOb2Rlcy5nZXQodGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCkpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcihzb3VyY2VOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wdWJsaXNoRHJhZ1NvdXJjZSgpO1xuICAgICAgICAgICAgaWYgKGUxLmNhbmNlbGFibGUpIGUxLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5vZGUgZWxlbWVudHMgb2YgdGhlIGhvdmVyZWQgRHJvcFRhcmdldHNcbiAgICAgICAgICAgIGNvbnN0IGRyYWdPdmVyVGFyZ2V0Tm9kZXMgPSAoZHJhZ092ZXJUYXJnZXRJZHMgfHwgW10pLm1hcCgoa2V5KT0+dGhpcy50YXJnZXROb2Rlcy5nZXQoa2V5KVxuICAgICAgICAgICAgKS5maWx0ZXIoKGUpPT4hIWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGEgb3JkZXJlZCBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRvdWNoZWQgYnlcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQXRQb2ludCA9IHRoaXMub3B0aW9ucy5nZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50ID8gdGhpcy5vcHRpb25zLmdldERyb3BUYXJnZXRFbGVtZW50c0F0UG9pbnQoY2xpZW50T2Zmc2V0LngsIGNsaWVudE9mZnNldC55LCBkcmFnT3ZlclRhcmdldE5vZGVzKSA6IHRoaXMuZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoY2xpZW50T2Zmc2V0LngsIGNsaWVudE9mZnNldC55KTtcbiAgICAgICAgICAgIC8vIEV4dGVuZCBsaXN0IHdpdGggcGFyZW50cyB0aGF0IGFyZSBub3QgcmVjZWl2aW5nIGVsZW1lbnRzRnJvbVBvaW50IGV2ZW50cyAoc2l6ZSAwIGVsZW1lbnRzIGFuZCBzdmcgZ3JvdXBzKVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQgPSBbXTtcbiAgICAgICAgICAgIGZvcihjb25zdCBub2RlSWQgaW4gZWxlbWVudHNBdFBvaW50KXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50c0F0UG9pbnQuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudHNBdFBvaW50W25vZGVJZF07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnROb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQuaW5kZXhPZihjdXJyZW50Tm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0F0UG9pbnRFeHRlbmRlZC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9yZGVyZWREcmFnT3ZlclRhcmdldElkcyA9IGVsZW1lbnRzQXRQb2ludEV4dGVuZGVkLy8gRmlsdGVyIG9mZiBub2RlcyB0aGF0IGFyZW50IGEgaG92ZXJlZCBEcm9wVGFyZ2V0cyBub2Rlc1xuICAgICAgICAgICAgLmZpbHRlcigobm9kZSk9PmRyYWdPdmVyVGFyZ2V0Tm9kZXMuaW5kZXhPZihub2RlKSA+IC0xXG4gICAgICAgICAgICApLy8gTWFwIGJhY2sgdGhlIG5vZGVzIGVsZW1lbnRzIHRvIHRhcmdldElkc1xuICAgICAgICAgICAgLm1hcCgobm9kZSk9PnRoaXMuX2dldERyb3BUYXJnZXRJZChub2RlKVxuICAgICAgICAgICAgKS8vIEZpbHRlciBvZmYgcG9zc2libGUgbnVsbCByb3dzXG4gICAgICAgICAgICAuZmlsdGVyKChub2RlKT0+ISFub2RlXG4gICAgICAgICAgICApLmZpbHRlcigoaWQsIGluZGV4LCBpZHMpPT5pZHMuaW5kZXhPZihpZCkgPT09IGluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gSW52b2tlIGhvdmVyIGZvciBkcm9wIHRhcmdldHMgd2hlbiBzb3VyY2Ugbm9kZSBpcyBzdGlsbCBvdmVyIGFuZCBwb2ludGVyIGlzIG91dHNpZGVcbiAgICAgICAgICAgIGlmIChlbmFibGVIb3Zlck91dHNpZGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IoY29uc3QgdGFyZ2V0SWQgaW4gdGhpcy50YXJnZXROb2Rlcyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLnRhcmdldE5vZGVzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlICYmIHRhcmdldE5vZGUgJiYgdGFyZ2V0Tm9kZS5jb250YWlucyhzb3VyY2VOb2RlKSAmJiBvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMudW5zaGlmdCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgYmVjYXVzZSBkbmQtY29yZSByZXZlcnNlIGl0IGJlZm9yZSBjYWxsaW5nIHRoZSBEcm9wVGFyZ2V0IGRyb3AgbWV0aG9kc1xuICAgICAgICAgICAgb3JkZXJlZERyYWdPdmVyVGFyZ2V0SWRzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3ZlcihvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuXHQgKlxuXHQgKiB2aXNpYmxlIGZvciB0ZXN0aW5nXG5cdCAqLyB0aGlzLl9nZXREcm9wVGFyZ2V0SWQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLnRhcmdldE5vZGVzLmtleXMoKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0ga2V5cy5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZShuZXh0LmRvbmUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJZCA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0Tm9kZXMuZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGtleXMubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUgPSAoZSk9PntcbiAgICAgICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZEVuZERyYWcoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkgfHwgdGhpcy5tb25pdG9yLmRpZERyb3AoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5kcm9wKCk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuZW5kRHJhZygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnICYmIHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zUmVhZGVyKG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50YXJnZXROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzID0gW107XG4gICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJUeXBlcy5wdXNoKExpc3RlbmVyVHlwZS5tb3VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLnB1c2goTGlzdGVuZXJUeXBlLnRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMucHVzaChMaXN0ZW5lclR5cGUua2V5Ym9hcmQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBUb3VjaEJhY2tlbmQgPSBmdW5jdGlvbiBjcmVhdGVCYWNrZW5kKG1hbmFnZXIsIGNvbnRleHQgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBUb3VjaEJhY2tlbmRJbXBsKG1hbmFnZXIsIGNvbnRleHQsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgQ2hlc3Nib2FyZERuRENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHsgaXNDdXN0b21EbmRQcm92aWRlclNldDogZmFsc2UgfSk7XHJcbmNvbnN0IEVtcHR5UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcclxufTtcclxuY29uc3QgQ2hlc3Nib2FyZERuRFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGJhY2tlbmQsIGNvbnRleHQsIG9wdGlvbnMsIGRlYnVnTW9kZSwgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChqc3goQ2hlc3Nib2FyZERuRENvbnRleHQuUHJvdmlkZXIsIE9iamVjdC5hc3NpZ24oeyB2YWx1ZTogeyBpc0N1c3RvbURuZFByb3ZpZGVyU2V0OiB0cnVlIH0gfSwgeyBjaGlsZHJlbjoganN4KERuZFByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgYmFja2VuZDogYmFja2VuZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgPyBUb3VjaEJhY2tlbmQgOiBIVE1MNUJhY2tlbmQpLCBjb250ZXh0OiBjb250ZXh0LCBvcHRpb25zOiBvcHRpb25zLCBkZWJ1Z01vZGU6IGRlYnVnTW9kZSAhPT0gbnVsbCAmJiBkZWJ1Z01vZGUgIT09IHZvaWQgMCA/IGRlYnVnTW9kZSA6IGZhbHNlIH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSB9KSkpO1xyXG59O1xyXG5jb25zdCBDaGVzc2JvYXJkRG5EUm9vdCA9ICh7IGN1c3RvbURuZEJhY2tlbmQsIGN1c3RvbURuZEJhY2tlbmRPcHRpb25zLCBjaGlsZHJlbiwgfSkgPT4ge1xyXG4gICAgY29uc3QgW2NsaWVudFdpbmRvdywgc2V0Q2xpZW50V2luZG93XSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbYmFja2VuZFNldCwgc2V0QmFja2VuZFNldF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNNb2JpbGUsIHNldElzTW9iaWxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHsgaXNDdXN0b21EbmRQcm92aWRlclNldCB9ID0gdXNlQ29udGV4dChDaGVzc2JvYXJkRG5EQ29udGV4dCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldElzTW9iaWxlKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KTtcclxuICAgICAgICBzZXRCYWNrZW5kU2V0KHRydWUpO1xyXG4gICAgICAgIHNldENsaWVudFdpbmRvdyh3aW5kb3cpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgLy8gaW4gY2FzZSB3ZSBhbHJlYWR5IHdyYXBwZWQgYDxDaGVzc2JvYXJkLz5gICB3aXRoIGA8RG5EUHJvdmlkZXIvPmAgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICBjb25zdCBEbkRXcmFwcGVyID0gaXNDdXN0b21EbmRQcm92aWRlclNldCA/IEVtcHR5UHJvdmlkZXIgOiBEbmRQcm92aWRlcjtcclxuICAgIGlmICghYmFja2VuZFNldCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsaWVudFdpbmRvdyA/IChqc3goRG5EV3JhcHBlciwgT2JqZWN0LmFzc2lnbih7IGJhY2tlbmQ6IGN1c3RvbURuZEJhY2tlbmQgfHwgKGlzTW9iaWxlID8gVG91Y2hCYWNrZW5kIDogSFRNTDVCYWNrZW5kKSwgY29udGV4dDogY2xpZW50V2luZG93LCBvcHRpb25zOiBjdXN0b21EbmRCYWNrZW5kID8gY3VzdG9tRG5kQmFja2VuZE9wdGlvbnMgOiB1bmRlZmluZWQgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpKSA6IChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcclxufTtcblxuZnVuY3Rpb24gQ3VzdG9tRHJhZ0xheWVyKHsgYm9hcmRDb250YWluZXIgfSkge1xyXG4gICAgY29uc3QgeyBib2FyZFdpZHRoLCBjaGVzc1BpZWNlcywgaWQsIHNuYXBUb0N1cnNvciwgYWxsb3dEcmFnT3V0c2lkZUJvYXJkIH0gPSB1c2VDaGVzc2JvYXJkKCk7XHJcbiAgICBjb25zdCBjb2xsZWN0ZWRQcm9wcyA9IHVzZURyYWdMYXllcigobW9uaXRvcikgPT4gKHtcclxuICAgICAgICBpdGVtOiBtb25pdG9yLmdldEl0ZW0oKSxcclxuICAgICAgICBjbGllbnRPZmZzZXQ6IG1vbml0b3IuZ2V0Q2xpZW50T2Zmc2V0KCksXHJcbiAgICAgICAgc291cmNlQ2xpZW50T2Zmc2V0OiBtb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpLFxyXG4gICAgICAgIGlzRHJhZ2dpbmc6IG1vbml0b3IuaXNEcmFnZ2luZygpLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgeyBpc0RyYWdnaW5nLCBpdGVtLCBjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCwgfSA9IGNvbGxlY3RlZFByb3BzO1xyXG4gICAgY29uc3QgZ2V0SXRlbVN0eWxlID0gdXNlQ2FsbGJhY2soKGNsaWVudE9mZnNldCwgc291cmNlQ2xpZW50T2Zmc2V0KSA9PiB7XHJcbiAgICAgICAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIXNvdXJjZUNsaWVudE9mZnNldClcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcGxheTogXCJub25lXCIgfTtcclxuICAgICAgICBsZXQgeyB4LCB5IH0gPSBzbmFwVG9DdXJzb3IgPyBjbGllbnRPZmZzZXQgOiBzb3VyY2VDbGllbnRPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgaGFsZlNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDggLyAyO1xyXG4gICAgICAgIGlmIChzbmFwVG9DdXJzb3IpIHtcclxuICAgICAgICAgICAgeCAtPSBoYWxmU3F1YXJlV2lkdGg7XHJcbiAgICAgICAgICAgIHkgLT0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFsbG93RHJhZ091dHNpZGVCb2FyZCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gYm9hcmRDb250YWluZXI7XHJcbiAgICAgICAgICAgIC8vIGhhbGYgc3F1YXJlIHNvIHRoZSBwaWVjZSByZWFjaGVzIHRoZSBib2FyZFxyXG4gICAgICAgICAgICBjb25zdCBtYXhMZWZ0ID0gbGVmdCAtIGhhbGZTcXVhcmVXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgbWF4VG9wID0gdG9wIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IGxlZnQgKyBib2FyZFdpZHRoIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhCb3R0b20gPSB0b3AgKyBib2FyZFdpZHRoIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5tYXgobWF4TGVmdCwgTWF0aC5taW4oeCwgbWF4UmlnaHQpKTtcclxuICAgICAgICAgICAgeSA9IE1hdGgubWF4KG1heFRvcCwgTWF0aC5taW4oeSwgbWF4Qm90dG9tKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICB0b3VjaEFjdGlvbjogXCJub25lXCIsXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtib2FyZFdpZHRoLCBhbGxvd0RyYWdPdXRzaWRlQm9hcmQsIHNuYXBUb0N1cnNvciwgYm9hcmRDb250YWluZXJdKTtcclxuICAgIHJldHVybiBpc0RyYWdnaW5nICYmIGl0ZW0uaWQgPT09IGlkID8gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcclxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXHJcbiAgICAgICAgICAgIHpJbmRleDogMTAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICB9IH0sIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IGdldEl0ZW1TdHlsZShjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkgfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW2l0ZW0ucGllY2VdID09PSBcImZ1bmN0aW9uXCIgPyAoY2hlc3NQaWVjZXNbaXRlbS5waWVjZV0oe1xyXG4gICAgICAgICAgICAgICAgc3F1YXJlV2lkdGg6IGJvYXJkV2lkdGggLyA4LFxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcclxuICAgICAgICAgICAgfSkpIDogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgdmlld0JveDogXCIxIDEgNDMgNDNcIiwgd2lkdGg6IGJvYXJkV2lkdGggLyA4LCBoZWlnaHQ6IGJvYXJkV2lkdGggLyA4IH0sIHsgY2hpbGRyZW46IGpzeChcImdcIiwgeyBjaGlsZHJlbjogY2hlc3NQaWVjZXNbaXRlbS5waWVjZV0gfSkgfSkpKSB9KSkgfSkpKSA6IG51bGw7XHJcbn1cblxuY29uc3QgU3BhcmVQaWVjZSA9ICh7IHBpZWNlLCB3aWR0aCwgY3VzdG9tUGllY2VKU1gsIGRuZElkLCB9KSA9PiB7XHJcbiAgICBjb25zdCByZW5kZXJQaWVjZSA9IGN1c3RvbVBpZWNlSlNYICE9PSBudWxsICYmIGN1c3RvbVBpZWNlSlNYICE9PSB2b2lkIDAgPyBjdXN0b21QaWVjZUpTWCA6IGRlZmF1bHRQaWVjZXNbcGllY2VdO1xyXG4gICAgY29uc3QgW3sgY2FuRHJhZywgaXNEcmFnZ2luZyB9LCBkcmFnLCBkcmFnUHJldmlld10gPSB1c2VEcmFnKCgpID0+ICh7XHJcbiAgICAgICAgdHlwZTogXCJwaWVjZVwiLFxyXG4gICAgICAgIGl0ZW06ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGllY2UsIGlzU3BhcmU6IHRydWUsIGlkOiBkbmRJZCB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdDogKG1vbml0b3IpID0+ICh7XHJcbiAgICAgICAgICAgIGNhbkRyYWc6IHRydWUsXHJcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6ICEhbW9uaXRvci5pc0RyYWdnaW5nKCksXHJcbiAgICAgICAgfSksXHJcbiAgICB9KSwgW3BpZWNlLCBkbmRJZF0pO1xyXG4gICAgLy8gaGlkZSB0aGUgZGVmYXVsdCBwcmV2aWV3XHJcbiAgICBkcmFnUHJldmlldyhnZXRFbXB0eUltYWdlKCksIHsgY2FwdHVyZURyYWdnaW5nU3RhdGU6IHRydWUgfSk7XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBjYW5EcmFnID8gZHJhZyA6IG51bGwsIFwiZGF0YS1waWVjZVwiOiBwaWVjZSwgc3R5bGU6IHsgY3Vyc29yOiBcIm1vdmVcIiB9IH0sIHsgY2hpbGRyZW46IHR5cGVvZiByZW5kZXJQaWVjZSA9PT0gXCJmdW5jdGlvblwiID8gKHJlbmRlclBpZWNlKHtcclxuICAgICAgICAgICAgc3F1YXJlV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBpc0RyYWdnaW5nLFxyXG4gICAgICAgIH0pKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiB3aWR0aCB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IHJlbmRlclBpZWNlIH0pIH0pKSkgfSkpKTtcclxufTtcblxuY29uc3QgQ2hlc3Nib2FyZCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcclxuICAgIGNvbnN0IHsgY3VzdG9tRG5kQmFja2VuZCwgY3VzdG9tRG5kQmFja2VuZE9wdGlvbnMsIG9uQm9hcmRXaWR0aENoYW5nZSB9ID0gcHJvcHMsIG90aGVyUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImN1c3RvbURuZEJhY2tlbmRcIiwgXCJjdXN0b21EbmRCYWNrZW5kT3B0aW9uc1wiLCBcIm9uQm9hcmRXaWR0aENoYW5nZVwiXSk7XHJcbiAgICBjb25zdCBbYm9hcmRXaWR0aCwgc2V0Qm9hcmRXaWR0aF0gPSB1c2VTdGF0ZShwcm9wcy5ib2FyZFdpZHRoKTtcclxuICAgIGNvbnN0IGJvYXJkUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgYm9hcmRDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBbYm9hcmRDb250YWluZXJQb3MsIHNldEJvYXJkQ29udGFpbmVyUG9zXSA9IHVzZVN0YXRlKHtcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbWV0cmljcyA9IHVzZU1lbW8oKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBib2FyZFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0sIFtib2FyZFJlZi5jdXJyZW50XSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGJvYXJkV2lkdGggJiYgKG9uQm9hcmRXaWR0aENoYW5nZSA9PT0gbnVsbCB8fCBvbkJvYXJkV2lkdGhDaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQm9hcmRXaWR0aENoYW5nZShib2FyZFdpZHRoKSk7XHJcbiAgICB9LCBbYm9hcmRXaWR0aF0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRCb2FyZENvbnRhaW5lclBvcyh7XHJcbiAgICAgICAgICAgIGxlZnQ6IChtZXRyaWNzID09PSBudWxsIHx8IG1ldHJpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldHJpY3MubGVmdCkgPyBtZXRyaWNzID09PSBudWxsIHx8IG1ldHJpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldHJpY3MubGVmdCA6IDAsXHJcbiAgICAgICAgICAgIHRvcDogKG1ldHJpY3MgPT09IG51bGwgfHwgbWV0cmljcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0cmljcy50b3ApID8gbWV0cmljcyA9PT0gbnVsbCB8fCBtZXRyaWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRyaWNzLnRvcCA6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbbWV0cmljc10pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHByb3BzLmJvYXJkV2lkdGggPT09IHVuZGVmaW5lZCAmJiAoKF9hID0gYm9hcmRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9mZnNldFdpZHRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBzZXRCb2FyZFdpZHRoKChfYSA9IGJvYXJkUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vZmZzZXRXaWR0aCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGJvYXJkUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtib2FyZFJlZi5jdXJyZW50XSk7XHJcbiAgICByZXR1cm4gKGpzeChFcnJvckJvdW5kYXJ5LCB7IGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyByZWY6IGJvYXJkQ29udGFpbmVyUmVmLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyByZWY6IGJvYXJkUmVmLCBzdHlsZTogeyB3aWR0aDogXCIxMDAlXCIgfSB9KSwganN4KENoZXNzYm9hcmREbkRSb290LCBPYmplY3QuYXNzaWduKHsgY3VzdG9tRG5kQmFja2VuZDogY3VzdG9tRG5kQmFja2VuZCwgY3VzdG9tRG5kQmFja2VuZE9wdGlvbnM6IGN1c3RvbURuZEJhY2tlbmRPcHRpb25zIH0sIHsgY2hpbGRyZW46IGJvYXJkV2lkdGggJiYgKGpzeHMoQ2hlc3Nib2FyZFByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgYm9hcmRXaWR0aDogYm9hcmRXaWR0aCB9LCBvdGhlclByb3BzLCB7IHJlZjogcmVmIH0sIHsgY2hpbGRyZW46IFtqc3goQ3VzdG9tRHJhZ0xheWVyLCB7IGJvYXJkQ29udGFpbmVyOiBib2FyZENvbnRhaW5lclBvcyB9KSwganN4KEJvYXJkLCB7fSldIH0pKSkgfSkpXSB9KSkgfSkpO1xyXG59KTtcblxuZXhwb3J0IHsgQ2hlc3Nib2FyZCwgQ2hlc3Nib2FyZERuRFByb3ZpZGVyLCBTcGFyZVBpZWNlIH07XG4iXSwibmFtZXMiOlsianN4IiwianN4cyIsIkZyYWdtZW50IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjcmVhdGVDb250ZXh0IiwiZm9yd2FyZFJlZiIsInVzZVJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VDb250ZXh0IiwibWVtbyIsInVzZUxheW91dEVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiRnJhZ21lbnQkMSIsIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiQ09MVU1OUyIsInNwbGl0IiwiU1RBUlRfUE9TSVRJT05fT0JKRUNUIiwiYTgiLCJiOCIsImM4IiwiZDgiLCJlOCIsImY4IiwiZzgiLCJoOCIsImE3IiwiYjciLCJjNyIsImQ3IiwiZTciLCJmNyIsImc3IiwiaDciLCJhMiIsImIyIiwiYzIiLCJkMiIsImUyIiwiZjIiLCJnMiIsImgyIiwiYTEiLCJiMSIsImMxIiwiZDEiLCJlMSIsImYxIiwiZzEiLCJoMSIsIldISVRFX0NPTFVNTl9WQUxVRVMiLCJhIiwiYiIsImMiLCJkIiwiZiIsImciLCJoIiwiQkxBQ0tfQ09MVU1OX1ZBTFVFUyIsIldISVRFX1JPV1MiLCJCTEFDS19ST1dTIiwiZGVmYXVsdFBpZWNlcyIsIndQIiwiYXNzaWduIiwieG1sbnMiLCJ2ZXJzaW9uIiwid2lkdGgiLCJoZWlnaHQiLCJjaGlsZHJlbiIsInN0eWxlIiwib3BhY2l0eSIsImZpbGwiLCJmaWxsT3BhY2l0eSIsImZpbGxSdWxlIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlT3BhY2l0eSIsIndSIiwid04iLCJ0cmFuc2Zvcm0iLCJ3QiIsIndRIiwiY3giLCJjeSIsInIiLCJ3SyIsImJQIiwiYlIiLCJiTiIsImJCIiwiYlEiLCJiSyIsImlkIiwiZ2V0UmVsYXRpdmVDb29yZHMiLCJib2FyZE9yaWVudGF0aW9uIiwiYm9hcmRXaWR0aCIsInNxdWFyZSIsInNxdWFyZVdpZHRoIiwiY29sdW1ucyIsInJvd3MiLCJ4IiwieSIsInBhcnNlSW50IiwiaXNEaWZmZXJlbnRGcm9tU3RhcnQiLCJuZXdQb3NpdGlvbiIsImlzRGlmZmVyZW50Iiwia2V5cyIsImZvckVhY2giLCJnZXRQb3NpdGlvbkRpZmZlcmVuY2VzIiwiY3VycmVudFBvc2l0aW9uIiwiZGlmZmVyZW5jZSIsInJlbW92ZWQiLCJhZGRlZCIsImNvbnZlcnRQb3NpdGlvblRvT2JqZWN0IiwicG9zaXRpb24iLCJmZW5Ub09iaiIsImZlbiIsImlzVmFsaWRGZW4iLCJyZXBsYWNlIiwiY3VycmVudFJvdyIsInJvdyIsImNvbElkeCIsImoiLCJzZWFyY2giLCJudW1FbXB0eVNxdWFyZXMiLCJmZW5Ub1BpZWNlQ29kZSIsImV4cGFuZEZlbkVtcHR5U3F1YXJlcyIsImNodW5rcyIsInBpZWNlIiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsInVzZUFycm93cyIsImN1c3RvbUFycm93cyIsImFyZUFycm93c0FsbG93ZWQiLCJvbkFycm93c0NoYW5nZSIsImN1c3RvbUFycm93Q29sb3IiLCJjdXN0b21BcnJvd3NTZXQiLCJzZXRDdXN0b21BcnJvd3MiLCJhcnJvd3MiLCJzZXRBcnJvd3MiLCJuZXdBcnJvdyIsInNldE5ld0Fycm93IiwiQXJyYXkiLCJpc0FycmF5IiwiY2xlYXJBcnJvd3MiLCJmaWx0ZXIiLCJhcnJvdyIsInVuZGVmaW5lZCIsImRyYXdOZXdBcnJvdyIsImZyb21TcXVhcmUiLCJ0b1NxdWFyZSIsImFsbEJvYXJkQXJyb3dzIiwib25BcnJvd0RyYXdFbmQiLCJhcnJvd3NDb3B5IiwiaXNOZXdBcnJvd1VuaXF1ZSIsImV2ZXJ5IiwiYXJyb3dGcm9tIiwiYXJyb3dUbyIsIkNoZXNzYm9hcmRDb250ZXh0IiwidXNlQ2hlc3Nib2FyZCIsIkNoZXNzYm9hcmRQcm92aWRlciIsInJlZiIsImFsbG93RHJhZ091dHNpZGVCb2FyZCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYXJlUGllY2VzRHJhZ2dhYmxlIiwiYXJlUHJlbW92ZXNBbGxvd2VkIiwiYXV0b1Byb21vdGVUb1F1ZWVuIiwiY2xlYXJQcmVtb3Zlc09uUmlnaHRDbGljayIsImN1c3RvbUJvYXJkU3R5bGUiLCJjdXN0b21Ob3RhdGlvblN0eWxlIiwiY3VzdG9tRGFya1NxdWFyZVN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiY3VzdG9tRHJvcFNxdWFyZVN0eWxlIiwiYm94U2hhZG93IiwiY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSIsImN1c3RvbVBpZWNlcyIsImN1c3RvbVByZW1vdmVEYXJrU3F1YXJlU3R5bGUiLCJjdXN0b21QcmVtb3ZlTGlnaHRTcXVhcmVTdHlsZSIsImN1c3RvbVNxdWFyZSIsImN1c3RvbVNxdWFyZVN0eWxlcyIsImRyb3BPZmZCb2FyZEFjdGlvbiIsImlzRHJhZ2dhYmxlUGllY2UiLCJnZXRQb3NpdGlvbk9iamVjdCIsIm9uRHJhZ092ZXJTcXVhcmUiLCJvbk1vdXNlT3V0U3F1YXJlIiwib25Nb3VzZU92ZXJTcXVhcmUiLCJvblBpZWNlQ2xpY2siLCJvblBpZWNlRHJhZ0JlZ2luIiwib25QaWVjZURyYWdFbmQiLCJvblBpZWNlRHJvcCIsIm9uUGllY2VEcm9wT2ZmQm9hcmQiLCJvblByb21vdGlvbkNoZWNrIiwic291cmNlU3F1YXJlIiwidGFyZ2V0U3F1YXJlIiwiTWF0aCIsImFicyIsImNoYXJDb2RlQXQiLCJvblByb21vdGlvblBpZWNlU2VsZWN0Iiwib25TcGFyZVBpZWNlRHJvcCIsIm9uU3F1YXJlQ2xpY2siLCJvblNxdWFyZVJpZ2h0Q2xpY2siLCJwcm9tb3Rpb25EaWFsb2dWYXJpYW50IiwicHJvbW90aW9uVG9TcXVhcmUiLCJzaG93Qm9hcmROb3RhdGlvbiIsInNob3dQcm9tb3Rpb25EaWFsb2ciLCJzbmFwVG9DdXJzb3IiLCJzZXRDdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbkRpZmZlcmVuY2VzIiwic2V0UG9zaXRpb25EaWZmZXJlbmNlcyIsImxhc3RQaWVjZUNvbG91ciIsInNldExhc3RQaWVjZUNvbG91ciIsInNob3dQcm9tb3RlRGlhbG9nIiwic2V0U2hvd1Byb21vdGVEaWFsb2ciLCJwcm9tb3RlRnJvbVNxdWFyZSIsInNldFByb21vdGVGcm9tU3F1YXJlIiwicHJvbW90ZVRvU3F1YXJlIiwic2V0UHJvbW90ZVRvU3F1YXJlIiwicHJlbW92ZXMiLCJzZXRQcmVtb3ZlcyIsInByZW1vdmVzUmVmIiwiY3VycmVudFJpZ2h0Q2xpY2tEb3duIiwic2V0Q3VycmVudFJpZ2h0Q2xpY2tEb3duIiwiY2hlc3NQaWVjZXMiLCJzZXRDaGVzc1BpZWNlcyIsIndhc01hbnVhbERyb3AiLCJzZXRXYXNNYW51YWxEcm9wIiwicHJldmlvdXNUaW1lb3V0Iiwic2V0UHJldmlvdXNUaW1lb3V0IiwiaXNXYWl0aW5nRm9yQW5pbWF0aW9uIiwic2V0SXNXYWl0aW5nRm9yQW5pbWF0aW9uIiwibGFzdFNxdWFyZURyYWdnZWRPdmVyIiwic2V0TGFzdFNxdWFyZURyYWdnZWRPdmVyIiwiY2xlYXJQcmVtb3ZlcyIsImNsZWFyTGFzdFBpZWNlQ29sb3VyIiwiX2EiLCJfYiIsIl9jIiwiY2xlYXJQcm9tb3Rpb24iLCJkaWZmZXJlbmNlcyIsIm5ld1BpZWNlQ29sb3VyIiwiZW50cmllcyIsImF0dGVtcHRQcmVtb3ZlIiwiY2xlYXJUaW1lb3V0IiwibmV3VGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVTZXRQb3NpdGlvbiIsInNvdXJjZVNxIiwidGFyZ2V0U3EiLCJ3YXNNYW51YWxEcm9wT3ZlcnJpZGUiLCJjdXJyZW50Iiwib2xkUHJlbW92ZXMiLCJwdXNoIiwibmV3T25Ecm9wUG9zaXRpb24iLCJpc1ZhbGlkTW92ZSIsImRlbGV0ZVBpZWNlRnJvbVNxdWFyZSIsInBvc2l0aW9uQ29weSIsInByZW1vdmUiLCJzaGlmdCIsImhhbmRsZVNwYXJlUGllY2VEcm9wIiwiaXNWYWxpZERyb3AiLCJvblJpZ2h0Q2xpY2tEb3duIiwib25SaWdodENsaWNrVXAiLCJjbGVhckN1cnJlbnRSaWdodENsaWNrRG93biIsIkNoZXNzYm9hcmRQcm92aWRlckNvbnRleHRWYWx1ZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJOb3RhdGlvbiIsImNvbCIsIndoaXRlQ29sb3IiLCJibGFja0NvbG9yIiwiaXNSb3ciLCJpc0NvbHVtbiIsImlzQm90dG9tTGVmdFNxdWFyZSIsImdldFJvdyIsImdldENvbHVtbiIsInJlbmRlckJvdHRvbUxlZnQiLCJ6SW5kZXgiLCJjb2xvciIsIm51bWVyaWNTdHlsZSIsImFscGhhU3R5bGUiLCJyZW5kZXJMZXR0ZXJzIiwidXNlclNlbGVjdCIsInJlbmRlck51bWJlcnMiLCJhbGlnblNlbGYiLCJwYWRkaW5nTGVmdCIsImZvbnRTaXplIiwicGFkZGluZ1JpZ2h0IiwiRG5kQ29udGV4dCIsImRyYWdEcm9wTWFuYWdlciIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJjb2RlIiwiJCRvYnNlcnZhYmxlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsInJhbmRvbVN0cmluZyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiam9pbiIsIkFjdGlvblR5cGVzIiwiSU5JVCIsIlJFUExBQ0UiLCJQUk9CRV9VTktOT1dOX0FDVElPTiIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwibWluaUtpbmRPZiIsInZhbCIsInR5cGUiLCJpc0RhdGUiLCJpc0Vycm9yIiwiY29uc3RydWN0b3JOYW1lIiwiY3Rvck5hbWUiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkVycm9yIiwibWVzc2FnZSIsInN0YWNrVHJhY2VMaW1pdCIsIkRhdGUiLCJ0b0RhdGVTdHJpbmciLCJnZXREYXRlIiwic2V0RGF0ZSIsImtpbmRPZiIsInR5cGVPZlZhbCIsInByb2Nlc3MiLCJjcmVhdGVTdG9yZSIsInJlZHVjZXIiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwiX3JlZjIiLCJhcmd1bWVudHMiLCJjdXJyZW50UmVkdWNlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnRMaXN0ZW5lcnMiLCJuZXh0TGlzdGVuZXJzIiwiaXNEaXNwYXRjaGluZyIsImVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMiLCJnZXRTdGF0ZSIsInN1YnNjcmliZSIsImxpc3RlbmVyIiwiaXNTdWJzY3JpYmVkIiwidW5zdWJzY3JpYmUiLCJpbmRleCIsInNwbGljZSIsImRpc3BhdGNoIiwiYWN0aW9uIiwibGlzdGVuZXJzIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsIl9yZWYiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwibmV4dCIsIndhcm5pbmciLCJjb25zb2xlIiwiZXJyb3IiLCJpc0NydXNoZWQiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJmb3JtYXQiLCJhcmdzIiwiaXNQcm9kdWN0aW9uIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsImdldCIsInBhdGgiLCJkZWZhdWx0VmFsdWUiLCJyZWR1Y2UiLCJ3aXRob3V0JDEiLCJpdGVtcyIsIml0ZW0iLCJpc09iamVjdCIsImlucHV0IiwieG9yIiwiaXRlbXNBIiwiaXRlbXNCIiwibWFwIiwiTWFwIiwiaW5zZXJ0SXRlbSIsInNldCIsImhhcyIsInJlc3VsdCIsImNvdW50Iiwia2V5IiwiaW50ZXJzZWN0aW9uIiwiSU5JVF9DT09SRFMiLCJCRUdJTl9EUkFHIiwiUFVCTElTSF9EUkFHX1NPVVJDRSIsIkhPVkVSIiwiRFJPUCIsIkVORF9EUkFHIiwic2V0Q2xpZW50T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwic291cmNlQ2xpZW50T2Zmc2V0IiwicGF5bG9hZCIsIlJlc2V0Q29vcmRpbmF0ZXNBY3Rpb24iLCJjcmVhdGVCZWdpbkRyYWciLCJtYW5hZ2VyIiwiYmVnaW5EcmFnIiwic291cmNlSWRzIiwib3B0aW9ucyIsInB1Ymxpc2hTb3VyY2UiLCJnZXRTb3VyY2VDbGllbnRPZmZzZXQiLCJtb25pdG9yIiwiZ2V0TW9uaXRvciIsInJlZ2lzdHJ5IiwiZ2V0UmVnaXN0cnkiLCJ2ZXJpZnlJbnZhcmlhbnRzJDEiLCJzb3VyY2VJZCIsImdldERyYWdnYWJsZVNvdXJjZSIsInZlcmlmeUdldFNvdXJjZUNsaWVudE9mZnNldElzRnVuY3Rpb24iLCJzb3VyY2UiLCJnZXRTb3VyY2UiLCJ2ZXJpZnlJdGVtSXNPYmplY3QiLCJwaW5Tb3VyY2UiLCJpdGVtVHlwZSIsImdldFNvdXJjZVR5cGUiLCJpc1NvdXJjZVB1YmxpYyIsImlzRHJhZ2dpbmciLCJjYW5EcmFnU291cmNlIiwiX2RlZmluZVByb3BlcnR5JDQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9vYmplY3RTcHJlYWQkNCIsInRhcmdldCIsIm93bktleXMiLCJjb25jYXQiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJjcmVhdGVEcm9wIiwiZHJvcCIsInZlcmlmeUludmFyaWFudHMiLCJ0YXJnZXRJZHMiLCJnZXREcm9wcGFibGVUYXJnZXRzIiwidGFyZ2V0SWQiLCJkcm9wUmVzdWx0IiwiZGV0ZXJtaW5lRHJvcFJlc3VsdCIsImRpZERyb3AiLCJnZXRUYXJnZXQiLCJ2ZXJpZnlEcm9wUmVzdWx0VHlwZSIsImdldERyb3BSZXN1bHQiLCJnZXRUYXJnZXRJZHMiLCJjYW5Ecm9wT25UYXJnZXQiLCJyZXZlcnNlIiwiY3JlYXRlRW5kRHJhZyIsImVuZERyYWciLCJ2ZXJpZnlJc0RyYWdnaW5nIiwiZ2V0U291cmNlSWQiLCJ1bnBpblNvdXJjZSIsIm1hdGNoZXNUeXBlIiwidGFyZ2V0VHlwZSIsImRyYWdnZWRJdGVtVHlwZSIsInNvbWUiLCJjcmVhdGVIb3ZlciIsImhvdmVyIiwidGFyZ2V0SWRzQXJnIiwidmVyaWZ5VGFyZ2V0SWRzSXNBcnJheSIsImdldEl0ZW1UeXBlIiwicmVtb3ZlTm9uTWF0Y2hpbmdUYXJnZXRJZHMiLCJjaGVja0ludmFyaWFudHMiLCJob3ZlckFsbFRhcmdldHMiLCJsYXN0SW5kZXhPZiIsImdldFRhcmdldFR5cGUiLCJjcmVhdGVQdWJsaXNoRHJhZ1NvdXJjZSIsInB1Ymxpc2hEcmFnU291cmNlIiwiY3JlYXRlRHJhZ0Ryb3BBY3Rpb25zIiwiRHJhZ0Ryb3BNYW5hZ2VySW1wbCIsInJlY2VpdmVCYWNrZW5kIiwiYmFja2VuZCIsImdldEJhY2tlbmQiLCJnZXRBY3Rpb25zIiwic3RvcmUiLCJiaW5kQWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3IiLCJhcHBseSIsImFjdGlvbnMiLCJib3VuZEFjdGlvbnMiLCJpc1NldFVwIiwiaGFuZGxlUmVmQ291bnRDaGFuZ2UiLCJzaG91bGRTZXRVcCIsInJlZkNvdW50Iiwic2V0dXAiLCJ0ZWFyZG93biIsImFkZCIsInN1YnRyYWN0Iiwic3RhdGUiLCJpbml0aWFsQ2xpZW50T2Zmc2V0IiwiaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCIsImdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldCIsIk5PTkUiLCJBTEwiLCJfX0lTX05PTkVfXyIsIl9fSVNfQUxMX18iLCJhcmVEaXJ0eSIsImRpcnR5SWRzIiwiaGFuZGxlcklkcyIsImNvbW1vbklkcyIsIkRyYWdEcm9wTW9uaXRvckltcGwiLCJzdWJzY3JpYmVUb1N0YXRlQ2hhbmdlIiwicHJldlN0YXRlSWQiLCJzdGF0ZUlkIiwiaGFuZGxlQ2hhbmdlIiwiY3VycmVudFN0YXRlSWQiLCJjYW5Ta2lwTGlzdGVuZXIiLCJkaXJ0eUhhbmRsZXJJZHMiLCJzdWJzY3JpYmVUb09mZnNldENoYW5nZSIsInByZXZpb3VzU3RhdGUiLCJkcmFnT2Zmc2V0IiwibmV4dFN0YXRlIiwiY2FuRHJhZyIsImNhbkRyb3AiLCJCb29sZWFuIiwiaXNEcmFnZ2luZ1NvdXJjZSIsInNvdXJjZVR5cGUiLCJpc092ZXJUYXJnZXQiLCJzaGFsbG93IiwiZHJhZ09wZXJhdGlvbiIsImdldEl0ZW0iLCJnZXRJbml0aWFsQ2xpZW50T2Zmc2V0IiwiZ2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCIsImdldENsaWVudE9mZnNldCIsInNjb3BlIiwiZ2xvYmFsIiwic2VsZiIsIkJyb3dzZXJNdXRhdGlvbk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIiLCJjYWxsYmFjayIsInJlcXVlc3RDYWxsIiwidGltZW91dEhhbmRsZSIsImhhbmRsZVRpbWVyIiwiaW50ZXJ2YWxIYW5kbGUiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlciIsInRvZ2dsZSIsIm5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJkYXRhIiwibWFrZVJlcXVlc3RDYWxsIiwiQXNhcFF1ZXVlIiwiZW5xdWV1ZVRhc2siLCJ0YXNrIiwicXVldWUiLCJxIiwicmVxdWVzdEZsdXNoIiwiZmx1c2hpbmciLCJwZW5kaW5nRXJyb3JzIiwiY2FwYWNpdHkiLCJmbHVzaCIsImN1cnJlbnRJbmRleCIsInNjYW4iLCJuZXdMZW5ndGgiLCJyZWdpc3RlclBlbmRpbmdFcnJvciIsImVyciIsInJlcXVlc3RFcnJvclRocm93IiwiUmF3VGFzayIsIm9uRXJyb3IiLCJyZWxlYXNlIiwiVGFza0ZhY3RvcnkiLCJjcmVhdGUiLCJ0YXNrcyIsImZyZWVUYXNrcyIsInQxIiwicG9wIiwiYXNhcFF1ZXVlIiwidGFza0ZhY3RvcnkiLCJhc2FwIiwiQUREX1NPVVJDRSIsIkFERF9UQVJHRVQiLCJSRU1PVkVfU09VUkNFIiwiUkVNT1ZFX1RBUkdFVCIsImFkZFNvdXJjZSIsImFkZFRhcmdldCIsInJlbW92ZVNvdXJjZSIsInJlbW92ZVRhcmdldCIsInZhbGlkYXRlU291cmNlQ29udHJhY3QiLCJ2YWxpZGF0ZVRhcmdldENvbnRyYWN0IiwidmFsaWRhdGVUeXBlIiwiYWxsb3dBcnJheSIsIkhhbmRsZXJSb2xlIiwibmV4dFVuaXF1ZUlkIiwiZ2V0TmV4dFVuaXF1ZUlkIiwiZ2V0TmV4dEhhbmRsZXJJZCIsInJvbGUiLCJTT1VSQ0UiLCJUQVJHRVQiLCJwYXJzZVJvbGVGcm9tSGFuZGxlcklkIiwiaGFuZGxlcklkIiwibWFwQ29udGFpbnNWYWx1ZSIsInNlYXJjaFZhbHVlIiwiaXNEb25lIiwiZG9uZSIsIkhhbmRsZXJSZWdpc3RyeUltcGwiLCJhZGRIYW5kbGVyIiwiY29udGFpbnNIYW5kbGVyIiwiaGFuZGxlciIsImRyYWdTb3VyY2VzIiwiZHJvcFRhcmdldHMiLCJpbmNsdWRlUGlubmVkIiwiaXNTb3VyY2VJZCIsImlzUGlubmVkIiwicGlubmVkU291cmNlSWQiLCJwaW5uZWRTb3VyY2UiLCJpc1RhcmdldElkIiwidHlwZXMiLCJkZWxldGUiLCJzdHJpY3RFcXVhbGl0eSIsImFyZUNvb3Jkc0VxdWFsIiwib2Zmc2V0QSIsIm9mZnNldEIiLCJhcmVBcnJheXNFcXVhbCIsImlzRXF1YWwiLCJyZWR1Y2UkNSIsIl9zdGF0ZSIsInByZXZUYXJnZXRJZHMiLCJkaWRDaGFuZ2UiLCJwcmV2SW5uZXJtb3N0VGFyZ2V0SWQiLCJpbm5lcm1vc3RUYXJnZXRJZCIsIl9kZWZpbmVQcm9wZXJ0eSQzIiwiX29iamVjdFNwcmVhZCQzIiwiaW5pdGlhbFN0YXRlJDEiLCJyZWR1Y2UkNCIsIl9kZWZpbmVQcm9wZXJ0eSQyIiwiX29iamVjdFNwcmVhZCQyIiwiaW5pdGlhbFN0YXRlIiwicmVkdWNlJDMiLCJyZWR1Y2UkMiIsInJlZHVjZSQxIiwiX2RlZmluZVByb3BlcnR5JDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJjcmVhdGVEcmFnRHJvcE1hbmFnZXIiLCJiYWNrZW5kRmFjdG9yeSIsImdsb2JhbENvbnRleHQiLCJiYWNrZW5kT3B0aW9ucyIsImRlYnVnTW9kZSIsIm1ha2VTdG9yZUluc3RhbmNlIiwicmVkdXhEZXZUb29scyIsIndpbmRvdyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJpbnN0YW5jZUlkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJzb3VyY2VLZXlzIiwiSU5TVEFOQ0VfU1lNIiwiZm9yIiwiRG5kUHJvdmlkZXIiLCJfcGFyYW0iLCJwcm9wcyIsImlzR2xvYmFsSW5zdGFuY2UiLCJnZXREbmRDb250ZXh0VmFsdWUiLCJjb250ZXh0IiwiZ2V0R2xvYmFsQ29udGV4dCIsImNyZWF0ZVNpbmdsZXRvbkRuZENvbnRleHQiLCJjdHgiLCJmYXN0RGVlcEVxdWFsIiwiZXF1YWwiLCJSZWdFeHAiLCJmbGFncyIsInZhbHVlT2YiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlQ29sbGVjdG9yIiwiY29sbGVjdCIsIm9uVXBkYXRlIiwiY29sbGVjdGVkIiwic2V0Q29sbGVjdGVkIiwidXBkYXRlQ29sbGVjdGVkIiwibmV4dFZhbHVlIiwidXNlTW9uaXRvck91dHB1dCIsIm9uQ29sbGVjdCIsInN1YnNjcmliZVRvTW9uaXRvclN0YXRlQ2hhbmdlIiwiZ2V0SGFuZGxlcklkIiwidXNlQ29sbGVjdGVkUHJvcHMiLCJjb2xsZWN0b3IiLCJjb25uZWN0b3IiLCJyZWNvbm5lY3QiLCJ1c2VPcHRpb25hbEZhY3RvcnkiLCJhcmciLCJkZXBzIiwibWVtb0RlcHMiLCJ1c2VDb25uZWN0RHJhZ1NvdXJjZSIsImhvb2tzIiwiZHJhZ1NvdXJjZSIsInVzZUNvbm5lY3REcmFnUHJldmlldyIsImRyYWdQcmV2aWV3IiwiaXNDYWxsaW5nQ2FuRHJhZyIsImlzQ2FsbGluZ0lzRHJhZ2dpbmciLCJEcmFnU291cmNlTW9uaXRvckltcGwiLCJyZWNlaXZlSGFuZGxlcklkIiwiaW50ZXJuYWxNb25pdG9yIiwiaXNDYWxsaW5nQ2FuRHJvcCIsIkRyb3BUYXJnZXRNb25pdG9ySW1wbCIsImlzT3ZlciIsInJlZ2lzdGVyVGFyZ2V0IiwicmVnaXN0ZXJTb3VyY2UiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImNvbXBhcmUiLCJjb21wYXJlQ29udGV4dCIsImNvbXBhcmVSZXN1bHQiLCJrZXlzQSIsImtleXNCIiwiYkhhc093blByb3BlcnR5IiwiYmluZCIsImlkeCIsInZhbHVlQSIsInZhbHVlQiIsImlzUmVmIiwidGhyb3dJZkNvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQiLCJlbGVtZW50IiwiZGlzcGxheU5hbWUiLCJ3cmFwSG9va1RvUmVjb2duaXplRWxlbWVudCIsImhvb2siLCJlbGVtZW50T3JOb2RlIiwiY2xvbmVXaXRoUmVmIiwid3JhcENvbm5lY3Rvckhvb2tzIiwid3JhcHBlZEhvb2tzIiwiZW5kc1dpdGgiLCJ3cmFwcGVkSG9vayIsInNldFJlZiIsIm5ld1JlZiIsInByZXZpb3VzUmVmIiwiU291cmNlQ29ubmVjdG9yIiwibmV3SGFuZGxlcklkIiwiY29ubmVjdFRhcmdldCIsImRyYWdTb3VyY2VPcHRpb25zIiwiZHJhZ1NvdXJjZU9wdGlvbnNJbnRlcm5hbCIsImRyYWdQcmV2aWV3T3B0aW9ucyIsImRyYWdQcmV2aWV3T3B0aW9uc0ludGVybmFsIiwicmVjb25uZWN0RHJhZ1NvdXJjZSIsInJlY29ubmVjdERyYWdQcmV2aWV3IiwiZGlkSGFuZGxlcklkQ2hhbmdlIiwiZGlkQ29ubmVjdGVkRHJhZ1NvdXJjZUNoYW5nZSIsImRpZERyYWdTb3VyY2VPcHRpb25zQ2hhbmdlIiwiZGlzY29ubmVjdERyYWdTb3VyY2UiLCJsYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZSIsImxhc3RDb25uZWN0ZWRIYW5kbGVySWQiLCJsYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZU9wdGlvbnMiLCJkcmFnU291cmNlVW5zdWJzY3JpYmUiLCJjb25uZWN0RHJhZ1NvdXJjZSIsImZvcmNlRGlkQ2hhbmdlIiwiZGlkQ29ubmVjdGVkRHJhZ1ByZXZpZXdDaGFuZ2UiLCJkaWREcmFnUHJldmlld09wdGlvbnNDaGFuZ2UiLCJkaXNjb25uZWN0RHJhZ1ByZXZpZXciLCJsYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXciLCJsYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXdPcHRpb25zIiwiZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSIsImNvbm5lY3REcmFnUHJldmlldyIsImRyYWdQcmV2aWV3Tm9kZSIsImRyYWdQcmV2aWV3UmVmIiwiZHJhZ1NvdXJjZU5vZGUiLCJkcmFnU291cmNlUmVmIiwiY2xlYXJEcmFnU291cmNlIiwiY2xlYXJEcmFnUHJldmlldyIsIlRhcmdldENvbm5lY3RvciIsImRyb3BUYXJnZXQiLCJkaWREcm9wVGFyZ2V0Q2hhbmdlIiwiZGlkT3B0aW9uc0NoYW5nZSIsImRpc2Nvbm5lY3REcm9wVGFyZ2V0IiwibGFzdENvbm5lY3RlZERyb3BUYXJnZXQiLCJsYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMiLCJkcm9wVGFyZ2V0T3B0aW9ucyIsInVuc3Vic2NyaWJlRHJvcFRhcmdldCIsImNvbm5lY3REcm9wVGFyZ2V0IiwiZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbCIsImRyb3BUYXJnZXROb2RlIiwiZHJvcFRhcmdldFJlZiIsImNsZWFyRHJvcFRhcmdldCIsInVzZURyYWdEcm9wTWFuYWdlciIsInVzZURyYWdTb3VyY2VDb25uZWN0b3IiLCJ1c2VEcmFnU291cmNlTW9uaXRvciIsIkRyYWdTb3VyY2VJbXBsIiwic3BlYyIsImdsb2JhbE1vbml0b3IiLCJlbmQiLCJ1c2VEcmFnU291cmNlIiwidXNlRHJhZ1R5cGUiLCJ1c2VSZWdpc3RlcmVkRHJhZ1NvdXJjZSIsInJlZ2lzdGVyRHJhZ1NvdXJjZSIsInVucmVnaXN0ZXIiLCJ1c2VEcmFnIiwic3BlY0FyZyIsImJlZ2luIiwicHJldmlld09wdGlvbnMiLCJ1c2VEcmFnTGF5ZXIiLCJ1c2VDb25uZWN0RHJvcFRhcmdldCIsInVzZURyb3BUYXJnZXRDb25uZWN0b3IiLCJ1c2VEcm9wVGFyZ2V0TW9uaXRvciIsInVzZUFjY2VwdCIsImFjY2VwdCIsIkRyb3BUYXJnZXRJbXBsIiwidXNlRHJvcFRhcmdldCIsInVzZVJlZ2lzdGVyZWREcm9wVGFyZ2V0IiwicmVnaXN0ZXJEcm9wVGFyZ2V0IiwidXNlRHJvcCIsIm1lbW9pemUiLCJmbiIsIm1lbW9pemVkIiwid2l0aG91dCIsInVuaW9uIiwiU2V0IiwiRW50ZXJMZWF2ZUNvdW50ZXIiLCJlbnRlciIsImVudGVyaW5nTm9kZSIsInByZXZpb3VzTGVuZ3RoIiwiZW50ZXJlZCIsImlzTm9kZUVudGVyZWQiLCJpc05vZGVJbkRvY3VtZW50IiwiY29udGFpbnMiLCJsZWF2ZSIsImxlYXZpbmdOb2RlIiwicmVzZXQiLCJOYXRpdmVEcmFnU291cmNlIiwiaW5pdGlhbGl6ZUV4cG9zZWRQcm9wZXJ0aWVzIiwiY29uZmlnIiwiZXhwb3NlUHJvcGVydGllcyIsInByb3BlcnR5Iiwid2FybiIsImxvYWREYXRhVHJhbnNmZXIiLCJkYXRhVHJhbnNmZXIiLCJuZXdQcm9wZXJ0aWVzIiwicHJvcGVydHlGbiIsIm1hdGNoZXNUeXBlcyIsImRlZmluZVByb3BlcnRpZXMiLCJoYW5kbGUiLCJGSUxFIiwiVVJMIiwiVEVYVCIsIkhUTUwiLCJOYXRpdmVUeXBlcyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImdldERhdGFGcm9tRGF0YVRyYW5zZmVyIiwidHlwZXNUb1RyeSIsInJlc3VsdFNvRmFyIiwidHlwZVRvVHJ5IiwiZ2V0RGF0YSIsIm5hdGl2ZVR5cGVzQ29uZmlnIiwiZmlsZXMiLCJodG1sIiwidXJscyIsInRleHQiLCJjcmVhdGVOYXRpdmVEcmFnU291cmNlIiwibWF0Y2hOYXRpdmVJdGVtVHlwZSIsImRhdGFUcmFuc2ZlclR5cGVzIiwibmF0aXZlSXRlbVR5cGUiLCJ0eXBlQ29uZmlnIiwiaXNGaXJlZm94IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzU2FmYXJpIiwic2FmYXJpIiwiTW9ub3RvbmljSW50ZXJwb2xhbnQiLCJpbnRlcnBvbGF0ZSIsInhzIiwieXMiLCJjMXMiLCJjMnMiLCJjM3MiLCJsb3ciLCJoaWdoIiwibWlkIiwiZmxvb3IiLCJ4SGVyZSIsIm1heCIsImRpZmYiLCJkaWZmU3EiLCJpbmRleGVzIiwic29ydCIsImR4cyIsIm1zIiwiZHgiLCJkeSIsImkxIiwiaTIiLCJtMiIsIm1OZXh0IiwiZHhOZXh0IiwiY29tbW9uIiwibSIsImkzIiwiaW52RHgiLCJFTEVNRU5UX05PREUkMSIsImdldE5vZGVDbGllbnRPZmZzZXQkMSIsImVsIiwibm9kZVR5cGUiLCJwYXJlbnRFbGVtZW50IiwidG9wIiwibGVmdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldEV2ZW50Q2xpZW50T2Zmc2V0JDEiLCJjbGllbnRYIiwiY2xpZW50WSIsImlzSW1hZ2VOb2RlIiwibm9kZU5hbWUiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXREcmFnUHJldmlld1NpemUiLCJpc0ltYWdlIiwic291cmNlV2lkdGgiLCJzb3VyY2VIZWlnaHQiLCJkcmFnUHJldmlld1dpZHRoIiwiZHJhZ1ByZXZpZXdIZWlnaHQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiZ2V0RHJhZ1ByZXZpZXdPZmZzZXQiLCJzb3VyY2VOb2RlIiwiYW5jaG9yUG9pbnQiLCJvZmZzZXRQb2ludCIsImRyYWdQcmV2aWV3Tm9kZU9mZnNldEZyb21DbGllbnQiLCJvZmZzZXRGcm9tRHJhZ1ByZXZpZXciLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImFuY2hvclgiLCJhbmNob3JZIiwiY2FsY3VsYXRlWU9mZnNldCIsImludGVycG9sYW50WSIsImNhbGN1bGF0ZVhPZmZzZXQiLCJpbnRlcnBvbGFudFgiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImlzTWFudWFsT2Zmc2V0WCIsImlzTWFudWFsT2Zmc2V0WSIsIk9wdGlvbnNSZWFkZXIkMSIsIk9wdGlvbnNSZWFkZXIiLCJyb290RWxlbWVudCIsIm9wdGlvbnNBcmdzIiwib3duZXJEb2N1bWVudCIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9vYmplY3RTcHJlYWQiLCJIVE1MNUJhY2tlbmRJbXBsIiwicHJvZmlsZSIsInJlZjEiLCJzb3VyY2VQcmV2aWV3Tm9kZXMiLCJzaXplIiwic291cmNlUHJldmlld05vZGVPcHRpb25zIiwic291cmNlTm9kZU9wdGlvbnMiLCJzb3VyY2VOb2RlcyIsImRyYWdTdGFydFNvdXJjZUlkcyIsImRyb3BUYXJnZXRJZHMiLCJkcmFnRW50ZXJUYXJnZXRJZHMiLCJkcmFnT3ZlclRhcmdldElkcyIsInJvb3QiLCJfX2lzUmVhY3REbmRCYWNrZW5kU2V0VXAiLCJhZGRFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwiY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUiLCJhc3luY0VuZERyYWdGcmFtZUlkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVEcmFnU3RhcnQiLCJoYW5kbGVTZWxlY3RTdGFydCIsInNldEF0dHJpYnV0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlRHJhZ0VudGVyIiwiaGFuZGxlRHJhZ092ZXIiLCJoYW5kbGVEcm9wIiwiaGFuZGxlVG9wRHJhZ1N0YXJ0IiwiaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSIsImhhbmRsZVRvcERyYWdFbmRDYXB0dXJlIiwiaGFuZGxlVG9wRHJhZ0VudGVyIiwiaGFuZGxlVG9wRHJhZ0VudGVyQ2FwdHVyZSIsImhhbmRsZVRvcERyYWdMZWF2ZUNhcHR1cmUiLCJoYW5kbGVUb3BEcmFnT3ZlciIsImhhbmRsZVRvcERyYWdPdmVyQ2FwdHVyZSIsImhhbmRsZVRvcERyb3AiLCJoYW5kbGVUb3BEcm9wQ2FwdHVyZSIsImdldEN1cnJlbnRTb3VyY2VOb2RlT3B0aW9ucyIsImRyb3BFZmZlY3QiLCJhbHRLZXlQcmVzc2VkIiwiZ2V0Q3VycmVudERyb3BFZmZlY3QiLCJpc0RyYWdnaW5nTmF0aXZlSXRlbSIsImdldEN1cnJlbnRTb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMiLCJjYXB0dXJlRHJhZ2dpbmdTdGF0ZSIsImJlZ2luRHJhZ05hdGl2ZUl0ZW0iLCJjdXJyZW50TmF0aXZlU291cmNlIiwiY3VycmVudE5hdGl2ZUhhbmRsZSIsInNldEN1cnJlbnREcmFnU291cmNlTm9kZSIsImN1cnJlbnREcmFnU291cmNlTm9kZSIsIk1PVVNFX01PVkVfVElNRU9VVCIsIm1vdXNlTW92ZVRpbWVvdXRUaW1lciIsImVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NIiwiZGVmYXVsdFByZXZlbnRlZCIsInVuc2hpZnQiLCJfZSIsImxhc3RDbGllbnRPZmZzZXQiLCJob3ZlclJhZklkIiwiZW5kRHJhZ05hdGl2ZUl0ZW0iLCJib2R5IiwiY2FuY2VsSG92ZXIiLCJzY2hlZHVsZUhvdmVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmF0aXZlVHlwZSIsInNldERyYWdJbWFnZSIsImRyYWdQcmV2aWV3T2Zmc2V0Iiwic2V0RGF0YSIsImhhc0F0dHJpYnV0ZSIsInByZXZlbnREZWZhdWx0IiwiaXNGaXJzdEVudGVyIiwiZW50ZXJMZWF2ZUNvdW50ZXIiLCJhbHRLZXkiLCJpc0xhc3RMZWF2ZSIsImRyYWdEcm9wIiwidGFnTmFtZSIsImlzQ29udGVudEVkaXRhYmxlIiwiZW1wdHlJbWFnZSIsImdldEVtcHR5SW1hZ2UiLCJJbWFnZSIsInNyYyIsIkhUTUw1QmFja2VuZCIsImNyZWF0ZUJhY2tlbmQiLCJQaWVjZSIsImlzUHJlbW92ZWRQaWVjZSIsInNxdWFyZXMiLCJwaWVjZVN0eWxlIiwic2V0UGllY2VTdHlsZSIsInRvdWNoQWN0aW9uIiwiY3Vyc29yIiwiZHJhZyIsIndhc0Ryb3BPdXRzaWRlVGhlQm9hcmQiLCJvbGRQaWVjZVN0eWxlIiwicmVtb3ZlZFBpZWNlIiwibmV3U3F1YXJlIiwiZmluZCIsIk51bWJlciIsInRyYW5zaXRpb24iLCJnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcyIsIm9uQ2xpY2siLCJ2aWV3Qm94IiwiZGlzcGxheSIsIlNxdWFyZSIsInNxdWFyZUNvbG9yIiwic2V0U3F1YXJlcyIsInNxdWFyZUhhc1ByZW1vdmUiLCJzcXVhcmVSZWYiLCJDdXN0b21TcXVhcmUiLCJpc1NwYXJlIiwib2xkU3F1YXJlcyIsImRlZmF1bHRTcXVhcmVTdHlsZSIsImJvcmRlclJhZGl1cyIsIm9uVG91Y2hNb3ZlIiwidG91Y2hMb2NhdGlvbiIsInRvdWNoZXMiLCJ0b3VjaEVsZW1lbnQiLCJlbGVtZW50c0Zyb21Qb2ludCIsImRyYWdnZWRPdmVyU3F1YXJlIiwiZ2V0QXR0cmlidXRlIiwib25Nb3VzZU92ZXIiLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJvbk1vdXNlT3V0Iiwib25Nb3VzZURvd24iLCJidXR0b24iLCJvbk1vdXNlVXAiLCJvbkRyYWdFbnRlciIsIm9uQ29udGV4dE1lbnUiLCJjZW50ZXIiLCJqdXN0aWZ5Q29udGVudCIsImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJCb3R0b21SaWdodFJhZGl1cyIsIlNxdWFyZXMiLCJwcmVtb3Zlc0hpc3RvcnkiLCJyZWxhdGVkUHJlbW92ZWRQaWVjZSIsInByZW1vdmVzUm91dGUiLCJhdCIsIl8iLCJmbGV4V3JhcCIsInNxdWFyZUhhc1ByZW1vdmVUYXJnZXQiLCJBcnJvd3MiLCJwcmltYXJ5QXJyb3dDb2xsb3IiLCJhcnJvd3NMaXN0IiwicG9pbnRlckV2ZW50cyIsImFycm93U3RhcnRGaWVsZCIsImFycm93RW5kRmllbGQiLCJhcnJvd0NvbG9yIiwiZnJvbSIsInRvIiwiQVJST1dfTEVOR1RIX1JFRFVDRVIiLCJpc0Fycm93QWN0aXZlIiwicmVzdEFycm93IiwiaHlwb3QiLCJtYXJrZXJXaWR0aCIsIm1hcmtlckhlaWdodCIsInJlZlgiLCJyZWZZIiwib3JpZW50IiwicG9pbnRzIiwieDEiLCJ5MSIsIngyIiwieTIiLCJtYXJrZXJFbmQiLCJQcm9tb3Rpb25PcHRpb24iLCJvcHRpb24iLCJpc0hvdmVyIiwic2V0SXNIb3ZlciIsIlByb21vdGlvbkRpYWxvZyIsInByb21vdGVQaWVjZUNvbG9yIiwicHJvbW90aW9uT3B0aW9ucyIsImRpYWxvZ1N0eWxlcyIsImRlZmF1bHQiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwidmVydGljYWwiLCJtb2RhbCIsImFsaWduSXRlbXMiLCJkaWFsb2dDb29yZHMiLCJ0aXRsZSIsImVycm9ySW1hZ2UiLCJ3aGl0ZUtpbmciLCJzaGFwZVJlbmRlcmluZyIsInRleHRSZW5kZXJpbmciLCJpbWFnZVJlbmRlcmluZyIsImNsaXBSdWxlIiwiRXJyb3JCb3VuZGFyeSIsImxvZyIsIldoaXRlS2luZyIsInNob3dFcnJvciIsImZsZXhEaXJlY3Rpb24iLCJCb2FyZCIsImJvYXJkUmVmIiwiaGFuZGxlQ2xpY2tPdXRzaWRlIiwiZXZlbnQiLCJwZXJzcGVjdGl2ZSIsImJvYXJkU3R5bGVzIiwiTGlzdGVuZXJUeXBlIiwiZGVsYXkiLCJfZGVsYXkiLCJzY3JvbGxBbmdsZVJhbmdlcyIsImdldERyb3BUYXJnZXRFbGVtZW50c0F0UG9pbnQiLCJpZ25vcmVDb250ZXh0TWVudSIsIl9pZ25vcmVDb250ZXh0TWVudSIsImVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCIsIl9lbmFibGVIb3Zlck91dHNpZGVUYXJnZXQiLCJlbmFibGVLZXlib2FyZEV2ZW50cyIsIl9lbmFibGVLZXlib2FyZEV2ZW50cyIsImVuYWJsZU1vdXNlRXZlbnRzIiwiX2VuYWJsZU1vdXNlRXZlbnRzIiwiZW5hYmxlVG91Y2hFdmVudHMiLCJfZW5hYmxlVG91Y2hFdmVudHMiLCJ0b3VjaFNsb3AiLCJkZWxheVRvdWNoU3RhcnQiLCJyZWYyIiwicmVmMyIsImRlbGF5TW91c2VTdGFydCIsInJlZjQiLCJyZWY1IiwicmVmNiIsImRpc3RhbmNlIiwic3FydCIsInBvdyIsImluQW5nbGVSYW5nZXMiLCJhbmdsZVJhbmdlcyIsImFuZ2xlIiwiYXRhbjIiLCJQSSIsImFyIiwic3RhcnQiLCJNb3VzZUJ1dHRvbnMiLCJMZWZ0IiwiUmlnaHQiLCJDZW50ZXIiLCJNb3VzZUJ1dHRvbiIsImV2ZW50U2hvdWxkU3RhcnREcmFnIiwiZXZlbnRTaG91bGRFbmREcmFnIiwiaXNUb3VjaEV2ZW50IiwidGFyZ2V0VG91Y2hlcyIsIkVMRU1FTlRfTk9ERSIsImdldE5vZGVDbGllbnRPZmZzZXQiLCJnZXRFdmVudENsaWVudFRvdWNoT2Zmc2V0IiwibGFzdFRhcmdldFRvdWNoRmFsbGJhY2siLCJnZXRFdmVudENsaWVudE9mZnNldCIsInN1cHBvcnRzUGFzc2l2ZSIsInN1cHBvcnRlZCIsImV2ZW50TmFtZXMiLCJtb3VzZSIsIm1vdmUiLCJjb250ZXh0bWVudSIsInRvdWNoIiwia2V5Ym9hcmQiLCJrZXlkb3duIiwiVG91Y2hCYWNrZW5kSW1wbCIsInRhcmdldE5vZGVzIiwiZ2V0VG9wTW92ZVN0YXJ0SGFuZGxlciIsImhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUiLCJoYW5kbGVUb3BNb3ZlIiwiaGFuZGxlVG9wTW92ZUNhcHR1cmUiLCJoYW5kbGVUb3BNb3ZlRW5kQ2FwdHVyZSIsImhhbmRsZUNhbmNlbE9uRXNjYXBlIiwiX21vdXNlQ2xpZW50T2Zmc2V0IiwiaGFuZGxlVG9wTW92ZVN0YXJ0IiwidW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciIsInN1YmplY3QiLCJjYXB0dXJlIiwicGFzc2l2ZSIsImxpc3RlbmVyVHlwZXMiLCJsaXN0ZW5lclR5cGUiLCJldnQiLCJoYW5kbGVNb3ZlU3RhcnQiLCJoYW5kbGVNb3ZlIiwiY29vcmRzIiwiZHJvcHBlZE9uIiwiZWxlbWVudEZyb21Qb2ludCIsImNoaWxkTWF0Y2giLCJoYW5kbGVUb3BNb3ZlU3RhcnREZWxheSIsImluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyIiwiZHJhZ2dlZFNvdXJjZU5vZGUiLCJkcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciIsInJlc3VycmVjdFNvdXJjZU5vZGUiLCJjaGlsZExpc3QiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsImRpc2Nvbm5lY3QiLCJtb3ZlU3RhcnRTb3VyY2VJZHMiLCJ3YWl0aW5nRm9yRGVsYXkiLCJ0aW1lb3V0IiwiX2V2dCIsIl9pc1Njcm9sbGluZyIsImNhbmNlbGFibGUiLCJkcmFnT3ZlclRhcmdldE5vZGVzIiwiZWxlbWVudHNBdFBvaW50IiwiZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQiLCJub2RlSWQiLCJjdXJyZW50Tm9kZSIsIm9yZGVyZWREcmFnT3ZlclRhcmdldElkcyIsIl9nZXREcm9wVGFyZ2V0SWQiLCJpZHMiLCJ0YXJnZXROb2RlIiwiVG91Y2hCYWNrZW5kIiwiQ2hlc3Nib2FyZERuRENvbnRleHQiLCJpc0N1c3RvbURuZFByb3ZpZGVyU2V0IiwiRW1wdHlQcm92aWRlciIsIkNoZXNzYm9hcmREbkRQcm92aWRlciIsIkNoZXNzYm9hcmREbkRSb290IiwiY3VzdG9tRG5kQmFja2VuZCIsImN1c3RvbURuZEJhY2tlbmRPcHRpb25zIiwiY2xpZW50V2luZG93Iiwic2V0Q2xpZW50V2luZG93IiwiYmFja2VuZFNldCIsInNldEJhY2tlbmRTZXQiLCJpc01vYmlsZSIsInNldElzTW9iaWxlIiwiRG5EV3JhcHBlciIsIkN1c3RvbURyYWdMYXllciIsImJvYXJkQ29udGFpbmVyIiwiY29sbGVjdGVkUHJvcHMiLCJnZXRJdGVtU3R5bGUiLCJoYWxmU3F1YXJlV2lkdGgiLCJtYXhMZWZ0IiwibWF4VG9wIiwibWF4UmlnaHQiLCJtYXhCb3R0b20iLCJtaW4iLCJXZWJraXRUcmFuc2Zvcm0iLCJTcGFyZVBpZWNlIiwiY3VzdG9tUGllY2VKU1giLCJkbmRJZCIsInJlbmRlclBpZWNlIiwiQ2hlc3Nib2FyZCIsIm9uQm9hcmRXaWR0aENoYW5nZSIsIm90aGVyUHJvcHMiLCJzZXRCb2FyZFdpZHRoIiwiYm9hcmRDb250YWluZXJSZWYiLCJib2FyZENvbnRhaW5lclBvcyIsInNldEJvYXJkQ29udGFpbmVyUG9zIiwibWV0cmljcyIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-chessboard/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/analysis/page.tsx":
/*!***********************************!*\
  !*** ./src/app/analysis/page.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AnalysisPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chess.js */ \"(app-pages-browser)/./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var react_chessboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-chessboard */ \"(app-pages-browser)/./node_modules/react-chessboard/dist/index.esm.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction AnalysisPage() {\n    _s();\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_4__.useSearchParams)();\n    const pgn = searchParams.get(\"pgn\") || \"\";\n    const white = searchParams.get(\"white\") || \"\";\n    const black = searchParams.get(\"black\") || \"\";\n    const [game, setGame] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess());\n    const gameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess()); // Add ref to track current game state\n    const [currentMove, setCurrentMove] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [moves, setMoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [formattedMoves, setFormattedMoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [evaluation, setEvaluation] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [topMoves, setTopMoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [positionTopMoves, setPositionTopMoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isEvaluating, setIsEvaluating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [engine, setEngine] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isEngineReady, setIsEngineReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [debugInfo, setDebugInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Update gameRef whenever game changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        gameRef.current = game;\n    }, [\n        game\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (false) {}\n        try {\n            console.log(\"Initializing Stockfish...\");\n            const stockfish = new Worker(\"/stockfish.js\");\n            if (!stockfish) {\n                console.error(\"Stockfish failed to initialize\");\n                setError(\"Stockfish failed to initialize.\");\n                return;\n            }\n            console.log(\"Stockfish initialized\");\n            stockfish.onmessage = (event)=>{\n                const output = event.data;\n                console.log(\"Stockfish output:\", output);\n                if (output.includes(\"uciok\")) {\n                    console.log(\"Received uciok, setting options...\");\n                    stockfish.postMessage(\"setoption name MultiPV value 3\");\n                    stockfish.postMessage(\"setoption name Threads value 4\");\n                    stockfish.postMessage(\"setoption name Hash value 16\");\n                    stockfish.postMessage(\"setoption name Minimum Thinking Time value 20\");\n                    stockfish.postMessage(\"setoption name Slow Mover value 100\");\n                    stockfish.postMessage(\"setoption name UCI_LimitStrength value false\");\n                    stockfish.postMessage(\"setoption name UCI_Elo value 1500\");\n                    stockfish.postMessage(\"isready\");\n                } else if (output.includes(\"readyok\")) {\n                    console.log(\"Engine is ready\");\n                    setIsEngineReady(true);\n                } else if (output.includes(\"bestmove\")) {\n                    console.log(\"Received bestmove\");\n                    setIsEvaluating(false);\n                } else if (output.includes(\"info depth\")) {\n                    const match = output.match(/info depth \\d+ .*?multipv (\\d+) .*?score (cp|mate) (-?\\d+).*? pv (\\S+)/);\n                    if (match) {\n                        const [, rank, type, value, uciMove] = match;\n                        // Keep evaluation from White's perspective\n                        const evalValue = type === \"cp\" ? parseInt(value) / 100 : parseInt(value);\n                        // Extract UCI move details\n                        const from = uciMove.slice(0, 2);\n                        const to = uciMove.slice(2, 4);\n                        const promotion = uciMove.length > 4 ? uciMove[4] : undefined;\n                        // Clone the current game state using the ref\n                        const tempGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n                        tempGame.load(gameRef.current.fen());\n                        // Extract the full PV line - get only the moves after \"pv\"\n                        const pvMatch = output.match(/\\bpv\\b(.*?)(?=\\s+\\b(?:multipv|depth|seldepth|score|nodes|nps|tbhits|time|$)|\\s*$)/);\n                        const pvMoves = pvMatch ? pvMatch[1].trim().split(\" \") : [];\n                        // Get the current position's turn\n                        const currentTurn = tempGame.turn();\n                        // Log the current state\n                        console.log(\"Current state:\", {\n                            gameFen: gameRef.current.fen(),\n                            tempGameFen: tempGame.fen(),\n                            turn: currentTurn,\n                            moveHistory: gameRef.current.history({\n                                verbose: true\n                            }).map((m)=>m.san),\n                            lastMove: gameRef.current.history({\n                                verbose: true\n                            }).length > 0 ? gameRef.current.history({\n                                verbose: true\n                            })[gameRef.current.history({\n                                verbose: true\n                            }).length - 1] : null\n                        });\n                        // If we're analyzing a move that doesn't match the current turn,\n                        // we need to find and apply the appropriate preceding moves\n                        if (pvMoves.length > 0) {\n                            // If it's white's turn and we're looking at a black move (from rank 7),\n                            // we need to find a white move to apply first\n                            if (currentTurn === \"w\" && from[1] === \"7\") {\n                                // Look for a white move in the PV line that comes before our target move\n                                for(let i = 0; i < pvMoves.length; i++){\n                                    const moveToTry = pvMoves[i];\n                                    // Skip if this is our target move\n                                    if (moveToTry === uciMove) continue;\n                                    // Try to find a valid white move\n                                    const tryFrom = moveToTry.slice(0, 2);\n                                    // Check if this is a white move (from rank 2)\n                                    if (tryFrom[1] === \"2\") {\n                                        try {\n                                            const tryTo = moveToTry.slice(2, 4);\n                                            const tryPromotion = moveToTry.length > 4 ? moveToTry[4] : undefined;\n                                            console.log(\"Trying white move:\", {\n                                                move: moveToTry,\n                                                from: tryFrom,\n                                                to: tryTo,\n                                                promotion: tryPromotion,\n                                                currentTurn: tempGame.turn()\n                                            });\n                                            const result = tempGame.move({\n                                                from: tryFrom,\n                                                to: tryTo,\n                                                promotion: tryPromotion\n                                            });\n                                            if (result) {\n                                                console.log(\"Successfully applied white move:\", result);\n                                                break;\n                                            }\n                                        } catch (error) {\n                                            console.error(\"Error trying white move:\", error);\n                                        }\n                                    }\n                                }\n                            }\n                            // Now we should be at the right position to make our move\n                            console.log(\"Ready to apply target move:\", {\n                                uciMove,\n                                currentFen: tempGame.fen(),\n                                currentTurn: tempGame.turn()\n                            });\n                        }\n                        // Store debug info for display\n                        setDebugInfo({\n                            from,\n                            to,\n                            fen: gameRef.current.fen(),\n                            moveObject: null,\n                            uciMove,\n                            currentTurn: tempGame.turn(),\n                            moveIndex: pvMoves.indexOf(uciMove)\n                        });\n                        // Add debug logging\n                        console.log(\"Before move:\", {\n                            fen: tempGame.fen(),\n                            turn: tempGame.turn(),\n                            from,\n                            to,\n                            promotion,\n                            isCheck: tempGame.isCheck(),\n                            moves: tempGame.moves({\n                                verbose: true\n                            }),\n                            pvMoves\n                        });\n                        try {\n                            // Apply the move to the temporary game instance\n                            const moveObject = tempGame.move({\n                                from,\n                                to,\n                                promotion\n                            });\n                            // Add debug logging for successful move\n                            console.log(\"After move:\", {\n                                success: !!moveObject,\n                                moveObject,\n                                newFen: tempGame.fen(),\n                                newTurn: tempGame.turn()\n                            });\n                            // Get correct standard algebraic notation\n                            const notation = moveObject ? moveObject.san : uciMove;\n                            // Get the PV line (principal variation)\n                            const pvMatch = output.match(/pv (.+)/);\n                            const pv = pvMatch ? pvMatch[1].split(\" \").slice(0, 3) : [];\n                            setTopMoves((prev)=>{\n                                const newMoves = [\n                                    ...prev\n                                ];\n                                const index = parseInt(rank) - 1;\n                                newMoves[index] = {\n                                    move: notation,\n                                    evaluation: evalValue,\n                                    pv\n                                };\n                                return newMoves;\n                            });\n                            // Store top moves for the current position\n                            setPositionTopMoves((prev)=>({\n                                    ...prev,\n                                    [gameRef.current.fen()]: [\n                                        ...prev[gameRef.current.fen()] || [],\n                                        {\n                                            move: notation,\n                                            evaluation: evalValue,\n                                            pv\n                                        }\n                                    ]\n                                }));\n                            // Update main evaluation from the best move\n                            if (parseInt(rank) === 1) {\n                                // Keep evaluation from White's perspective\n                                setEvaluation(evalValue.toFixed(1));\n                            }\n                            // Log move details for debugging\n                            console.log(\"\".concat(tempGame.turn() === \"w\" ? \"White\" : \"Black\", \" to move: \").concat(notation, \" (\").concat(evalValue.toFixed(2), \")\"));\n                            // Update debug info with move object\n                            setDebugInfo((prev)=>prev ? {\n                                    ...prev,\n                                    moveObject: moveObject ? {\n                                        san: moveObject.san,\n                                        from: moveObject.from,\n                                        to: moveObject.to,\n                                        piece: moveObject.piece,\n                                        color: moveObject.color\n                                    } : null,\n                                    currentTurn: tempGame.turn(),\n                                    error: undefined // Clear any previous error\n                                } : null);\n                        } catch (error) {\n                            console.error(\"Error applying move:\", error);\n                            // Update debug info with error\n                            setDebugInfo((prev)=>prev ? {\n                                    ...prev,\n                                    error: error instanceof Error ? error.message : String(error)\n                                } : null);\n                            // Fallback to UCI notation if move conversion fails\n                            setTopMoves((prev)=>{\n                                const newMoves = [\n                                    ...prev\n                                ];\n                                const index = parseInt(rank) - 1;\n                                newMoves[index] = {\n                                    move: uciMove,\n                                    evaluation: evalValue,\n                                    pv: []\n                                };\n                                return newMoves;\n                            });\n                        }\n                    }\n                }\n            };\n            stockfish.onerror = (error)=>{\n                console.error(\"Stockfish error:\", error);\n                setError(\"Failed to initialize Stockfish\");\n            };\n            console.log(\"Sending uci command...\");\n            stockfish.postMessage(\"uci\");\n            setEngine(stockfish);\n            return ()=>{\n                console.log(\"Terminating Stockfish...\");\n                stockfish.terminate();\n            };\n        } catch (err) {\n            console.error(\"Stockfish init error:\", err);\n            setError(err instanceof Error ? err.message : \"Unknown error\");\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (engine && isEngineReady) {\n            console.log(\"Sending position to Stockfish...\");\n            setIsEvaluating(true);\n            setTopMoves([]); // Reset top moves for new position\n            // Get all moves in UCI format\n            const moveHistory = game.history({\n                verbose: true\n            });\n            const uciMoves = moveHistory.map((move)=>move.from + move.to + (move.promotion || \"\")).join(\" \");\n            // Send the starting position and moves to Stockfish\n            engine.postMessage(\"position startpos\" + (uciMoves ? \" moves \".concat(uciMoves) : \"\"));\n            console.log(\"Sent to Stockfish:\", \"position startpos\" + (uciMoves ? \" moves \".concat(uciMoves) : \"\"));\n            engine.postMessage(\"go depth 15 movetime 1000\");\n        }\n    }, [\n        game.fen(),\n        engine,\n        isEngineReady\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (pgn) {\n            const newGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n            newGame.loadPgn(pgn);\n            // Extract moves from PGN\n            const moveHistory = newGame.history({\n                verbose: true\n            });\n            const moveList = moveHistory.map((move)=>\"\".concat(move.color === \"w\" ? \"White\" : \"Black\", \": \").concat(move.san));\n            setMoves(moveList);\n            // Format moves in PGN style\n            const formatted = [];\n            for(let i = 0; i < moveHistory.length; i += 2){\n                const moveNumber = Math.floor(i / 2) + 1;\n                const whiteMove = moveHistory[i].san;\n                const blackMove = moveHistory[i + 1] ? moveHistory[i + 1].san : \"\";\n                formatted.push(\"\".concat(moveNumber, \". \").concat(whiteMove, \" \").concat(blackMove));\n            }\n            setFormattedMoves(formatted);\n            // Set to final position\n            setGame(newGame);\n            setCurrentMove(moveList.length);\n        }\n    }, [\n        pgn\n    ]);\n    const goToStart = ()=>{\n        const newGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n        setGame(newGame);\n        setCurrentMove(0);\n    };\n    const goToEnd = ()=>{\n        const newGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n        newGame.loadPgn(pgn);\n        setGame(newGame);\n        setCurrentMove(moves.length);\n    };\n    const goToNextMove = ()=>{\n        if (currentMove < moves.length) {\n            const newGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n            // Apply moves up to current position\n            for(let i = 0; i <= currentMove; i++){\n                const move = moves[i].split(\": \")[1];\n                newGame.move(move);\n            }\n            setGame(newGame);\n            setCurrentMove(currentMove + 1);\n        }\n    };\n    const goToPreviousMove = ()=>{\n        if (currentMove > 0) {\n            const newGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n            // Apply moves up to previous position\n            for(let i = 0; i < currentMove - 1; i++){\n                const move = moves[i].split(\": \")[1];\n                newGame.move(move);\n            }\n            setGame(newGame);\n            setCurrentMove(currentMove - 1);\n        }\n    };\n    const goToMove = (index)=>{\n        const newGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n        // Apply moves up to selected position\n        for(let i = 0; i <= index; i++){\n            const move = moves[i].split(\": \")[1];\n            newGame.move(move);\n        }\n        setGame(newGame);\n        setCurrentMove(index + 1);\n    };\n    const getEvaluationDisplay = ()=>{\n        if (error) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"text-red-500\",\n                children: error\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                lineNumber: 389,\n                columnNumber: 14\n            }, this);\n        }\n        if (!isEngineReady) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"text-gray-500\",\n                children: \"Loading engine...\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                lineNumber: 392,\n                columnNumber: 14\n            }, this);\n        }\n        if (isEvaluating) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"text-gray-500\",\n                children: \"Evaluating...\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                lineNumber: 395,\n                columnNumber: 14\n            }, this);\n        }\n        if (!evaluation) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"text-gray-500\",\n                children: \"No evaluation\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                lineNumber: 398,\n                columnNumber: 14\n            }, this);\n        }\n        const evalValue = parseFloat(evaluation);\n        const isPositive = evalValue >= 0;\n        const displayValue = isPositive ? \"+\".concat(evalValue.toFixed(1)) : evalValue.toFixed(1);\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            className: isPositive ? \"text-green-600\" : \"text-red-600\",\n            children: displayValue\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n            lineNumber: 406,\n            columnNumber: 7\n        }, this);\n    };\n    const getTopMovesDisplay = ()=>{\n        if (!topMoves.length) return null;\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"mt-4\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                    className: \"text-lg font-semibold mb-2\",\n                    children: \"Top Moves:\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                    lineNumber: 417,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    className: \"space-y-1\",\n                    children: topMoves.map((move, index)=>{\n                        const evalValue = move.evaluation; // Keep evaluation from White's perspective\n                        const displayValue = evalValue >= 0 ? \"+\".concat(evalValue.toFixed(1)) : evalValue.toFixed(1);\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"text-blue-500\",\n                            children: [\n                                index + 1,\n                                \". \",\n                                move.move,\n                                \" (\",\n                                displayValue,\n                                \")\"\n                            ]\n                        }, index, true, {\n                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                            lineNumber: 424,\n                            columnNumber: 15\n                        }, this);\n                    })\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                    lineNumber: 418,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n            lineNumber: 416,\n            columnNumber: 7\n        }, this);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container mx-auto px-4 py-8\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"max-w-4xl mx-auto\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"text-3xl font-bold mb-8\",\n                    children: \"Game Analysis\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                    lineNumber: 437,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-white rounded-lg shadow p-4 mb-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"text-xl font-semibold mb-2\",\n                            children: [\n                                white,\n                                \" vs \",\n                                black\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                            lineNumber: 440,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-sm text-gray-600\",\n                            children: [\n                                \"Move \",\n                                currentMove,\n                                \" of \",\n                                moves.length\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                            lineNumber: 443,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                    lineNumber: 439,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid grid-cols-1 md:grid-cols-2 gap-8\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-white rounded-lg shadow p-4\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"aspect-square mb-4\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_chessboard__WEBPACK_IMPORTED_MODULE_3__.Chessboard, {\n                                        position: game.fen(),\n                                        boardOrientation: \"white\",\n                                        customBoardStyle: {\n                                            borderRadius: \"4px\",\n                                            boxShadow: \"0 2px 10px rgba(0, 0, 0, 0.3)\"\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                        lineNumber: 452,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                    lineNumber: 451,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-center mb-4\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-lg font-semibold\",\n                                            children: getEvaluationDisplay()\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                            lineNumber: 464,\n                                            columnNumber: 15\n                                        }, this),\n                                        getTopMovesDisplay()\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                    lineNumber: 463,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex justify-center gap-2 mb-4\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: goToStart,\n                                            className: \"px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50\",\n                                            disabled: currentMove === 0,\n                                            children: \"\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                            lineNumber: 472,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: goToPreviousMove,\n                                            className: \"px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50\",\n                                            disabled: currentMove === 0,\n                                            children: \"\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                            lineNumber: 479,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: goToNextMove,\n                                            className: \"px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50\",\n                                            disabled: currentMove === moves.length,\n                                            children: \"\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                            lineNumber: 486,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: goToEnd,\n                                            className: \"px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50\",\n                                            disabled: currentMove === moves.length,\n                                            children: \"\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                            lineNumber: 493,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                    lineNumber: 471,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                            lineNumber: 450,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-white rounded-lg shadow p-4\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                    className: \"text-xl font-semibold mb-4\",\n                                    children: \"Move List\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                    lineNumber: 505,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex flex-wrap gap-2 text-sm\",\n                                    children: formattedMoves.map((move, index)=>{\n                                        const moveNumber = index + 1;\n                                        const [whiteMove, blackMove] = move.split(\" \").slice(1);\n                                        const isCurrentWhiteMove = currentMove === moveNumber * 2 - 1;\n                                        const isCurrentBlackMove = currentMove === moveNumber * 2;\n                                        // Get the position before each move\n                                        const whiteMoveGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n                                        const blackMoveGame = new chess_js__WEBPACK_IMPORTED_MODULE_2__.Chess();\n                                        // Apply moves up to but not including the current move\n                                        moves.slice(0, index * 2).forEach((m)=>{\n                                            const moveStr = m.split(\": \")[1];\n                                            whiteMoveGame.move(moveStr);\n                                            blackMoveGame.move(moveStr);\n                                        });\n                                        // For black's move, also apply white's move\n                                        if (blackMove) {\n                                            blackMoveGame.move(whiteMove);\n                                        }\n                                        // Get suggested moves for each position\n                                        const whiteSuggestedMoves = positionTopMoves[whiteMoveGame.fen()] || [];\n                                        const blackSuggestedMoves = positionTopMoves[blackMoveGame.fen()] || [];\n                                        // Only check if moves were among suggestions if we have suggestions for that position\n                                        const hasWhiteSuggestions = whiteSuggestedMoves.length > 0;\n                                        const hasBlackSuggestions = blackSuggestedMoves.length > 0;\n                                        const isWhiteMoveTopMove = hasWhiteSuggestions && whiteSuggestedMoves.some((tm)=>tm.move === whiteMove);\n                                        const isBlackMoveTopMove = hasBlackSuggestions && blackSuggestedMoves.some((tm)=>tm.move === blackMove);\n                                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex items-center gap-1\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"text-gray-500\",\n                                                    children: [\n                                                        moveNumber,\n                                                        \".\"\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                                    lineNumber: 541,\n                                                    columnNumber: 21\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: ()=>goToMove(index * 2),\n                                                    className: \"px-1.5 py-0.5 rounded \".concat(hasWhiteSuggestions ? isWhiteMoveTopMove ? \"bg-green-100 text-green-700\" : \"bg-red-100 text-red-700\" : \"hover:bg-gray-100\", \" \").concat(isCurrentWhiteMove ? \"font-bold\" : \"\"),\n                                                    children: whiteMove\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                                    lineNumber: 542,\n                                                    columnNumber: 21\n                                                }, this),\n                                                blackMove && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: ()=>goToMove(index * 2 + 1),\n                                                    className: \"px-1.5 py-0.5 rounded \".concat(hasBlackSuggestions ? isBlackMoveTopMove ? \"bg-green-100 text-green-700\" : \"bg-red-100 text-red-700\" : \"hover:bg-gray-100\", \" \").concat(isCurrentBlackMove ? \"font-bold\" : \"\"),\n                                                    children: blackMove\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                                    lineNumber: 557,\n                                                    columnNumber: 23\n                                                }, this)\n                                            ]\n                                        }, index, true, {\n                                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                            lineNumber: 540,\n                                            columnNumber: 19\n                                        }, this);\n                                    })\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                                    lineNumber: 506,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                            lineNumber: 504,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n                    lineNumber: 448,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n            lineNumber: 436,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\amirn\\\\OneDrive\\\\chessmentor\\\\src\\\\app\\\\analysis\\\\page.tsx\",\n        lineNumber: 435,\n        columnNumber: 5\n    }, this);\n}\n_s(AnalysisPage, \"tF5a8V9bH0BVJS7Gl6gncrz2N/g=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_4__.useSearchParams\n    ];\n});\n_c = AnalysisPage;\nvar _c;\n$RefreshReg$(_c, \"AnalysisPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvYW5hbHlzaXMvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRW9EO0FBQ2I7QUFDTztBQUNJO0FBWW5DLFNBQVNNOztJQUN0QixNQUFNQyxlQUFlRixnRUFBZUE7SUFDcEMsTUFBTUcsTUFBTUQsYUFBYUUsR0FBRyxDQUFDLFVBQVU7SUFDdkMsTUFBTUMsUUFBUUgsYUFBYUUsR0FBRyxDQUFDLFlBQVk7SUFDM0MsTUFBTUUsUUFBUUosYUFBYUUsR0FBRyxDQUFDLFlBQVk7SUFFM0MsTUFBTSxDQUFDRyxNQUFNQyxRQUFRLEdBQUdaLCtDQUFRQSxDQUFDLElBQUlFLDJDQUFLQTtJQUMxQyxNQUFNVyxVQUFVWiw2Q0FBTUEsQ0FBQyxJQUFJQywyQ0FBS0EsS0FBTSxzQ0FBc0M7SUFDNUUsTUFBTSxDQUFDWSxhQUFhQyxlQUFlLEdBQUdmLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2dCLE9BQU9DLFNBQVMsR0FBR2pCLCtDQUFRQSxDQUFXLEVBQUU7SUFDL0MsTUFBTSxDQUFDa0IsZ0JBQWdCQyxrQkFBa0IsR0FBR25CLCtDQUFRQSxDQUFXLEVBQUU7SUFDakUsTUFBTSxDQUFDb0IsWUFBWUMsY0FBYyxHQUFHckIsK0NBQVFBLENBQWdCO0lBQzVELE1BQU0sQ0FBQ3NCLFVBQVVDLFlBQVksR0FBR3ZCLCtDQUFRQSxDQUFZLEVBQUU7SUFDdEQsTUFBTSxDQUFDd0Isa0JBQWtCQyxvQkFBb0IsR0FBR3pCLCtDQUFRQSxDQUFtQixDQUFDO0lBQzVFLE1BQU0sQ0FBQzBCLGNBQWNDLGdCQUFnQixHQUFHM0IsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDNEIsUUFBUUMsVUFBVSxHQUFHN0IsK0NBQVFBLENBQU07SUFDMUMsTUFBTSxDQUFDOEIsZUFBZUMsaUJBQWlCLEdBQUcvQiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNnQyxPQUFPQyxTQUFTLEdBQUdqQywrQ0FBUUEsQ0FBZ0I7SUFD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TkFRLHNCQUNJSSxxQkFDRSxnQ0FDQSw0QkFDRixxQkFDTCxLQUVBLE9BRENaLHFCQUFxQixjQUFjOzhEQUdwQzdCOzs7Ozs7OzJDQTdCR3BCOzs7OztvQ0FrQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT2Q7R0FuakJ3QjVGOztRQUNERCw0REFBZUE7OztLQURkQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2FuYWx5c2lzL3BhZ2UudHN4PzZmMWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDaGVzcywgTW92ZSB9IGZyb20gJ2NoZXNzLmpzJztcbmltcG9ydCB7IENoZXNzYm9hcmQgfSBmcm9tICdyZWFjdC1jaGVzc2JvYXJkJztcbmltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5cbmludGVyZmFjZSBUb3BNb3ZlIHtcbiAgbW92ZTogc3RyaW5nO1xuICBldmFsdWF0aW9uOiBudW1iZXI7XG4gIHB2OiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIFBvc2l0aW9uVG9wTW92ZXMge1xuICBbZmVuOiBzdHJpbmddOiBUb3BNb3ZlW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFuYWx5c2lzUGFnZSgpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKCk7XG4gIGNvbnN0IHBnbiA9IHNlYXJjaFBhcmFtcy5nZXQoJ3BnbicpIHx8ICcnO1xuICBjb25zdCB3aGl0ZSA9IHNlYXJjaFBhcmFtcy5nZXQoJ3doaXRlJykgfHwgJyc7XG4gIGNvbnN0IGJsYWNrID0gc2VhcmNoUGFyYW1zLmdldCgnYmxhY2snKSB8fCAnJztcblxuICBjb25zdCBbZ2FtZSwgc2V0R2FtZV0gPSB1c2VTdGF0ZShuZXcgQ2hlc3MoKSk7XG4gIGNvbnN0IGdhbWVSZWYgPSB1c2VSZWYobmV3IENoZXNzKCkpOyAgLy8gQWRkIHJlZiB0byB0cmFjayBjdXJyZW50IGdhbWUgc3RhdGVcbiAgY29uc3QgW2N1cnJlbnRNb3ZlLCBzZXRDdXJyZW50TW92ZV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW21vdmVzLCBzZXRNb3Zlc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCBbZm9ybWF0dGVkTW92ZXMsIHNldEZvcm1hdHRlZE1vdmVzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gIGNvbnN0IFtldmFsdWF0aW9uLCBzZXRFdmFsdWF0aW9uXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbdG9wTW92ZXMsIHNldFRvcE1vdmVzXSA9IHVzZVN0YXRlPFRvcE1vdmVbXT4oW10pO1xuICBjb25zdCBbcG9zaXRpb25Ub3BNb3Zlcywgc2V0UG9zaXRpb25Ub3BNb3Zlc10gPSB1c2VTdGF0ZTxQb3NpdGlvblRvcE1vdmVzPih7fSk7XG4gIGNvbnN0IFtpc0V2YWx1YXRpbmcsIHNldElzRXZhbHVhdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlbmdpbmUsIHNldEVuZ2luZV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xuICBjb25zdCBbaXNFbmdpbmVSZWFkeSwgc2V0SXNFbmdpbmVSZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtkZWJ1Z0luZm8sIHNldERlYnVnSW5mb10gPSB1c2VTdGF0ZTx7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHRvOiBzdHJpbmc7XG4gICAgZmVuOiBzdHJpbmc7XG4gICAgbW92ZU9iamVjdDoge1xuICAgICAgc2FuOiBzdHJpbmc7XG4gICAgICBmcm9tOiBzdHJpbmc7XG4gICAgICB0bzogc3RyaW5nO1xuICAgICAgcGllY2U6IHN0cmluZztcbiAgICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgfSB8IG51bGw7XG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgdWNpTW92ZTogc3RyaW5nO1xuICAgIGN1cnJlbnRUdXJuOiBzdHJpbmc7XG4gICAgbW92ZUluZGV4OiBudW1iZXI7XG4gIH0gfCBudWxsPihudWxsKTtcblxuICAvLyBVcGRhdGUgZ2FtZVJlZiB3aGVuZXZlciBnYW1lIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBnYW1lUmVmLmN1cnJlbnQgPSBnYW1lO1xuICB9LCBbZ2FtZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIFN0b2NrZmlzaC4uLicpO1xuICAgICAgY29uc3Qgc3RvY2tmaXNoID0gbmV3IFdvcmtlcignL3N0b2NrZmlzaC5qcycpO1xuICAgICAgXG4gICAgICBpZiAoIXN0b2NrZmlzaCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiU3RvY2tmaXNoIGZhaWxlZCB0byBpbml0aWFsaXplXCIpO1xuICAgICAgICBzZXRFcnJvcihcIlN0b2NrZmlzaCBmYWlsZWQgdG8gaW5pdGlhbGl6ZS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1N0b2NrZmlzaCBpbml0aWFsaXplZCcpO1xuICAgICAgXG4gICAgICBzdG9ja2Zpc2gub25tZXNzYWdlID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXZlbnQuZGF0YSBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTdG9ja2Zpc2ggb3V0cHV0OicsIG91dHB1dCk7XG4gICAgICAgIFxuICAgICAgICBpZiAob3V0cHV0LmluY2x1ZGVzKCd1Y2lvaycpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIHVjaW9rLCBzZXR0aW5nIG9wdGlvbnMuLi4nKTtcbiAgICAgICAgICBzdG9ja2Zpc2gucG9zdE1lc3NhZ2UoJ3NldG9wdGlvbiBuYW1lIE11bHRpUFYgdmFsdWUgMycpO1xuICAgICAgICAgIHN0b2NrZmlzaC5wb3N0TWVzc2FnZSgnc2V0b3B0aW9uIG5hbWUgVGhyZWFkcyB2YWx1ZSA0Jyk7XG4gICAgICAgICAgc3RvY2tmaXNoLnBvc3RNZXNzYWdlKCdzZXRvcHRpb24gbmFtZSBIYXNoIHZhbHVlIDE2Jyk7XG4gICAgICAgICAgc3RvY2tmaXNoLnBvc3RNZXNzYWdlKCdzZXRvcHRpb24gbmFtZSBNaW5pbXVtIFRoaW5raW5nIFRpbWUgdmFsdWUgMjAnKTtcbiAgICAgICAgICBzdG9ja2Zpc2gucG9zdE1lc3NhZ2UoJ3NldG9wdGlvbiBuYW1lIFNsb3cgTW92ZXIgdmFsdWUgMTAwJyk7XG4gICAgICAgICAgc3RvY2tmaXNoLnBvc3RNZXNzYWdlKCdzZXRvcHRpb24gbmFtZSBVQ0lfTGltaXRTdHJlbmd0aCB2YWx1ZSBmYWxzZScpO1xuICAgICAgICAgIHN0b2NrZmlzaC5wb3N0TWVzc2FnZSgnc2V0b3B0aW9uIG5hbWUgVUNJX0VsbyB2YWx1ZSAxNTAwJyk7XG4gICAgICAgICAgc3RvY2tmaXNoLnBvc3RNZXNzYWdlKCdpc3JlYWR5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0cHV0LmluY2x1ZGVzKCdyZWFkeW9rJykpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRW5naW5lIGlzIHJlYWR5Jyk7XG4gICAgICAgICAgc2V0SXNFbmdpbmVSZWFkeSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdXRwdXQuaW5jbHVkZXMoJ2Jlc3Rtb3ZlJykpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgYmVzdG1vdmUnKTtcbiAgICAgICAgICBzZXRJc0V2YWx1YXRpbmcoZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKG91dHB1dC5pbmNsdWRlcygnaW5mbyBkZXB0aCcpKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBvdXRwdXQubWF0Y2goL2luZm8gZGVwdGggXFxkKyAuKj9tdWx0aXB2IChcXGQrKSAuKj9zY29yZSAoY3B8bWF0ZSkgKC0/XFxkKykuKj8gcHYgKFxcUyspLyk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbLCByYW5rLCB0eXBlLCB2YWx1ZSwgdWNpTW92ZV0gPSBtYXRjaDtcblxuICAgICAgICAgICAgLy8gS2VlcCBldmFsdWF0aW9uIGZyb20gV2hpdGUncyBwZXJzcGVjdGl2ZVxuICAgICAgICAgICAgY29uc3QgZXZhbFZhbHVlID0gdHlwZSA9PT0gJ2NwJyA/IHBhcnNlSW50KHZhbHVlKSAvIDEwMCA6IHBhcnNlSW50KHZhbHVlKTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCBVQ0kgbW92ZSBkZXRhaWxzXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gdWNpTW92ZS5zbGljZSgwLCAyKTtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gdWNpTW92ZS5zbGljZSgyLCA0KTtcbiAgICAgICAgICAgIGNvbnN0IHByb21vdGlvbiA9IHVjaU1vdmUubGVuZ3RoID4gNCA/IHVjaU1vdmVbNF0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBjdXJyZW50IGdhbWUgc3RhdGUgdXNpbmcgdGhlIHJlZlxuICAgICAgICAgICAgY29uc3QgdGVtcEdhbWUgPSBuZXcgQ2hlc3MoKTtcbiAgICAgICAgICAgIHRlbXBHYW1lLmxvYWQoZ2FtZVJlZi5jdXJyZW50LmZlbigpKTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgZnVsbCBQViBsaW5lIC0gZ2V0IG9ubHkgdGhlIG1vdmVzIGFmdGVyIFwicHZcIlxuICAgICAgICAgICAgY29uc3QgcHZNYXRjaCA9IG91dHB1dC5tYXRjaCgvXFxicHZcXGIoLio/KSg/PVxccytcXGIoPzptdWx0aXB2fGRlcHRofHNlbGRlcHRofHNjb3JlfG5vZGVzfG5wc3x0YmhpdHN8dGltZXwkKXxcXHMqJCkvKTtcbiAgICAgICAgICAgIGNvbnN0IHB2TW92ZXMgPSBwdk1hdGNoID8gcHZNYXRjaFsxXS50cmltKCkuc3BsaXQoJyAnKSA6IFtdO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcG9zaXRpb24ncyB0dXJuXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHVybiA9IHRlbXBHYW1lLnR1cm4oKTtcblxuICAgICAgICAgICAgLy8gTG9nIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBzdGF0ZTonLCB7XG4gICAgICAgICAgICAgIGdhbWVGZW46IGdhbWVSZWYuY3VycmVudC5mZW4oKSxcbiAgICAgICAgICAgICAgdGVtcEdhbWVGZW46IHRlbXBHYW1lLmZlbigpLFxuICAgICAgICAgICAgICB0dXJuOiBjdXJyZW50VHVybixcbiAgICAgICAgICAgICAgbW92ZUhpc3Rvcnk6IGdhbWVSZWYuY3VycmVudC5oaXN0b3J5KHsgdmVyYm9zZTogdHJ1ZSB9KS5tYXAobSA9PiBtLnNhbiksXG4gICAgICAgICAgICAgIGxhc3RNb3ZlOiBnYW1lUmVmLmN1cnJlbnQuaGlzdG9yeSh7IHZlcmJvc2U6IHRydWUgfSkubGVuZ3RoID4gMCA/IGdhbWVSZWYuY3VycmVudC5oaXN0b3J5KHsgdmVyYm9zZTogdHJ1ZSB9KVtnYW1lUmVmLmN1cnJlbnQuaGlzdG9yeSh7IHZlcmJvc2U6IHRydWUgfSkubGVuZ3RoIC0gMV0gOiBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgYW5hbHl6aW5nIGEgbW92ZSB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgdHVybixcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZmluZCBhbmQgYXBwbHkgdGhlIGFwcHJvcHJpYXRlIHByZWNlZGluZyBtb3Zlc1xuICAgICAgICAgICAgaWYgKHB2TW92ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgd2hpdGUncyB0dXJuIGFuZCB3ZSdyZSBsb29raW5nIGF0IGEgYmxhY2sgbW92ZSAoZnJvbSByYW5rIDcpLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZmluZCBhIHdoaXRlIG1vdmUgdG8gYXBwbHkgZmlyc3RcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFR1cm4gPT09ICd3JyAmJiBmcm9tWzFdID09PSAnNycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYSB3aGl0ZSBtb3ZlIGluIHRoZSBQViBsaW5lIHRoYXQgY29tZXMgYmVmb3JlIG91ciB0YXJnZXQgbW92ZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB2TW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vdmVUb1RyeSA9IHB2TW92ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGlmIHRoaXMgaXMgb3VyIHRhcmdldCBtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVRvVHJ5ID09PSB1Y2lNb3ZlKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSB2YWxpZCB3aGl0ZSBtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cnlGcm9tID0gbW92ZVRvVHJ5LnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHdoaXRlIG1vdmUgKGZyb20gcmFuayAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUZyb21bMV0gPT09ICcyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyeVRvID0gbW92ZVRvVHJ5LnNsaWNlKDIsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cnlQcm9tb3Rpb24gPSBtb3ZlVG9UcnkubGVuZ3RoID4gNCA/IG1vdmVUb1RyeVs0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgd2hpdGUgbW92ZTonLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlOiBtb3ZlVG9UcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0cnlGcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRyeVRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbW90aW9uOiB0cnlQcm9tb3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHVybjogdGVtcEdhbWUudHVybigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRlbXBHYW1lLm1vdmUoeyBmcm9tOiB0cnlGcm9tLCB0bzogdHJ5VG8sIHByb21vdGlvbjogdHJ5UHJvbW90aW9uIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IGFwcGxpZWQgd2hpdGUgbW92ZTonLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdHJ5aW5nIHdoaXRlIG1vdmU6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgd2Ugc2hvdWxkIGJlIGF0IHRoZSByaWdodCBwb3NpdGlvbiB0byBtYWtlIG91ciBtb3ZlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWR5IHRvIGFwcGx5IHRhcmdldCBtb3ZlOicsIHtcbiAgICAgICAgICAgICAgICAgICAgdWNpTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZlbjogdGVtcEdhbWUuZmVuKCksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUdXJuOiB0ZW1wR2FtZS50dXJuKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcmUgZGVidWcgaW5mbyBmb3IgZGlzcGxheVxuICAgICAgICAgICAgc2V0RGVidWdJbmZvKHtcbiAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgIGZlbjogZ2FtZVJlZi5jdXJyZW50LmZlbigpLFxuICAgICAgICAgICAgICBtb3ZlT2JqZWN0OiBudWxsLFxuICAgICAgICAgICAgICB1Y2lNb3ZlLFxuICAgICAgICAgICAgICBjdXJyZW50VHVybjogdGVtcEdhbWUudHVybigpLFxuICAgICAgICAgICAgICBtb3ZlSW5kZXg6IHB2TW92ZXMuaW5kZXhPZih1Y2lNb3ZlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBkZWJ1ZyBsb2dnaW5nXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmVmb3JlIG1vdmU6Jywge1xuICAgICAgICAgICAgICBmZW46IHRlbXBHYW1lLmZlbigpLFxuICAgICAgICAgICAgICB0dXJuOiB0ZW1wR2FtZS50dXJuKCksXG4gICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICBwcm9tb3Rpb24sXG4gICAgICAgICAgICAgIGlzQ2hlY2s6IHRlbXBHYW1lLmlzQ2hlY2soKSxcbiAgICAgICAgICAgICAgbW92ZXM6IHRlbXBHYW1lLm1vdmVzKHsgdmVyYm9zZTogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgcHZNb3Zlc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBtb3ZlIHRvIHRoZSB0ZW1wb3JhcnkgZ2FtZSBpbnN0YW5jZVxuICAgICAgICAgICAgICBjb25zdCBtb3ZlT2JqZWN0ID0gdGVtcEdhbWUubW92ZSh7IFxuICAgICAgICAgICAgICAgIGZyb20sIFxuICAgICAgICAgICAgICAgIHRvLCBcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb25cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gQWRkIGRlYnVnIGxvZ2dpbmcgZm9yIHN1Y2Nlc3NmdWwgbW92ZVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWZ0ZXIgbW92ZTonLCB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogISFtb3ZlT2JqZWN0LFxuICAgICAgICAgICAgICAgIG1vdmVPYmplY3QsXG4gICAgICAgICAgICAgICAgbmV3RmVuOiB0ZW1wR2FtZS5mZW4oKSxcbiAgICAgICAgICAgICAgICBuZXdUdXJuOiB0ZW1wR2FtZS50dXJuKClcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gR2V0IGNvcnJlY3Qgc3RhbmRhcmQgYWxnZWJyYWljIG5vdGF0aW9uXG4gICAgICAgICAgICAgIGNvbnN0IG5vdGF0aW9uID0gbW92ZU9iamVjdCA/IG1vdmVPYmplY3Quc2FuIDogdWNpTW92ZTtcblxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIFBWIGxpbmUgKHByaW5jaXBhbCB2YXJpYXRpb24pXG4gICAgICAgICAgICAgIGNvbnN0IHB2TWF0Y2ggPSBvdXRwdXQubWF0Y2goL3B2ICguKykvKTtcbiAgICAgICAgICAgICAgY29uc3QgcHYgPSBwdk1hdGNoID8gcHZNYXRjaFsxXS5zcGxpdCgnICcpLnNsaWNlKDAsIDMpIDogW107XG5cbiAgICAgICAgICAgICAgc2V0VG9wTW92ZXMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TW92ZXMgPSBbLi4ucHJldl07XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChyYW5rKSAtIDE7XG4gICAgICAgICAgICAgICAgbmV3TW92ZXNbaW5kZXhdID0geyBtb3ZlOiBub3RhdGlvbiwgZXZhbHVhdGlvbjogZXZhbFZhbHVlLCBwdiB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdNb3ZlcztcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gU3RvcmUgdG9wIG1vdmVzIGZvciB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgICBzZXRQb3NpdGlvblRvcE1vdmVzKHByZXYgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICAgIFtnYW1lUmVmLmN1cnJlbnQuZmVuKCldOiBbLi4uKHByZXZbZ2FtZVJlZi5jdXJyZW50LmZlbigpXSB8fCBbXSksIHsgbW92ZTogbm90YXRpb24sIGV2YWx1YXRpb246IGV2YWxWYWx1ZSwgcHYgfV1cbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYWluIGV2YWx1YXRpb24gZnJvbSB0aGUgYmVzdCBtb3ZlXG4gICAgICAgICAgICAgIGlmIChwYXJzZUludChyYW5rKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgZXZhbHVhdGlvbiBmcm9tIFdoaXRlJ3MgcGVyc3BlY3RpdmVcbiAgICAgICAgICAgICAgICBzZXRFdmFsdWF0aW9uKGV2YWxWYWx1ZS50b0ZpeGVkKDEpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIExvZyBtb3ZlIGRldGFpbHMgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHt0ZW1wR2FtZS50dXJuKCkgPT09IFwid1wiID8gXCJXaGl0ZVwiIDogXCJCbGFja1wifSB0byBtb3ZlOiAke25vdGF0aW9ufSAoJHtldmFsVmFsdWUudG9GaXhlZCgyKX0pYCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVcGRhdGUgZGVidWcgaW5mbyB3aXRoIG1vdmUgb2JqZWN0XG4gICAgICAgICAgICAgIHNldERlYnVnSW5mbyhwcmV2ID0+IHByZXYgPyB7XG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICBtb3ZlT2JqZWN0OiBtb3ZlT2JqZWN0ID8ge1xuICAgICAgICAgICAgICAgICAgc2FuOiBtb3ZlT2JqZWN0LnNhbixcbiAgICAgICAgICAgICAgICAgIGZyb206IG1vdmVPYmplY3QuZnJvbSxcbiAgICAgICAgICAgICAgICAgIHRvOiBtb3ZlT2JqZWN0LnRvLFxuICAgICAgICAgICAgICAgICAgcGllY2U6IG1vdmVPYmplY3QucGllY2UsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogbW92ZU9iamVjdC5jb2xvclxuICAgICAgICAgICAgICAgIH0gOiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUdXJuOiB0ZW1wR2FtZS50dXJuKCksXG4gICAgICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGVycm9yXG4gICAgICAgICAgICAgIH0gOiBudWxsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhcHBseWluZyBtb3ZlOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBkZWJ1ZyBpbmZvIHdpdGggZXJyb3JcbiAgICAgICAgICAgICAgc2V0RGVidWdJbmZvKHByZXYgPT4gcHJldiA/IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgICAgfSA6IG51bGwpO1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBVQ0kgbm90YXRpb24gaWYgbW92ZSBjb252ZXJzaW9uIGZhaWxzXG4gICAgICAgICAgICAgIHNldFRvcE1vdmVzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld01vdmVzID0gWy4uLnByZXZdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQocmFuaykgLSAxO1xuICAgICAgICAgICAgICAgIG5ld01vdmVzW2luZGV4XSA9IHsgbW92ZTogdWNpTW92ZSwgZXZhbHVhdGlvbjogZXZhbFZhbHVlLCBwdjogW10gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3TW92ZXM7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc3RvY2tmaXNoLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlN0b2NrZmlzaCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIFN0b2NrZmlzaFwiKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIHVjaSBjb21tYW5kLi4uJyk7XG4gICAgICBzdG9ja2Zpc2gucG9zdE1lc3NhZ2UoJ3VjaScpO1xuICAgICAgc2V0RW5naW5lKHN0b2NrZmlzaCk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUZXJtaW5hdGluZyBTdG9ja2Zpc2guLi4nKTtcbiAgICAgICAgc3RvY2tmaXNoLnRlcm1pbmF0ZSgpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0b2NrZmlzaCBpbml0IGVycm9yOicsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVuZ2luZSAmJiBpc0VuZ2luZVJlYWR5KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgcG9zaXRpb24gdG8gU3RvY2tmaXNoLi4uXCIpO1xuICAgICAgc2V0SXNFdmFsdWF0aW5nKHRydWUpO1xuICAgICAgc2V0VG9wTW92ZXMoW10pOyAvLyBSZXNldCB0b3AgbW92ZXMgZm9yIG5ldyBwb3NpdGlvblxuXG4gICAgICAvLyBHZXQgYWxsIG1vdmVzIGluIFVDSSBmb3JtYXRcbiAgICAgIGNvbnN0IG1vdmVIaXN0b3J5ID0gZ2FtZS5oaXN0b3J5KHsgdmVyYm9zZTogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHVjaU1vdmVzID0gbW92ZUhpc3RvcnkubWFwKG1vdmUgPT4gbW92ZS5mcm9tICsgbW92ZS50byArIChtb3ZlLnByb21vdGlvbiB8fCAnJykpLmpvaW4oJyAnKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gYW5kIG1vdmVzIHRvIFN0b2NrZmlzaFxuICAgICAgZW5naW5lLnBvc3RNZXNzYWdlKCdwb3NpdGlvbiBzdGFydHBvcycgKyAodWNpTW92ZXMgPyBgIG1vdmVzICR7dWNpTW92ZXN9YCA6ICcnKSk7XG4gICAgICBjb25zb2xlLmxvZygnU2VudCB0byBTdG9ja2Zpc2g6JywgJ3Bvc2l0aW9uIHN0YXJ0cG9zJyArICh1Y2lNb3ZlcyA/IGAgbW92ZXMgJHt1Y2lNb3Zlc31gIDogJycpKTtcbiAgICAgIFxuICAgICAgZW5naW5lLnBvc3RNZXNzYWdlKCdnbyBkZXB0aCAxNSBtb3ZldGltZSAxMDAwJyk7XG4gICAgfVxuICB9LCBbZ2FtZS5mZW4oKSwgZW5naW5lLCBpc0VuZ2luZVJlYWR5XSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocGduKSB7XG4gICAgICBjb25zdCBuZXdHYW1lID0gbmV3IENoZXNzKCk7XG4gICAgICBuZXdHYW1lLmxvYWRQZ24ocGduKTtcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCBtb3ZlcyBmcm9tIFBHTlxuICAgICAgY29uc3QgbW92ZUhpc3RvcnkgPSBuZXdHYW1lLmhpc3RvcnkoeyB2ZXJib3NlOiB0cnVlIH0pO1xuICAgICAgY29uc3QgbW92ZUxpc3QgPSBtb3ZlSGlzdG9yeS5tYXAobW92ZSA9PiBgJHttb3ZlLmNvbG9yID09PSAndycgPyAnV2hpdGUnIDogJ0JsYWNrJ306ICR7bW92ZS5zYW59YCk7XG4gICAgICBzZXRNb3Zlcyhtb3ZlTGlzdCk7XG4gICAgICBcbiAgICAgIC8vIEZvcm1hdCBtb3ZlcyBpbiBQR04gc3R5bGVcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3ZlSGlzdG9yeS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBtb3ZlTnVtYmVyID0gTWF0aC5mbG9vcihpIC8gMikgKyAxO1xuICAgICAgICBjb25zdCB3aGl0ZU1vdmUgPSBtb3ZlSGlzdG9yeVtpXS5zYW47XG4gICAgICAgIGNvbnN0IGJsYWNrTW92ZSA9IG1vdmVIaXN0b3J5W2kgKyAxXSA/IG1vdmVIaXN0b3J5W2kgKyAxXS5zYW4gOiAnJztcbiAgICAgICAgZm9ybWF0dGVkLnB1c2goYCR7bW92ZU51bWJlcn0uICR7d2hpdGVNb3ZlfSAke2JsYWNrTW92ZX1gKTtcbiAgICAgIH1cbiAgICAgIHNldEZvcm1hdHRlZE1vdmVzKGZvcm1hdHRlZCk7XG4gICAgICBcbiAgICAgIC8vIFNldCB0byBmaW5hbCBwb3NpdGlvblxuICAgICAgc2V0R2FtZShuZXdHYW1lKTtcbiAgICAgIHNldEN1cnJlbnRNb3ZlKG1vdmVMaXN0Lmxlbmd0aCk7XG4gICAgfVxuICB9LCBbcGduXSk7XG5cbiAgY29uc3QgZ29Ub1N0YXJ0ID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0dhbWUgPSBuZXcgQ2hlc3MoKTtcbiAgICBzZXRHYW1lKG5ld0dhbWUpO1xuICAgIHNldEN1cnJlbnRNb3ZlKDApO1xuICB9O1xuXG4gIGNvbnN0IGdvVG9FbmQgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3R2FtZSA9IG5ldyBDaGVzcygpO1xuICAgIG5ld0dhbWUubG9hZFBnbihwZ24pO1xuICAgIHNldEdhbWUobmV3R2FtZSk7XG4gICAgc2V0Q3VycmVudE1vdmUobW92ZXMubGVuZ3RoKTtcbiAgfTtcblxuICBjb25zdCBnb1RvTmV4dE1vdmUgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRNb3ZlIDwgbW92ZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdHYW1lID0gbmV3IENoZXNzKCk7XG4gICAgICAvLyBBcHBseSBtb3ZlcyB1cCB0byBjdXJyZW50IHBvc2l0aW9uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBjdXJyZW50TW92ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1vdmUgPSBtb3Zlc1tpXS5zcGxpdCgnOiAnKVsxXTtcbiAgICAgICAgbmV3R2FtZS5tb3ZlKG1vdmUpO1xuICAgICAgfVxuICAgICAgc2V0R2FtZShuZXdHYW1lKTtcbiAgICAgIHNldEN1cnJlbnRNb3ZlKGN1cnJlbnRNb3ZlICsgMSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdvVG9QcmV2aW91c01vdmUgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRNb3ZlID4gMCkge1xuICAgICAgY29uc3QgbmV3R2FtZSA9IG5ldyBDaGVzcygpO1xuICAgICAgLy8gQXBwbHkgbW92ZXMgdXAgdG8gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudE1vdmUgLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgbW92ZSA9IG1vdmVzW2ldLnNwbGl0KCc6ICcpWzFdO1xuICAgICAgICBuZXdHYW1lLm1vdmUobW92ZSk7XG4gICAgICB9XG4gICAgICBzZXRHYW1lKG5ld0dhbWUpO1xuICAgICAgc2V0Q3VycmVudE1vdmUoY3VycmVudE1vdmUgLSAxKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ29Ub01vdmUgPSAoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IG5ld0dhbWUgPSBuZXcgQ2hlc3MoKTtcbiAgICAvLyBBcHBseSBtb3ZlcyB1cCB0byBzZWxlY3RlZCBwb3NpdGlvblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtb3Zlc1tpXS5zcGxpdCgnOiAnKVsxXTtcbiAgICAgIG5ld0dhbWUubW92ZShtb3ZlKTtcbiAgICB9XG4gICAgc2V0R2FtZShuZXdHYW1lKTtcbiAgICBzZXRDdXJyZW50TW92ZShpbmRleCArIDEpO1xuICB9O1xuXG4gIGNvbnN0IGdldEV2YWx1YXRpb25EaXNwbGF5ID0gKCkgPT4ge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtcmVkLTUwMFwiPntlcnJvcn08L3NwYW4+O1xuICAgIH1cbiAgICBpZiAoIWlzRW5naW5lUmVhZHkpIHtcbiAgICAgIHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwXCI+TG9hZGluZyBlbmdpbmUuLi48L3NwYW4+O1xuICAgIH1cbiAgICBpZiAoaXNFdmFsdWF0aW5nKSB7XG4gICAgICByZXR1cm4gPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPkV2YWx1YXRpbmcuLi48L3NwYW4+O1xuICAgIH1cbiAgICBpZiAoIWV2YWx1YXRpb24pIHtcbiAgICAgIHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwXCI+Tm8gZXZhbHVhdGlvbjwvc3Bhbj47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGV2YWxWYWx1ZSA9IHBhcnNlRmxvYXQoZXZhbHVhdGlvbik7XG4gICAgY29uc3QgaXNQb3NpdGl2ZSA9IGV2YWxWYWx1ZSA+PSAwO1xuICAgIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IGlzUG9zaXRpdmUgPyBgKyR7ZXZhbFZhbHVlLnRvRml4ZWQoMSl9YCA6IGV2YWxWYWx1ZS50b0ZpeGVkKDEpO1xuICAgIFxuICAgIHJldHVybiAoXG4gICAgICA8c3BhbiBjbGFzc05hbWU9e2lzUG9zaXRpdmUgPyAndGV4dC1ncmVlbi02MDAnIDogJ3RleHQtcmVkLTYwMCd9PlxuICAgICAgICB7ZGlzcGxheVZhbHVlfVxuICAgICAgPC9zcGFuPlxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgZ2V0VG9wTW92ZXNEaXNwbGF5ID0gKCkgPT4ge1xuICAgIGlmICghdG9wTW92ZXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTRcIj5cbiAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZCBtYi0yXCI+VG9wIE1vdmVzOjwvaDM+XG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJzcGFjZS15LTFcIj5cbiAgICAgICAgICB7dG9wTW92ZXMubWFwKChtb3ZlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZhbFZhbHVlID0gbW92ZS5ldmFsdWF0aW9uOyAgLy8gS2VlcCBldmFsdWF0aW9uIGZyb20gV2hpdGUncyBwZXJzcGVjdGl2ZVxuICAgICAgICAgICAgY29uc3QgZGlzcGxheVZhbHVlID0gZXZhbFZhbHVlID49IDAgPyBgKyR7ZXZhbFZhbHVlLnRvRml4ZWQoMSl9YCA6IGV2YWxWYWx1ZS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8bGkga2V5PXtpbmRleH0gY2xhc3NOYW1lPVwidGV4dC1ibHVlLTUwMFwiPlxuICAgICAgICAgICAgICAgIHtpbmRleCArIDF9LiB7bW92ZS5tb3ZlfSAoe2Rpc3BsYXlWYWx1ZX0pXG4gICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIG14LWF1dG8gcHgtNCBweS04XCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTR4bCBteC1hdXRvXCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgbWItOFwiPkdhbWUgQW5hbHlzaXM8L2gxPlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdyBwLTQgbWItNFwiPlxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgbWItMlwiPlxuICAgICAgICAgICAge3doaXRlfSB2cyB7YmxhY2t9XG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTYwMFwiPlxuICAgICAgICAgICAgTW92ZSB7Y3VycmVudE1vdmV9IG9mIHttb3Zlcy5sZW5ndGh9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMiBnYXAtOFwiPlxuICAgICAgICAgIHsvKiBDaGVzcyBCb2FyZCAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93IHAtNFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhc3BlY3Qtc3F1YXJlIG1iLTRcIj5cbiAgICAgICAgICAgICAgPENoZXNzYm9hcmRcbiAgICAgICAgICAgICAgICBwb3NpdGlvbj17Z2FtZS5mZW4oKX1cbiAgICAgICAgICAgICAgICBib2FyZE9yaWVudGF0aW9uPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGN1c3RvbUJvYXJkU3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKScsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICB7LyogRXZhbHVhdGlvbiAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgbWItNFwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZFwiPlxuICAgICAgICAgICAgICAgIHtnZXRFdmFsdWF0aW9uRGlzcGxheSgpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAge2dldFRvcE1vdmVzRGlzcGxheSgpfVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsvKiBOYXZpZ2F0aW9uIENvbnRyb2xzICovfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGdhcC0yIG1iLTRcIj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2dvVG9TdGFydH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTEgYmctZ3JheS01MDAgdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLWdyYXktNjAwIGRpc2FibGVkOm9wYWNpdHktNTBcIlxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtjdXJyZW50TW92ZSA9PT0gMH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIOKPru+4j1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2dvVG9QcmV2aW91c01vdmV9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMyBweS0xIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1ibHVlLTYwMCBkaXNhYmxlZDpvcGFjaXR5LTUwXCJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y3VycmVudE1vdmUgPT09IDB9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICDirIXvuI9cbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtnb1RvTmV4dE1vdmV9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMyBweS0xIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1ibHVlLTYwMCBkaXNhYmxlZDpvcGFjaXR5LTUwXCJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y3VycmVudE1vdmUgPT09IG1vdmVzLmxlbmd0aH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIOKeoe+4j1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2dvVG9FbmR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMyBweS0xIGJnLWdyYXktNTAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTYwMCBkaXNhYmxlZDpvcGFjaXR5LTUwXCJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y3VycmVudE1vdmUgPT09IG1vdmVzLmxlbmd0aH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIOKPre+4j1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIE1vdmUgTGlzdCAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93IHAtNFwiPlxuICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1zZW1pYm9sZCBtYi00XCI+TW92ZSBMaXN0PC9oMj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXdyYXAgZ2FwLTIgdGV4dC1zbVwiPlxuICAgICAgICAgICAgICB7Zm9ybWF0dGVkTW92ZXMubWFwKChtb3ZlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdmVOdW1iZXIgPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgW3doaXRlTW92ZSwgYmxhY2tNb3ZlXSA9IG1vdmUuc3BsaXQoJyAnKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnRXaGl0ZU1vdmUgPSBjdXJyZW50TW92ZSA9PT0gbW92ZU51bWJlciAqIDIgLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEJsYWNrTW92ZSA9IGN1cnJlbnRNb3ZlID09PSBtb3ZlTnVtYmVyICogMjtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gYmVmb3JlIGVhY2ggbW92ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlTW92ZUdhbWUgPSBuZXcgQ2hlc3MoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBibGFja01vdmVHYW1lID0gbmV3IENoZXNzKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgbW92ZXMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgbW92ZVxuICAgICAgICAgICAgICAgIG1vdmVzLnNsaWNlKDAsIGluZGV4ICogMikuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1vdmVTdHIgPSBtLnNwbGl0KCc6ICcpWzFdO1xuICAgICAgICAgICAgICAgICAgd2hpdGVNb3ZlR2FtZS5tb3ZlKG1vdmVTdHIpO1xuICAgICAgICAgICAgICAgICAgYmxhY2tNb3ZlR2FtZS5tb3ZlKG1vdmVTdHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEZvciBibGFjaydzIG1vdmUsIGFsc28gYXBwbHkgd2hpdGUncyBtb3ZlXG4gICAgICAgICAgICAgICAgaWYgKGJsYWNrTW92ZSkge1xuICAgICAgICAgICAgICAgICAgYmxhY2tNb3ZlR2FtZS5tb3ZlKHdoaXRlTW92ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHN1Z2dlc3RlZCBtb3ZlcyBmb3IgZWFjaCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3VnZ2VzdGVkTW92ZXMgPSBwb3NpdGlvblRvcE1vdmVzW3doaXRlTW92ZUdhbWUuZmVuKCldIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsYWNrU3VnZ2VzdGVkTW92ZXMgPSBwb3NpdGlvblRvcE1vdmVzW2JsYWNrTW92ZUdhbWUuZmVuKCldIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBjaGVjayBpZiBtb3ZlcyB3ZXJlIGFtb25nIHN1Z2dlc3Rpb25zIGlmIHdlIGhhdmUgc3VnZ2VzdGlvbnMgZm9yIHRoYXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNXaGl0ZVN1Z2dlc3Rpb25zID0gd2hpdGVTdWdnZXN0ZWRNb3Zlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0JsYWNrU3VnZ2VzdGlvbnMgPSBibGFja1N1Z2dlc3RlZE1vdmVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNXaGl0ZU1vdmVUb3BNb3ZlID0gaGFzV2hpdGVTdWdnZXN0aW9ucyAmJiB3aGl0ZVN1Z2dlc3RlZE1vdmVzLnNvbWUodG0gPT4gdG0ubW92ZSA9PT0gd2hpdGVNb3ZlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0JsYWNrTW92ZVRvcE1vdmUgPSBoYXNCbGFja1N1Z2dlc3Rpb25zICYmIGJsYWNrU3VnZ2VzdGVkTW92ZXMuc29tZSh0bSA9PiB0bS5tb3ZlID09PSBibGFja01vdmUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpbmRleH0gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPnttb3ZlTnVtYmVyfS48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBnb1RvTW92ZShpbmRleCAqIDIpfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHB4LTEuNSBweS0wLjUgcm91bmRlZCAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzV2hpdGVTdWdnZXN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGlzV2hpdGVNb3ZlVG9wTW92ZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1ncmVlbi0xMDAgdGV4dC1ncmVlbi03MDAnIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLXJlZC0xMDAgdGV4dC1yZWQtNzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdob3ZlcjpiZy1ncmF5LTEwMCdcbiAgICAgICAgICAgICAgICAgICAgICB9ICR7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRXaGl0ZU1vdmUgPyAnZm9udC1ib2xkJyA6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7d2hpdGVNb3ZlfVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAge2JsYWNrTW92ZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZ29Ub01vdmUoaW5kZXggKiAyICsgMSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BweC0xLjUgcHktMC41IHJvdW5kZWQgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmxhY2tTdWdnZXN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXNCbGFja01vdmVUb3BNb3ZlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYmctZ3JlZW4tMTAwIHRleHQtZ3JlZW4tNzAwJyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLXJlZC0xMDAgdGV4dC1yZWQtNzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2hvdmVyOmJnLWdyYXktMTAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRCbGFja01vdmUgPyAnZm9udC1ib2xkJyA6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7YmxhY2tNb3ZlfVxuICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwiQ2hlc3MiLCJDaGVzc2JvYXJkIiwidXNlU2VhcmNoUGFyYW1zIiwiQW5hbHlzaXNQYWdlIiwic2VhcmNoUGFyYW1zIiwicGduIiwiZ2V0Iiwid2hpdGUiLCJibGFjayIsImdhbWUiLCJzZXRHYW1lIiwiZ2FtZVJlZiIsImN1cnJlbnRNb3ZlIiwic2V0Q3VycmVudE1vdmUiLCJtb3ZlcyIsInNldE1vdmVzIiwiZm9ybWF0dGVkTW92ZXMiLCJzZXRGb3JtYXR0ZWRNb3ZlcyIsImV2YWx1YXRpb24iLCJzZXRFdmFsdWF0aW9uIiwidG9wTW92ZXMiLCJzZXRUb3BNb3ZlcyIsInBvc2l0aW9uVG9wTW92ZXMiLCJzZXRQb3NpdGlvblRvcE1vdmVzIiwiaXNFdmFsdWF0aW5nIiwic2V0SXNFdmFsdWF0aW5nIiwiZW5naW5lIiwic2V0RW5naW5lIiwiaXNFbmdpbmVSZWFkeSIsInNldElzRW5naW5lUmVhZHkiLCJlcnJvciIsInNldEVycm9yIiwiZGVidWdJbmZvIiwic2V0RGVidWdJbmZvIiwiY3VycmVudCIsImNvbnNvbGUiLCJsb2ciLCJzdG9ja2Zpc2giLCJXb3JrZXIiLCJvbm1lc3NhZ2UiLCJldmVudCIsIm91dHB1dCIsImRhdGEiLCJpbmNsdWRlcyIsInBvc3RNZXNzYWdlIiwibWF0Y2giLCJyYW5rIiwidHlwZSIsInZhbHVlIiwidWNpTW92ZSIsImV2YWxWYWx1ZSIsInBhcnNlSW50IiwiZnJvbSIsInNsaWNlIiwidG8iLCJwcm9tb3Rpb24iLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ0ZW1wR2FtZSIsImxvYWQiLCJmZW4iLCJwdk1hdGNoIiwicHZNb3ZlcyIsInRyaW0iLCJzcGxpdCIsImN1cnJlbnRUdXJuIiwidHVybiIsImdhbWVGZW4iLCJ0ZW1wR2FtZUZlbiIsIm1vdmVIaXN0b3J5IiwiaGlzdG9yeSIsInZlcmJvc2UiLCJtYXAiLCJtIiwic2FuIiwibGFzdE1vdmUiLCJpIiwibW92ZVRvVHJ5IiwidHJ5RnJvbSIsInRyeVRvIiwidHJ5UHJvbW90aW9uIiwibW92ZSIsInJlc3VsdCIsImN1cnJlbnRGZW4iLCJtb3ZlT2JqZWN0IiwibW92ZUluZGV4IiwiaW5kZXhPZiIsImlzQ2hlY2siLCJzdWNjZXNzIiwibmV3RmVuIiwibmV3VHVybiIsIm5vdGF0aW9uIiwicHYiLCJwcmV2IiwibmV3TW92ZXMiLCJpbmRleCIsInRvRml4ZWQiLCJwaWVjZSIsImNvbG9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwib25lcnJvciIsInRlcm1pbmF0ZSIsImVyciIsInVjaU1vdmVzIiwiam9pbiIsIm5ld0dhbWUiLCJsb2FkUGduIiwibW92ZUxpc3QiLCJmb3JtYXR0ZWQiLCJtb3ZlTnVtYmVyIiwiTWF0aCIsImZsb29yIiwid2hpdGVNb3ZlIiwiYmxhY2tNb3ZlIiwicHVzaCIsImdvVG9TdGFydCIsImdvVG9FbmQiLCJnb1RvTmV4dE1vdmUiLCJnb1RvUHJldmlvdXNNb3ZlIiwiZ29Ub01vdmUiLCJnZXRFdmFsdWF0aW9uRGlzcGxheSIsInNwYW4iLCJjbGFzc05hbWUiLCJwYXJzZUZsb2F0IiwiaXNQb3NpdGl2ZSIsImRpc3BsYXlWYWx1ZSIsImdldFRvcE1vdmVzRGlzcGxheSIsImRpdiIsImgzIiwidWwiLCJsaSIsImgxIiwiaDIiLCJwb3NpdGlvbiIsImJvYXJkT3JpZW50YXRpb24iLCJjdXN0b21Cb2FyZFN0eWxlIiwiYm9yZGVyUmFkaXVzIiwiYm94U2hhZG93IiwiYnV0dG9uIiwib25DbGljayIsImRpc2FibGVkIiwiaXNDdXJyZW50V2hpdGVNb3ZlIiwiaXNDdXJyZW50QmxhY2tNb3ZlIiwid2hpdGVNb3ZlR2FtZSIsImJsYWNrTW92ZUdhbWUiLCJmb3JFYWNoIiwibW92ZVN0ciIsIndoaXRlU3VnZ2VzdGVkTW92ZXMiLCJibGFja1N1Z2dlc3RlZE1vdmVzIiwiaGFzV2hpdGVTdWdnZXN0aW9ucyIsImhhc0JsYWNrU3VnZ2VzdGlvbnMiLCJpc1doaXRlTW92ZVRvcE1vdmUiLCJzb21lIiwidG0iLCJpc0JsYWNrTW92ZVRvcE1vdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/analysis/page.tsx\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Camirn%5COneDrive%5Cchessmentor%5Csrc%5Capp%5Canalysis%5Cpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);